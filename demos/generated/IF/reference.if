system simple;
type int = range 0 .. 255;
const sO = 0;
const sP = 15;
const sJ = 1;
const sE1 = 1;
const sE2 = 3;
const cE1 = 2;
const cE2 = 4;
const aO = 0;
const aP = 5;
const aJ = 1;
const aE1 = 1;
const aE2 = 3;
signal sData();
signal cData();
process Sensor(1);
    var x clock;
    var e clock;
    
    state startS #start ;
        set x := 0;
        nextstate first;
    endstate;
    state first ;
        when x = sO;
            informal "S_START";
            set x := 0;
            set e := 0;
            nextstate exec;
    endstate;
    state exec;
        deadline delayable;
        when e >= sE1 and e <= sE2;
            informal "S_FINISH";
            reset e;
            output sData();
            nextstate wait;
    endstate;
    state wait;
        when x = sP;
            set x := 0;
            nextstate jitter;
    endstate;
    state jitter;
        deadline delayable;
        when x <= (sJ * 2) ;
            informal "S_START";
            set e := 0;
            nextstate exec;
    endstate;
endprocess;
process Actuator(1);
    var x clock;
    var e clock;
    var nbData int;
    state startA #start ;
        task nbData := 0;
        set x := 0;
        nextstate first;
    endstate;
    state first ;
        when x = aO;
            set x := 0;
            set e := 0;
            nextstate preprocessing;
        
        input cData();
            task nbData := nbData + 1;
            nextstate first;
    endstate;
    state wait;
        when x = aP;
            set x := 0;
            nextstate jitter;
        
        input cData();
            task nbData := nbData + 1;
            nextstate wait;
    endstate;
    state jitter;
        deadline delayable;
        when x <= (aJ * 2);
            set e := 0;
            nextstate preprocessing;
        
        input cData();
            task nbData := nbData + 1;
            nextstate jitter;
    endstate;
    state preprocessing;
        deadline eager;
        provided nbData =  0;
            informal "USELESS_ACT";
            nextstate processing;
        deadline eager;
        provided nbData <>  0;
            informal "USEFUL_ACT";
            task nbData := 0;
            nextstate processing;
    endstate;
    state processing;
        deadline delayable;
        when x >= aE1 and x <= aE2;
            informal "A_FINISH";
            reset e;
            nextstate wait;
        
        input cData();
            task nbData := nbData + 1;
            nextstate processing;
    endstate;
endprocess;
process Control(1);
    var e clock;
    state wait #start ;
        input sData();
            informal "C_START";
            set e := 0;
            nextstate processing;
    endstate;
    state processing;
        deadline delayable;
        when e >= cE1 and e <= cE2;
            informal "C_FINISH";
            output cData() to {Actuator}0;
            reset e;
            nextstate wait;
    endstate;
endprocess;
endsystem;