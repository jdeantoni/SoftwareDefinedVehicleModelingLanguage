(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
      if (decorator = decorators[i2])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
  };
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

  // node_modules/reflect-metadata/Reflect.js
  var require_Reflect = __commonJS({
    "node_modules/reflect-metadata/Reflect.js"() {
      var Reflect2;
      (function(Reflect3) {
        (function(factory) {
          var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
          var exporter = makeExporter(Reflect3);
          if (typeof root.Reflect !== "undefined") {
            exporter = makeExporter(root.Reflect, exporter);
          }
          factory(exporter, root);
          if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect3;
          }
          function makeExporter(target, previous) {
            return function(key, value) {
              Object.defineProperty(target, key, { configurable: true, writable: true, value });
              if (previous)
                previous(key, value);
            };
          }
          function functionThis() {
            try {
              return Function("return this;")();
            } catch (_3) {
            }
          }
          function indirectEvalThis() {
            try {
              return (void 0, eval)("(function() { return this; })()");
            } catch (_3) {
            }
          }
          function sloppyModeThis() {
            return functionThis() || indirectEvalThis();
          }
        })(function(exporter, root) {
          var hasOwn = Object.prototype.hasOwnProperty;
          var supportsSymbol = typeof Symbol === "function";
          var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
          var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
          var supportsCreate = typeof Object.create === "function";
          var supportsProto = { __proto__: [] } instanceof Array;
          var downLevel = !supportsCreate && !supportsProto;
          var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate ? function() {
              return MakeDictionary(/* @__PURE__ */ Object.create(null));
            } : supportsProto ? function() {
              return MakeDictionary({ __proto__: null });
            } : function() {
              return MakeDictionary({});
            },
            has: downLevel ? function(map, key) {
              return hasOwn.call(map, key);
            } : function(map, key) {
              return key in map;
            },
            get: downLevel ? function(map, key) {
              return hasOwn.call(map, key) ? map[key] : void 0;
            } : function(map, key) {
              return map[key];
            }
          };
          var functionPrototype = Object.getPrototypeOf(Function);
          var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
          var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
          var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
          var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
          var metadataRegistry = GetOrCreateMetadataRegistry();
          var metadataProvider = CreateMetadataProvider(metadataRegistry);
          function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsObject(target))
                throw new TypeError();
              if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                throw new TypeError();
              if (IsNull(attributes))
                attributes = void 0;
              propertyKey = ToPropertyKey(propertyKey);
              return DecorateProperty(decorators, target, propertyKey, attributes);
            } else {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsConstructor(target))
                throw new TypeError();
              return DecorateConstructor(decorators, target);
            }
          }
          exporter("decorate", decorate);
          function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
              if (!IsObject(target))
                throw new TypeError();
              if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                throw new TypeError();
              OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
          }
          exporter("metadata", metadata);
          function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          exporter("defineMetadata", defineMetadata);
          function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasMetadata", hasMetadata);
          function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasOwnMetadata", hasOwnMetadata);
          function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
          }
          exporter("getMetadata", getMetadata);
          function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("getOwnMetadata", getOwnMetadata);
          function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
          }
          exporter("getMetadataKeys", getMetadataKeys);
          function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
          }
          exporter("getOwnMetadataKeys", getOwnMetadataKeys);
          function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            var provider = GetMetadataProvider(
              target,
              propertyKey,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
          }
          exporter("deleteMetadata", deleteMetadata);
          function DecorateConstructor(decorators, target) {
            for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
              var decorator = decorators[i2];
              var decorated = decorator(target);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                  throw new TypeError();
                target = decorated;
              }
            }
            return target;
          }
          function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
              var decorator = decorators[i2];
              var decorated = decorator(target, propertyKey, descriptor);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsObject(decorated))
                  throw new TypeError();
                descriptor = decorated;
              }
            }
            return descriptor;
          }
          function OrdinaryHasMetadata(MetadataKey, O3, P2) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O3, P2);
            if (hasOwn2)
              return true;
            var parent = OrdinaryGetPrototypeOf(O3);
            if (!IsNull(parent))
              return OrdinaryHasMetadata(MetadataKey, parent, P2);
            return false;
          }
          function OrdinaryHasOwnMetadata(MetadataKey, O3, P2) {
            var provider = GetMetadataProvider(
              O3,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O3, P2));
          }
          function OrdinaryGetMetadata(MetadataKey, O3, P2) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O3, P2);
            if (hasOwn2)
              return OrdinaryGetOwnMetadata(MetadataKey, O3, P2);
            var parent = OrdinaryGetPrototypeOf(O3);
            if (!IsNull(parent))
              return OrdinaryGetMetadata(MetadataKey, parent, P2);
            return void 0;
          }
          function OrdinaryGetOwnMetadata(MetadataKey, O3, P2) {
            var provider = GetMetadataProvider(
              O3,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return;
            return provider.OrdinaryGetOwnMetadata(MetadataKey, O3, P2);
          }
          function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O3, P2) {
            var provider = GetMetadataProvider(
              O3,
              P2,
              /*Create*/
              true
            );
            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O3, P2);
          }
          function OrdinaryMetadataKeys(O3, P2) {
            var ownKeys = OrdinaryOwnMetadataKeys(O3, P2);
            var parent = OrdinaryGetPrototypeOf(O3);
            if (parent === null)
              return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P2);
            if (parentKeys.length <= 0)
              return ownKeys;
            if (ownKeys.length <= 0)
              return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i2 = 0, ownKeys_1 = ownKeys; _i2 < ownKeys_1.length; _i2++) {
              var key = ownKeys_1[_i2];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            for (var _a4 = 0, parentKeys_1 = parentKeys; _a4 < parentKeys_1.length; _a4++) {
              var key = parentKeys_1[_a4];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            return keys;
          }
          function OrdinaryOwnMetadataKeys(O3, P2) {
            var provider = GetMetadataProvider(
              O3,
              P2,
              /*create*/
              false
            );
            if (!provider) {
              return [];
            }
            return provider.OrdinaryOwnMetadataKeys(O3, P2);
          }
          function Type(x3) {
            if (x3 === null)
              return 1;
            switch (typeof x3) {
              case "undefined":
                return 0;
              case "boolean":
                return 2;
              case "string":
                return 3;
              case "symbol":
                return 4;
              case "number":
                return 5;
              case "object":
                return x3 === null ? 1 : 6;
              default:
                return 6;
            }
          }
          function IsUndefined(x3) {
            return x3 === void 0;
          }
          function IsNull(x3) {
            return x3 === null;
          }
          function IsSymbol(x3) {
            return typeof x3 === "symbol";
          }
          function IsObject(x3) {
            return typeof x3 === "object" ? x3 !== null : typeof x3 === "function";
          }
          function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
              case 0:
                return input;
              case 1:
                return input;
              case 2:
                return input;
              case 3:
                return input;
              case 4:
                return input;
              case 5:
                return input;
            }
            var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== void 0) {
              var result = exoticToPrim.call(input, hint);
              if (IsObject(result))
                throw new TypeError();
              return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
          }
          function OrdinaryToPrimitive(O3, hint) {
            if (hint === "string") {
              var toString_1 = O3.toString;
              if (IsCallable(toString_1)) {
                var result = toString_1.call(O3);
                if (!IsObject(result))
                  return result;
              }
              var valueOf = O3.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O3);
                if (!IsObject(result))
                  return result;
              }
            } else {
              var valueOf = O3.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O3);
                if (!IsObject(result))
                  return result;
              }
              var toString_2 = O3.toString;
              if (IsCallable(toString_2)) {
                var result = toString_2.call(O3);
                if (!IsObject(result))
                  return result;
              }
            }
            throw new TypeError();
          }
          function ToBoolean(argument) {
            return !!argument;
          }
          function ToString(argument) {
            return "" + argument;
          }
          function ToPropertyKey(argument) {
            var key = ToPrimitive(
              argument,
              3
              /* String */
            );
            if (IsSymbol(key))
              return key;
            return ToString(key);
          }
          function IsArray(argument) {
            return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
          }
          function IsCallable(argument) {
            return typeof argument === "function";
          }
          function IsConstructor(argument) {
            return typeof argument === "function";
          }
          function IsPropertyKey(argument) {
            switch (Type(argument)) {
              case 3:
                return true;
              case 4:
                return true;
              default:
                return false;
            }
          }
          function SameValueZero(x3, y3) {
            return x3 === y3 || x3 !== x3 && y3 !== y3;
          }
          function GetMethod(V2, P2) {
            var func = V2[P2];
            if (func === void 0 || func === null)
              return void 0;
            if (!IsCallable(func))
              throw new TypeError();
            return func;
          }
          function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
              throw new TypeError();
            var iterator = method.call(obj);
            if (!IsObject(iterator))
              throw new TypeError();
            return iterator;
          }
          function IteratorValue(iterResult) {
            return iterResult.value;
          }
          function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
          }
          function IteratorClose(iterator) {
            var f3 = iterator["return"];
            if (f3)
              f3.call(iterator);
          }
          function OrdinaryGetPrototypeOf(O3) {
            var proto = Object.getPrototypeOf(O3);
            if (typeof O3 !== "function" || O3 === functionPrototype)
              return proto;
            if (proto !== functionPrototype)
              return proto;
            var prototype = O3.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
              return proto;
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
              return proto;
            if (constructor === O3)
              return proto;
            return constructor;
          }
          function CreateMetadataRegistry() {
            var fallback;
            if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
              fallback = CreateFallbackProvider(root.Reflect);
            }
            var first;
            var second;
            var rest;
            var targetProviderMap = new _WeakMap();
            var registry = {
              registerProvider,
              getProvider,
              setProvider
            };
            return registry;
            function registerProvider(provider) {
              if (!Object.isExtensible(registry)) {
                throw new Error("Cannot add provider to a frozen registry.");
              }
              switch (true) {
                case fallback === provider:
                  break;
                case IsUndefined(first):
                  first = provider;
                  break;
                case first === provider:
                  break;
                case IsUndefined(second):
                  second = provider;
                  break;
                case second === provider:
                  break;
                default:
                  if (rest === void 0)
                    rest = new _Set();
                  rest.add(provider);
                  break;
              }
            }
            function getProviderNoCache(O3, P2) {
              if (!IsUndefined(first)) {
                if (first.isProviderFor(O3, P2))
                  return first;
                if (!IsUndefined(second)) {
                  if (second.isProviderFor(O3, P2))
                    return first;
                  if (!IsUndefined(rest)) {
                    var iterator = GetIterator(rest);
                    while (true) {
                      var next = IteratorStep(iterator);
                      if (!next) {
                        return void 0;
                      }
                      var provider = IteratorValue(next);
                      if (provider.isProviderFor(O3, P2)) {
                        IteratorClose(iterator);
                        return provider;
                      }
                    }
                  }
                }
              }
              if (!IsUndefined(fallback) && fallback.isProviderFor(O3, P2)) {
                return fallback;
              }
              return void 0;
            }
            function getProvider(O3, P2) {
              var providerMap = targetProviderMap.get(O3);
              var provider;
              if (!IsUndefined(providerMap)) {
                provider = providerMap.get(P2);
              }
              if (!IsUndefined(provider)) {
                return provider;
              }
              provider = getProviderNoCache(O3, P2);
              if (!IsUndefined(provider)) {
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O3, providerMap);
                }
                providerMap.set(P2, provider);
              }
              return provider;
            }
            function hasProvider(provider) {
              if (IsUndefined(provider))
                throw new TypeError();
              return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
            }
            function setProvider(O3, P2, provider) {
              if (!hasProvider(provider)) {
                throw new Error("Metadata provider not registered.");
              }
              var existingProvider = getProvider(O3, P2);
              if (existingProvider !== provider) {
                if (!IsUndefined(existingProvider)) {
                  return false;
                }
                var providerMap = targetProviderMap.get(O3);
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O3, providerMap);
                }
                providerMap.set(P2, provider);
              }
              return true;
            }
          }
          function GetOrCreateMetadataRegistry() {
            var metadataRegistry2;
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
              metadataRegistry2 = root.Reflect[registrySymbol];
            }
            if (IsUndefined(metadataRegistry2)) {
              metadataRegistry2 = CreateMetadataRegistry();
            }
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
              Object.defineProperty(root.Reflect, registrySymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: metadataRegistry2
              });
            }
            return metadataRegistry2;
          }
          function CreateMetadataProvider(registry) {
            var metadata2 = new _WeakMap();
            var provider = {
              isProviderFor: function(O3, P2) {
                var targetMetadata = metadata2.get(O3);
                if (IsUndefined(targetMetadata))
                  return false;
                return targetMetadata.has(P2);
              },
              OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
              OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
              OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
              OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
              OrdinaryDeleteMetadata
            };
            metadataRegistry.registerProvider(provider);
            return provider;
            function GetOrCreateMetadataMap(O3, P2, Create) {
              var targetMetadata = metadata2.get(O3);
              var createdTargetMetadata = false;
              if (IsUndefined(targetMetadata)) {
                if (!Create)
                  return void 0;
                targetMetadata = new _Map();
                metadata2.set(O3, targetMetadata);
                createdTargetMetadata = true;
              }
              var metadataMap = targetMetadata.get(P2);
              if (IsUndefined(metadataMap)) {
                if (!Create)
                  return void 0;
                metadataMap = new _Map();
                targetMetadata.set(P2, metadataMap);
                if (!registry.setProvider(O3, P2, provider)) {
                  targetMetadata.delete(P2);
                  if (createdTargetMetadata) {
                    metadata2.delete(O3);
                  }
                  throw new Error("Wrong provider for target.");
                }
              }
              return metadataMap;
            }
            function OrdinaryHasOwnMetadata2(MetadataKey, O3, P2) {
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              return ToBoolean(metadataMap.has(MetadataKey));
            }
            function OrdinaryGetOwnMetadata2(MetadataKey, O3, P2) {
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return void 0;
              return metadataMap.get(MetadataKey);
            }
            function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O3, P2) {
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                true
              );
              metadataMap.set(MetadataKey, MetadataValue);
            }
            function OrdinaryOwnMetadataKeys2(O3, P2) {
              var keys = [];
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return keys;
              var keysObj = metadataMap.keys();
              var iterator = GetIterator(keysObj);
              var k3 = 0;
              while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                  keys.length = k3;
                  return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                  keys[k3] = nextValue;
                } catch (e2) {
                  try {
                    IteratorClose(iterator);
                  } finally {
                    throw e2;
                  }
                }
                k3++;
              }
            }
            function OrdinaryDeleteMetadata(MetadataKey, O3, P2) {
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              if (!metadataMap.delete(MetadataKey))
                return false;
              if (metadataMap.size === 0) {
                var targetMetadata = metadata2.get(O3);
                if (!IsUndefined(targetMetadata)) {
                  targetMetadata.delete(P2);
                  if (targetMetadata.size === 0) {
                    metadata2.delete(targetMetadata);
                  }
                }
              }
              return true;
            }
          }
          function CreateFallbackProvider(reflect) {
            var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
            var metadataOwner = new _WeakMap();
            var provider = {
              isProviderFor: function(O3, P2) {
                var metadataPropertySet = metadataOwner.get(O3);
                if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P2)) {
                  return true;
                }
                if (getOwnMetadataKeys2(O3, P2).length) {
                  if (IsUndefined(metadataPropertySet)) {
                    metadataPropertySet = new _Set();
                    metadataOwner.set(O3, metadataPropertySet);
                  }
                  metadataPropertySet.add(P2);
                  return true;
                }
                return false;
              },
              OrdinaryDefineOwnMetadata: defineMetadata2,
              OrdinaryHasOwnMetadata: hasOwnMetadata2,
              OrdinaryGetOwnMetadata: getOwnMetadata2,
              OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
              OrdinaryDeleteMetadata: deleteMetadata2
            };
            return provider;
          }
          function GetMetadataProvider(O3, P2, Create) {
            var registeredProvider = metadataRegistry.getProvider(O3, P2);
            if (!IsUndefined(registeredProvider)) {
              return registeredProvider;
            }
            if (Create) {
              if (metadataRegistry.setProvider(O3, P2, metadataProvider)) {
                return metadataProvider;
              }
              throw new Error("Illegal state.");
            }
            return void 0;
          }
          function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (
              /** @class */
              function() {
                function MapIterator2(keys, values, selector) {
                  this._index = 0;
                  this._keys = keys;
                  this._values = values;
                  this._selector = selector;
                }
                MapIterator2.prototype["@@iterator"] = function() {
                  return this;
                };
                MapIterator2.prototype[iteratorSymbol] = function() {
                  return this;
                };
                MapIterator2.prototype.next = function() {
                  var index = this._index;
                  if (index >= 0 && index < this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                      this._index = -1;
                      this._keys = arraySentinel;
                      this._values = arraySentinel;
                    } else {
                      this._index++;
                    }
                    return { value: result, done: false };
                  }
                  return { value: void 0, done: true };
                };
                MapIterator2.prototype.throw = function(error) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  throw error;
                };
                MapIterator2.prototype.return = function(value) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  return { value, done: true };
                };
                return MapIterator2;
              }()
            );
            var Map2 = (
              /** @class */
              function() {
                function Map3() {
                  this._keys = [];
                  this._values = [];
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                Object.defineProperty(Map3.prototype, "size", {
                  get: function() {
                    return this._keys.length;
                  },
                  enumerable: true,
                  configurable: true
                });
                Map3.prototype.has = function(key) {
                  return this._find(
                    key,
                    /*insert*/
                    false
                  ) >= 0;
                };
                Map3.prototype.get = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  return index >= 0 ? this._values[index] : void 0;
                };
                Map3.prototype.set = function(key, value) {
                  var index = this._find(
                    key,
                    /*insert*/
                    true
                  );
                  this._values[index] = value;
                  return this;
                };
                Map3.prototype.delete = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  if (index >= 0) {
                    var size = this._keys.length;
                    for (var i2 = index + 1; i2 < size; i2++) {
                      this._keys[i2 - 1] = this._keys[i2];
                      this._values[i2 - 1] = this._values[i2];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (SameValueZero(key, this._cacheKey)) {
                      this._cacheKey = cacheSentinel;
                      this._cacheIndex = -2;
                    }
                    return true;
                  }
                  return false;
                };
                Map3.prototype.clear = function() {
                  this._keys.length = 0;
                  this._values.length = 0;
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                };
                Map3.prototype.keys = function() {
                  return new MapIterator(this._keys, this._values, getKey);
                };
                Map3.prototype.values = function() {
                  return new MapIterator(this._keys, this._values, getValue);
                };
                Map3.prototype.entries = function() {
                  return new MapIterator(this._keys, this._values, getEntry);
                };
                Map3.prototype["@@iterator"] = function() {
                  return this.entries();
                };
                Map3.prototype[iteratorSymbol] = function() {
                  return this.entries();
                };
                Map3.prototype._find = function(key, insert) {
                  if (!SameValueZero(this._cacheKey, key)) {
                    this._cacheIndex = -1;
                    for (var i2 = 0; i2 < this._keys.length; i2++) {
                      if (SameValueZero(this._keys[i2], key)) {
                        this._cacheIndex = i2;
                        break;
                      }
                    }
                  }
                  if (this._cacheIndex < 0 && insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(void 0);
                  }
                  return this._cacheIndex;
                };
                return Map3;
              }()
            );
            return Map2;
            function getKey(key, _3) {
              return key;
            }
            function getValue(_3, value) {
              return value;
            }
            function getEntry(key, value) {
              return [key, value];
            }
          }
          function CreateSetPolyfill() {
            var Set2 = (
              /** @class */
              function() {
                function Set3() {
                  this._map = new _Map();
                }
                Object.defineProperty(Set3.prototype, "size", {
                  get: function() {
                    return this._map.size;
                  },
                  enumerable: true,
                  configurable: true
                });
                Set3.prototype.has = function(value) {
                  return this._map.has(value);
                };
                Set3.prototype.add = function(value) {
                  return this._map.set(value, value), this;
                };
                Set3.prototype.delete = function(value) {
                  return this._map.delete(value);
                };
                Set3.prototype.clear = function() {
                  this._map.clear();
                };
                Set3.prototype.keys = function() {
                  return this._map.keys();
                };
                Set3.prototype.values = function() {
                  return this._map.keys();
                };
                Set3.prototype.entries = function() {
                  return this._map.entries();
                };
                Set3.prototype["@@iterator"] = function() {
                  return this.keys();
                };
                Set3.prototype[iteratorSymbol] = function() {
                  return this.keys();
                };
                return Set3;
              }()
            );
            return Set2;
          }
          function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (
              /** @class */
              function() {
                function WeakMap2() {
                  this._key = CreateUniqueKey();
                }
                WeakMap2.prototype.has = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.has(table, this._key) : false;
                };
                WeakMap2.prototype.get = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.get(table, this._key) : void 0;
                };
                WeakMap2.prototype.set = function(target, value) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    true
                  );
                  table[this._key] = value;
                  return this;
                };
                WeakMap2.prototype.delete = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? delete table[this._key] : false;
                };
                WeakMap2.prototype.clear = function() {
                  this._key = CreateUniqueKey();
                };
                return WeakMap2;
              }()
            );
            function CreateUniqueKey() {
              var key;
              do
                key = "@@WeakMap@@" + CreateUUID();
              while (HashMap.has(keys, key));
              keys[key] = true;
              return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
              if (!hasOwn.call(target, rootKey)) {
                if (!create)
                  return void 0;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
              }
              return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
              for (var i2 = 0; i2 < size; ++i2)
                buffer[i2] = Math.random() * 255 | 0;
              return buffer;
            }
            function GenRandomBytes(size) {
              if (typeof Uint8Array === "function") {
                var array = new Uint8Array(size);
                if (typeof crypto !== "undefined") {
                  crypto.getRandomValues(array);
                } else if (typeof msCrypto !== "undefined") {
                  msCrypto.getRandomValues(array);
                } else {
                  FillRandomBytes(array, size);
                }
                return array;
              }
              return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
              var data = GenRandomBytes(UUID_SIZE);
              data[6] = data[6] & 79 | 64;
              data[8] = data[8] & 191 | 128;
              var result = "";
              for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                  result += "-";
                if (byte < 16)
                  result += "0";
                result += byte.toString(16).toLowerCase();
              }
              return result;
            }
          }
          function MakeDictionary(obj) {
            obj.__ = void 0;
            delete obj.__;
            return obj;
          }
        });
      })(Reflect2 || (Reflect2 = {}));
    }
  });

  // node_modules/@inversifyjs/common/lib/cjs/services/calculations/stringifyServiceIdentifier.js
  var require_stringifyServiceIdentifier = __commonJS({
    "node_modules/@inversifyjs/common/lib/cjs/services/calculations/stringifyServiceIdentifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringifyServiceIdentifier = stringifyServiceIdentifier;
      function stringifyServiceIdentifier(serviceIdentifier) {
        switch (typeof serviceIdentifier) {
          case "string":
          case "symbol":
            return serviceIdentifier.toString();
          case "function":
            return serviceIdentifier.name;
          default:
            throw new Error(`Unexpected ${typeof serviceIdentifier} service id type`);
        }
      }
    }
  });

  // node_modules/@inversifyjs/common/lib/cjs/services/models/LazyServiceIdentifier.js
  var require_LazyServiceIdentifier = __commonJS({
    "node_modules/@inversifyjs/common/lib/cjs/services/models/LazyServiceIdentifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LazyServiceIdentifier = exports.islazyServiceIdentifierSymbol = void 0;
      exports.islazyServiceIdentifierSymbol = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
      var _a4, _buildServiceId;
      _a4 = exports.islazyServiceIdentifierSymbol;
      var LazyServiceIdentifier = class {
        constructor(buildServiceId) {
          __publicField(this, _a4);
          __privateAdd(this, _buildServiceId);
          __privateSet(this, _buildServiceId, buildServiceId);
          this[exports.islazyServiceIdentifierSymbol] = true;
        }
        static is(value) {
          return typeof value === "object" && value !== null && value[exports.islazyServiceIdentifierSymbol] === true;
        }
        unwrap() {
          return __privateGet(this, _buildServiceId).call(this);
        }
      };
      _buildServiceId = new WeakMap();
      exports.LazyServiceIdentifier = LazyServiceIdentifier;
    }
  });

  // node_modules/@inversifyjs/common/lib/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/@inversifyjs/common/lib/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringifyServiceIdentifier = exports.LazyServiceIdentifier = void 0;
      var stringifyServiceIdentifier_1 = require_stringifyServiceIdentifier();
      Object.defineProperty(exports, "stringifyServiceIdentifier", { enumerable: true, get: function() {
        return stringifyServiceIdentifier_1.stringifyServiceIdentifier;
      } });
      var LazyServiceIdentifier_1 = require_LazyServiceIdentifier();
      Object.defineProperty(exports, "LazyServiceIdentifier", { enumerable: true, get: function() {
        return LazyServiceIdentifier_1.LazyServiceIdentifier;
      } });
    }
  });

  // node_modules/inversify/lib/cjs/constants/metadata_keys.js
  var require_metadata_keys = __commonJS({
    "node_modules/inversify/lib/cjs/constants/metadata_keys.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NON_CUSTOM_TAG_KEYS = exports.PRE_DESTROY = exports.POST_CONSTRUCT = exports.DESIGN_PARAM_TYPES = exports.PARAM_TYPES = exports.TAGGED_PROP = exports.TAGGED = exports.MULTI_INJECT_TAG = exports.INJECT_TAG = exports.OPTIONAL_TAG = exports.UNMANAGED_TAG = exports.NAME_TAG = exports.NAMED_TAG = void 0;
      exports.NAMED_TAG = "named";
      exports.NAME_TAG = "name";
      exports.UNMANAGED_TAG = "unmanaged";
      exports.OPTIONAL_TAG = "optional";
      exports.INJECT_TAG = "inject";
      exports.MULTI_INJECT_TAG = "multi_inject";
      exports.TAGGED = "inversify:tagged";
      exports.TAGGED_PROP = "inversify:tagged_props";
      exports.PARAM_TYPES = "inversify:paramtypes";
      exports.DESIGN_PARAM_TYPES = "design:paramtypes";
      exports.POST_CONSTRUCT = "post_construct";
      exports.PRE_DESTROY = "pre_destroy";
      function getNonCustomTagKeys() {
        return [
          exports.INJECT_TAG,
          exports.MULTI_INJECT_TAG,
          exports.NAME_TAG,
          exports.UNMANAGED_TAG,
          exports.NAMED_TAG,
          exports.OPTIONAL_TAG
        ];
      }
      exports.NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
    }
  });

  // node_modules/inversify/lib/cjs/constants/literal_types.js
  var require_literal_types = __commonJS({
    "node_modules/inversify/lib/cjs/constants/literal_types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = void 0;
      var BindingScopeEnum = {
        Request: "Request",
        Singleton: "Singleton",
        Transient: "Transient"
      };
      exports.BindingScopeEnum = BindingScopeEnum;
      var BindingTypeEnum = {
        ConstantValue: "ConstantValue",
        Constructor: "Constructor",
        DynamicValue: "DynamicValue",
        Factory: "Factory",
        Function: "Function",
        Instance: "Instance",
        Invalid: "Invalid",
        Provider: "Provider"
      };
      exports.BindingTypeEnum = BindingTypeEnum;
      var TargetTypeEnum = {
        ClassProperty: "ClassProperty",
        ConstructorArgument: "ConstructorArgument",
        Variable: "Variable"
      };
      exports.TargetTypeEnum = TargetTypeEnum;
    }
  });

  // node_modules/inversify/lib/cjs/utils/id.js
  var require_id = __commonJS({
    "node_modules/inversify/lib/cjs/utils/id.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.id = id;
      var idCounter = 0;
      function id() {
        return idCounter++;
      }
    }
  });

  // node_modules/inversify/lib/cjs/bindings/binding.js
  var require_binding = __commonJS({
    "node_modules/inversify/lib/cjs/bindings/binding.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Binding = void 0;
      var literal_types_1 = require_literal_types();
      var id_1 = require_id();
      var Binding = class _Binding {
        constructor(serviceIdentifier, scope) {
          __publicField(this, "id");
          __publicField(this, "moduleId");
          // Determines weather the bindings has been already activated
          // The activation action takes place when an instance is resolved
          // If the scope is singleton it only happens once
          __publicField(this, "activated");
          // A runtime identifier because at runtime we don't have interfaces
          __publicField(this, "serviceIdentifier");
          // constructor from binding to or toConstructor
          __publicField(this, "implementationType");
          // Cache used to allow singleton scope and BindingType.ConstantValue bindings
          __publicField(this, "cache");
          // Cache used to allow BindingType.DynamicValue bindings
          __publicField(this, "dynamicValue");
          // The scope mode to be used
          __publicField(this, "scope");
          // The kind of binding
          __publicField(this, "type");
          // A factory method used in BindingType.Factory bindings
          __publicField(this, "factory");
          // An async factory method used in BindingType.Provider bindings
          __publicField(this, "provider");
          // A constraint used to limit the contexts in which this binding is applicable
          __publicField(this, "constraint");
          // On activation handler (invoked just before an instance is added to cache and injected)
          __publicField(this, "onActivation");
          // On deactivation handler (invoked just before an instance is unbinded and removed from container)
          __publicField(this, "onDeactivation");
          this.id = (0, id_1.id)();
          this.activated = false;
          this.serviceIdentifier = serviceIdentifier;
          this.scope = scope;
          this.type = literal_types_1.BindingTypeEnum.Invalid;
          this.constraint = (_request) => true;
          this.implementationType = null;
          this.cache = null;
          this.factory = null;
          this.provider = null;
          this.onActivation = null;
          this.onDeactivation = null;
          this.dynamicValue = null;
        }
        clone() {
          const clone = new _Binding(this.serviceIdentifier, this.scope);
          clone.activated = clone.scope === literal_types_1.BindingScopeEnum.Singleton ? this.activated : false;
          clone.implementationType = this.implementationType;
          clone.dynamicValue = this.dynamicValue;
          clone.scope = this.scope;
          clone.type = this.type;
          clone.factory = this.factory;
          clone.provider = this.provider;
          clone.constraint = this.constraint;
          clone.onActivation = this.onActivation;
          clone.onDeactivation = this.onDeactivation;
          clone.cache = this.cache;
          return clone;
        }
      };
      exports.Binding = Binding;
    }
  });

  // node_modules/inversify/lib/cjs/constants/error_msgs.js
  var require_error_msgs = __commonJS({
    "node_modules/inversify/lib/cjs/constants/error_msgs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.STACK_OVERFLOW = exports.CIRCULAR_DEPENDENCY_IN_FACTORY = exports.ON_DEACTIVATION_ERROR = exports.PRE_DESTROY_ERROR = exports.POST_CONSTRUCT_ERROR = exports.ASYNC_UNBIND_REQUIRED = exports.MULTIPLE_POST_CONSTRUCT_METHODS = exports.MULTIPLE_PRE_DESTROY_METHODS = exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = exports.ARGUMENTS_LENGTH_MISMATCH = exports.INVALID_DECORATOR_OPERATION = exports.INVALID_TO_SELF_VALUE = exports.LAZY_IN_SYNC = exports.INVALID_FUNCTION_BINDING = exports.INVALID_MIDDLEWARE_RETURN = exports.NO_MORE_SNAPSHOTS_AVAILABLE = exports.INVALID_BINDING_TYPE = exports.CIRCULAR_DEPENDENCY = exports.UNDEFINED_INJECT_ANNOTATION = exports.TRYING_TO_RESOLVE_BINDINGS = exports.NOT_REGISTERED = exports.CANNOT_UNBIND = exports.AMBIGUOUS_MATCH = exports.KEY_NOT_FOUND = exports.NULL_ARGUMENT = exports.DUPLICATED_METADATA = exports.DUPLICATED_INJECTABLE_DECORATOR = void 0;
      exports.DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
      exports.DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
      exports.NULL_ARGUMENT = "NULL argument";
      exports.KEY_NOT_FOUND = "Key Not Found";
      exports.AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
      exports.CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
      exports.NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
      var TRYING_TO_RESOLVE_BINDINGS = (name) => `Trying to resolve bindings for "${name}"`;
      exports.TRYING_TO_RESOLVE_BINDINGS = TRYING_TO_RESOLVE_BINDINGS;
      var UNDEFINED_INJECT_ANNOTATION = (name) => `@inject called with undefined this could mean that the class ${name} has a circular dependency problem. You can use a LazyServiceIdentifer to overcome this limitation.`;
      exports.UNDEFINED_INJECT_ANNOTATION = UNDEFINED_INJECT_ANNOTATION;
      exports.CIRCULAR_DEPENDENCY = "Circular dependency found:";
      exports.INVALID_BINDING_TYPE = "Invalid binding type:";
      exports.NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
      exports.INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
      exports.INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
      var LAZY_IN_SYNC = (key) => `You are attempting to construct ${keyToString(key)} in a synchronous way but it has asynchronous dependencies.`;
      exports.LAZY_IN_SYNC = LAZY_IN_SYNC;
      exports.INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier";
      exports.INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
      var ARGUMENTS_LENGTH_MISMATCH = (name) => `The number of constructor arguments in the derived class ${name} must be >= than the number of constructor arguments of its base class.`;
      exports.ARGUMENTS_LENGTH_MISMATCH = ARGUMENTS_LENGTH_MISMATCH;
      exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object.";
      exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must be a string ("singleton" or "transient").';
      exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean";
      exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean";
      exports.MULTIPLE_PRE_DESTROY_METHODS = "Cannot apply @preDestroy decorator multiple times in the same class";
      exports.MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
      exports.ASYNC_UNBIND_REQUIRED = "Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)";
      var POST_CONSTRUCT_ERROR = (clazz, errorMessage) => `@postConstruct error in class ${clazz}: ${errorMessage}`;
      exports.POST_CONSTRUCT_ERROR = POST_CONSTRUCT_ERROR;
      var PRE_DESTROY_ERROR = (clazz, errorMessage) => `@preDestroy error in class ${clazz}: ${errorMessage}`;
      exports.PRE_DESTROY_ERROR = PRE_DESTROY_ERROR;
      var ON_DEACTIVATION_ERROR = (clazz, errorMessage) => `onDeactivation() error in class ${clazz}: ${errorMessage}`;
      exports.ON_DEACTIVATION_ERROR = ON_DEACTIVATION_ERROR;
      var CIRCULAR_DEPENDENCY_IN_FACTORY = (factoryType, serviceIdentifier) => `It looks like there is a circular dependency in one of the '${factoryType}' bindings. Please investigate bindings with service identifier '${serviceIdentifier}'.`;
      exports.CIRCULAR_DEPENDENCY_IN_FACTORY = CIRCULAR_DEPENDENCY_IN_FACTORY;
      exports.STACK_OVERFLOW = "Maximum call stack size exceeded";
      function keyToString(key) {
        if (typeof key === "function") {
          return `[function/class ${key.name || "<anonymous>"}]`;
        }
        if (typeof key === "symbol") {
          return key.toString();
        }
        return `'${key}'`;
      }
    }
  });

  // node_modules/inversify/lib/cjs/planning/metadata_reader.js
  var require_metadata_reader = __commonJS({
    "node_modules/inversify/lib/cjs/planning/metadata_reader.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MetadataReader = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var MetadataReader = class {
        getConstructorMetadata(constructorFunc) {
          const compilerGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, constructorFunc) ?? [];
          const userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, constructorFunc);
          return {
            compilerGeneratedMetadata,
            userGeneratedMetadata: userGeneratedMetadata ?? {}
          };
        }
        getPropertiesMetadata(constructorFunc) {
          const userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED_PROP, constructorFunc) ?? {};
          return userGeneratedMetadata;
        }
      };
      exports.MetadataReader = MetadataReader;
    }
  });

  // node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/reflectMetadata/utils/getReflectMetadata.js
  var require_getReflectMetadata = __commonJS({
    "node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/reflectMetadata/utils/getReflectMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getReflectMetadata = getReflectMetadata;
      function getReflectMetadata(target, metadataKey) {
        return Reflect.getMetadata(metadataKey, target);
      }
    }
  });

  // node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/reflectMetadata/utils/updateReflectMetadata.js
  var require_updateReflectMetadata = __commonJS({
    "node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/reflectMetadata/utils/updateReflectMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.updateReflectMetadata = updateReflectMetadata;
      var getReflectMetadata_1 = require_getReflectMetadata();
      function updateReflectMetadata(target, metadataKey, defaultValue, callback) {
        const metadata = (0, getReflectMetadata_1.getReflectMetadata)(target, metadataKey) ?? defaultValue;
        const updatedMetadata = callback(metadata);
        Reflect.defineMetadata(metadataKey, updatedMetadata, target);
      }
    }
  });

  // node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/index.js
  var require_cjs2 = __commonJS({
    "node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.updateReflectMetadata = exports.getReflectMetadata = void 0;
      var getReflectMetadata_1 = require_getReflectMetadata();
      Object.defineProperty(exports, "getReflectMetadata", { enumerable: true, get: function() {
        return getReflectMetadata_1.getReflectMetadata;
      } });
      var updateReflectMetadata_1 = require_updateReflectMetadata();
      Object.defineProperty(exports, "updateReflectMetadata", { enumerable: true, get: function() {
        return updateReflectMetadata_1.updateReflectMetadata;
      } });
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/reflectMetadata/data/keys.js
  var require_keys = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/reflectMetadata/data/keys.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NON_CUSTOM_TAG_KEYS = exports.PRE_DESTROY = exports.POST_CONSTRUCT = exports.DESIGN_PARAM_TYPES = exports.PARAM_TYPES = exports.TAGGED_PROP = exports.TAGGED = exports.MULTI_INJECT_TAG = exports.INJECT_TAG = exports.OPTIONAL_TAG = exports.UNMANAGED_TAG = exports.NAME_TAG = exports.NAMED_TAG = void 0;
      exports.NAMED_TAG = "named";
      exports.NAME_TAG = "name";
      exports.UNMANAGED_TAG = "unmanaged";
      exports.OPTIONAL_TAG = "optional";
      exports.INJECT_TAG = "inject";
      exports.MULTI_INJECT_TAG = "multi_inject";
      exports.TAGGED = "inversify:tagged";
      exports.TAGGED_PROP = "inversify:tagged_props";
      exports.PARAM_TYPES = "inversify:paramtypes";
      exports.DESIGN_PARAM_TYPES = "design:paramtypes";
      exports.POST_CONSTRUCT = "post_construct";
      exports.PRE_DESTROY = "pre_destroy";
      function getNonCustomTagKeys() {
        return [
          exports.INJECT_TAG,
          exports.MULTI_INJECT_TAG,
          exports.NAME_TAG,
          exports.UNMANAGED_TAG,
          exports.NAMED_TAG,
          exports.OPTIONAL_TAG
        ];
      }
      exports.NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/error/models/InversifyCoreError.js
  var require_InversifyCoreError = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/error/models/InversifyCoreError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InversifyCoreError = exports.isAppErrorSymbol = void 0;
      exports.isAppErrorSymbol = Symbol.for("@inversifyjs/core/InversifyCoreError");
      var _a4, _b2;
      var InversifyCoreError = class _InversifyCoreError extends (_b2 = Error, _a4 = exports.isAppErrorSymbol, _b2) {
        constructor(kind, message, options) {
          super(message, options);
          __publicField(this, _a4);
          __publicField(this, "kind");
          this[exports.isAppErrorSymbol] = true;
          this.kind = kind;
        }
        static is(value) {
          return typeof value === "object" && value !== null && value[exports.isAppErrorSymbol] === true;
        }
        static isErrorOfKind(value, kind) {
          return _InversifyCoreError.is(value) && value.kind === kind;
        }
      };
      exports.InversifyCoreError = InversifyCoreError;
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/error/models/InversifyCoreErrorKind.js
  var require_InversifyCoreErrorKind = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/error/models/InversifyCoreErrorKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InversifyCoreErrorKind = void 0;
      var InversifyCoreErrorKind;
      (function(InversifyCoreErrorKind2) {
        InversifyCoreErrorKind2[InversifyCoreErrorKind2["injectionDecoratorConflict"] = 0] = "injectionDecoratorConflict";
        InversifyCoreErrorKind2[InversifyCoreErrorKind2["missingInjectionDecorator"] = 1] = "missingInjectionDecorator";
        InversifyCoreErrorKind2[InversifyCoreErrorKind2["planning"] = 2] = "planning";
        InversifyCoreErrorKind2[InversifyCoreErrorKind2["unknown"] = 3] = "unknown";
      })(InversifyCoreErrorKind || (exports.InversifyCoreErrorKind = InversifyCoreErrorKind = {}));
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/assertConstructorMetadataArrayFilled.js
  var require_assertConstructorMetadataArrayFilled = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/assertConstructorMetadataArrayFilled.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.assertConstructorMetadataArrayFilled = assertConstructorMetadataArrayFilled;
      var InversifyCoreError_1 = require_InversifyCoreError();
      var InversifyCoreErrorKind_1 = require_InversifyCoreErrorKind();
      function assertConstructorMetadataArrayFilled(type, value) {
        const undefinedIndexes = [];
        for (let i2 = 0; i2 < value.length; ++i2) {
          const element = value[i2];
          if (element === void 0) {
            undefinedIndexes.push(i2);
          }
        }
        if (undefinedIndexes.length > 0) {
          throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, `Found unexpected missing metadata on type "${type.name}" at constructor indexes "${undefinedIndexes.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
        }
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/models/ClassElementMetadataKind.js
  var require_ClassElementMetadataKind = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/models/ClassElementMetadataKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClassElementMetadataKind = void 0;
      var ClassElementMetadataKind;
      (function(ClassElementMetadataKind2) {
        ClassElementMetadataKind2[ClassElementMetadataKind2["multipleInjection"] = 0] = "multipleInjection";
        ClassElementMetadataKind2[ClassElementMetadataKind2["singleInjection"] = 1] = "singleInjection";
        ClassElementMetadataKind2[ClassElementMetadataKind2["unmanaged"] = 2] = "unmanaged";
      })(ClassElementMetadataKind || (exports.ClassElementMetadataKind = ClassElementMetadataKind = {}));
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassElementMetadataFromNewable.js
  var require_getClassElementMetadataFromNewable = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassElementMetadataFromNewable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassElementMetadataFromNewable = getClassElementMetadataFromNewable;
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      function getClassElementMetadataFromNewable(type) {
        return {
          kind: ClassElementMetadataKind_1.ClassElementMetadataKind.singleInjection,
          name: void 0,
          optional: false,
          tags: /* @__PURE__ */ new Map(),
          targetName: void 0,
          value: type
        };
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassElementMetadataFromLegacyMetadata.js
  var require_getClassElementMetadataFromLegacyMetadata = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassElementMetadataFromLegacyMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassElementMetadataFromLegacyMetadata = getClassElementMetadataFromLegacyMetadata;
      var InversifyCoreError_1 = require_InversifyCoreError();
      var InversifyCoreErrorKind_1 = require_InversifyCoreErrorKind();
      var keys_1 = require_keys();
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      function getClassElementMetadataFromLegacyMetadata(metadataList) {
        const injectMetadata = metadataList.find((metadata) => metadata.key === keys_1.INJECT_TAG);
        const multiInjectMetadata = metadataList.find((metadata) => metadata.key === keys_1.MULTI_INJECT_TAG);
        const unmanagedMetadata = metadataList.find((metadata) => metadata.key === keys_1.UNMANAGED_TAG);
        if (unmanagedMetadata !== void 0) {
          return getUnmanagedClassElementMetadata(injectMetadata, multiInjectMetadata);
        }
        if (multiInjectMetadata === void 0 && injectMetadata === void 0) {
          throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, "Expected @inject, @multiInject or @unmanaged metadata");
        }
        const nameMetadata = metadataList.find((metadata) => metadata.key === keys_1.NAMED_TAG);
        const optionalMetadata = metadataList.find((metadata) => metadata.key === keys_1.OPTIONAL_TAG);
        const targetNameMetadata = metadataList.find((metadata) => metadata.key === keys_1.NAME_TAG);
        const managedClassElementMetadata = {
          kind: injectMetadata === void 0 ? ClassElementMetadataKind_1.ClassElementMetadataKind.multipleInjection : ClassElementMetadataKind_1.ClassElementMetadataKind.singleInjection,
          name: nameMetadata?.value,
          optional: optionalMetadata !== void 0,
          tags: new Map(metadataList.filter((metadata) => keys_1.NON_CUSTOM_TAG_KEYS.every((customTagKey) => metadata.key !== customTagKey)).map((metadata) => [
            metadata.key,
            metadata.value
          ])),
          targetName: targetNameMetadata?.value,
          value: injectMetadata === void 0 ? multiInjectMetadata?.value : injectMetadata.value
        };
        return managedClassElementMetadata;
      }
      function getUnmanagedClassElementMetadata(injectMetadata, multiInjectMetadata) {
        if (multiInjectMetadata !== void 0 || injectMetadata !== void 0) {
          throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, "Expected a single @inject, @multiInject or @unmanaged metadata");
        }
        return {
          kind: ClassElementMetadataKind_1.ClassElementMetadataKind.unmanaged
        };
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getConstructorArgumentMetadataFromLegacyMetadata.js
  var require_getConstructorArgumentMetadataFromLegacyMetadata = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getConstructorArgumentMetadataFromLegacyMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getConstructorArgumentMetadataFromLegacyMetadata = getConstructorArgumentMetadataFromLegacyMetadata;
      var InversifyCoreError_1 = require_InversifyCoreError();
      var InversifyCoreErrorKind_1 = require_InversifyCoreErrorKind();
      var getClassElementMetadataFromLegacyMetadata_1 = require_getClassElementMetadataFromLegacyMetadata();
      function getConstructorArgumentMetadataFromLegacyMetadata(type, index, metadataList) {
        try {
          return (0, getClassElementMetadataFromLegacyMetadata_1.getClassElementMetadataFromLegacyMetadata)(metadataList);
        } catch (error) {
          if (InversifyCoreError_1.InversifyCoreError.isErrorOfKind(error, InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator)) {
            throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${type.name}" at constructor arguments at index "${index.toString()}"`, { cause: error });
          } else {
            throw error;
          }
        }
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataConstructorArguments.js
  var require_getClassMetadataConstructorArguments = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataConstructorArguments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataConstructorArguments = getClassMetadataConstructorArguments;
      var reflect_metadata_utils_1 = require_cjs2();
      var keys_1 = require_keys();
      var assertConstructorMetadataArrayFilled_1 = require_assertConstructorMetadataArrayFilled();
      var getClassElementMetadataFromNewable_1 = require_getClassElementMetadataFromNewable();
      var getConstructorArgumentMetadataFromLegacyMetadata_1 = require_getConstructorArgumentMetadataFromLegacyMetadata();
      function getClassMetadataConstructorArguments(type) {
        const typescriptMetadataList = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.DESIGN_PARAM_TYPES);
        const constructorParametersLegacyMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.TAGGED);
        const constructorArgumentsMetadata = [];
        if (constructorParametersLegacyMetadata !== void 0) {
          for (const [stringifiedIndex, metadataList] of Object.entries(constructorParametersLegacyMetadata)) {
            const index = parseInt(stringifiedIndex);
            constructorArgumentsMetadata[index] = (0, getConstructorArgumentMetadataFromLegacyMetadata_1.getConstructorArgumentMetadataFromLegacyMetadata)(type, index, metadataList);
          }
        }
        if (typescriptMetadataList !== void 0) {
          for (let i2 = 0; i2 < typescriptMetadataList.length; ++i2) {
            if (constructorArgumentsMetadata[i2] === void 0) {
              const typescriptMetadata = typescriptMetadataList[i2];
              constructorArgumentsMetadata[i2] = (0, getClassElementMetadataFromNewable_1.getClassElementMetadataFromNewable)(typescriptMetadata);
            }
          }
        }
        (0, assertConstructorMetadataArrayFilled_1.assertConstructorMetadataArrayFilled)(type, constructorArgumentsMetadata);
        return constructorArgumentsMetadata;
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getPropertyMetadataFromLegacyMetadata.js
  var require_getPropertyMetadataFromLegacyMetadata = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getPropertyMetadataFromLegacyMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPropertyMetadataFromLegacyMetadata = getPropertyMetadataFromLegacyMetadata;
      var InversifyCoreError_1 = require_InversifyCoreError();
      var InversifyCoreErrorKind_1 = require_InversifyCoreErrorKind();
      var getClassElementMetadataFromLegacyMetadata_1 = require_getClassElementMetadataFromLegacyMetadata();
      function getPropertyMetadataFromLegacyMetadata(type, key, metadataList) {
        try {
          return (0, getClassElementMetadataFromLegacyMetadata_1.getClassElementMetadataFromLegacyMetadata)(metadataList);
        } catch (error) {
          if (InversifyCoreError_1.InversifyCoreError.isErrorOfKind(error, InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator)) {
            throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${type.name}" at property "${key.toString()}"`, { cause: error });
          } else {
            throw error;
          }
        }
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataProperties.js
  var require_getClassMetadataProperties = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataProperties.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataProperties = getClassMetadataProperties;
      var reflect_metadata_utils_1 = require_cjs2();
      var keys_1 = require_keys();
      var getPropertyMetadataFromLegacyMetadata_1 = require_getPropertyMetadataFromLegacyMetadata();
      function getClassMetadataProperties(type) {
        const propertiesLegacyMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.TAGGED_PROP);
        const propertiesMetadata = /* @__PURE__ */ new Map();
        if (propertiesLegacyMetadata !== void 0) {
          for (const property of Reflect.ownKeys(propertiesLegacyMetadata)) {
            const legacyMetadata = propertiesLegacyMetadata[property];
            propertiesMetadata.set(property, (0, getPropertyMetadataFromLegacyMetadata_1.getPropertyMetadataFromLegacyMetadata)(type, property, legacyMetadata));
          }
        }
        return propertiesMetadata;
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadata.js
  var require_getClassMetadata = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadata = getClassMetadata;
      var reflect_metadata_utils_1 = require_cjs2();
      var keys_1 = require_keys();
      var getClassMetadataConstructorArguments_1 = require_getClassMetadataConstructorArguments();
      var getClassMetadataProperties_1 = require_getClassMetadataProperties();
      function getClassMetadata(type) {
        const postConstructMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.POST_CONSTRUCT);
        const preDestroyMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.PRE_DESTROY);
        const classMetadata = {
          constructorArguments: (0, getClassMetadataConstructorArguments_1.getClassMetadataConstructorArguments)(type),
          lifecycle: {
            postConstructMethodName: postConstructMetadata?.value,
            preDestroyMethodName: preDestroyMetadata?.value
          },
          properties: (0, getClassMetadataProperties_1.getClassMetadataProperties)(type)
        };
        return classMetadata;
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataConstructorArgumentsFromMetadataReader.js
  var require_getClassMetadataConstructorArgumentsFromMetadataReader = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataConstructorArgumentsFromMetadataReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataConstructorArgumentsFromMetadataReader = getClassMetadataConstructorArgumentsFromMetadataReader;
      var assertConstructorMetadataArrayFilled_1 = require_assertConstructorMetadataArrayFilled();
      var getClassElementMetadataFromNewable_1 = require_getClassElementMetadataFromNewable();
      var getConstructorArgumentMetadataFromLegacyMetadata_1 = require_getConstructorArgumentMetadataFromLegacyMetadata();
      function getClassMetadataConstructorArgumentsFromMetadataReader(type, metadataReader) {
        const legacyConstructorMetadata = metadataReader.getConstructorMetadata(type);
        const constructorArgumentsMetadata = [];
        for (const [stringifiedIndex, metadataList] of Object.entries(legacyConstructorMetadata.userGeneratedMetadata)) {
          const index = parseInt(stringifiedIndex);
          constructorArgumentsMetadata[index] = (0, getConstructorArgumentMetadataFromLegacyMetadata_1.getConstructorArgumentMetadataFromLegacyMetadata)(type, index, metadataList);
        }
        if (legacyConstructorMetadata.compilerGeneratedMetadata !== void 0) {
          for (let i2 = 0; i2 < legacyConstructorMetadata.compilerGeneratedMetadata.length; ++i2) {
            if (constructorArgumentsMetadata[i2] === void 0) {
              const typescriptMetadata = legacyConstructorMetadata.compilerGeneratedMetadata[i2];
              constructorArgumentsMetadata[i2] = (0, getClassElementMetadataFromNewable_1.getClassElementMetadataFromNewable)(typescriptMetadata);
            }
          }
        }
        (0, assertConstructorMetadataArrayFilled_1.assertConstructorMetadataArrayFilled)(type, constructorArgumentsMetadata);
        return constructorArgumentsMetadata;
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataPropertiesFromMetadataReader.js
  var require_getClassMetadataPropertiesFromMetadataReader = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataPropertiesFromMetadataReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataPropertiesFromMetadataReader = getClassMetadataPropertiesFromMetadataReader;
      var getPropertyMetadataFromLegacyMetadata_1 = require_getPropertyMetadataFromLegacyMetadata();
      function getClassMetadataPropertiesFromMetadataReader(type, metadataReader) {
        const propertiesLegacyMetadata = metadataReader.getPropertiesMetadata(type);
        const propertiesMetadata = /* @__PURE__ */ new Map();
        for (const property of Reflect.ownKeys(propertiesLegacyMetadata)) {
          const legacyMetadata = propertiesLegacyMetadata[property];
          propertiesMetadata.set(property, (0, getPropertyMetadataFromLegacyMetadata_1.getPropertyMetadataFromLegacyMetadata)(type, property, legacyMetadata));
        }
        return propertiesMetadata;
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataFromMetadataReader.js
  var require_getClassMetadataFromMetadataReader = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataFromMetadataReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataFromMetadataReader = getClassMetadataFromMetadataReader;
      var reflect_metadata_utils_1 = require_cjs2();
      var keys_1 = require_keys();
      var getClassMetadataConstructorArgumentsFromMetadataReader_1 = require_getClassMetadataConstructorArgumentsFromMetadataReader();
      var getClassMetadataPropertiesFromMetadataReader_1 = require_getClassMetadataPropertiesFromMetadataReader();
      function getClassMetadataFromMetadataReader(type, metadataReader) {
        const postConstructMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.POST_CONSTRUCT);
        const preDestroyMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.PRE_DESTROY);
        const classMetadata = {
          constructorArguments: (0, getClassMetadataConstructorArgumentsFromMetadataReader_1.getClassMetadataConstructorArgumentsFromMetadataReader)(type, metadataReader),
          lifecycle: {
            postConstructMethodName: postConstructMetadata?.value,
            preDestroyMethodName: preDestroyMetadata?.value
          },
          properties: (0, getClassMetadataPropertiesFromMetadataReader_1.getClassMetadataPropertiesFromMetadataReader)(type, metadataReader)
        };
        return classMetadata;
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/prototype/calculations/getBaseType.js
  var require_getBaseType = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/prototype/calculations/getBaseType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBaseType = getBaseType;
      function getBaseType(type) {
        const prototype = Object.getPrototypeOf(type.prototype);
        const baseType = prototype?.constructor;
        return baseType;
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getLegacyMetadata.js
  var require_getLegacyMetadata = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getLegacyMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getLegacyMetadata = getLegacyMetadata;
      var keys_1 = require_keys();
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      function getLegacyMetadata(classElementMetadata) {
        switch (classElementMetadata.kind) {
          case ClassElementMetadataKind_1.ClassElementMetadataKind.unmanaged:
            return getUnmanagedLegacyMetadata();
          default:
            return getManagedLegacyMetadata(classElementMetadata);
        }
      }
      function getManagedLegacyMetadata(classElementMetadata) {
        const legacyMetadataList = [
          getManagedKindLegacyMetadata(classElementMetadata)
        ];
        if (classElementMetadata.name !== void 0) {
          legacyMetadataList.push({
            key: keys_1.NAMED_TAG,
            value: classElementMetadata.name
          });
        }
        if (classElementMetadata.optional) {
          legacyMetadataList.push({
            key: keys_1.OPTIONAL_TAG,
            value: true
          });
        }
        for (const [tagKey, tagValue] of classElementMetadata.tags) {
          legacyMetadataList.push({
            key: tagKey,
            value: tagValue
          });
        }
        if (classElementMetadata.targetName !== void 0) {
          legacyMetadataList.push({
            key: keys_1.NAME_TAG,
            value: classElementMetadata.targetName
          });
        }
        return legacyMetadataList;
      }
      function getManagedKindLegacyMetadata(classElementMetadata) {
        let kindLegacyMetadata;
        switch (classElementMetadata.kind) {
          case ClassElementMetadataKind_1.ClassElementMetadataKind.multipleInjection:
            kindLegacyMetadata = {
              key: keys_1.MULTI_INJECT_TAG,
              value: classElementMetadata.value
            };
            break;
          case ClassElementMetadataKind_1.ClassElementMetadataKind.singleInjection:
            kindLegacyMetadata = {
              key: keys_1.INJECT_TAG,
              value: classElementMetadata.value
            };
            break;
        }
        return kindLegacyMetadata;
      }
      function getUnmanagedLegacyMetadata() {
        return [
          {
            key: keys_1.UNMANAGED_TAG,
            value: true
          }
        ];
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/string/models/LegacyQueryableStringImpl.js
  var require_LegacyQueryableStringImpl = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/string/models/LegacyQueryableStringImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LegacyQueryableStringImpl = void 0;
      var _str;
      var LegacyQueryableStringImpl = class {
        constructor(str) {
          __privateAdd(this, _str);
          __privateSet(this, _str, str);
        }
        startsWith(searchString) {
          return __privateGet(this, _str).startsWith(searchString);
        }
        endsWith(searchString) {
          return __privateGet(this, _str).endsWith(searchString);
        }
        contains(searchString) {
          return __privateGet(this, _str).includes(searchString);
        }
        equals(compareString) {
          return __privateGet(this, _str) === compareString;
        }
        value() {
          return __privateGet(this, _str);
        }
      };
      _str = new WeakMap();
      exports.LegacyQueryableStringImpl = LegacyQueryableStringImpl;
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/symbol/calculations/getDescription.js
  var require_getDescription = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/symbol/calculations/getDescription.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getDescription = getDescription;
      var SYMBOL_INDEX_START = 7;
      var SYMBOL_INDEX_END = -1;
      function getDescription(symbol) {
        return symbol.toString().slice(SYMBOL_INDEX_START, SYMBOL_INDEX_END);
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargetId.js
  var require_getTargetId = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargetId.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTargetId = getTargetId;
      var reflect_metadata_utils_1 = require_cjs2();
      var ID_METADATA = "@inversifyjs/core/targetId";
      function getTargetId() {
        const targetId = (0, reflect_metadata_utils_1.getReflectMetadata)(Object, ID_METADATA) ?? 0;
        if (targetId === Number.MAX_SAFE_INTEGER) {
          (0, reflect_metadata_utils_1.updateReflectMetadata)(Object, ID_METADATA, targetId, () => Number.MIN_SAFE_INTEGER);
        } else {
          (0, reflect_metadata_utils_1.updateReflectMetadata)(Object, ID_METADATA, targetId, (id) => id + 1);
        }
        return targetId;
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/legacyTarget/models/LegacyTargetImpl.js
  var require_LegacyTargetImpl = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/legacyTarget/models/LegacyTargetImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LegacyTargetImpl = void 0;
      var common_1 = require_cjs();
      var getLegacyMetadata_1 = require_getLegacyMetadata();
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      var keys_1 = require_keys();
      var LegacyQueryableStringImpl_1 = require_LegacyQueryableStringImpl();
      var getDescription_1 = require_getDescription();
      var getTargetId_1 = require_getTargetId();
      var _metadata, _id, _identifier, _lazyLegacyMetadata, _name, _type;
      var LegacyTargetImpl = class {
        constructor(identifier, metadata, type) {
          __privateAdd(this, _metadata);
          __privateAdd(this, _id);
          __privateAdd(this, _identifier);
          __privateAdd(this, _lazyLegacyMetadata);
          __privateAdd(this, _name);
          __privateAdd(this, _type);
          __privateSet(this, _id, (0, getTargetId_1.getTargetId)());
          __privateSet(this, _identifier, identifier);
          __privateSet(this, _lazyLegacyMetadata, void 0);
          __privateSet(this, _metadata, metadata);
          __privateSet(this, _name, new LegacyQueryableStringImpl_1.LegacyQueryableStringImpl(typeof identifier === "string" ? identifier : (0, getDescription_1.getDescription)(identifier)));
          __privateSet(this, _type, type);
        }
        get id() {
          return __privateGet(this, _id);
        }
        /**
         * If this is a class property target, this is the name of the property to be injected
         */
        get identifier() {
          return __privateGet(this, _identifier);
        }
        get metadata() {
          if (__privateGet(this, _lazyLegacyMetadata) === void 0) {
            __privateSet(this, _lazyLegacyMetadata, (0, getLegacyMetadata_1.getLegacyMetadata)(__privateGet(this, _metadata)));
          }
          return __privateGet(this, _lazyLegacyMetadata);
        }
        get name() {
          return __privateGet(this, _name);
        }
        get type() {
          return __privateGet(this, _type);
        }
        get serviceIdentifier() {
          if (common_1.LazyServiceIdentifier.is(__privateGet(this, _metadata).value)) {
            return __privateGet(this, _metadata).value.unwrap();
          } else {
            return __privateGet(this, _metadata).value;
          }
        }
        getCustomTags() {
          return [...__privateGet(this, _metadata).tags.entries()].map(([key, value]) => ({
            key,
            value
          }));
        }
        getNamedTag() {
          return __privateGet(this, _metadata).name === void 0 ? null : {
            key: keys_1.NAMED_TAG,
            value: __privateGet(this, _metadata).name
          };
        }
        hasTag(key) {
          return this.metadata.some((metadata) => metadata.key === key);
        }
        isArray() {
          return __privateGet(this, _metadata).kind === ClassElementMetadataKind_1.ClassElementMetadataKind.multipleInjection;
        }
        isNamed() {
          return __privateGet(this, _metadata).name !== void 0;
        }
        isOptional() {
          return __privateGet(this, _metadata).optional;
        }
        isTagged() {
          return __privateGet(this, _metadata).tags.size > 0;
        }
        matchesArray(name) {
          return this.isArray() && __privateGet(this, _metadata).value === name;
        }
        matchesNamedTag(name) {
          return __privateGet(this, _metadata).name === name;
        }
        matchesTag(key) {
          return (value) => this.metadata.some((metadata) => metadata.key === key && metadata.value === value);
        }
      };
      _metadata = new WeakMap();
      _id = new WeakMap();
      _identifier = new WeakMap();
      _lazyLegacyMetadata = new WeakMap();
      _name = new WeakMap();
      _type = new WeakMap();
      exports.LegacyTargetImpl = LegacyTargetImpl;
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargetsFromMetadataProviders.js
  var require_getTargetsFromMetadataProviders = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargetsFromMetadataProviders.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTargetsFromMetadataProviders = getTargetsFromMetadataProviders;
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      var getBaseType_1 = require_getBaseType();
      var LegacyTargetImpl_1 = require_LegacyTargetImpl();
      function getTargetsFromMetadataProviders(getClassMetadata, getClassMetadataProperties) {
        return function getTagets(type) {
          const classMetadata = getClassMetadata(type);
          let baseType = (0, getBaseType_1.getBaseType)(type);
          while (baseType !== void 0 && baseType !== Object) {
            const classMetadataProperties = getClassMetadataProperties(baseType);
            for (const [propertyKey, propertyValue] of classMetadataProperties) {
              if (!classMetadata.properties.has(propertyKey)) {
                classMetadata.properties.set(propertyKey, propertyValue);
              }
            }
            baseType = (0, getBaseType_1.getBaseType)(baseType);
          }
          const targets = [];
          for (const constructorArgument of classMetadata.constructorArguments) {
            if (constructorArgument.kind !== ClassElementMetadataKind_1.ClassElementMetadataKind.unmanaged) {
              const targetName = constructorArgument.targetName ?? "";
              targets.push(new LegacyTargetImpl_1.LegacyTargetImpl(targetName, constructorArgument, "ConstructorArgument"));
            }
          }
          for (const [property, metadata] of classMetadata.properties) {
            if (metadata.kind !== ClassElementMetadataKind_1.ClassElementMetadataKind.unmanaged) {
              const targetName = metadata.targetName ?? property;
              targets.push(new LegacyTargetImpl_1.LegacyTargetImpl(targetName, metadata, "ClassProperty"));
            }
          }
          return targets;
        };
      }
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargets.js
  var require_getTargets = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargets.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTargets = void 0;
      var getClassMetadata_1 = require_getClassMetadata();
      var getClassMetadataFromMetadataReader_1 = require_getClassMetadataFromMetadataReader();
      var getClassMetadataProperties_1 = require_getClassMetadataProperties();
      var getClassMetadataPropertiesFromMetadataReader_1 = require_getClassMetadataPropertiesFromMetadataReader();
      var getTargetsFromMetadataProviders_1 = require_getTargetsFromMetadataProviders();
      var getTargets = (metadataReader) => {
        const getClassMetadataFn = metadataReader === void 0 ? getClassMetadata_1.getClassMetadata : (type) => (0, getClassMetadataFromMetadataReader_1.getClassMetadataFromMetadataReader)(type, metadataReader);
        const getClassMetadataPropertiesFn = metadataReader === void 0 ? getClassMetadataProperties_1.getClassMetadataProperties : (type) => (0, getClassMetadataPropertiesFromMetadataReader_1.getClassMetadataPropertiesFromMetadataReader)(type, metadataReader);
        return (0, getTargetsFromMetadataProviders_1.getTargetsFromMetadataProviders)(getClassMetadataFn, getClassMetadataPropertiesFn);
      };
      exports.getTargets = getTargets;
    }
  });

  // node_modules/@inversifyjs/core/lib/cjs/index.js
  var require_cjs3 = __commonJS({
    "node_modules/@inversifyjs/core/lib/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LegacyTargetImpl = exports.getTargets = exports.getClassMetadataFromMetadataReader = exports.getClassMetadata = exports.getClassElementMetadataFromLegacyMetadata = exports.ClassElementMetadataKind = void 0;
      var getTargets_1 = require_getTargets();
      Object.defineProperty(exports, "getTargets", { enumerable: true, get: function() {
        return getTargets_1.getTargets;
      } });
      var LegacyTargetImpl_1 = require_LegacyTargetImpl();
      Object.defineProperty(exports, "LegacyTargetImpl", { enumerable: true, get: function() {
        return LegacyTargetImpl_1.LegacyTargetImpl;
      } });
      var getClassElementMetadataFromLegacyMetadata_1 = require_getClassElementMetadataFromLegacyMetadata();
      Object.defineProperty(exports, "getClassElementMetadataFromLegacyMetadata", { enumerable: true, get: function() {
        return getClassElementMetadataFromLegacyMetadata_1.getClassElementMetadataFromLegacyMetadata;
      } });
      var getClassMetadata_1 = require_getClassMetadata();
      Object.defineProperty(exports, "getClassMetadata", { enumerable: true, get: function() {
        return getClassMetadata_1.getClassMetadata;
      } });
      var getClassMetadataFromMetadataReader_1 = require_getClassMetadataFromMetadataReader();
      Object.defineProperty(exports, "getClassMetadataFromMetadataReader", { enumerable: true, get: function() {
        return getClassMetadataFromMetadataReader_1.getClassMetadataFromMetadataReader;
      } });
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      Object.defineProperty(exports, "ClassElementMetadataKind", { enumerable: true, get: function() {
        return ClassElementMetadataKind_1.ClassElementMetadataKind;
      } });
    }
  });

  // node_modules/inversify/lib/cjs/bindings/binding_count.js
  var require_binding_count = __commonJS({
    "node_modules/inversify/lib/cjs/bindings/binding_count.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingCount = void 0;
      var BindingCount;
      (function(BindingCount2) {
        BindingCount2[BindingCount2["MultipleBindingsAvailable"] = 2] = "MultipleBindingsAvailable";
        BindingCount2[BindingCount2["NoBindingsAvailable"] = 0] = "NoBindingsAvailable";
        BindingCount2[BindingCount2["OnlyOneBindingAvailable"] = 1] = "OnlyOneBindingAvailable";
      })(BindingCount || (exports.BindingCount = BindingCount = {}));
    }
  });

  // node_modules/inversify/lib/cjs/utils/exceptions.js
  var require_exceptions = __commonJS({
    "node_modules/inversify/lib/cjs/utils/exceptions.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tryAndThrowErrorIfStackOverflow = void 0;
      exports.isStackOverflowException = isStackOverflowException;
      var ERROR_MSGS = __importStar(require_error_msgs());
      function isStackOverflowException(error) {
        return error instanceof RangeError || error.message === ERROR_MSGS.STACK_OVERFLOW;
      }
      var tryAndThrowErrorIfStackOverflow = (fn, errorCallback) => {
        try {
          return fn();
        } catch (error) {
          if (isStackOverflowException(error)) {
            throw errorCallback();
          }
          throw error;
        }
      };
      exports.tryAndThrowErrorIfStackOverflow = tryAndThrowErrorIfStackOverflow;
    }
  });

  // node_modules/inversify/lib/cjs/utils/serialization.js
  var require_serialization = __commonJS({
    "node_modules/inversify/lib/cjs/utils/serialization.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFunctionName = getFunctionName;
      exports.getServiceIdentifierAsString = getServiceIdentifierAsString;
      exports.listRegisteredBindingsForServiceIdentifier = listRegisteredBindingsForServiceIdentifier;
      exports.listMetadataForTarget = listMetadataForTarget;
      exports.circularDependencyToException = circularDependencyToException;
      exports.getSymbolDescription = getSymbolDescription;
      var ERROR_MSGS = __importStar(require_error_msgs());
      function getServiceIdentifierAsString(serviceIdentifier) {
        if (typeof serviceIdentifier === "function") {
          return serviceIdentifier.name;
        } else if (typeof serviceIdentifier === "symbol") {
          return serviceIdentifier.toString();
        } else {
          return serviceIdentifier;
        }
      }
      function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
        let registeredBindingsList = "";
        const registeredBindings = getBindings(container, serviceIdentifier);
        if (registeredBindings.length !== 0) {
          registeredBindingsList = "\nRegistered bindings:";
          registeredBindings.forEach((binding) => {
            let name = "Object";
            if (binding.implementationType !== null) {
              name = getFunctionName(binding.implementationType);
            }
            registeredBindingsList = `${registeredBindingsList}
 ${name}`;
            if (binding.constraint.metaData) {
              registeredBindingsList = `${registeredBindingsList} - ${binding.constraint.metaData}`;
            }
          });
        }
        return registeredBindingsList;
      }
      function alreadyDependencyChain(request, serviceIdentifier) {
        if (request.parentRequest === null) {
          return false;
        } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
          return true;
        } else {
          return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
        }
      }
      function dependencyChainToString(request) {
        function _createStringArr(req, result = []) {
          const serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
          result.push(serviceIdentifier);
          if (req.parentRequest !== null) {
            return _createStringArr(req.parentRequest, result);
          }
          return result;
        }
        const stringArr = _createStringArr(request);
        return stringArr.reverse().join(" --> ");
      }
      function circularDependencyToException(request) {
        request.childRequests.forEach((childRequest) => {
          if (alreadyDependencyChain(request, childRequest.serviceIdentifier)) {
            const services = dependencyChainToString(childRequest);
            throw new Error(`${ERROR_MSGS.CIRCULAR_DEPENDENCY} ${services}`);
          } else {
            circularDependencyToException(childRequest);
          }
        });
      }
      function listMetadataForTarget(serviceIdentifierString, target) {
        if (target.isTagged() || target.isNamed()) {
          let m3 = "";
          const namedTag = target.getNamedTag();
          const otherTags = target.getCustomTags();
          if (namedTag !== null) {
            m3 += stringifyMetadata(namedTag) + "\n";
          }
          if (otherTags !== null) {
            otherTags.forEach((tag) => {
              m3 += stringifyMetadata(tag) + "\n";
            });
          }
          return ` ${serviceIdentifierString}
 ${serviceIdentifierString} - ${m3}`;
        } else {
          return ` ${serviceIdentifierString}`;
        }
      }
      function getFunctionName(func) {
        if (func.name != null && func.name !== "") {
          return func.name;
        } else {
          const name = func.toString();
          const match = name.match(/^function\s*([^\s(]+)/);
          return match === null ? `Anonymous function: ${name}` : match[1];
        }
      }
      function getSymbolDescription(symbol) {
        return symbol.toString().slice(7, -1);
      }
      function stringifyMetadata(metadata) {
        return `{"key":"${metadata.key.toString()}","value":"${metadata.value.toString()}"}`;
      }
    }
  });

  // node_modules/inversify/lib/cjs/planning/context.js
  var require_context = __commonJS({
    "node_modules/inversify/lib/cjs/planning/context.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Context = void 0;
      var id_1 = require_id();
      var Context = class {
        constructor(container) {
          __publicField(this, "id");
          __publicField(this, "container");
          __publicField(this, "plan");
          __publicField(this, "currentRequest");
          this.id = (0, id_1.id)();
          this.container = container;
        }
        addPlan(plan) {
          this.plan = plan;
        }
        setCurrentRequest(currentRequest) {
          this.currentRequest = currentRequest;
        }
      };
      exports.Context = Context;
    }
  });

  // node_modules/inversify/lib/cjs/planning/metadata.js
  var require_metadata = __commonJS({
    "node_modules/inversify/lib/cjs/planning/metadata.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Metadata = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var Metadata = class {
        constructor(key, value) {
          __publicField(this, "key");
          __publicField(this, "value");
          this.key = key;
          this.value = value;
        }
        toString() {
          if (this.key === METADATA_KEY.NAMED_TAG) {
            return `named: ${String(this.value).toString()} `;
          } else {
            return `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
          }
        }
      };
      exports.Metadata = Metadata;
    }
  });

  // node_modules/inversify/lib/cjs/planning/plan.js
  var require_plan = __commonJS({
    "node_modules/inversify/lib/cjs/planning/plan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Plan = void 0;
      var Plan = class {
        constructor(parentContext, rootRequest) {
          __publicField(this, "parentContext");
          __publicField(this, "rootRequest");
          this.parentContext = parentContext;
          this.rootRequest = rootRequest;
        }
      };
      exports.Plan = Plan;
    }
  });

  // node_modules/inversify/lib/cjs/utils/get_base_type.js
  var require_get_base_type = __commonJS({
    "node_modules/inversify/lib/cjs/utils/get_base_type.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBaseType = getBaseType;
      function getBaseType(type) {
        const prototype = Object.getPrototypeOf(type.prototype);
        const baseType = prototype?.constructor;
        return baseType;
      }
    }
  });

  // node_modules/inversify/lib/cjs/planning/reflection_utils.js
  var require_reflection_utils = __commonJS({
    "node_modules/inversify/lib/cjs/planning/reflection_utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFunctionName = void 0;
      exports.getDependencies = getDependencies;
      exports.getBaseClassDependencyCount = getBaseClassDependencyCount;
      var core_1 = require_cjs3();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var get_base_type_1 = require_get_base_type();
      var serialization_1 = require_serialization();
      Object.defineProperty(exports, "getFunctionName", { enumerable: true, get: function() {
        return serialization_1.getFunctionName;
      } });
      function getDependencies(metadataReader, func) {
        return (0, core_1.getTargets)(metadataReader)(func);
      }
      function getBaseClassDependencyCount(metadataReader, func) {
        const baseConstructor = (0, get_base_type_1.getBaseType)(func);
        if (baseConstructor === void 0 || baseConstructor === Object) {
          return 0;
        }
        const targets = (0, core_1.getTargets)(metadataReader)(baseConstructor);
        const metadata = targets.map((t3) => t3.metadata.filter((m3) => m3.key === METADATA_KEY.UNMANAGED_TAG));
        const unmanagedCount = [].concat.apply([], metadata).length;
        const dependencyCount = targets.length - unmanagedCount;
        if (dependencyCount > 0) {
          return dependencyCount;
        } else {
          return getBaseClassDependencyCount(metadataReader, baseConstructor);
        }
      }
    }
  });

  // node_modules/inversify/lib/cjs/planning/request.js
  var require_request = __commonJS({
    "node_modules/inversify/lib/cjs/planning/request.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Request = void 0;
      var id_1 = require_id();
      var Request = class _Request {
        constructor(serviceIdentifier, parentContext, parentRequest, bindings, target) {
          __publicField(this, "id");
          __publicField(this, "serviceIdentifier");
          __publicField(this, "parentContext");
          __publicField(this, "parentRequest");
          __publicField(this, "bindings");
          __publicField(this, "childRequests");
          __publicField(this, "target");
          __publicField(this, "requestScope");
          this.id = (0, id_1.id)();
          this.serviceIdentifier = serviceIdentifier;
          this.parentContext = parentContext;
          this.parentRequest = parentRequest;
          this.target = target;
          this.childRequests = [];
          this.bindings = Array.isArray(bindings) ? bindings : [bindings];
          this.requestScope = parentRequest === null ? /* @__PURE__ */ new Map() : null;
        }
        addChildRequest(serviceIdentifier, bindings, target) {
          const child = new _Request(serviceIdentifier, this.parentContext, this, bindings, target);
          this.childRequests.push(child);
          return child;
        }
      };
      exports.Request = Request;
    }
  });

  // node_modules/inversify/lib/cjs/planning/planner.js
  var require_planner = __commonJS({
    "node_modules/inversify/lib/cjs/planning/planner.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBindingDictionary = getBindingDictionary;
      exports.plan = plan;
      exports.createMockRequest = createMockRequest;
      var core_1 = require_cjs3();
      var binding_count_1 = require_binding_count();
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var exceptions_1 = require_exceptions();
      var serialization_1 = require_serialization();
      var context_1 = require_context();
      var metadata_1 = require_metadata();
      var plan_1 = require_plan();
      var reflection_utils_1 = require_reflection_utils();
      var request_1 = require_request();
      function getBindingDictionary(cntnr) {
        return cntnr._bindingDictionary;
      }
      function _createTarget(targetType, serviceIdentifier, metadata) {
        const metadataList = _getTargetMetadata(serviceIdentifier, metadata);
        const classElementMetadata = (0, core_1.getClassElementMetadataFromLegacyMetadata)(metadataList);
        if (classElementMetadata.kind === core_1.ClassElementMetadataKind.unmanaged) {
          throw new Error("Unexpected metadata when creating target");
        }
        const target = new core_1.LegacyTargetImpl("", classElementMetadata, targetType);
        return target;
      }
      function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
        let bindings = getBindings(context.container, target.serviceIdentifier);
        let activeBindings = [];
        if (bindings.length === binding_count_1.BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable === true && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
          context.container.bind(target.serviceIdentifier).toSelf();
          bindings = getBindings(context.container, target.serviceIdentifier);
        }
        if (!avoidConstraints) {
          activeBindings = bindings.filter((binding) => {
            const request = new request_1.Request(binding.serviceIdentifier, context, parentRequest, binding, target);
            return binding.constraint(request);
          });
        } else {
          activeBindings = bindings;
        }
        _validateActiveBindingCount(target.serviceIdentifier, activeBindings, parentRequest, target, context.container);
        return activeBindings;
      }
      function _getTargetMetadata(serviceIdentifier, metadata) {
        const metadataKey = metadata.isMultiInject ? METADATA_KEY.MULTI_INJECT_TAG : METADATA_KEY.INJECT_TAG;
        const metadataList = [
          new metadata_1.Metadata(metadataKey, serviceIdentifier)
        ];
        if (metadata.customTag !== void 0) {
          metadataList.push(new metadata_1.Metadata(metadata.customTag.key, metadata.customTag.value));
        }
        if (metadata.isOptional === true) {
          metadataList.push(new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true));
        }
        return metadataList;
      }
      function _validateActiveBindingCount(serviceIdentifier, bindings, parentRequest, target, container) {
        switch (bindings.length) {
          case binding_count_1.BindingCount.NoBindingsAvailable:
            if (target.isOptional()) {
              return bindings;
            } else {
              const serviceIdentifierString = (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier);
              let msg = ERROR_MSGS.NOT_REGISTERED;
              msg += (0, serialization_1.listMetadataForTarget)(serviceIdentifierString, target);
              msg += (0, serialization_1.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);
              if (parentRequest !== null) {
                msg += `
${ERROR_MSGS.TRYING_TO_RESOLVE_BINDINGS((0, serialization_1.getServiceIdentifierAsString)(parentRequest.serviceIdentifier))}`;
              }
              throw new Error(msg);
            }
          case binding_count_1.BindingCount.OnlyOneBindingAvailable:
            return bindings;
          case binding_count_1.BindingCount.MultipleBindingsAvailable:
          default:
            if (!target.isArray()) {
              const serviceIdentifierString = (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier);
              let msg = `${ERROR_MSGS.AMBIGUOUS_MATCH} ${serviceIdentifierString}`;
              msg += (0, serialization_1.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);
              throw new Error(msg);
            } else {
              return bindings;
            }
        }
      }
      function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
        let activeBindings;
        let childRequest;
        if (parentRequest === null) {
          activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
          childRequest = new request_1.Request(serviceIdentifier, context, null, activeBindings, target);
          const thePlan = new plan_1.Plan(context, childRequest);
          context.addPlan(thePlan);
        } else {
          activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
          childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
        }
        activeBindings.forEach((binding) => {
          let subChildRequest = null;
          if (target.isArray()) {
            subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
          } else {
            if (binding.cache !== null) {
              return;
            }
            subChildRequest = childRequest;
          }
          if (binding.type === literal_types_1.BindingTypeEnum.Instance && binding.implementationType !== null) {
            const dependencies = (0, reflection_utils_1.getDependencies)(metadataReader, binding.implementationType);
            if (context.container.options.skipBaseClassChecks !== true) {
              const baseClassDependencyCount = (0, reflection_utils_1.getBaseClassDependencyCount)(metadataReader, binding.implementationType);
              if (dependencies.length < baseClassDependencyCount) {
                const error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH((0, reflection_utils_1.getFunctionName)(binding.implementationType));
                throw new Error(error);
              }
            }
            dependencies.forEach((dependency) => {
              _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
            });
          }
        });
      }
      function getBindings(container, serviceIdentifier) {
        let bindings = [];
        const bindingDictionary = getBindingDictionary(container);
        if (bindingDictionary.hasKey(serviceIdentifier)) {
          bindings = bindingDictionary.get(serviceIdentifier);
        } else if (container.parent !== null) {
          bindings = getBindings(container.parent, serviceIdentifier);
        }
        return bindings;
      }
      function plan(metadataReader, container, targetType, serviceIdentifier, metadata, avoidConstraints = false) {
        const context = new context_1.Context(container);
        const target = _createTarget(targetType, serviceIdentifier, metadata);
        try {
          _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
          return context;
        } catch (error) {
          if ((0, exceptions_1.isStackOverflowException)(error)) {
            (0, serialization_1.circularDependencyToException)(context.plan.rootRequest);
          }
          throw error;
        }
      }
      function createMockRequest(container, serviceIdentifier, metadata) {
        const metadataList = _getTargetMetadata(serviceIdentifier, metadata);
        const classElementMetadata = (0, core_1.getClassElementMetadataFromLegacyMetadata)(metadataList);
        if (classElementMetadata.kind === core_1.ClassElementMetadataKind.unmanaged) {
          throw new Error("Unexpected metadata when creating target");
        }
        const target = new core_1.LegacyTargetImpl("", classElementMetadata, "Variable");
        const context = new context_1.Context(container);
        const request = new request_1.Request(serviceIdentifier, context, null, [], target);
        return request;
      }
    }
  });

  // node_modules/inversify/lib/cjs/utils/async.js
  var require_async = __commonJS({
    "node_modules/inversify/lib/cjs/utils/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPromise = isPromise;
      exports.isPromiseOrContainsPromise = isPromiseOrContainsPromise;
      function isPromise(object) {
        const isObjectOrFunction = typeof object === "object" && object !== null || typeof object === "function";
        return isObjectOrFunction && typeof object.then === "function";
      }
      function isPromiseOrContainsPromise(object) {
        if (isPromise(object)) {
          return true;
        }
        return Array.isArray(object) && object.some(isPromise);
      }
    }
  });

  // node_modules/inversify/lib/cjs/scope/scope.js
  var require_scope = __commonJS({
    "node_modules/inversify/lib/cjs/scope/scope.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.saveToScope = exports.tryGetFromScope = void 0;
      var literal_types_1 = require_literal_types();
      var async_1 = require_async();
      var tryGetFromScope = (requestScope, binding) => {
        if (binding.scope === literal_types_1.BindingScopeEnum.Singleton && binding.activated) {
          return binding.cache;
        }
        if (binding.scope === literal_types_1.BindingScopeEnum.Request && requestScope.has(binding.id)) {
          return requestScope.get(binding.id);
        }
        return null;
      };
      exports.tryGetFromScope = tryGetFromScope;
      var saveToScope = (requestScope, binding, result) => {
        if (binding.scope === literal_types_1.BindingScopeEnum.Singleton) {
          _saveToSingletonScope(binding, result);
        }
        if (binding.scope === literal_types_1.BindingScopeEnum.Request) {
          _saveToRequestScope(requestScope, binding, result);
        }
      };
      exports.saveToScope = saveToScope;
      var _saveToRequestScope = (requestScope, binding, result) => {
        if (!requestScope.has(binding.id)) {
          requestScope.set(binding.id, result);
        }
      };
      var _saveToSingletonScope = (binding, result) => {
        binding.cache = result;
        binding.activated = true;
        if ((0, async_1.isPromise)(result)) {
          void _saveAsyncResultToSingletonScope(binding, result);
        }
      };
      var _saveAsyncResultToSingletonScope = async (binding, asyncResult) => {
        try {
          const result = await asyncResult;
          binding.cache = result;
        } catch (ex) {
          binding.cache = null;
          binding.activated = false;
          throw ex;
        }
      };
    }
  });

  // node_modules/inversify/lib/cjs/utils/factory_type.js
  var require_factory_type = __commonJS({
    "node_modules/inversify/lib/cjs/utils/factory_type.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FactoryType = void 0;
      var FactoryType;
      (function(FactoryType2) {
        FactoryType2["DynamicValue"] = "toDynamicValue";
        FactoryType2["Factory"] = "toFactory";
        FactoryType2["Provider"] = "toProvider";
      })(FactoryType || (exports.FactoryType = FactoryType = {}));
    }
  });

  // node_modules/inversify/lib/cjs/utils/binding_utils.js
  var require_binding_utils = __commonJS({
    "node_modules/inversify/lib/cjs/utils/binding_utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFactoryDetails = exports.ensureFullyBound = exports.multiBindToService = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var serialization_1 = require_serialization();
      var factory_type_1 = require_factory_type();
      var multiBindToService = (container) => (service) => (...types) => {
        types.forEach((t3) => {
          container.bind(t3).toService(service);
        });
      };
      exports.multiBindToService = multiBindToService;
      var ensureFullyBound = (binding) => {
        let boundValue = null;
        switch (binding.type) {
          case literal_types_1.BindingTypeEnum.ConstantValue:
          case literal_types_1.BindingTypeEnum.Function:
            boundValue = binding.cache;
            break;
          case literal_types_1.BindingTypeEnum.Constructor:
          case literal_types_1.BindingTypeEnum.Instance:
            boundValue = binding.implementationType;
            break;
          case literal_types_1.BindingTypeEnum.DynamicValue:
            boundValue = binding.dynamicValue;
            break;
          case literal_types_1.BindingTypeEnum.Provider:
            boundValue = binding.provider;
            break;
          case literal_types_1.BindingTypeEnum.Factory:
            boundValue = binding.factory;
            break;
        }
        if (boundValue === null) {
          const serviceIdentifierAsString = (0, serialization_1.getServiceIdentifierAsString)(binding.serviceIdentifier);
          throw new Error(`${ERROR_MSGS.INVALID_BINDING_TYPE} ${serviceIdentifierAsString}`);
        }
      };
      exports.ensureFullyBound = ensureFullyBound;
      var getFactoryDetails = (binding) => {
        switch (binding.type) {
          case literal_types_1.BindingTypeEnum.Factory:
            return { factory: binding.factory, factoryType: factory_type_1.FactoryType.Factory };
          case literal_types_1.BindingTypeEnum.Provider:
            return { factory: binding.provider, factoryType: factory_type_1.FactoryType.Provider };
          case literal_types_1.BindingTypeEnum.DynamicValue:
            return {
              factory: binding.dynamicValue,
              factoryType: factory_type_1.FactoryType.DynamicValue
            };
          default:
            throw new Error(`Unexpected factory type ${binding.type}`);
        }
      };
      exports.getFactoryDetails = getFactoryDetails;
    }
  });

  // node_modules/inversify/lib/cjs/resolution/instantiation.js
  var require_instantiation = __commonJS({
    "node_modules/inversify/lib/cjs/resolution/instantiation.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.resolveInstance = resolveInstance;
      var error_msgs_1 = require_error_msgs();
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var async_1 = require_async();
      function _resolveRequests(childRequests, resolveRequest) {
        return childRequests.reduce((resolvedRequests, childRequest) => {
          const injection = resolveRequest(childRequest);
          const targetType = childRequest.target.type;
          if (targetType === literal_types_1.TargetTypeEnum.ConstructorArgument) {
            resolvedRequests.constructorInjections.push(injection);
          } else {
            resolvedRequests.propertyRequests.push(childRequest);
            resolvedRequests.propertyInjections.push(injection);
          }
          if (!resolvedRequests.isAsync) {
            resolvedRequests.isAsync = (0, async_1.isPromiseOrContainsPromise)(injection);
          }
          return resolvedRequests;
        }, {
          constructorInjections: [],
          isAsync: false,
          propertyInjections: [],
          propertyRequests: []
        });
      }
      function _createInstance(constr, childRequests, resolveRequest) {
        let result;
        if (childRequests.length > 0) {
          const resolved = _resolveRequests(childRequests, resolveRequest);
          const createInstanceWithInjectionsArg = {
            ...resolved,
            constr
          };
          if (resolved.isAsync) {
            result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg);
          } else {
            result = createInstanceWithInjections(createInstanceWithInjectionsArg);
          }
        } else {
          result = new constr();
        }
        return result;
      }
      function createInstanceWithInjections(args) {
        const instance = new args.constr(...args.constructorInjections);
        args.propertyRequests.forEach((r3, index) => {
          const property = r3.target.identifier;
          const injection = args.propertyInjections[index];
          if (!r3.target.isOptional() || injection !== void 0) {
            instance[property] = injection;
          }
        });
        return instance;
      }
      async function createInstanceWithInjectionsAsync(args) {
        const constructorInjections = await possiblyWaitInjections(args.constructorInjections);
        const propertyInjections = await possiblyWaitInjections(args.propertyInjections);
        return createInstanceWithInjections({
          ...args,
          constructorInjections,
          propertyInjections
        });
      }
      async function possiblyWaitInjections(possiblePromiseinjections) {
        const injections = [];
        for (const injection of possiblePromiseinjections) {
          if (Array.isArray(injection)) {
            injections.push(Promise.all(injection));
          } else {
            injections.push(injection);
          }
        }
        return Promise.all(injections);
      }
      function _getInstanceAfterPostConstruct(constr, result) {
        const postConstructResult = _postConstruct(constr, result);
        if ((0, async_1.isPromise)(postConstructResult)) {
          return postConstructResult.then(() => result);
        } else {
          return result;
        }
      }
      function _postConstruct(constr, instance) {
        if (Reflect.hasMetadata(METADATA_KEY.POST_CONSTRUCT, constr)) {
          const data = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, constr);
          try {
            return instance[data.value]?.();
          } catch (e2) {
            if (e2 instanceof Error) {
              throw new Error((0, error_msgs_1.POST_CONSTRUCT_ERROR)(constr.name, e2.message));
            }
          }
        }
      }
      function _validateInstanceResolution(binding, constr) {
        if (binding.scope !== literal_types_1.BindingScopeEnum.Singleton) {
          _throwIfHandlingDeactivation(binding, constr);
        }
      }
      function _throwIfHandlingDeactivation(binding, constr) {
        const scopeErrorMessage = `Class cannot be instantiated in ${binding.scope === literal_types_1.BindingScopeEnum.Request ? "request" : "transient"} scope.`;
        if (typeof binding.onDeactivation === "function") {
          throw new Error((0, error_msgs_1.ON_DEACTIVATION_ERROR)(constr.name, scopeErrorMessage));
        }
        if (Reflect.hasMetadata(METADATA_KEY.PRE_DESTROY, constr)) {
          throw new Error((0, error_msgs_1.PRE_DESTROY_ERROR)(constr.name, scopeErrorMessage));
        }
      }
      function resolveInstance(binding, constr, childRequests, resolveRequest) {
        _validateInstanceResolution(binding, constr);
        const result = _createInstance(constr, childRequests, resolveRequest);
        if ((0, async_1.isPromise)(result)) {
          return result.then((resolvedResult) => _getInstanceAfterPostConstruct(constr, resolvedResult));
        } else {
          return _getInstanceAfterPostConstruct(constr, result);
        }
      }
    }
  });

  // node_modules/inversify/lib/cjs/resolution/resolver.js
  var require_resolver = __commonJS({
    "node_modules/inversify/lib/cjs/resolution/resolver.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.resolve = resolve;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var planner_1 = require_planner();
      var scope_1 = require_scope();
      var async_1 = require_async();
      var binding_utils_1 = require_binding_utils();
      var exceptions_1 = require_exceptions();
      var instantiation_1 = require_instantiation();
      var _resolveRequest = (requestScope) => (request) => {
        request.parentContext.setCurrentRequest(request);
        const bindings = request.bindings;
        const childRequests = request.childRequests;
        const targetIsAnArray = request.target && request.target.isArray();
        const targetParentIsNotAnArray = !request.parentRequest || // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions
        !request.parentRequest.target || // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions
        !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
        if (targetIsAnArray && targetParentIsNotAnArray) {
          return childRequests.map((childRequest) => {
            const resolveRequest = _resolveRequest(requestScope);
            return resolveRequest(childRequest);
          });
        } else {
          if (request.target.isOptional() && bindings.length === 0) {
            return void 0;
          }
          const binding = bindings[0];
          return _resolveBinding(requestScope, request, binding);
        }
      };
      var _resolveFactoryFromBinding = (binding, context) => {
        const factoryDetails = (0, binding_utils_1.getFactoryDetails)(binding);
        return (0, exceptions_1.tryAndThrowErrorIfStackOverflow)(() => factoryDetails.factory.bind(binding)(context), () => new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString())));
      };
      var _getResolvedFromBinding = (requestScope, request, binding) => {
        let result;
        const childRequests = request.childRequests;
        (0, binding_utils_1.ensureFullyBound)(binding);
        switch (binding.type) {
          case literal_types_1.BindingTypeEnum.ConstantValue:
          case literal_types_1.BindingTypeEnum.Function:
            result = binding.cache;
            break;
          case literal_types_1.BindingTypeEnum.Constructor:
            result = binding.implementationType;
            break;
          case literal_types_1.BindingTypeEnum.Instance:
            result = (0, instantiation_1.resolveInstance)(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
            break;
          default:
            result = _resolveFactoryFromBinding(binding, request.parentContext);
        }
        return result;
      };
      var _resolveInScope = (requestScope, binding, resolveFromBinding) => {
        let result = (0, scope_1.tryGetFromScope)(requestScope, binding);
        if (result !== null) {
          return result;
        }
        result = resolveFromBinding();
        (0, scope_1.saveToScope)(requestScope, binding, result);
        return result;
      };
      var _resolveBinding = (requestScope, request, binding) => {
        return _resolveInScope(requestScope, binding, () => {
          let result = _getResolvedFromBinding(requestScope, request, binding);
          if ((0, async_1.isPromise)(result)) {
            result = result.then((resolved) => _onActivation(request, binding, resolved));
          } else {
            result = _onActivation(request, binding, result);
          }
          return result;
        });
      };
      function _onActivation(request, binding, resolved) {
        let result = _bindingActivation(request.parentContext, binding, resolved);
        const containersIterator = _getContainersIterator(request.parentContext.container);
        let container;
        let containersIteratorResult = containersIterator.next();
        do {
          container = containersIteratorResult.value;
          const context = request.parentContext;
          const serviceIdentifier = request.serviceIdentifier;
          const activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);
          if ((0, async_1.isPromise)(result)) {
            result = _activateContainerAsync(activationsIterator, context, result);
          } else {
            result = _activateContainer(activationsIterator, context, result);
          }
          containersIteratorResult = containersIterator.next();
        } while (containersIteratorResult.done !== true && !(0, planner_1.getBindingDictionary)(container).hasKey(request.serviceIdentifier));
        return result;
      }
      var _bindingActivation = (context, binding, previousResult) => {
        let result;
        if (typeof binding.onActivation === "function") {
          result = binding.onActivation(context, previousResult);
        } else {
          result = previousResult;
        }
        return result;
      };
      var _activateContainer = (activationsIterator, context, result) => {
        let activation = activationsIterator.next();
        while (activation.done !== true) {
          result = activation.value(context, result);
          if ((0, async_1.isPromise)(result)) {
            return _activateContainerAsync(activationsIterator, context, result);
          }
          activation = activationsIterator.next();
        }
        return result;
      };
      var _activateContainerAsync = async (activationsIterator, context, resultPromise) => {
        let result = await resultPromise;
        let activation = activationsIterator.next();
        while (activation.done !== true) {
          result = await activation.value(context, result);
          activation = activationsIterator.next();
        }
        return result;
      };
      var _getContainerActivationsForService = (container, serviceIdentifier) => {
        const activations = container._activations;
        return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
      };
      var _getContainersIterator = (container) => {
        const containersStack = [container];
        let parent = container.parent;
        while (parent !== null) {
          containersStack.push(parent);
          parent = parent.parent;
        }
        const getNextContainer = () => {
          const nextContainer = containersStack.pop();
          if (nextContainer !== void 0) {
            return { done: false, value: nextContainer };
          } else {
            return { done: true, value: void 0 };
          }
        };
        const containersIterator = {
          next: getNextContainer
        };
        return containersIterator;
      };
      function resolve(context) {
        const resolveRequestFunction = _resolveRequest(context.plan.rootRequest.requestScope);
        return resolveRequestFunction(context.plan.rootRequest);
      }
    }
  });

  // node_modules/inversify/lib/cjs/syntax/constraint_helpers.js
  var require_constraint_helpers = __commonJS({
    "node_modules/inversify/lib/cjs/syntax/constraint_helpers.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var traverseAncerstors = (request, constraint) => {
        const parent = request.parentRequest;
        if (parent !== null) {
          return constraint(parent) ? true : traverseAncerstors(parent, constraint);
        } else {
          return false;
        }
      };
      exports.traverseAncerstors = traverseAncerstors;
      var taggedConstraint = (key) => (value) => {
        const constraint = (request) => request !== null && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        request.target !== null && request.target.matchesTag(key)(value);
        constraint.metaData = new metadata_1.Metadata(key, value);
        return constraint;
      };
      exports.taggedConstraint = taggedConstraint;
      var namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);
      exports.namedConstraint = namedConstraint;
      var typeConstraint = (type) => (request) => {
        let binding = null;
        if (request !== null) {
          binding = request.bindings[0];
          if (typeof type === "string") {
            return binding.serviceIdentifier === type;
          } else {
            const constructor = request.bindings[0].implementationType;
            return type === constructor;
          }
        }
        return false;
      };
      exports.typeConstraint = typeConstraint;
    }
  });

  // node_modules/inversify/lib/cjs/syntax/binding_when_syntax.js
  var require_binding_when_syntax = __commonJS({
    "node_modules/inversify/lib/cjs/syntax/binding_when_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingWhenSyntax = void 0;
      var binding_on_syntax_1 = require_binding_on_syntax();
      var constraint_helpers_1 = require_constraint_helpers();
      var BindingWhenSyntax = class {
        constructor(binding) {
          __publicField(this, "_binding");
          this._binding = binding;
        }
        when(constraint) {
          this._binding.constraint = constraint;
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenTargetNamed(name) {
          this._binding.constraint = (0, constraint_helpers_1.namedConstraint)(name);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenTargetIsDefault() {
          this._binding.constraint = (request) => {
            if (request === null) {
              return false;
            }
            const targetIsDefault = (
              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
              request.target !== null && !request.target.isNamed() && !request.target.isTagged()
            );
            return targetIsDefault;
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenTargetTagged(tag, value) {
          this._binding.constraint = (0, constraint_helpers_1.taggedConstraint)(tag)(value);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenInjectedInto(parent) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.typeConstraint)(parent)(request.parentRequest);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenParentNamed(name) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.namedConstraint)(name)(request.parentRequest);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenParentTagged(tag, value) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.taggedConstraint)(tag)(value)(request.parentRequest);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenAnyAncestorIs(ancestor) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.typeConstraint)(ancestor));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenNoAncestorIs(ancestor) {
          this._binding.constraint = (request) => request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.typeConstraint)(ancestor));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenAnyAncestorNamed(name) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.namedConstraint)(name));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenNoAncestorNamed(name) {
          this._binding.constraint = (request) => request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.namedConstraint)(name));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenAnyAncestorTagged(tag, value) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.taggedConstraint)(tag)(value));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenNoAncestorTagged(tag, value) {
          this._binding.constraint = (request) => request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.taggedConstraint)(tag)(value));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenAnyAncestorMatches(constraint) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, constraint);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenNoAncestorMatches(constraint) {
          this._binding.constraint = (request) => request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, constraint);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
      };
      exports.BindingWhenSyntax = BindingWhenSyntax;
    }
  });

  // node_modules/inversify/lib/cjs/syntax/binding_on_syntax.js
  var require_binding_on_syntax = __commonJS({
    "node_modules/inversify/lib/cjs/syntax/binding_on_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingOnSyntax = void 0;
      var binding_when_syntax_1 = require_binding_when_syntax();
      var BindingOnSyntax = class {
        constructor(binding) {
          __publicField(this, "_binding");
          this._binding = binding;
        }
        onActivation(handler) {
          this._binding.onActivation = handler;
          return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        }
        onDeactivation(handler) {
          this._binding.onDeactivation = handler;
          return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        }
      };
      exports.BindingOnSyntax = BindingOnSyntax;
    }
  });

  // node_modules/inversify/lib/cjs/syntax/binding_when_on_syntax.js
  var require_binding_when_on_syntax = __commonJS({
    "node_modules/inversify/lib/cjs/syntax/binding_when_on_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingWhenOnSyntax = void 0;
      var binding_on_syntax_1 = require_binding_on_syntax();
      var binding_when_syntax_1 = require_binding_when_syntax();
      var BindingWhenOnSyntax = class {
        constructor(binding) {
          __publicField(this, "_bindingWhenSyntax");
          __publicField(this, "_bindingOnSyntax");
          __publicField(this, "_binding");
          this._binding = binding;
          this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
          this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        when(constraint) {
          return this._bindingWhenSyntax.when(constraint);
        }
        whenTargetNamed(name) {
          return this._bindingWhenSyntax.whenTargetNamed(name);
        }
        whenTargetIsDefault() {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        }
        whenTargetTagged(tag, value) {
          return this._bindingWhenSyntax.whenTargetTagged(tag, value);
        }
        whenInjectedInto(parent) {
          return this._bindingWhenSyntax.whenInjectedInto(parent);
        }
        whenParentNamed(name) {
          return this._bindingWhenSyntax.whenParentNamed(name);
        }
        whenParentTagged(tag, value) {
          return this._bindingWhenSyntax.whenParentTagged(tag, value);
        }
        whenAnyAncestorIs(ancestor) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
        }
        whenNoAncestorIs(ancestor) {
          return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
        }
        whenAnyAncestorNamed(name) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
        }
        whenAnyAncestorTagged(tag, value) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
        }
        whenNoAncestorNamed(name) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(name);
        }
        whenNoAncestorTagged(tag, value) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
        }
        whenAnyAncestorMatches(constraint) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
        }
        whenNoAncestorMatches(constraint) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
        }
        onActivation(handler) {
          return this._bindingOnSyntax.onActivation(handler);
        }
        onDeactivation(handler) {
          return this._bindingOnSyntax.onDeactivation(handler);
        }
      };
      exports.BindingWhenOnSyntax = BindingWhenOnSyntax;
    }
  });

  // node_modules/inversify/lib/cjs/syntax/binding_in_syntax.js
  var require_binding_in_syntax = __commonJS({
    "node_modules/inversify/lib/cjs/syntax/binding_in_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingInSyntax = void 0;
      var literal_types_1 = require_literal_types();
      var binding_when_on_syntax_1 = require_binding_when_on_syntax();
      var BindingInSyntax = class {
        constructor(binding) {
          __publicField(this, "_binding");
          this._binding = binding;
        }
        inRequestScope() {
          this._binding.scope = literal_types_1.BindingScopeEnum.Request;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        inSingletonScope() {
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        inTransientScope() {
          this._binding.scope = literal_types_1.BindingScopeEnum.Transient;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
      };
      exports.BindingInSyntax = BindingInSyntax;
    }
  });

  // node_modules/inversify/lib/cjs/syntax/binding_in_when_on_syntax.js
  var require_binding_in_when_on_syntax = __commonJS({
    "node_modules/inversify/lib/cjs/syntax/binding_in_when_on_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingInWhenOnSyntax = void 0;
      var binding_in_syntax_1 = require_binding_in_syntax();
      var binding_on_syntax_1 = require_binding_on_syntax();
      var binding_when_syntax_1 = require_binding_when_syntax();
      var BindingInWhenOnSyntax = class {
        constructor(binding) {
          __publicField(this, "_bindingInSyntax");
          __publicField(this, "_bindingWhenSyntax");
          __publicField(this, "_bindingOnSyntax");
          __publicField(this, "_binding");
          this._binding = binding;
          this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
          this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
          this._bindingInSyntax = new binding_in_syntax_1.BindingInSyntax(binding);
        }
        inRequestScope() {
          return this._bindingInSyntax.inRequestScope();
        }
        inSingletonScope() {
          return this._bindingInSyntax.inSingletonScope();
        }
        inTransientScope() {
          return this._bindingInSyntax.inTransientScope();
        }
        when(constraint) {
          return this._bindingWhenSyntax.when(constraint);
        }
        whenTargetNamed(name) {
          return this._bindingWhenSyntax.whenTargetNamed(name);
        }
        whenTargetIsDefault() {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        }
        whenTargetTagged(tag, value) {
          return this._bindingWhenSyntax.whenTargetTagged(tag, value);
        }
        whenInjectedInto(parent) {
          return this._bindingWhenSyntax.whenInjectedInto(parent);
        }
        whenParentNamed(name) {
          return this._bindingWhenSyntax.whenParentNamed(name);
        }
        whenParentTagged(tag, value) {
          return this._bindingWhenSyntax.whenParentTagged(tag, value);
        }
        whenAnyAncestorIs(ancestor) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
        }
        whenNoAncestorIs(ancestor) {
          return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
        }
        whenAnyAncestorNamed(name) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
        }
        whenAnyAncestorTagged(tag, value) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
        }
        whenNoAncestorNamed(name) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(name);
        }
        whenNoAncestorTagged(tag, value) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
        }
        whenAnyAncestorMatches(constraint) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
        }
        whenNoAncestorMatches(constraint) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
        }
        onActivation(handler) {
          return this._bindingOnSyntax.onActivation(handler);
        }
        onDeactivation(handler) {
          return this._bindingOnSyntax.onDeactivation(handler);
        }
      };
      exports.BindingInWhenOnSyntax = BindingInWhenOnSyntax;
    }
  });

  // node_modules/inversify/lib/cjs/syntax/binding_to_syntax.js
  var require_binding_to_syntax = __commonJS({
    "node_modules/inversify/lib/cjs/syntax/binding_to_syntax.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingToSyntax = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var binding_in_when_on_syntax_1 = require_binding_in_when_on_syntax();
      var binding_when_on_syntax_1 = require_binding_when_on_syntax();
      var BindingToSyntax = class {
        constructor(binding) {
          // TODO: Implement an internal type `_BindingToSyntax<T>` wherein this member
          // can be public. Let `BindingToSyntax<T>` be the presentational type that
          // depends on it, and does not expose this member as public.
          __publicField(this, "_binding");
          this._binding = binding;
        }
        to(constructor) {
          this._binding.type = literal_types_1.BindingTypeEnum.Instance;
          this._binding.implementationType = constructor;
          return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
        }
        toSelf() {
          if (typeof this._binding.serviceIdentifier !== "function") {
            throw new Error(ERROR_MSGS.INVALID_TO_SELF_VALUE);
          }
          const self2 = this._binding.serviceIdentifier;
          return this.to(self2);
        }
        toConstantValue(value) {
          this._binding.type = literal_types_1.BindingTypeEnum.ConstantValue;
          this._binding.cache = value;
          this._binding.dynamicValue = null;
          this._binding.implementationType = null;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toDynamicValue(func) {
          this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
          this._binding.cache = null;
          this._binding.dynamicValue = func;
          this._binding.implementationType = null;
          return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
        }
        toConstructor(constructor) {
          this._binding.type = literal_types_1.BindingTypeEnum.Constructor;
          this._binding.implementationType = constructor;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toFactory(factory) {
          this._binding.type = literal_types_1.BindingTypeEnum.Factory;
          this._binding.factory = factory;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toFunction(func) {
          if (typeof func !== "function") {
            throw new Error(ERROR_MSGS.INVALID_FUNCTION_BINDING);
          }
          const bindingWhenOnSyntax = this.toConstantValue(func);
          this._binding.type = literal_types_1.BindingTypeEnum.Function;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return bindingWhenOnSyntax;
        }
        toAutoFactory(serviceIdentifier) {
          this._binding.type = literal_types_1.BindingTypeEnum.Factory;
          this._binding.factory = (context) => {
            const autofactory = () => context.container.get(serviceIdentifier);
            return autofactory;
          };
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toAutoNamedFactory(serviceIdentifier) {
          this._binding.type = literal_types_1.BindingTypeEnum.Factory;
          this._binding.factory = (context) => {
            return (named) => context.container.getNamed(serviceIdentifier, named);
          };
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toProvider(provider) {
          this._binding.type = literal_types_1.BindingTypeEnum.Provider;
          this._binding.provider = provider;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toService(service) {
          this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
          Object.defineProperty(this._binding, "cache", {
            configurable: true,
            enumerable: true,
            get() {
              return null;
            },
            set(_value) {
            }
          });
          this._binding.dynamicValue = (context) => {
            try {
              return context.container.get(service);
            } catch (_error) {
              return context.container.getAsync(service);
            }
          };
          this._binding.implementationType = null;
        }
      };
      exports.BindingToSyntax = BindingToSyntax;
    }
  });

  // node_modules/inversify/lib/cjs/container/container_snapshot.js
  var require_container_snapshot = __commonJS({
    "node_modules/inversify/lib/cjs/container/container_snapshot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContainerSnapshot = void 0;
      var ContainerSnapshot = class _ContainerSnapshot {
        constructor() {
          __publicField(this, "bindings");
          __publicField(this, "activations");
          __publicField(this, "deactivations");
          __publicField(this, "middleware");
          __publicField(this, "moduleActivationStore");
        }
        static of(bindings, middleware, activations, deactivations, moduleActivationStore) {
          const snapshot = new _ContainerSnapshot();
          snapshot.bindings = bindings;
          snapshot.middleware = middleware;
          snapshot.deactivations = deactivations;
          snapshot.activations = activations;
          snapshot.moduleActivationStore = moduleActivationStore;
          return snapshot;
        }
      };
      exports.ContainerSnapshot = ContainerSnapshot;
    }
  });

  // node_modules/inversify/lib/cjs/utils/clonable.js
  var require_clonable = __commonJS({
    "node_modules/inversify/lib/cjs/utils/clonable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isClonable = isClonable;
      function isClonable(obj) {
        return typeof obj === "object" && obj !== null && "clone" in obj && typeof obj.clone === "function";
      }
    }
  });

  // node_modules/inversify/lib/cjs/container/lookup.js
  var require_lookup = __commonJS({
    "node_modules/inversify/lib/cjs/container/lookup.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Lookup = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var clonable_1 = require_clonable();
      var Lookup = class _Lookup {
        constructor() {
          // dictionary used store multiple values for each key <key>
          __publicField(this, "_map");
          this._map = /* @__PURE__ */ new Map();
        }
        getMap() {
          return this._map;
        }
        // adds a new entry to _map
        add(serviceIdentifier, value) {
          this._checkNonNulish(serviceIdentifier);
          if (value === null || value === void 0) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
          }
          const entry = this._map.get(serviceIdentifier);
          if (entry !== void 0) {
            entry.push(value);
          } else {
            this._map.set(serviceIdentifier, [value]);
          }
        }
        // gets the value of a entry by its key (serviceIdentifier)
        get(serviceIdentifier) {
          this._checkNonNulish(serviceIdentifier);
          const entry = this._map.get(serviceIdentifier);
          if (entry !== void 0) {
            return entry;
          } else {
            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
          }
        }
        // removes a entry from _map by its key (serviceIdentifier)
        remove(serviceIdentifier) {
          this._checkNonNulish(serviceIdentifier);
          if (!this._map.delete(serviceIdentifier)) {
            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
          }
        }
        removeIntersection(lookup) {
          this.traverse((serviceIdentifier, value) => {
            const lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : void 0;
            if (lookupActivations !== void 0) {
              const filteredValues = value.filter((lookupValue) => !lookupActivations.some((moduleActivation) => lookupValue === moduleActivation));
              this._setValue(serviceIdentifier, filteredValues);
            }
          });
        }
        removeByCondition(condition) {
          const removals = [];
          this._map.forEach((entries, key) => {
            const updatedEntries = [];
            for (const entry of entries) {
              const remove = condition(entry);
              if (remove) {
                removals.push(entry);
              } else {
                updatedEntries.push(entry);
              }
            }
            this._setValue(key, updatedEntries);
          });
          return removals;
        }
        // returns true if _map contains a key (serviceIdentifier)
        hasKey(serviceIdentifier) {
          this._checkNonNulish(serviceIdentifier);
          return this._map.has(serviceIdentifier);
        }
        // returns a new Lookup instance; note: this is not a deep clone, only Lookup related data structure (dictionary) is
        // cloned, content remains the same
        clone() {
          const copy = new _Lookup();
          this._map.forEach((value, key) => {
            value.forEach((b3) => {
              copy.add(key, (0, clonable_1.isClonable)(b3) ? b3.clone() : b3);
            });
          });
          return copy;
        }
        traverse(func) {
          this._map.forEach((value, key) => {
            func(key, value);
          });
        }
        _checkNonNulish(value) {
          if (value == null) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
          }
        }
        _setValue(serviceIdentifier, value) {
          if (value.length > 0) {
            this._map.set(serviceIdentifier, value);
          } else {
            this._map.delete(serviceIdentifier);
          }
        }
      };
      exports.Lookup = Lookup;
    }
  });

  // node_modules/inversify/lib/cjs/container/module_activation_store.js
  var require_module_activation_store = __commonJS({
    "node_modules/inversify/lib/cjs/container/module_activation_store.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ModuleActivationStore = void 0;
      var lookup_1 = require_lookup();
      var ModuleActivationStore = class _ModuleActivationStore {
        constructor() {
          __publicField(this, "_map", /* @__PURE__ */ new Map());
        }
        remove(moduleId) {
          const handlers = this._map.get(moduleId);
          if (handlers === void 0) {
            return this._getEmptyHandlersStore();
          }
          this._map.delete(moduleId);
          return handlers;
        }
        addDeactivation(moduleId, serviceIdentifier, onDeactivation) {
          this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation);
        }
        addActivation(moduleId, serviceIdentifier, onActivation) {
          this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation);
        }
        clone() {
          const clone = new _ModuleActivationStore();
          this._map.forEach((handlersStore, moduleId) => {
            clone._map.set(moduleId, {
              onActivations: handlersStore.onActivations.clone(),
              onDeactivations: handlersStore.onDeactivations.clone()
            });
          });
          return clone;
        }
        _getModuleActivationHandlers(moduleId) {
          let moduleActivationHandlers = this._map.get(moduleId);
          if (moduleActivationHandlers === void 0) {
            moduleActivationHandlers = this._getEmptyHandlersStore();
            this._map.set(moduleId, moduleActivationHandlers);
          }
          return moduleActivationHandlers;
        }
        _getEmptyHandlersStore() {
          const handlersStore = {
            onActivations: new lookup_1.Lookup(),
            onDeactivations: new lookup_1.Lookup()
          };
          return handlersStore;
        }
      };
      exports.ModuleActivationStore = ModuleActivationStore;
    }
  });

  // node_modules/inversify/lib/cjs/container/container.js
  var require_container = __commonJS({
    "node_modules/inversify/lib/cjs/container/container.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Container = void 0;
      var binding_1 = require_binding();
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_reader_1 = require_metadata_reader();
      var planner_1 = require_planner();
      var resolver_1 = require_resolver();
      var binding_to_syntax_1 = require_binding_to_syntax();
      var async_1 = require_async();
      var id_1 = require_id();
      var serialization_1 = require_serialization();
      var container_snapshot_1 = require_container_snapshot();
      var lookup_1 = require_lookup();
      var module_activation_store_1 = require_module_activation_store();
      var Container2 = class _Container {
        constructor(containerOptions) {
          __publicField(this, "id");
          __publicField(this, "parent");
          __publicField(this, "options");
          __publicField(this, "_middleware");
          __publicField(this, "_bindingDictionary");
          __publicField(this, "_activations");
          __publicField(this, "_deactivations");
          __publicField(this, "_snapshots");
          __publicField(this, "_metadataReader");
          __publicField(this, "_moduleActivationStore");
          const options = containerOptions || {};
          if (typeof options !== "object") {
            throw new Error(ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
          }
          if (options.defaultScope === void 0) {
            options.defaultScope = literal_types_1.BindingScopeEnum.Transient;
          } else if (options.defaultScope !== literal_types_1.BindingScopeEnum.Singleton && options.defaultScope !== literal_types_1.BindingScopeEnum.Transient && options.defaultScope !== literal_types_1.BindingScopeEnum.Request) {
            throw new Error(ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
          }
          if (options.autoBindInjectable === void 0) {
            options.autoBindInjectable = false;
          } else if (typeof options.autoBindInjectable !== "boolean") {
            throw new Error(ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
          }
          if (options.skipBaseClassChecks === void 0) {
            options.skipBaseClassChecks = false;
          } else if (typeof options.skipBaseClassChecks !== "boolean") {
            throw new Error(ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
          }
          this.options = {
            autoBindInjectable: options.autoBindInjectable,
            defaultScope: options.defaultScope,
            skipBaseClassChecks: options.skipBaseClassChecks
          };
          this.id = (0, id_1.id)();
          this._bindingDictionary = new lookup_1.Lookup();
          this._snapshots = [];
          this._middleware = null;
          this._activations = new lookup_1.Lookup();
          this._deactivations = new lookup_1.Lookup();
          this.parent = null;
          this._metadataReader = new metadata_reader_1.MetadataReader();
          this._moduleActivationStore = new module_activation_store_1.ModuleActivationStore();
        }
        static merge(container1, container2, ...containers) {
          const container = new _Container();
          const targetContainers = [
            container1,
            container2,
            ...containers
          ].map((targetContainer) => (0, planner_1.getBindingDictionary)(targetContainer));
          const bindingDictionary = (0, planner_1.getBindingDictionary)(container);
          function copyDictionary(origin, destination) {
            origin.traverse((_key, value) => {
              value.forEach((binding) => {
                destination.add(binding.serviceIdentifier, binding.clone());
              });
            });
          }
          targetContainers.forEach((targetBindingDictionary) => {
            copyDictionary(targetBindingDictionary, bindingDictionary);
          });
          return container;
        }
        load(...modules) {
          const getHelpers = this._getContainerModuleHelpersFactory();
          for (const currentModule of modules) {
            const containerModuleHelpers = getHelpers(currentModule.id);
            currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
          }
        }
        async loadAsync(...modules) {
          const getHelpers = this._getContainerModuleHelpersFactory();
          for (const currentModule of modules) {
            const containerModuleHelpers = getHelpers(currentModule.id);
            await currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
          }
        }
        unload(...modules) {
          modules.forEach((module2) => {
            const deactivations = this._removeModuleBindings(module2.id);
            this._deactivateSingletons(deactivations);
            this._removeModuleHandlers(module2.id);
          });
        }
        async unloadAsync(...modules) {
          for (const module2 of modules) {
            const deactivations = this._removeModuleBindings(module2.id);
            await this._deactivateSingletonsAsync(deactivations);
            this._removeModuleHandlers(module2.id);
          }
        }
        // Registers a type binding
        bind(serviceIdentifier) {
          return this._bind(this._buildBinding(serviceIdentifier));
        }
        rebind(serviceIdentifier) {
          this.unbind(serviceIdentifier);
          return this.bind(serviceIdentifier);
        }
        async rebindAsync(serviceIdentifier) {
          await this.unbindAsync(serviceIdentifier);
          return this.bind(serviceIdentifier);
        }
        // Removes a type binding from the registry by its key
        unbind(serviceIdentifier) {
          if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            const bindings = this._bindingDictionary.get(serviceIdentifier);
            this._deactivateSingletons(bindings);
          }
          this._removeServiceFromDictionary(serviceIdentifier);
        }
        async unbindAsync(serviceIdentifier) {
          if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            const bindings = this._bindingDictionary.get(serviceIdentifier);
            await this._deactivateSingletonsAsync(bindings);
          }
          this._removeServiceFromDictionary(serviceIdentifier);
        }
        // Removes all the type bindings from the registry
        unbindAll() {
          this._bindingDictionary.traverse((_key, value) => {
            this._deactivateSingletons(value);
          });
          this._bindingDictionary = new lookup_1.Lookup();
        }
        async unbindAllAsync() {
          const promises = [];
          this._bindingDictionary.traverse((_key, value) => {
            promises.push(this._deactivateSingletonsAsync(value));
          });
          await Promise.all(promises);
          this._bindingDictionary = new lookup_1.Lookup();
        }
        onActivation(serviceIdentifier, onActivation) {
          this._activations.add(serviceIdentifier, onActivation);
        }
        onDeactivation(serviceIdentifier, onDeactivation) {
          this._deactivations.add(serviceIdentifier, onDeactivation);
        }
        // Allows to check if there are bindings available for serviceIdentifier
        isBound(serviceIdentifier) {
          let bound = this._bindingDictionary.hasKey(serviceIdentifier);
          if (!bound && this.parent) {
            bound = this.parent.isBound(serviceIdentifier);
          }
          return bound;
        }
        // check binding dependency only in current container
        isCurrentBound(serviceIdentifier) {
          return this._bindingDictionary.hasKey(serviceIdentifier);
        }
        isBoundNamed(serviceIdentifier, named) {
          return this.isBoundTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        // Check if a binding with a complex constraint is available without throwing a error. Ancestors are also verified.
        isBoundTagged(serviceIdentifier, key, value) {
          let bound = false;
          if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            const bindings = this._bindingDictionary.get(serviceIdentifier);
            const request = (0, planner_1.createMockRequest)(this, serviceIdentifier, {
              customTag: {
                key,
                value
              },
              isMultiInject: false
            });
            bound = bindings.some((b3) => b3.constraint(request));
          }
          if (!bound && this.parent) {
            bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
          }
          return bound;
        }
        snapshot() {
          this._snapshots.push(container_snapshot_1.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
        }
        restore() {
          const snapshot = this._snapshots.pop();
          if (snapshot === void 0) {
            throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);
          }
          this._bindingDictionary = snapshot.bindings;
          this._activations = snapshot.activations;
          this._deactivations = snapshot.deactivations;
          this._middleware = snapshot.middleware;
          this._moduleActivationStore = snapshot.moduleActivationStore;
        }
        createChild(containerOptions) {
          const child = new _Container(containerOptions || this.options);
          child.parent = this;
          return child;
        }
        applyMiddleware(...middlewares) {
          const initial = this._middleware ? this._middleware : this._planAndResolve();
          this._middleware = middlewares.reduce((prev, curr) => curr(prev), initial);
        }
        applyCustomMetadataReader(metadataReader) {
          this._metadataReader = metadataReader;
        }
        // Resolves a dependency by its runtime identifier
        // The runtime identifier must be associated with only one binding
        // use getAll when the runtime identifier is associated with multiple bindings
        get(serviceIdentifier) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, false);
          return this._getButThrowIfAsync(getArgs);
        }
        async getAsync(serviceIdentifier) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, false);
          return this._get(getArgs);
        }
        getTagged(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, false, key, value);
          return this._getButThrowIfAsync(getArgs);
        }
        async getTaggedAsync(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, false, key, value);
          return this._get(getArgs);
        }
        getNamed(serviceIdentifier, named) {
          return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        async getNamedAsync(serviceIdentifier, named) {
          return this.getTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        // Resolves a dependency by its runtime identifier
        // The runtime identifier can be associated with one or multiple bindings
        getAll(serviceIdentifier, options) {
          const getArgs = this._getAllArgs(serviceIdentifier, options, false);
          return this._getButThrowIfAsync(getArgs);
        }
        async getAllAsync(serviceIdentifier, options) {
          const getArgs = this._getAllArgs(serviceIdentifier, options, false);
          return this._getAll(getArgs);
        }
        getAllTagged(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, true, false, key, value);
          return this._getButThrowIfAsync(getArgs);
        }
        async getAllTaggedAsync(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, true, false, key, value);
          return this._getAll(getArgs);
        }
        getAllNamed(serviceIdentifier, named) {
          return this.getAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        async getAllNamedAsync(serviceIdentifier, named) {
          return this.getAllTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        resolve(constructorFunction) {
          const isBound = this.isBound(constructorFunction);
          if (!isBound) {
            this.bind(constructorFunction).toSelf();
          }
          const resolved = this.get(constructorFunction);
          if (!isBound) {
            this.unbind(constructorFunction);
          }
          return resolved;
        }
        tryGet(serviceIdentifier) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, true);
          return this._getButThrowIfAsync(getArgs);
        }
        async tryGetAsync(serviceIdentifier) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, true);
          return this._get(getArgs);
        }
        tryGetTagged(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, true, key, value);
          return this._getButThrowIfAsync(getArgs);
        }
        async tryGetTaggedAsync(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, true, key, value);
          return this._get(getArgs);
        }
        tryGetNamed(serviceIdentifier, named) {
          return this.tryGetTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        async tryGetNamedAsync(serviceIdentifier, named) {
          return this.tryGetTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        tryGetAll(serviceIdentifier, options) {
          const getArgs = this._getAllArgs(serviceIdentifier, options, true);
          return this._getButThrowIfAsync(getArgs);
        }
        async tryGetAllAsync(serviceIdentifier, options) {
          const getArgs = this._getAllArgs(serviceIdentifier, options, true);
          return this._getAll(getArgs);
        }
        tryGetAllTagged(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, true, true, key, value);
          return this._getButThrowIfAsync(getArgs);
        }
        async tryGetAllTaggedAsync(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, true, true, key, value);
          return this._getAll(getArgs);
        }
        tryGetAllNamed(serviceIdentifier, named) {
          return this.tryGetAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        async tryGetAllNamedAsync(serviceIdentifier, named) {
          return this.tryGetAllTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        _preDestroy(constructor, instance) {
          if (constructor !== void 0 && Reflect.hasMetadata(METADATA_KEY.PRE_DESTROY, constructor)) {
            const data = Reflect.getMetadata(METADATA_KEY.PRE_DESTROY, constructor);
            return instance[data.value]?.();
          }
        }
        _removeModuleHandlers(moduleId) {
          const moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
          this._activations.removeIntersection(moduleActivationsHandlers.onActivations);
          this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
        }
        _removeModuleBindings(moduleId) {
          return this._bindingDictionary.removeByCondition((binding) => binding.moduleId === moduleId);
        }
        _deactivate(binding, instance) {
          const constructor = instance == void 0 ? void 0 : (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            Object.getPrototypeOf(instance).constructor
          );
          try {
            if (this._deactivations.hasKey(binding.serviceIdentifier)) {
              const result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());
              if ((0, async_1.isPromise)(result)) {
                return this._handleDeactivationError(result.then(async () => this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor)), binding.serviceIdentifier);
              }
            }
            const propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);
            if ((0, async_1.isPromise)(propagateDeactivationResult)) {
              return this._handleDeactivationError(propagateDeactivationResult, binding.serviceIdentifier);
            }
          } catch (ex) {
            if (ex instanceof Error) {
              throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR((0, serialization_1.getServiceIdentifierAsString)(binding.serviceIdentifier), ex.message));
            }
          }
        }
        async _handleDeactivationError(asyncResult, serviceIdentifier) {
          try {
            await asyncResult;
          } catch (ex) {
            if (ex instanceof Error) {
              throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR((0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier), ex.message));
            }
          }
        }
        _deactivateContainer(instance, deactivationsIterator) {
          let deactivation = deactivationsIterator.next();
          while (typeof deactivation.value === "function") {
            const result = deactivation.value(instance);
            if ((0, async_1.isPromise)(result)) {
              return result.then(async () => this._deactivateContainerAsync(instance, deactivationsIterator));
            }
            deactivation = deactivationsIterator.next();
          }
        }
        async _deactivateContainerAsync(instance, deactivationsIterator) {
          let deactivation = deactivationsIterator.next();
          while (typeof deactivation.value === "function") {
            await deactivation.value(instance);
            deactivation = deactivationsIterator.next();
          }
        }
        _getContainerModuleHelpersFactory() {
          const getBindFunction = (moduleId) => (serviceIdentifier) => {
            const binding = this._buildBinding(serviceIdentifier);
            binding.moduleId = moduleId;
            return this._bind(binding);
          };
          const getUnbindFunction = () => (serviceIdentifier) => {
            this.unbind(serviceIdentifier);
          };
          const getUnbindAsyncFunction = () => async (serviceIdentifier) => {
            return this.unbindAsync(serviceIdentifier);
          };
          const getIsboundFunction = () => (serviceIdentifier) => {
            return this.isBound(serviceIdentifier);
          };
          const getRebindFunction = (moduleId) => {
            const bind = getBindFunction(moduleId);
            return (serviceIdentifier) => {
              this.unbind(serviceIdentifier);
              return bind(serviceIdentifier);
            };
          };
          const getOnActivationFunction = (moduleId) => (serviceIdentifier, onActivation) => {
            this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);
            this.onActivation(serviceIdentifier, onActivation);
          };
          const getOnDeactivationFunction = (moduleId) => (serviceIdentifier, onDeactivation) => {
            this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);
            this.onDeactivation(serviceIdentifier, onDeactivation);
          };
          return (mId) => ({
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(),
            onActivationFunction: getOnActivationFunction(mId),
            onDeactivationFunction: getOnDeactivationFunction(mId),
            rebindFunction: getRebindFunction(mId),
            unbindAsyncFunction: getUnbindAsyncFunction(),
            unbindFunction: getUnbindFunction()
          });
        }
        _bind(binding) {
          this._bindingDictionary.add(binding.serviceIdentifier, binding);
          return new binding_to_syntax_1.BindingToSyntax(binding);
        }
        _buildBinding(serviceIdentifier) {
          const scope = this.options.defaultScope || literal_types_1.BindingScopeEnum.Transient;
          return new binding_1.Binding(serviceIdentifier, scope);
        }
        async _getAll(getArgs) {
          return Promise.all(this._get(getArgs));
        }
        // Prepares arguments required for resolution and
        // delegates resolution to _middleware if available
        // otherwise it delegates resolution to _planAndResolve
        _get(getArgs) {
          const planAndResolveArgs = {
            ...getArgs,
            contextInterceptor: (context) => context,
            targetType: literal_types_1.TargetTypeEnum.Variable
          };
          if (this._middleware) {
            const middlewareResult = this._middleware(planAndResolveArgs);
            if (middlewareResult === void 0 || middlewareResult === null) {
              throw new Error(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);
            }
            return middlewareResult;
          }
          return this._planAndResolve()(planAndResolveArgs);
        }
        _getButThrowIfAsync(getArgs) {
          const result = this._get(getArgs);
          if ((0, async_1.isPromiseOrContainsPromise)(result)) {
            throw new Error(ERROR_MSGS.LAZY_IN_SYNC(getArgs.serviceIdentifier));
          }
          return result;
        }
        _getAllArgs(serviceIdentifier, options, isOptional) {
          const getAllArgs = {
            avoidConstraints: !(options?.enforceBindingConstraints ?? false),
            isMultiInject: true,
            isOptional,
            serviceIdentifier
          };
          return getAllArgs;
        }
        _getNotAllArgs(serviceIdentifier, isMultiInject, isOptional, key, value) {
          const getNotAllArgs = {
            avoidConstraints: false,
            isMultiInject,
            isOptional,
            key,
            serviceIdentifier,
            value
          };
          return getNotAllArgs;
        }
        _getPlanMetadataFromNextArgs(args) {
          const planMetadata = {
            isMultiInject: args.isMultiInject
          };
          if (args.key !== void 0) {
            planMetadata.customTag = {
              key: args.key,
              value: args.value
            };
          }
          if (args.isOptional === true) {
            planMetadata.isOptional = true;
          }
          return planMetadata;
        }
        // Planner creates a plan and Resolver resolves a plan
        // one of the jobs of the Container is to links the Planner
        // with the Resolver and that is what this function is about
        _planAndResolve() {
          return (args) => {
            let context = (0, planner_1.plan)(this._metadataReader, this, args.targetType, args.serviceIdentifier, this._getPlanMetadataFromNextArgs(args), args.avoidConstraints);
            context = args.contextInterceptor(context);
            const result = (0, resolver_1.resolve)(context);
            return result;
          };
        }
        _deactivateIfSingleton(binding) {
          if (!binding.activated) {
            return;
          }
          if ((0, async_1.isPromise)(binding.cache)) {
            return binding.cache.then((resolved) => this._deactivate(binding, resolved));
          }
          return this._deactivate(binding, binding.cache);
        }
        _deactivateSingletons(bindings) {
          for (const binding of bindings) {
            const result = this._deactivateIfSingleton(binding);
            if ((0, async_1.isPromise)(result)) {
              throw new Error(ERROR_MSGS.ASYNC_UNBIND_REQUIRED);
            }
          }
        }
        async _deactivateSingletonsAsync(bindings) {
          await Promise.all(bindings.map(async (b3) => this._deactivateIfSingleton(b3)));
        }
        _propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor) {
          if (this.parent) {
            return this._deactivate.bind(this.parent)(binding, instance);
          } else {
            return this._bindingDeactivationAndPreDestroy(binding, instance, constructor);
          }
        }
        async _propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor) {
          if (this.parent) {
            await this._deactivate.bind(this.parent)(binding, instance);
          } else {
            await this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor);
          }
        }
        _removeServiceFromDictionary(serviceIdentifier) {
          try {
            this._bindingDictionary.remove(serviceIdentifier);
          } catch (_e3) {
            throw new Error(`${ERROR_MSGS.CANNOT_UNBIND} ${(0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier)}`);
          }
        }
        _bindingDeactivationAndPreDestroy(binding, instance, constructor) {
          if (typeof binding.onDeactivation === "function") {
            const result = binding.onDeactivation(instance);
            if ((0, async_1.isPromise)(result)) {
              return result.then(() => this._preDestroy(constructor, instance));
            }
          }
          return this._preDestroy(constructor, instance);
        }
        async _bindingDeactivationAndPreDestroyAsync(binding, instance, constructor) {
          if (typeof binding.onDeactivation === "function") {
            await binding.onDeactivation(instance);
          }
          await this._preDestroy(constructor, instance);
        }
      };
      exports.Container = Container2;
    }
  });

  // node_modules/inversify/lib/cjs/container/container_module.js
  var require_container_module = __commonJS({
    "node_modules/inversify/lib/cjs/container/container_module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncContainerModule = exports.ContainerModule = void 0;
      var id_1 = require_id();
      var ContainerModule = class {
        constructor(registry) {
          __publicField(this, "id");
          __publicField(this, "registry");
          this.id = (0, id_1.id)();
          this.registry = registry;
        }
      };
      exports.ContainerModule = ContainerModule;
      var AsyncContainerModule = class {
        constructor(registry) {
          __publicField(this, "id");
          __publicField(this, "registry");
          this.id = (0, id_1.id)();
          this.registry = registry;
        }
      };
      exports.AsyncContainerModule = AsyncContainerModule;
    }
  });

  // node_modules/inversify/lib/cjs/utils/js.js
  var require_js = __commonJS({
    "node_modules/inversify/lib/cjs/utils/js.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFirstArrayDuplicate = getFirstArrayDuplicate;
      function getFirstArrayDuplicate(array) {
        const seenValues = /* @__PURE__ */ new Set();
        for (const entry of array) {
          if (seenValues.has(entry)) {
            return entry;
          } else {
            seenValues.add(entry);
          }
        }
        return void 0;
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/decorator_utils.js
  var require_decorator_utils = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/decorator_utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.decorate = decorate;
      exports.tagParameter = tagParameter;
      exports.tagProperty = tagProperty;
      exports.createTaggedDecorator = createTaggedDecorator;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      var js_1 = require_js();
      function targetIsConstructorFunction(target) {
        return target.prototype !== void 0;
      }
      function _throwIfMethodParameter(parameterName) {
        if (parameterName !== void 0) {
          throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
        }
      }
      function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
        _throwIfMethodParameter(parameterName);
        _tagParameterOrProperty(METADATA_KEY.TAGGED, annotationTarget, parameterIndex.toString(), metadata);
      }
      function tagProperty(annotationTarget, propertyName, metadata) {
        if (targetIsConstructorFunction(annotationTarget)) {
          throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
        }
        _tagParameterOrProperty(METADATA_KEY.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
      }
      function _ensureNoMetadataKeyDuplicates(metadata) {
        let metadatas = [];
        if (Array.isArray(metadata)) {
          metadatas = metadata;
          const duplicate = (0, js_1.getFirstArrayDuplicate)(metadatas.map((md) => md.key));
          if (duplicate !== void 0) {
            throw new Error(`${ERROR_MSGS.DUPLICATED_METADATA} ${duplicate.toString()}`);
          }
        } else {
          metadatas = [metadata];
        }
        return metadatas;
      }
      function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
        const metadatas = _ensureNoMetadataKeyDuplicates(metadata);
        let paramsOrPropertiesMetadata = {};
        if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
          paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
        }
        let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
        if (paramOrPropertyMetadata === void 0) {
          paramOrPropertyMetadata = [];
        } else {
          for (const m3 of paramOrPropertyMetadata) {
            if (metadatas.some((md) => md.key === m3.key)) {
              throw new Error(`${ERROR_MSGS.DUPLICATED_METADATA} ${m3.key.toString()}`);
            }
          }
        }
        paramOrPropertyMetadata.push(...metadatas);
        paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
        Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
      }
      function createTaggedDecorator(metadata) {
        return (target, targetKey, indexOrPropertyDescriptor) => {
          if (typeof indexOrPropertyDescriptor === "number") {
            tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
          } else {
            tagProperty(target, targetKey, metadata);
          }
        };
      }
      function _decorate(decorators, target) {
        Reflect.decorate(decorators, target);
      }
      function _param(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function decorate(decorator, target, parameterIndexOrProperty) {
        if (typeof parameterIndexOrProperty === "number") {
          _decorate([_param(parameterIndexOrProperty, decorator)], target);
        } else if (typeof parameterIndexOrProperty === "string") {
          Reflect.decorate([decorator], target, parameterIndexOrProperty);
        } else {
          _decorate([decorator], target);
        }
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/injectable.js
  var require_injectable = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/injectable.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.injectable = injectable;
      var ERRORS_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      function injectable() {
        return function(target) {
          if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {
            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);
          }
          const types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];
          Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);
          return target;
        };
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/tagged.js
  var require_tagged = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/tagged.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tagged = tagged;
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function tagged(metadataKey, metadataValue) {
        return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(metadataKey, metadataValue));
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/named.js
  var require_named = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/named.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.named = named;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function named(name) {
        return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, name));
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/inject_base.js
  var require_inject_base = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/inject_base.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.injectBase = injectBase;
      var error_msgs_1 = require_error_msgs();
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function injectBase(metadataKey) {
        return (serviceIdentifier) => {
          return (target, targetKey, indexOrPropertyDescriptor) => {
            if (serviceIdentifier === void 0) {
              const className = typeof target === "function" ? target.name : target.constructor.name;
              throw new Error((0, error_msgs_1.UNDEFINED_INJECT_ANNOTATION)(className));
            }
            (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
          };
        };
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/inject.js
  var require_inject = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/inject.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.inject = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var inject_base_1 = require_inject_base();
      var inject = (0, inject_base_1.injectBase)(METADATA_KEY.INJECT_TAG);
      exports.inject = inject;
    }
  });

  // node_modules/inversify/lib/cjs/annotation/optional.js
  var require_optional = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/optional.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.optional = optional;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function optional() {
        return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true));
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/unmanaged.js
  var require_unmanaged = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/unmanaged.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unmanaged = unmanaged;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function unmanaged() {
        return function(target, targetKey, index) {
          const metadata = new metadata_1.Metadata(METADATA_KEY.UNMANAGED_TAG, true);
          (0, decorator_utils_1.tagParameter)(target, targetKey, index, metadata);
        };
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/multi_inject.js
  var require_multi_inject = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/multi_inject.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.multiInject = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var inject_base_1 = require_inject_base();
      var multiInject = (0, inject_base_1.injectBase)(METADATA_KEY.MULTI_INJECT_TAG);
      exports.multiInject = multiInject;
    }
  });

  // node_modules/inversify/lib/cjs/annotation/target_name.js
  var require_target_name = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/target_name.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.targetName = targetName;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function targetName(name) {
        return function(target, targetKey, index) {
          const metadata = new metadata_1.Metadata(METADATA_KEY.NAME_TAG, name);
          (0, decorator_utils_1.tagParameter)(target, targetKey, index, metadata);
        };
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/property_event_decorator.js
  var require_property_event_decorator = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/property_event_decorator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.propertyEventDecorator = propertyEventDecorator;
      var metadata_1 = require_metadata();
      function propertyEventDecorator(eventKey, errorMessage) {
        return () => {
          return (target, propertyKey) => {
            const metadata = new metadata_1.Metadata(eventKey, propertyKey);
            if (Reflect.hasOwnMetadata(eventKey, target.constructor)) {
              throw new Error(errorMessage);
            }
            Reflect.defineMetadata(eventKey, metadata, target.constructor);
          };
        };
      }
    }
  });

  // node_modules/inversify/lib/cjs/annotation/post_construct.js
  var require_post_construct = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/post_construct.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.postConstruct = void 0;
      var ERRORS_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      var property_event_decorator_1 = require_property_event_decorator();
      var postConstruct = (0, property_event_decorator_1.propertyEventDecorator)(METADATA_KEY.POST_CONSTRUCT, ERRORS_MSGS.MULTIPLE_POST_CONSTRUCT_METHODS);
      exports.postConstruct = postConstruct;
    }
  });

  // node_modules/inversify/lib/cjs/annotation/pre_destroy.js
  var require_pre_destroy = __commonJS({
    "node_modules/inversify/lib/cjs/annotation/pre_destroy.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.preDestroy = void 0;
      var ERRORS_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      var property_event_decorator_1 = require_property_event_decorator();
      var preDestroy = (0, property_event_decorator_1.propertyEventDecorator)(METADATA_KEY.PRE_DESTROY, ERRORS_MSGS.MULTIPLE_PRE_DESTROY_METHODS);
      exports.preDestroy = preDestroy;
    }
  });

  // node_modules/inversify/lib/cjs/index.js
  var require_cjs4 = __commonJS({
    "node_modules/inversify/lib/cjs/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.multiBindToService = exports.getServiceIdentifierAsString = exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = exports.decorate = exports.id = exports.MetadataReader = exports.preDestroy = exports.postConstruct = exports.targetName = exports.multiInject = exports.unmanaged = exports.optional = exports.inject = exports.named = exports.tagged = exports.injectable = exports.createTaggedDecorator = exports.ContainerModule = exports.AsyncContainerModule = exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = exports.Container = exports.METADATA_KEY = exports.LazyServiceIdentifer = exports.LazyServiceIdentifier = void 0;
      require_Reflect();
      var common_1 = require_cjs();
      var keys = __importStar(require_metadata_keys());
      var common_2 = require_cjs();
      Object.defineProperty(exports, "LazyServiceIdentifier", { enumerable: true, get: function() {
        return common_2.LazyServiceIdentifier;
      } });
      exports.LazyServiceIdentifer = common_1.LazyServiceIdentifier;
      exports.METADATA_KEY = keys;
      var container_1 = require_container();
      Object.defineProperty(exports, "Container", { enumerable: true, get: function() {
        return container_1.Container;
      } });
      var literal_types_1 = require_literal_types();
      Object.defineProperty(exports, "BindingScopeEnum", { enumerable: true, get: function() {
        return literal_types_1.BindingScopeEnum;
      } });
      Object.defineProperty(exports, "BindingTypeEnum", { enumerable: true, get: function() {
        return literal_types_1.BindingTypeEnum;
      } });
      Object.defineProperty(exports, "TargetTypeEnum", { enumerable: true, get: function() {
        return literal_types_1.TargetTypeEnum;
      } });
      var container_module_1 = require_container_module();
      Object.defineProperty(exports, "AsyncContainerModule", { enumerable: true, get: function() {
        return container_module_1.AsyncContainerModule;
      } });
      Object.defineProperty(exports, "ContainerModule", { enumerable: true, get: function() {
        return container_module_1.ContainerModule;
      } });
      var decorator_utils_1 = require_decorator_utils();
      Object.defineProperty(exports, "createTaggedDecorator", { enumerable: true, get: function() {
        return decorator_utils_1.createTaggedDecorator;
      } });
      var injectable_1 = require_injectable();
      Object.defineProperty(exports, "injectable", { enumerable: true, get: function() {
        return injectable_1.injectable;
      } });
      var tagged_1 = require_tagged();
      Object.defineProperty(exports, "tagged", { enumerable: true, get: function() {
        return tagged_1.tagged;
      } });
      var named_1 = require_named();
      Object.defineProperty(exports, "named", { enumerable: true, get: function() {
        return named_1.named;
      } });
      var inject_1 = require_inject();
      Object.defineProperty(exports, "inject", { enumerable: true, get: function() {
        return inject_1.inject;
      } });
      var optional_1 = require_optional();
      Object.defineProperty(exports, "optional", { enumerable: true, get: function() {
        return optional_1.optional;
      } });
      var unmanaged_1 = require_unmanaged();
      Object.defineProperty(exports, "unmanaged", { enumerable: true, get: function() {
        return unmanaged_1.unmanaged;
      } });
      var multi_inject_1 = require_multi_inject();
      Object.defineProperty(exports, "multiInject", { enumerable: true, get: function() {
        return multi_inject_1.multiInject;
      } });
      var target_name_1 = require_target_name();
      Object.defineProperty(exports, "targetName", { enumerable: true, get: function() {
        return target_name_1.targetName;
      } });
      var post_construct_1 = require_post_construct();
      Object.defineProperty(exports, "postConstruct", { enumerable: true, get: function() {
        return post_construct_1.postConstruct;
      } });
      var pre_destroy_1 = require_pre_destroy();
      Object.defineProperty(exports, "preDestroy", { enumerable: true, get: function() {
        return pre_destroy_1.preDestroy;
      } });
      var metadata_reader_1 = require_metadata_reader();
      Object.defineProperty(exports, "MetadataReader", { enumerable: true, get: function() {
        return metadata_reader_1.MetadataReader;
      } });
      var id_1 = require_id();
      Object.defineProperty(exports, "id", { enumerable: true, get: function() {
        return id_1.id;
      } });
      var decorator_utils_2 = require_decorator_utils();
      Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
        return decorator_utils_2.decorate;
      } });
      var constraint_helpers_1 = require_constraint_helpers();
      Object.defineProperty(exports, "traverseAncerstors", { enumerable: true, get: function() {
        return constraint_helpers_1.traverseAncerstors;
      } });
      Object.defineProperty(exports, "taggedConstraint", { enumerable: true, get: function() {
        return constraint_helpers_1.taggedConstraint;
      } });
      Object.defineProperty(exports, "namedConstraint", { enumerable: true, get: function() {
        return constraint_helpers_1.namedConstraint;
      } });
      Object.defineProperty(exports, "typeConstraint", { enumerable: true, get: function() {
        return constraint_helpers_1.typeConstraint;
      } });
      var serialization_1 = require_serialization();
      Object.defineProperty(exports, "getServiceIdentifierAsString", { enumerable: true, get: function() {
        return serialization_1.getServiceIdentifierAsString;
      } });
      var binding_utils_1 = require_binding_utils();
      Object.defineProperty(exports, "multiBindToService", { enumerable: true, get: function() {
        return binding_utils_1.multiBindToService;
      } });
    }
  });

  // node_modules/sprotty/lib/base/actions/action.js
  var require_action = __commonJS({
    "node_modules/sprotty/lib/base/actions/action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isLabeledAction = exports.LabeledAction = void 0;
      var LabeledAction = class {
        constructor(label, actions, icon) {
          this.label = label;
          this.actions = actions;
          this.icon = icon;
        }
      };
      exports.LabeledAction = LabeledAction;
      function isLabeledAction(element) {
        return element !== void 0 && element.label !== void 0 && element.actions !== void 0;
      }
      exports.isLabeledAction = isLabeledAction;
    }
  });

  // node_modules/sprotty-protocol/lib/utils/object.js
  var require_object = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/object.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.safeAssign = exports.hasOwnProperty = exports.isObject = void 0;
      function isObject(data) {
        return typeof data === "object" && data !== null;
      }
      exports.isObject = isObject;
      function hasOwnProperty(arg, key, type) {
        if (!isObject(arg)) {
          return false;
        }
        if (Array.isArray(key)) {
          for (const k3 of key) {
            if (!Object.prototype.hasOwnProperty.call(arg, k3)) {
              return false;
            }
            if (typeof type === "string" && typeof arg[k3] !== type) {
              return false;
            } else if (typeof type === "function" && !type(arg[k3])) {
              return false;
            }
          }
        } else {
          if (!Object.prototype.hasOwnProperty.call(arg, key)) {
            return false;
          }
          if (typeof type === "string") {
            return typeof arg[key] === type;
          }
          if (typeof type === "function") {
            return type(arg[key]);
          }
        }
        return true;
      }
      exports.hasOwnProperty = hasOwnProperty;
      function safeAssign(target, partial) {
        return Object.assign(target, partial);
      }
      exports.safeAssign = safeAssign;
    }
  });

  // node_modules/sprotty-protocol/lib/actions.js
  var require_actions = __commonJS({
    "node_modules/sprotty-protocol/lib/actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReconnectAction = exports.ApplyLabelEditAction = exports.DeleteElementAction = exports.CreateElementAction = exports.ExportSvgAction = exports.RequestExportSvgAction = exports.HoverFeedbackAction = exports.MoveAction = exports.RedoAction = exports.UndoAction = exports.BringToFrontAction = exports.ViewportResult = exports.GetViewportAction = exports.SetViewportAction = exports.FitToScreenAction = exports.CenterAction = exports.LayoutAction = exports.OpenAction = exports.CollapseExpandAllAction = exports.CollapseExpandAction = exports.SelectionResult = exports.GetSelectionAction = exports.SelectAllAction = exports.SelectAction = exports.LoggingAction = exports.ComputedBoundsAction = exports.RequestBoundsAction = exports.SetBoundsAction = exports.SetPopupModelAction = exports.RequestPopupModelAction = exports.UpdateModelAction = exports.SetModelAction = exports.RequestModelAction = exports.RejectAction = exports.isResponseAction = exports.setRequestContext = exports.generateRequestId = exports.isRequestAction = exports.isAction = exports.isActionMessage = void 0;
      var object_1 = require_object();
      function isActionMessage(object) {
        return (0, object_1.hasOwnProperty)(object, "action");
      }
      exports.isActionMessage = isActionMessage;
      function isAction(object) {
        return (0, object_1.hasOwnProperty)(object, "kind", "string");
      }
      exports.isAction = isAction;
      function isRequestAction(object) {
        return (0, object_1.hasOwnProperty)(object, "requestId", "string");
      }
      exports.isRequestAction = isRequestAction;
      var requestContext = "";
      var nextRequestId = 1;
      function generateRequestId() {
        return `${requestContext}_${nextRequestId++}`;
      }
      exports.generateRequestId = generateRequestId;
      function setRequestContext(context) {
        requestContext = context;
      }
      exports.setRequestContext = setRequestContext;
      function isResponseAction(object) {
        return (0, object_1.hasOwnProperty)(object, "responseId", "string") && object.responseId !== "";
      }
      exports.isResponseAction = isResponseAction;
      var RejectAction;
      (function(RejectAction2) {
        RejectAction2.KIND = "rejectRequest";
        function create(options) {
          return {
            kind: RejectAction2.KIND,
            message: options.message,
            detail: options.detail,
            responseId: options.requestId
          };
        }
        RejectAction2.create = create;
      })(RejectAction || (exports.RejectAction = RejectAction = {}));
      var RequestModelAction2;
      (function(RequestModelAction3) {
        RequestModelAction3.KIND = "requestModel";
        function create(options) {
          return {
            kind: RequestModelAction3.KIND,
            options,
            requestId: generateRequestId()
          };
        }
        RequestModelAction3.create = create;
      })(RequestModelAction2 || (exports.RequestModelAction = RequestModelAction2 = {}));
      var SetModelAction3;
      (function(SetModelAction4) {
        SetModelAction4.KIND = "setModel";
        function create(newRoot, requestId = "") {
          return {
            kind: SetModelAction4.KIND,
            newRoot,
            responseId: requestId
          };
        }
        SetModelAction4.create = create;
      })(SetModelAction3 || (exports.SetModelAction = SetModelAction3 = {}));
      var UpdateModelAction3;
      (function(UpdateModelAction4) {
        UpdateModelAction4.KIND = "updateModel";
        function create(input, options = {}) {
          if (Array.isArray(input)) {
            return {
              kind: UpdateModelAction4.KIND,
              matches: input,
              animate: options.animate,
              cause: options.cause
            };
          } else {
            return {
              kind: UpdateModelAction4.KIND,
              newRoot: input,
              animate: options.animate,
              cause: options.cause
            };
          }
        }
        UpdateModelAction4.create = create;
      })(UpdateModelAction3 || (exports.UpdateModelAction = UpdateModelAction3 = {}));
      var RequestPopupModelAction;
      (function(RequestPopupModelAction2) {
        RequestPopupModelAction2.KIND = "requestPopupModel";
        function create(options) {
          return {
            kind: RequestPopupModelAction2.KIND,
            elementId: options.elementId,
            bounds: options.bounds,
            requestId: generateRequestId()
          };
        }
        RequestPopupModelAction2.create = create;
      })(RequestPopupModelAction || (exports.RequestPopupModelAction = RequestPopupModelAction = {}));
      var SetPopupModelAction;
      (function(SetPopupModelAction2) {
        SetPopupModelAction2.KIND = "setPopupModel";
        function create(newRoot, requestId = "") {
          return {
            kind: SetPopupModelAction2.KIND,
            newRoot,
            responseId: requestId
          };
        }
        SetPopupModelAction2.create = create;
      })(SetPopupModelAction || (exports.SetPopupModelAction = SetPopupModelAction = {}));
      var SetBoundsAction;
      (function(SetBoundsAction2) {
        SetBoundsAction2.KIND = "setBounds";
        function create(bounds) {
          return {
            kind: SetBoundsAction2.KIND,
            bounds
          };
        }
        SetBoundsAction2.create = create;
      })(SetBoundsAction || (exports.SetBoundsAction = SetBoundsAction = {}));
      var RequestBoundsAction;
      (function(RequestBoundsAction2) {
        RequestBoundsAction2.KIND = "requestBounds";
        function create(newRoot) {
          return {
            kind: RequestBoundsAction2.KIND,
            newRoot,
            requestId: generateRequestId()
          };
        }
        RequestBoundsAction2.create = create;
      })(RequestBoundsAction || (exports.RequestBoundsAction = RequestBoundsAction = {}));
      var ComputedBoundsAction;
      (function(ComputedBoundsAction2) {
        ComputedBoundsAction2.KIND = "computedBounds";
        function create(bounds, options = {}) {
          var _a4;
          return {
            kind: ComputedBoundsAction2.KIND,
            bounds,
            revision: options.revision,
            alignments: options.alignments,
            responseId: (_a4 = options.requestId) !== null && _a4 !== void 0 ? _a4 : ""
          };
        }
        ComputedBoundsAction2.create = create;
      })(ComputedBoundsAction || (exports.ComputedBoundsAction = ComputedBoundsAction = {}));
      var LoggingAction;
      (function(LoggingAction2) {
        LoggingAction2.KIND = "logging";
        function create(options) {
          return Object.assign({ kind: LoggingAction2.KIND }, options);
        }
        LoggingAction2.create = create;
      })(LoggingAction || (exports.LoggingAction = LoggingAction = {}));
      var SelectAction;
      (function(SelectAction2) {
        SelectAction2.KIND = "elementSelected";
        function create(options) {
          var _a4, _b2;
          return {
            kind: SelectAction2.KIND,
            selectedElementsIDs: (_a4 = options.selectedElementsIDs) !== null && _a4 !== void 0 ? _a4 : [],
            deselectedElementsIDs: (_b2 = options.deselectedElementsIDs) !== null && _b2 !== void 0 ? _b2 : []
          };
        }
        SelectAction2.create = create;
      })(SelectAction || (exports.SelectAction = SelectAction = {}));
      var SelectAllAction;
      (function(SelectAllAction2) {
        SelectAllAction2.KIND = "allSelected";
        function create(options = {}) {
          var _a4;
          return {
            kind: SelectAllAction2.KIND,
            select: (_a4 = options.select) !== null && _a4 !== void 0 ? _a4 : true
          };
        }
        SelectAllAction2.create = create;
      })(SelectAllAction || (exports.SelectAllAction = SelectAllAction = {}));
      var GetSelectionAction;
      (function(GetSelectionAction2) {
        GetSelectionAction2.KIND = "getSelection";
        function create() {
          return {
            kind: GetSelectionAction2.KIND,
            requestId: generateRequestId()
          };
        }
        GetSelectionAction2.create = create;
      })(GetSelectionAction || (exports.GetSelectionAction = GetSelectionAction = {}));
      var SelectionResult;
      (function(SelectionResult2) {
        SelectionResult2.KIND = "selectionResult";
        function create(selectedElementsIDs, requestId) {
          return {
            kind: SelectionResult2.KIND,
            selectedElementsIDs,
            responseId: requestId
          };
        }
        SelectionResult2.create = create;
      })(SelectionResult || (exports.SelectionResult = SelectionResult = {}));
      var CollapseExpandAction;
      (function(CollapseExpandAction2) {
        CollapseExpandAction2.KIND = "collapseExpand";
        function create(options) {
          var _a4, _b2;
          return {
            kind: CollapseExpandAction2.KIND,
            expandIds: (_a4 = options.expandIds) !== null && _a4 !== void 0 ? _a4 : [],
            collapseIds: (_b2 = options.collapseIds) !== null && _b2 !== void 0 ? _b2 : []
          };
        }
        CollapseExpandAction2.create = create;
      })(CollapseExpandAction || (exports.CollapseExpandAction = CollapseExpandAction = {}));
      var CollapseExpandAllAction;
      (function(CollapseExpandAllAction2) {
        CollapseExpandAllAction2.KIND = "collapseExpandAll";
        function create(options = {}) {
          var _a4;
          return {
            kind: CollapseExpandAllAction2.KIND,
            expand: (_a4 = options.expand) !== null && _a4 !== void 0 ? _a4 : true
          };
        }
        CollapseExpandAllAction2.create = create;
      })(CollapseExpandAllAction || (exports.CollapseExpandAllAction = CollapseExpandAllAction = {}));
      var OpenAction;
      (function(OpenAction2) {
        OpenAction2.KIND = "open";
        function create(elementId) {
          return {
            kind: OpenAction2.KIND,
            elementId
          };
        }
        OpenAction2.create = create;
      })(OpenAction || (exports.OpenAction = OpenAction = {}));
      var LayoutAction;
      (function(LayoutAction2) {
        LayoutAction2.KIND = "layout";
        function create(options = {}) {
          return {
            kind: LayoutAction2.KIND,
            layoutType: options.layoutType,
            elementIds: options.elementIds
          };
        }
        LayoutAction2.create = create;
      })(LayoutAction || (exports.LayoutAction = LayoutAction = {}));
      var CenterAction;
      (function(CenterAction2) {
        CenterAction2.KIND = "center";
        function create(elementIds, options = {}) {
          var _a4, _b2;
          return {
            kind: CenterAction2.KIND,
            elementIds,
            animate: (_a4 = options.animate) !== null && _a4 !== void 0 ? _a4 : true,
            retainZoom: (_b2 = options.retainZoom) !== null && _b2 !== void 0 ? _b2 : false,
            zoomScale: options.zoomScale
          };
        }
        CenterAction2.create = create;
      })(CenterAction || (exports.CenterAction = CenterAction = {}));
      var FitToScreenAction;
      (function(FitToScreenAction2) {
        FitToScreenAction2.KIND = "fit";
        function create(elementIds, options = {}) {
          var _a4;
          return {
            kind: FitToScreenAction2.KIND,
            elementIds,
            padding: options.padding,
            maxZoom: options.maxZoom,
            animate: (_a4 = options.animate) !== null && _a4 !== void 0 ? _a4 : true
          };
        }
        FitToScreenAction2.create = create;
      })(FitToScreenAction || (exports.FitToScreenAction = FitToScreenAction = {}));
      var SetViewportAction2;
      (function(SetViewportAction3) {
        SetViewportAction3.KIND = "viewport";
        function create(elementId, newViewport, options = {}) {
          var _a4;
          return {
            kind: SetViewportAction3.KIND,
            elementId,
            newViewport,
            animate: (_a4 = options.animate) !== null && _a4 !== void 0 ? _a4 : true
          };
        }
        SetViewportAction3.create = create;
      })(SetViewportAction2 || (exports.SetViewportAction = SetViewportAction2 = {}));
      var GetViewportAction;
      (function(GetViewportAction2) {
        GetViewportAction2.KIND = "getViewport";
        function create() {
          return {
            kind: GetViewportAction2.KIND,
            requestId: generateRequestId()
          };
        }
        GetViewportAction2.create = create;
      })(GetViewportAction || (exports.GetViewportAction = GetViewportAction = {}));
      var ViewportResult;
      (function(ViewportResult2) {
        ViewportResult2.KIND = "viewportResult";
        function create(viewport, canvasBounds, requestId) {
          return {
            kind: ViewportResult2.KIND,
            viewport,
            canvasBounds,
            responseId: requestId
          };
        }
        ViewportResult2.create = create;
      })(ViewportResult || (exports.ViewportResult = ViewportResult = {}));
      var BringToFrontAction;
      (function(BringToFrontAction2) {
        BringToFrontAction2.KIND = "bringToFront";
        function create(elementIDs) {
          return {
            kind: BringToFrontAction2.KIND,
            elementIDs
          };
        }
        BringToFrontAction2.create = create;
      })(BringToFrontAction || (exports.BringToFrontAction = BringToFrontAction = {}));
      var UndoAction;
      (function(UndoAction2) {
        UndoAction2.KIND = "undo";
        function create() {
          return {
            kind: UndoAction2.KIND
          };
        }
        UndoAction2.create = create;
      })(UndoAction || (exports.UndoAction = UndoAction = {}));
      var RedoAction;
      (function(RedoAction2) {
        RedoAction2.KIND = "redo";
        function create() {
          return {
            kind: RedoAction2.KIND
          };
        }
        RedoAction2.create = create;
      })(RedoAction || (exports.RedoAction = RedoAction = {}));
      var MoveAction;
      (function(MoveAction2) {
        MoveAction2.KIND = "move";
        function create(moves, options = {}) {
          var _a4, _b2, _c;
          return {
            kind: MoveAction2.KIND,
            moves,
            animate: (_a4 = options.animate) !== null && _a4 !== void 0 ? _a4 : true,
            finished: (_b2 = options.finished) !== null && _b2 !== void 0 ? _b2 : false,
            stoppable: (_c = options.stoppable) !== null && _c !== void 0 ? _c : false
          };
        }
        MoveAction2.create = create;
      })(MoveAction || (exports.MoveAction = MoveAction = {}));
      var HoverFeedbackAction;
      (function(HoverFeedbackAction2) {
        HoverFeedbackAction2.KIND = "hoverFeedback";
        function create(options) {
          return {
            kind: HoverFeedbackAction2.KIND,
            mouseoverElement: options.mouseoverElement,
            mouseIsOver: options.mouseIsOver
          };
        }
        HoverFeedbackAction2.create = create;
      })(HoverFeedbackAction || (exports.HoverFeedbackAction = HoverFeedbackAction = {}));
      var RequestExportSvgAction;
      (function(RequestExportSvgAction2) {
        RequestExportSvgAction2.KIND = "requestExportSvg";
        function create(options) {
          return {
            kind: RequestExportSvgAction2.KIND,
            requestId: generateRequestId(),
            options
          };
        }
        RequestExportSvgAction2.create = create;
      })(RequestExportSvgAction || (exports.RequestExportSvgAction = RequestExportSvgAction = {}));
      var ExportSvgAction;
      (function(ExportSvgAction2) {
        ExportSvgAction2.KIND = "exportSvg";
        function create(svg, requestId, options) {
          return {
            kind: ExportSvgAction2.KIND,
            svg,
            responseId: requestId,
            options
          };
        }
        ExportSvgAction2.create = create;
      })(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));
      var CreateElementAction;
      (function(CreateElementAction2) {
        CreateElementAction2.KIND = "createElement";
        function create(elementSchema, options) {
          return {
            kind: CreateElementAction2.KIND,
            elementSchema,
            containerId: options.containerId
          };
        }
        CreateElementAction2.create = create;
      })(CreateElementAction || (exports.CreateElementAction = CreateElementAction = {}));
      var DeleteElementAction;
      (function(DeleteElementAction2) {
        DeleteElementAction2.KIND = "delete";
        function create(elementIds) {
          return {
            kind: DeleteElementAction2.KIND,
            elementIds
          };
        }
        DeleteElementAction2.create = create;
      })(DeleteElementAction || (exports.DeleteElementAction = DeleteElementAction = {}));
      var ApplyLabelEditAction;
      (function(ApplyLabelEditAction2) {
        ApplyLabelEditAction2.KIND = "applyLabelEdit";
        function create(labelId, text) {
          return {
            kind: ApplyLabelEditAction2.KIND,
            labelId,
            text
          };
        }
        ApplyLabelEditAction2.create = create;
      })(ApplyLabelEditAction || (exports.ApplyLabelEditAction = ApplyLabelEditAction = {}));
      var ReconnectAction;
      (function(ReconnectAction2) {
        ReconnectAction2.KIND = "reconnect";
        function create(options) {
          return {
            kind: ReconnectAction2.KIND,
            routableId: options.routableId,
            newSourceId: options.newSourceId,
            newTargetId: options.newTargetId
          };
        }
        ReconnectAction2.create = create;
      })(ReconnectAction || (exports.ReconnectAction = ReconnectAction = {}));
    }
  });

  // node_modules/sprotty-protocol/lib/utils/async.js
  var require_async2 = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Deferred = void 0;
      var Deferred = class {
        constructor() {
          this._state = "unresolved";
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
          this.promise.then((res) => this._state = "resolved", (rej) => this._state = "rejected");
        }
        set state(state) {
          if (this._state === "unresolved") {
            this._state = state;
          }
        }
        get state() {
          return this._state;
        }
      };
      exports.Deferred = Deferred;
    }
  });

  // node_modules/sprotty/lib/base/types.js
  var require_types = __commonJS({
    "node_modules/sprotty/lib/base/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TYPES = void 0;
      exports.TYPES = {
        Action: Symbol("Action"),
        IActionDispatcher: Symbol("IActionDispatcher"),
        IActionDispatcherProvider: Symbol("IActionDispatcherProvider"),
        IActionHandlerInitializer: Symbol("IActionHandlerInitializer"),
        ActionHandlerRegistration: Symbol("ActionHandlerRegistration"),
        ActionHandlerRegistryProvider: Symbol("ActionHandlerRegistryProvider"),
        IAnchorComputer: Symbol("IAnchor"),
        AnimationFrameSyncer: Symbol("AnimationFrameSyncer"),
        IButtonHandlerRegistration: Symbol("IButtonHandlerRegistration"),
        ICommandPaletteActionProvider: Symbol("ICommandPaletteActionProvider"),
        ICommandPaletteActionProviderRegistry: Symbol("ICommandPaletteActionProviderRegistry"),
        CommandRegistration: Symbol("CommandRegistration"),
        ICommandStack: Symbol("ICommandStack"),
        CommandStackOptions: Symbol("CommandStackOptions"),
        ICommandStackProvider: Symbol("ICommandStackProvider"),
        IContextMenuItemProvider: Symbol.for("IContextMenuProvider"),
        IContextMenuProviderRegistry: Symbol.for("IContextMenuProviderRegistry"),
        IContextMenuService: Symbol.for("IContextMenuService"),
        IContextMenuServiceProvider: Symbol.for("IContextMenuServiceProvider"),
        DOMHelper: Symbol("DOMHelper"),
        IDiagramLocker: Symbol("IDiagramLocker"),
        IEdgeRouter: Symbol("IEdgeRouter"),
        IEdgeRoutePostprocessor: Symbol("IEdgeRoutePostprocessor"),
        IEditLabelValidationDecorator: Symbol("IEditLabelValidationDecorator"),
        IEditLabelValidator: Symbol("IEditLabelValidator"),
        HiddenModelViewer: Symbol("HiddenModelViewer"),
        HiddenVNodePostprocessor: Symbol("HiddenVNodeDecorator"),
        HoverState: Symbol("HoverState"),
        KeyListener: Symbol("KeyListener"),
        LayoutRegistration: Symbol("LayoutRegistration"),
        LayoutRegistry: Symbol("LayoutRegistry"),
        Layouter: Symbol("Layouter"),
        LogLevel: Symbol("LogLevel"),
        ILogger: Symbol("ILogger"),
        IModelFactory: Symbol("IModelFactory"),
        IModelLayoutEngine: Symbol("IModelLayoutEngine"),
        ModelRendererFactory: Symbol("ModelRendererFactory"),
        ModelSource: Symbol("ModelSource"),
        ModelSourceProvider: Symbol("ModelSourceProvider"),
        ModelViewer: Symbol("ModelViewer"),
        MouseListener: Symbol("MouseListener"),
        PatcherProvider: Symbol("PatcherProvider"),
        IPopupModelProvider: Symbol("IPopupModelProvider"),
        PopupModelViewer: Symbol("PopupModelViewer"),
        PopupMouseListener: Symbol("PopupMouseListener"),
        PopupVNodePostprocessor: Symbol("PopupVNodeDecorator"),
        SModelElementRegistration: Symbol("SModelElementRegistration"),
        SModelRegistry: Symbol("SModelRegistry"),
        ISnapper: Symbol("ISnapper"),
        SvgExporter: Symbol("SvgExporter"),
        ISvgExportPostprocessor: Symbol("ISvgExportPostprocessor"),
        IUIExtension: Symbol("IUIExtension"),
        UIExtensionRegistry: Symbol("UIExtensionRegistry"),
        IVNodePostprocessor: Symbol("IVNodePostprocessor"),
        ViewRegistration: Symbol("ViewRegistration"),
        ViewRegistry: Symbol("ViewRegistry"),
        IViewer: Symbol("IViewer"),
        ViewerOptions: Symbol("ViewerOptions"),
        IViewerProvider: Symbol("IViewerProvider")
      };
    }
  });

  // node_modules/sprotty/lib/utils/registry.js
  var require_registry = __commonJS({
    "node_modules/sprotty/lib/utils/registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultiInstanceRegistry = exports.InstanceRegistry = exports.FactoryRegistry = exports.ProviderRegistry = void 0;
      var inversify_1 = require_cjs4();
      var ProviderRegistry = class ProviderRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, cstr) {
          if (key === void 0)
            throw new Error("Key is undefined");
          if (this.hasKey(key))
            throw new Error("Key is already registered: " + key);
          this.elements.set(key, cstr);
        }
        deregister(key) {
          if (key === void 0)
            throw new Error("Key is undefined");
          this.elements.delete(key);
        }
        hasKey(key) {
          return this.elements.has(key);
        }
        get(key, arg) {
          const existingCstr = this.elements.get(key);
          if (existingCstr)
            return new existingCstr(arg);
          else
            return this.missing(key, arg);
        }
        missing(key, arg) {
          throw new Error("Unknown registry key: " + key);
        }
      };
      exports.ProviderRegistry = ProviderRegistry;
      exports.ProviderRegistry = ProviderRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], ProviderRegistry);
      var FactoryRegistry = class FactoryRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, factory) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            throw new Error(`Key is already registered: ${key}. Use \`overrideModelElement\` instead.`);
          }
          this.elements.set(key, factory);
        }
        override(key, factory) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          } else if (!this.hasKey(key)) {
            throw new Error(`Key is not registered: ${key}. Use \`configureModelElement\` instead.`);
          }
          this.elements.set(key, factory);
        }
        deregister(key) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          this.elements.delete(key);
        }
        hasKey(key) {
          return this.elements.has(key);
        }
        get(key, arg) {
          const existingFactory = this.elements.get(key);
          if (existingFactory) {
            return existingFactory(arg);
          } else {
            return this.missing(key, arg);
          }
        }
        missing(key, arg) {
          throw new Error("Unknown registry key: " + key);
        }
      };
      exports.FactoryRegistry = FactoryRegistry;
      exports.FactoryRegistry = FactoryRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], FactoryRegistry);
      var InstanceRegistry = class InstanceRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            throw new Error(`Key is already registered: ${key}. Use \`overrideModelElement\` instead.`);
          }
          this.elements.set(key, instance);
        }
        override(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          } else if (!this.hasKey(key)) {
            throw new Error(`Key is not registered: ${key}. Use \`configureModelElement\` instead.`);
          }
          this.elements.set(key, instance);
        }
        deregister(key) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          this.elements.delete(key);
        }
        hasKey(key) {
          return this.elements.has(key);
        }
        get(key) {
          const existingInstance = this.elements.get(key);
          if (existingInstance) {
            return existingInstance;
          } else {
            return this.missing(key);
          }
        }
        missing(key) {
          throw new Error("Unknown registry key: " + key);
        }
      };
      exports.InstanceRegistry = InstanceRegistry;
      exports.InstanceRegistry = InstanceRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], InstanceRegistry);
      var MultiInstanceRegistry = class MultiInstanceRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          const instances = this.elements.get(key);
          if (instances !== void 0) {
            instances.push(instance);
          } else {
            this.elements.set(key, [instance]);
          }
        }
        deregisterAll(key) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          this.elements.delete(key);
        }
        get(key) {
          const existingInstances = this.elements.get(key);
          if (existingInstances !== void 0) {
            return existingInstances;
          } else {
            return [];
          }
        }
      };
      exports.MultiInstanceRegistry = MultiInstanceRegistry;
      exports.MultiInstanceRegistry = MultiInstanceRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], MultiInstanceRegistry);
    }
  });

  // node_modules/sprotty-protocol/lib/utils/geometry.js
  var require_geometry = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/geometry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.almostEquals = exports.toRadians = exports.toDegrees = exports.Bounds = exports.isBounds = exports.Dimension = exports.centerOfLine = exports.angleBetweenPoints = exports.angleOfPoint = exports.Point = void 0;
      var object_1 = require_object();
      var Point;
      (function(Point2) {
        Point2.ORIGIN = Object.freeze({
          x: 0,
          y: 0
        });
        function add(p1, p22) {
          return {
            x: p1.x + p22.x,
            y: p1.y + p22.y
          };
        }
        Point2.add = add;
        function subtract(p1, p22) {
          return {
            x: p1.x - p22.x,
            y: p1.y - p22.y
          };
        }
        Point2.subtract = subtract;
        function equals(point1, point2) {
          return point1.x === point2.x && point1.y === point2.y;
        }
        Point2.equals = equals;
        function shiftTowards(point, refPoint, distance) {
          const diff = subtract(refPoint, point);
          const normalized = normalize(diff);
          const shift = { x: normalized.x * distance, y: normalized.y * distance };
          return add(point, shift);
        }
        Point2.shiftTowards = shiftTowards;
        function normalize(point) {
          const mag = magnitude(point);
          if (mag === 0 || mag === 1) {
            return Point2.ORIGIN;
          }
          return {
            x: point.x / mag,
            y: point.y / mag
          };
        }
        Point2.normalize = normalize;
        function magnitude(point) {
          return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        }
        Point2.magnitude = magnitude;
        function linear(p0, p1, lambda) {
          return {
            x: (1 - lambda) * p0.x + lambda * p1.x,
            y: (1 - lambda) * p0.y + lambda * p1.y
          };
        }
        Point2.linear = linear;
        function euclideanDistance(a3, b3) {
          const dx = b3.x - a3.x;
          const dy = b3.y - a3.y;
          return Math.sqrt(dx * dx + dy * dy);
        }
        Point2.euclideanDistance = euclideanDistance;
        function manhattanDistance(a3, b3) {
          return Math.abs(b3.x - a3.x) + Math.abs(b3.y - a3.y);
        }
        Point2.manhattanDistance = manhattanDistance;
        function maxDistance(a3, b3) {
          return Math.max(Math.abs(b3.x - a3.x), Math.abs(b3.y - a3.y));
        }
        Point2.maxDistance = maxDistance;
        function dotProduct(a3, b3) {
          return a3.x * b3.x + a3.y * b3.y;
        }
        Point2.dotProduct = dotProduct;
      })(Point || (exports.Point = Point = {}));
      function angleOfPoint(p3) {
        return Math.atan2(p3.y, p3.x);
      }
      exports.angleOfPoint = angleOfPoint;
      function angleBetweenPoints(a3, b3) {
        const lengthProduct = Math.sqrt((a3.x * a3.x + a3.y * a3.y) * (b3.x * b3.x + b3.y * b3.y));
        if (isNaN(lengthProduct) || lengthProduct === 0)
          return NaN;
        const dotProduct = a3.x * b3.x + a3.y * b3.y;
        return Math.acos(dotProduct / lengthProduct);
      }
      exports.angleBetweenPoints = angleBetweenPoints;
      function centerOfLine(s3, e2) {
        const b3 = {
          x: s3.x > e2.x ? e2.x : s3.x,
          y: s3.y > e2.y ? e2.y : s3.y,
          width: Math.abs(e2.x - s3.x),
          height: Math.abs(e2.y - s3.y)
        };
        return Bounds.center(b3);
      }
      exports.centerOfLine = centerOfLine;
      var Dimension;
      (function(Dimension2) {
        Dimension2.EMPTY = Object.freeze({
          width: -1,
          height: -1
        });
        function isValid(d3) {
          return d3.width >= 0 && d3.height >= 0;
        }
        Dimension2.isValid = isValid;
      })(Dimension || (exports.Dimension = Dimension = {}));
      function isBounds(element) {
        return (0, object_1.hasOwnProperty)(element, ["x", "y", "width", "height"]);
      }
      exports.isBounds = isBounds;
      var Bounds;
      (function(Bounds2) {
        Bounds2.EMPTY = Object.freeze({
          x: 0,
          y: 0,
          width: -1,
          height: -1
        });
        function combine(b0, b1) {
          if (!Dimension.isValid(b0))
            return Dimension.isValid(b1) ? b1 : Bounds2.EMPTY;
          if (!Dimension.isValid(b1))
            return b0;
          const minX = Math.min(b0.x, b1.x);
          const minY = Math.min(b0.y, b1.y);
          const maxX = Math.max(b0.x + (b0.width >= 0 ? b0.width : 0), b1.x + (b1.width >= 0 ? b1.width : 0));
          const maxY = Math.max(b0.y + (b0.height >= 0 ? b0.height : 0), b1.y + (b1.height >= 0 ? b1.height : 0));
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        }
        Bounds2.combine = combine;
        function translate(b3, p3) {
          return {
            x: b3.x + p3.x,
            y: b3.y + p3.y,
            width: b3.width,
            height: b3.height
          };
        }
        Bounds2.translate = translate;
        function center(b3) {
          return {
            x: b3.x + (b3.width >= 0 ? 0.5 * b3.width : 0),
            y: b3.y + (b3.height >= 0 ? 0.5 * b3.height : 0)
          };
        }
        Bounds2.center = center;
        function includes(b3, p3) {
          return p3.x >= b3.x && p3.x <= b3.x + b3.width && p3.y >= b3.y && p3.y <= b3.y + b3.height;
        }
        Bounds2.includes = includes;
      })(Bounds || (exports.Bounds = Bounds = {}));
      function toDegrees(a3) {
        return a3 * 180 / Math.PI;
      }
      exports.toDegrees = toDegrees;
      function toRadians(a3) {
        return a3 * Math.PI / 180;
      }
      exports.toRadians = toRadians;
      function almostEquals(a3, b3) {
        return Math.abs(a3 - b3) < 1e-3;
      }
      exports.almostEquals = almostEquals;
    }
  });

  // node_modules/sprotty/lib/utils/iterable.js
  var require_iterable = __commonJS({
    "node_modules/sprotty/lib/utils/iterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapIterable = exports.filterIterable = exports.DONE_RESULT = exports.toArray = exports.FluentIterableImpl = void 0;
      var FluentIterableImpl = class {
        constructor(startFn, nextFn) {
          this.startFn = startFn;
          this.nextFn = nextFn;
        }
        [Symbol.iterator]() {
          const iterator = {
            state: this.startFn(),
            next: () => this.nextFn(iterator.state),
            [Symbol.iterator]: () => iterator
          };
          return iterator;
        }
        filter(callback) {
          return filterIterable(this, callback);
        }
        map(callback) {
          return mapIterable(this, callback);
        }
        forEach(callback) {
          const iterator = this[Symbol.iterator]();
          let index = 0;
          let result;
          do {
            result = iterator.next();
            if (result.value !== void 0)
              callback(result.value, index);
            index++;
          } while (!result.done);
        }
        indexOf(element) {
          const iterator = this[Symbol.iterator]();
          let index = 0;
          let result;
          do {
            result = iterator.next();
            if (result.value === element)
              return index;
            index++;
          } while (!result.done);
          return -1;
        }
      };
      exports.FluentIterableImpl = FluentIterableImpl;
      function toArray(input) {
        if (input.constructor === Array) {
          return input;
        }
        const result = [];
        input.forEach((element) => result.push(element));
        return result;
      }
      exports.toArray = toArray;
      exports.DONE_RESULT = Object.freeze({ done: true, value: void 0 });
      function filterIterable(input, callback) {
        return new FluentIterableImpl(() => createIterator(input), (iterator) => {
          let result;
          do {
            result = iterator.next();
          } while (!result.done && !callback(result.value));
          return result;
        });
      }
      exports.filterIterable = filterIterable;
      function mapIterable(input, callback) {
        return new FluentIterableImpl(() => createIterator(input), (iterator) => {
          const { done, value } = iterator.next();
          if (done)
            return exports.DONE_RESULT;
          else
            return { done: false, value: callback(value) };
        });
      }
      exports.mapIterable = mapIterable;
      function createIterator(collection) {
        const method = collection[Symbol.iterator];
        if (typeof method === "function") {
          return method.call(collection);
        }
        const length = collection.length;
        if (typeof length === "number" && length >= 0) {
          return new ArrayIterator(collection);
        }
        return { next: () => exports.DONE_RESULT };
      }
      var ArrayIterator = class {
        constructor(array) {
          this.array = array;
          this.index = 0;
        }
        next() {
          if (this.index < this.array.length)
            return { done: false, value: this.array[this.index++] };
          else
            return exports.DONE_RESULT;
        }
        [Symbol.iterator]() {
          return this;
        }
      };
    }
  });

  // node_modules/sprotty/lib/base/model/smodel.js
  var require_smodel = __commonJS({
    "node_modules/sprotty/lib/base/model/smodel.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ModelIndexImpl = exports.createRandomId = exports.SModelRootImpl = exports.SChildElementImpl = exports.SParentElementImpl = exports.isParent = exports.SModelElementImpl = void 0;
      var geometry_1 = require_geometry();
      var iterable_1 = require_iterable();
      var SModelElementImpl = class {
        get root() {
          let current = this;
          while (current) {
            if (current instanceof SModelRootImpl)
              return current;
            else if (current instanceof SChildElementImpl)
              current = current.parent;
            else
              current = void 0;
          }
          throw new Error("Element has no root");
        }
        get index() {
          return this.root.index;
        }
        /**
         * A feature is a symbol identifying some functionality that can be enabled or disabled for
         * a model element. The set of supported features is determined by the `features` property.
         */
        hasFeature(feature) {
          return this.features !== void 0 && this.features.has(feature);
        }
      };
      exports.SModelElementImpl = SModelElementImpl;
      function isParent(element) {
        const children = element.children;
        return children !== void 0 && children.constructor === Array;
      }
      exports.isParent = isParent;
      var SParentElementImpl = class extends SModelElementImpl {
        constructor() {
          super(...arguments);
          this.children = [];
        }
        add(child, index) {
          const children = this.children;
          if (index === void 0) {
            children.push(child);
          } else {
            if (index < 0 || index > this.children.length) {
              throw new Error(`Child index ${index} out of bounds (0..${children.length})`);
            }
            children.splice(index, 0, child);
          }
          child.parent = this;
          this.index.add(child);
        }
        remove(child) {
          const children = this.children;
          const i2 = children.indexOf(child);
          if (i2 < 0) {
            throw new Error(`No such child ${child.id}`);
          }
          children.splice(i2, 1);
          this.index.remove(child);
        }
        removeAll(filter) {
          const children = this.children;
          if (filter !== void 0) {
            for (let i2 = children.length - 1; i2 >= 0; i2--) {
              if (filter(children[i2])) {
                const child = children.splice(i2, 1)[0];
                this.index.remove(child);
              }
            }
          } else {
            children.forEach((child) => {
              this.index.remove(child);
            });
            children.splice(0, children.length);
          }
        }
        move(child, newIndex) {
          const children = this.children;
          const i2 = children.indexOf(child);
          if (i2 === -1) {
            throw new Error(`No such child ${child.id}`);
          } else {
            if (newIndex < 0 || newIndex > children.length - 1) {
              throw new Error(`Child index ${newIndex} out of bounds (0..${children.length})`);
            }
            children.splice(i2, 1);
            children.splice(newIndex, 0, child);
          }
        }
        /**
         * Transform the given bounds from the local coordinate system of this element to the coordinate
         * system of its parent. This function should consider any transformation that is applied to the
         * view of this element and its contents.
         * The base implementation assumes that this element does not define a local coordinate system,
         * so it leaves the bounds unchanged.
         */
        localToParent(point) {
          return (0, geometry_1.isBounds)(point) ? point : { x: point.x, y: point.y, width: -1, height: -1 };
        }
        /**
         * Transform the given bounds from the coordinate system of this element's parent to its local
         * coordinate system. This function should consider any transformation that is applied to the
         * view of this element and its contents.
         * The base implementation assumes that this element does not define a local coordinate system,
         * so it leaves the bounds unchanged.
         */
        parentToLocal(point) {
          return (0, geometry_1.isBounds)(point) ? point : { x: point.x, y: point.y, width: -1, height: -1 };
        }
      };
      exports.SParentElementImpl = SParentElementImpl;
      var SChildElementImpl = class extends SParentElementImpl {
      };
      exports.SChildElementImpl = SChildElementImpl;
      var SModelRootImpl = class extends SParentElementImpl {
        constructor(index = new ModelIndexImpl()) {
          super();
          this.canvasBounds = geometry_1.Bounds.EMPTY;
          Object.defineProperty(this, "index", {
            value: index,
            writable: false
          });
        }
      };
      exports.SModelRootImpl = SModelRootImpl;
      var ID_CHARS = "0123456789abcdefghijklmnopqrstuvwxyz";
      function createRandomId(length = 8) {
        let id = "";
        for (let i2 = 0; i2 < length; i2++) {
          id += ID_CHARS.charAt(Math.floor(Math.random() * ID_CHARS.length));
        }
        return id;
      }
      exports.createRandomId = createRandomId;
      var ModelIndexImpl = class {
        constructor() {
          this.id2element = /* @__PURE__ */ new Map();
        }
        add(element) {
          if (!element.id) {
            do {
              element.id = createRandomId();
            } while (this.contains(element));
          } else if (this.contains(element)) {
            throw new Error("Duplicate ID in model: " + element.id);
          }
          this.id2element.set(element.id, element);
          if (element instanceof SParentElementImpl) {
            for (const child of element.children) {
              this.add(child);
            }
          }
        }
        remove(element) {
          this.id2element.delete(element.id);
          if (element instanceof SParentElementImpl) {
            for (const child of element.children) {
              this.remove(child);
            }
          }
        }
        contains(element) {
          return this.id2element.has(element.id);
        }
        getById(id) {
          return this.id2element.get(id);
        }
        getAttachedElements(element) {
          return [];
        }
        all() {
          return (0, iterable_1.mapIterable)(this.id2element, ([key, value]) => value);
        }
      };
      exports.ModelIndexImpl = ModelIndexImpl;
    }
  });

  // node_modules/sprotty/lib/base/model/smodel-factory.js
  var require_smodel_factory = __commonJS({
    "node_modules/sprotty/lib/base/model/smodel-factory.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createFeatureSet = exports.EMPTY_ROOT = exports.SModelFactory = exports.SModelRegistry = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var smodel_1 = require_smodel();
      var SModelRegistry = class SModelRegistry extends registry_1.FactoryRegistry {
        constructor(registrations) {
          super();
          registrations.forEach((registration) => {
            let defaultFeatures = this.getDefaultFeatures(registration.constr);
            if (!defaultFeatures && registration.features && registration.features.enable)
              defaultFeatures = [];
            if (defaultFeatures) {
              const featureSet = createFeatureSet(defaultFeatures, registration.features);
              if (registration.isOverride) {
                this.override(registration.type, () => {
                  const element = new registration.constr();
                  element.features = featureSet;
                  return element;
                });
              } else {
                this.register(registration.type, () => {
                  const element = new registration.constr();
                  element.features = featureSet;
                  return element;
                });
              }
            } else {
              if (registration.isOverride) {
                this.override(registration.type, () => new registration.constr());
              } else {
                this.register(registration.type, () => new registration.constr());
              }
            }
          });
        }
        getDefaultFeatures(constr) {
          let obj = constr;
          do {
            const defaultFeatures = obj.DEFAULT_FEATURES;
            if (defaultFeatures)
              return defaultFeatures;
            obj = Object.getPrototypeOf(obj);
          } while (obj);
          return void 0;
        }
      };
      exports.SModelRegistry = SModelRegistry;
      exports.SModelRegistry = SModelRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.SModelElementRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], SModelRegistry);
      var SModelFactory = class SModelFactory {
        createElement(schema, parent) {
          let child;
          if (this.registry.hasKey(schema.type)) {
            const regElement = this.registry.get(schema.type, void 0);
            if (!(regElement instanceof smodel_1.SChildElementImpl))
              throw new Error(`Element with type ${schema.type} was expected to be an SChildElement.`);
            child = regElement;
          } else {
            child = new smodel_1.SChildElementImpl();
          }
          return this.initializeChild(child, schema, parent);
        }
        createRoot(schema) {
          let root;
          if (this.registry.hasKey(schema.type)) {
            const regElement = this.registry.get(schema.type, void 0);
            if (!(regElement instanceof smodel_1.SModelRootImpl))
              throw new Error(`Element with type ${schema.type} was expected to be an SModelRoot.`);
            root = regElement;
          } else {
            root = new smodel_1.SModelRootImpl();
          }
          return this.initializeRoot(root, schema);
        }
        createSchema(element) {
          const schema = {};
          for (const key in element) {
            if (!this.isReserved(element, key)) {
              const value = element[key];
              if (typeof value !== "function")
                schema[key] = value;
            }
          }
          if (element instanceof smodel_1.SParentElementImpl)
            schema["children"] = element.children.map((child) => this.createSchema(child));
          return schema;
        }
        initializeElement(element, schema) {
          for (const key in schema) {
            if (!this.isReserved(element, key)) {
              const value = schema[key];
              if (typeof value !== "function")
                element[key] = value;
            }
          }
          return element;
        }
        isReserved(element, propertyName) {
          if (["children", "parent", "index"].indexOf(propertyName) >= 0)
            return true;
          let obj = element;
          do {
            const descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
            if (descriptor !== void 0)
              return descriptor.get !== void 0;
            obj = Object.getPrototypeOf(obj);
          } while (obj);
          return false;
        }
        initializeParent(parent, schema) {
          this.initializeElement(parent, schema);
          if ((0, smodel_1.isParent)(schema)) {
            parent.children = schema.children.map((childSchema) => this.createElement(childSchema, parent));
          }
          return parent;
        }
        initializeChild(child, schema, parent) {
          this.initializeParent(child, schema);
          if (parent !== void 0) {
            child.parent = parent;
          }
          return child;
        }
        initializeRoot(root, schema) {
          this.initializeParent(root, schema);
          root.index.add(root);
          return root;
        }
      };
      exports.SModelFactory = SModelFactory;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.SModelRegistry),
        __metadata("design:type", SModelRegistry)
      ], SModelFactory.prototype, "registry", void 0);
      exports.SModelFactory = SModelFactory = __decorate([
        (0, inversify_1.injectable)()
      ], SModelFactory);
      exports.EMPTY_ROOT = Object.freeze({
        type: "NONE",
        id: "EMPTY"
      });
      function createFeatureSet(defaults, custom) {
        const featureSet = new Set(defaults);
        if (custom && custom.enable) {
          for (const f3 of custom.enable) {
            featureSet.add(f3);
          }
        }
        if (custom && custom.disable) {
          for (const f3 of custom.disable) {
            featureSet.delete(f3);
          }
        }
        return featureSet;
      }
      exports.createFeatureSet = createFeatureSet;
    }
  });

  // node_modules/sprotty/lib/base/animations/animation-frame-syncer.js
  var require_animation_frame_syncer = __commonJS({
    "node_modules/sprotty/lib/base/animations/animation-frame-syncer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnimationFrameSyncer = void 0;
      var inversify_1 = require_cjs4();
      var AnimationFrameSyncer = class AnimationFrameSyncer {
        constructor() {
          this.tasks = [];
          this.endTasks = [];
          this.triggered = false;
        }
        isAvailable() {
          return typeof requestAnimationFrame === "function";
        }
        onNextFrame(task) {
          this.tasks.push(task);
          this.trigger();
        }
        onEndOfNextFrame(task) {
          this.endTasks.push(task);
          this.trigger();
        }
        trigger() {
          if (!this.triggered) {
            this.triggered = true;
            if (this.isAvailable())
              requestAnimationFrame((time) => this.run(time));
            else
              setTimeout((time) => this.run(time));
          }
        }
        run(time) {
          const tasks = this.tasks;
          const endTasks = this.endTasks;
          this.triggered = false;
          this.tasks = [];
          this.endTasks = [];
          tasks.forEach((task) => task.call(void 0, time));
          endTasks.forEach((task) => task.call(void 0, time));
        }
      };
      exports.AnimationFrameSyncer = AnimationFrameSyncer;
      exports.AnimationFrameSyncer = AnimationFrameSyncer = __decorate([
        (0, inversify_1.injectable)()
      ], AnimationFrameSyncer);
    }
  });

  // node_modules/sprotty/lib/base/actions/action-dispatcher.js
  var require_action_dispatcher = __commonJS({
    "node_modules/sprotty/lib/base/actions/action-dispatcher.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ActionDispatcher = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var async_1 = require_async2();
      var types_1 = require_types();
      var smodel_factory_1 = require_smodel_factory();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      (0, actions_1.setRequestContext)("client");
      var ActionDispatcher = class ActionDispatcher {
        constructor() {
          this.postponedActions = [];
          this.requests = /* @__PURE__ */ new Map();
        }
        initialize() {
          if (!this.initialized) {
            this.initialized = this.actionHandlerRegistryProvider().then((registry) => {
              this.actionHandlerRegistry = registry;
              this.handleAction(actions_1.SetModelAction.create(smodel_factory_1.EMPTY_ROOT)).catch(() => {
              });
            });
          }
          return this.initialized;
        }
        /**
         * Dispatch an action by querying all handlers that are registered for its kind.
         * The returned promise is resolved when all handler results (commands or actions)
         * have been processed.
         */
        dispatch(action) {
          return this.initialize().then(() => {
            if (this.blockUntil !== void 0) {
              return this.handleBlocked(action, this.blockUntil);
            } else if (this.diagramLocker.isAllowed(action)) {
              return this.handleAction(action);
            }
            return void 0;
          });
        }
        /**
         * Calls `dispatch` on every action in the given array. The returned promise
         * is resolved when the promises of all `dispatch` calls have been resolved.
         */
        dispatchAll(actions) {
          return Promise.all(actions.map((action) => this.dispatch(action)));
        }
        /**
         * Dispatch a request. The returned promise is resolved when a response with matching
         * identifier is dispatched. That response is _not_ passed to the registered action
         * handlers. Instead, it is the responsibility of the caller of this method to handle
         * the response properly. For example, it can be sent to the registered handlers by
         * passing it again to the `dispatch` method.
         */
        request(action) {
          if (!action.requestId) {
            return Promise.reject(new Error("Request without requestId"));
          }
          const deferred = new async_1.Deferred();
          this.requests.set(action.requestId, deferred);
          this.dispatch(action).catch(() => {
          });
          return deferred.promise;
        }
        handleAction(action) {
          if (action.kind === actions_1.UndoAction.KIND) {
            return this.commandStack.undo().then(() => {
            });
          }
          if (action.kind === actions_1.RedoAction.KIND) {
            return this.commandStack.redo().then(() => {
            });
          }
          if ((0, actions_1.isResponseAction)(action)) {
            const deferred = this.requests.get(action.responseId);
            if (deferred !== void 0) {
              this.requests.delete(action.responseId);
              if (action.kind === actions_1.RejectAction.KIND) {
                const rejectAction = action;
                deferred.reject(new Error(rejectAction.message));
                this.logger.warn(this, `Request with id ${action.responseId} failed.`, rejectAction.message, rejectAction.detail);
              } else {
                deferred.resolve(action);
              }
              return Promise.resolve();
            }
            this.logger.log(this, "No matching request for response", action);
          }
          const handlers = this.actionHandlerRegistry.get(action.kind);
          if (handlers.length === 0) {
            this.logger.warn(this, "Missing handler for action", action);
            const error = new Error(`Missing handler for action '${action.kind}'`);
            if ((0, actions_1.isRequestAction)(action)) {
              const deferred = this.requests.get(action.requestId);
              if (deferred !== void 0) {
                this.requests.delete(action.requestId);
                deferred.reject(error);
              }
            }
            return Promise.reject(error);
          }
          this.logger.log(this, "Handle", action);
          const promises = [];
          for (const handler of handlers) {
            const result = handler.handle(action);
            if ((0, actions_1.isAction)(result)) {
              promises.push(this.dispatch(result));
            } else if (result !== void 0) {
              promises.push(this.commandStack.execute(result));
              this.blockUntil = result.blockUntil;
            }
          }
          return Promise.all(promises);
        }
        handleBlocked(action, predicate) {
          if (predicate(action)) {
            this.blockUntil = void 0;
            const result = this.handleAction(action);
            const actions = this.postponedActions;
            this.postponedActions = [];
            for (const a3 of actions) {
              this.dispatch(a3.action).then(a3.resolve, a3.reject);
            }
            return result;
          } else {
            this.logger.log(this, "Action is postponed due to block condition", action);
            return new Promise((resolve, reject) => {
              this.postponedActions.push({ action, resolve, reject });
            });
          }
        }
      };
      exports.ActionDispatcher = ActionDispatcher;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ActionHandlerRegistryProvider),
        __metadata("design:type", Function)
      ], ActionDispatcher.prototype, "actionHandlerRegistryProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ICommandStack),
        __metadata("design:type", Object)
      ], ActionDispatcher.prototype, "commandStack", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], ActionDispatcher.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
      ], ActionDispatcher.prototype, "syncer", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IDiagramLocker),
        __metadata("design:type", Object)
      ], ActionDispatcher.prototype, "diagramLocker", void 0);
      exports.ActionDispatcher = ActionDispatcher = __decorate([
        (0, inversify_1.injectable)()
      ], ActionDispatcher);
    }
  });

  // node_modules/sprotty/lib/utils/inversify.js
  var require_inversify = __commonJS({
    "node_modules/sprotty/lib/utils/inversify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isInjectable = void 0;
      function isInjectable(constr) {
        return Reflect.getMetadata("inversify:paramtypes", constr) !== void 0;
      }
      exports.isInjectable = isInjectable;
    }
  });

  // node_modules/sprotty/lib/base/actions/action-handler.js
  var require_action_handler = __commonJS({
    "node_modules/sprotty/lib/base/actions/action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onAction = exports.configureActionHandler = exports.ActionHandlerRegistry = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var inversify_2 = require_inversify();
      var ActionHandlerRegistry = class ActionHandlerRegistry extends registry_1.MultiInstanceRegistry {
        constructor(registrations, initializers) {
          super();
          registrations.forEach((registration) => this.register(registration.actionKind, registration.factory()));
          initializers.forEach((initializer) => this.initializeActionHandler(initializer));
        }
        initializeActionHandler(initializer) {
          initializer.initialize(this);
        }
      };
      exports.ActionHandlerRegistry = ActionHandlerRegistry;
      exports.ActionHandlerRegistry = ActionHandlerRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ActionHandlerRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __param(1, (0, inversify_1.multiInject)(types_1.TYPES.IActionHandlerInitializer)),
        __param(1, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array, Array])
      ], ActionHandlerRegistry);
      function configureActionHandler2(context, kind, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Action handlers should be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.ActionHandlerRegistration).toDynamicValue((ctx) => ({
          actionKind: kind,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureActionHandler = configureActionHandler2;
      function onAction(context, kind, handle) {
        context.bind(types_1.TYPES.ActionHandlerRegistration).toConstantValue({
          actionKind: kind,
          factory: () => ({ handle })
        });
      }
      exports.onAction = onAction;
    }
  });

  // node_modules/sprotty/lib/base/actions/diagram-locker.js
  var require_diagram_locker = __commonJS({
    "node_modules/sprotty/lib/base/actions/diagram-locker.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultDiagramLocker = void 0;
      var inversify_1 = require_cjs4();
      var DefaultDiagramLocker = class DefaultDiagramLocker {
        isAllowed(action) {
          return true;
        }
      };
      exports.DefaultDiagramLocker = DefaultDiagramLocker;
      exports.DefaultDiagramLocker = DefaultDiagramLocker = __decorate([
        (0, inversify_1.injectable)()
      ], DefaultDiagramLocker);
    }
  });

  // node_modules/sprotty/lib/base/animations/easing.js
  var require_easing = __commonJS({
    "node_modules/sprotty/lib/base/animations/easing.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.easeInOut = void 0;
      function easeInOut(x3) {
        if (x3 < 0.5)
          return x3 * x3 * 2;
        else
          return 1 - (1 - x3) * (1 - x3) * 2;
      }
      exports.easeInOut = easeInOut;
    }
  });

  // node_modules/sprotty/lib/base/animations/animation.js
  var require_animation = __commonJS({
    "node_modules/sprotty/lib/base/animations/animation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompoundAnimation = exports.Animation = void 0;
      var easing_1 = require_easing();
      var Animation = class {
        constructor(context, ease = easing_1.easeInOut) {
          this.context = context;
          this.ease = ease;
          this.stopped = false;
        }
        start() {
          this.stopped = false;
          return new Promise((resolve, reject) => {
            let start = void 0;
            let frames = 0;
            const lambda = (time) => {
              frames++;
              let dtime;
              if (start === void 0) {
                start = time;
                dtime = 0;
              } else {
                dtime = time - start;
              }
              const t3 = Math.min(1, dtime / this.context.duration);
              const current = this.tween(this.ease(t3), this.context);
              this.context.modelChanged.update(current);
              if (t3 === 1) {
                this.context.logger.log(this, frames * 1e3 / this.context.duration + " fps");
                resolve(current);
              } else if (this.stopped) {
                this.context.logger.log(this, "Animation stopped at " + t3 * 100 + "%");
                resolve(current);
              } else {
                this.context.syncer.onNextFrame(lambda);
              }
            };
            if (this.context.syncer.isAvailable()) {
              this.context.syncer.onNextFrame(lambda);
            } else {
              const finalModel = this.tween(1, this.context);
              resolve(finalModel);
            }
          });
        }
        /**
         * Stop the animation at the current state.
         * The promise returned by start() will be resolved with the current state after the next tweening step.
         */
        stop() {
          this.stopped = true;
        }
      };
      exports.Animation = Animation;
      var CompoundAnimation = class extends Animation {
        constructor(model, context, components = [], ease = easing_1.easeInOut) {
          super(context, ease);
          this.model = model;
          this.context = context;
          this.components = components;
          this.ease = ease;
        }
        include(animation) {
          this.components.push(animation);
          return this;
        }
        tween(t3, context) {
          for (const a3 of this.components) {
            a3.tween(t3, context);
          }
          return this.model;
        }
      };
      exports.CompoundAnimation = CompoundAnimation;
    }
  });

  // node_modules/sprotty-protocol/lib/action-handler.js
  var require_action_handler2 = __commonJS({
    "node_modules/sprotty-protocol/lib/action-handler.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ServerActionHandlerRegistry = void 0;
      var ServerActionHandlerRegistry = class {
        constructor() {
          this.handlers = /* @__PURE__ */ new Map();
        }
        /**
         * Returns the action handlers for the given action kind, or `undefined` if there are none.
         */
        getHandler(kind) {
          return this.handlers.get(kind);
        }
        /**
         * Add an action handler to be called when an action of the specified kind is received.
         */
        onAction(kind, handler) {
          if (this.handlers.has(kind)) {
            this.handlers.get(kind).push(handler);
          } else {
            this.handlers.set(kind, [handler]);
          }
        }
        /**
         * Remove an action handler that was previously added with `onAction`.
         */
        removeActionHandler(kind, handler) {
          const list = this.handlers.get(kind);
          if (list) {
            const index = list.indexOf(handler);
            if (index >= 0) {
              list.splice(index, 1);
            }
          }
        }
      };
      exports.ServerActionHandlerRegistry = ServerActionHandlerRegistry;
    }
  });

  // node_modules/sprotty-protocol/lib/utils/model-utils.js
  var require_model_utils = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/model-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SModelIndex = exports.findElement = exports.getSubType = exports.getBasicType = exports.applyBounds = exports.cloneModel = void 0;
      function cloneModel(model) {
        return JSON.parse(JSON.stringify(model));
      }
      exports.cloneModel = cloneModel;
      function applyBounds(root, action) {
        const index = new SModelIndex();
        index.add(root);
        for (const b3 of action.bounds) {
          const element = index.getById(b3.elementId);
          if (element) {
            const bae = element;
            if (b3.newPosition) {
              bae.position = { x: b3.newPosition.x, y: b3.newPosition.y };
            }
            if (b3.newSize) {
              bae.size = { width: b3.newSize.width, height: b3.newSize.height };
            }
          }
        }
        if (action.alignments) {
          for (const a3 of action.alignments) {
            const element = index.getById(a3.elementId);
            if (element) {
              const alignable = element;
              alignable.alignment = { x: a3.newAlignment.x, y: a3.newAlignment.y };
            }
          }
        }
      }
      exports.applyBounds = applyBounds;
      function getBasicType(element) {
        if (!element.type) {
          return "";
        }
        const colonIndex = element.type.indexOf(":");
        return colonIndex >= 0 ? element.type.substring(0, colonIndex) : element.type;
      }
      exports.getBasicType = getBasicType;
      function getSubType(schema) {
        if (!schema.type) {
          return "";
        }
        const colonIndex = schema.type.indexOf(":");
        return colonIndex >= 0 ? schema.type.substring(colonIndex + 1) : schema.type;
      }
      exports.getSubType = getSubType;
      function findElement(parent, elementId) {
        if (parent.id === elementId) {
          return parent;
        }
        if (parent.children) {
          for (const child of parent.children) {
            const result = findElement(child, elementId);
            if (result !== void 0) {
              return result;
            }
          }
        }
        return void 0;
      }
      exports.findElement = findElement;
      var SModelIndex = class {
        constructor() {
          this.id2element = /* @__PURE__ */ new Map();
          this.id2parent = /* @__PURE__ */ new Map();
        }
        add(element) {
          if (!element.id) {
            throw new Error("Model element has no ID.");
          } else if (this.contains(element)) {
            throw new Error("Duplicate ID in model: " + element.id);
          }
          this.id2element.set(element.id, element);
          if (Array.isArray(element.children)) {
            for (const child of element.children) {
              this.add(child);
              this.id2parent.set(child.id, element);
            }
          }
          return this;
        }
        remove(element) {
          this.id2element.delete(element.id);
          if (Array.isArray(element.children)) {
            for (const child of element.children) {
              this.id2parent.delete(child.id);
              this.remove(child);
            }
          }
          return this;
        }
        contains(element) {
          return this.id2element.has(element.id);
        }
        getById(id) {
          return this.id2element.get(id);
        }
        getParent(id) {
          return this.id2parent.get(id);
        }
        getRoot(element) {
          let current = element;
          while (current) {
            const parent = this.id2parent.get(current.id);
            if (parent === void 0) {
              return current;
            }
            current = parent;
          }
          throw new Error("Element has no root");
        }
      };
      exports.SModelIndex = SModelIndex;
    }
  });

  // node_modules/sprotty-protocol/lib/diagram-server.js
  var require_diagram_server = __commonJS({
    "node_modules/sprotty-protocol/lib/diagram-server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramServer = void 0;
      var actions_1 = require_actions();
      var async_1 = require_async2();
      var model_utils_1 = require_model_utils();
      var DiagramServer = class {
        constructor(dispatch, services) {
          this.state = {
            currentRoot: {
              type: "NONE",
              id: "ROOT"
            },
            revision: 0
          };
          this.requests = /* @__PURE__ */ new Map();
          this.dispatch = dispatch;
          this.diagramGenerator = services.DiagramGenerator;
          this.layoutEngine = services.ModelLayoutEngine;
          this.actionHandlerRegistry = services.ServerActionHandlerRegistry;
        }
        /**
         * Set the model and submit it to the client.
         */
        setModel(newRoot) {
          newRoot.revision = ++this.state.revision;
          this.state.currentRoot = newRoot;
          return this.submitModel(newRoot, false);
        }
        /**
         * Update the model to a new state and submit it to the client.
         */
        updateModel(newRoot) {
          newRoot.revision = ++this.state.revision;
          this.state.currentRoot = newRoot;
          return this.submitModel(newRoot, true);
        }
        /**
         * Whether the client needs to compute the layout of parts of the model. This affects the behavior
         * of `submitModel`.
         *
         * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
         * from the client. If the client does not specify whether it needs client layout, the default value
         * is `true`.
         */
        get needsClientLayout() {
          if (this.state.options && this.state.options.needsClientLayout !== void 0) {
            return !!this.state.options.needsClientLayout;
          }
          return true;
        }
        /**
         * Whether the server needs to compute the layout of parts of the model. This affects the behavior
         * of `submitModel`.
         *
         * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
         * from the client. If the client does not specify whether it needs server layout, the default value
         * is `false`.
         */
        get needsServerLayout() {
          if (this.state.options && this.state.options.needsServerLayout !== void 0) {
            return !!this.state.options.needsServerLayout;
          }
          return false;
        }
        /**
         * Called when an action is received from the client.
         */
        accept(action) {
          if ((0, actions_1.isResponseAction)(action)) {
            const id = action.responseId;
            const future = this.requests.get(id);
            if (future) {
              this.requests.delete(id);
              if (action.kind === actions_1.RejectAction.KIND) {
                const rejectAction = action;
                future.reject(new Error(rejectAction.message));
                console.warn(`Request with id ${action.responseId} failed: ${rejectAction.message}`, rejectAction.detail);
              } else {
                future.resolve(action);
              }
              return Promise.resolve();
            }
            console.info("No matching request for response:", action);
          }
          return this.handleAction(action);
        }
        /**
         * Send a request action to the client. The resulting promise is resolved when a matching
         * response is received and rejected when a `RejectAction` is received.
         */
        request(action) {
          if (!action.requestId) {
            action.requestId = "server_" + (0, actions_1.generateRequestId)();
          }
          const future = new async_1.Deferred();
          this.requests.set(action.requestId, future);
          this.dispatch(action).catch((err) => {
            this.requests.delete(action.requestId);
            future.reject(err);
          });
          return future.promise;
        }
        /**
         * Send a `RejectAction` to the client to notify that a request could not be fulfilled.
         */
        rejectRemoteRequest(action, error) {
          if (action && (0, actions_1.isRequestAction)(action)) {
            this.dispatch({
              kind: actions_1.RejectAction.KIND,
              responseId: action.requestId,
              message: error.message,
              detail: error.stack
            });
          }
        }
        handleAction(action) {
          var _a4, _b2;
          const handlers = (_a4 = this.actionHandlerRegistry) === null || _a4 === void 0 ? void 0 : _a4.getHandler(action.kind);
          if (handlers && handlers.length === 1) {
            return (_b2 = handlers[0](action, this.state, this)) !== null && _b2 !== void 0 ? _b2 : Promise.resolve();
          } else if (handlers && handlers.length > 1) {
            return Promise.all(handlers.map((h3) => {
              var _a5;
              return (_a5 = h3(action, this.state, this)) !== null && _a5 !== void 0 ? _a5 : Promise.resolve();
            }));
          }
          switch (action.kind) {
            case actions_1.RequestModelAction.KIND:
              return this.handleRequestModel(action);
            case actions_1.ComputedBoundsAction.KIND:
              return this.handleComputedBounds(action);
            case actions_1.LayoutAction.KIND:
              return this.handleLayout(action);
          }
          console.warn(`Unhandled action from client: ${action.kind}`);
          return Promise.resolve();
        }
        async handleRequestModel(action) {
          var _a4;
          this.state.options = action.options;
          try {
            const newRoot = await this.diagramGenerator.generate({
              options: (_a4 = this.state.options) !== null && _a4 !== void 0 ? _a4 : {},
              state: this.state
            });
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
            await this.submitModel(this.state.currentRoot, false, action);
          } catch (err) {
            this.rejectRemoteRequest(action, err);
            console.error("Failed to generate diagram:", err);
          }
        }
        /**
         * Submit a model to the client after it has been updated in the server state.
         */
        async submitModel(newRoot, update, cause) {
          if (this.needsClientLayout) {
            if (!this.needsServerLayout) {
              this.dispatch({ kind: actions_1.RequestBoundsAction.KIND, newRoot });
            } else {
              const request = actions_1.RequestBoundsAction.create(newRoot);
              const response = await this.request(request);
              const currentRoot = this.state.currentRoot;
              if (response.revision === currentRoot.revision) {
                (0, model_utils_1.applyBounds)(currentRoot, response);
                await this.doSubmitModel(currentRoot, update, cause);
              } else {
                this.rejectRemoteRequest(cause, new Error(`Model revision does not match: ${response.revision}`));
              }
            }
          } else {
            await this.doSubmitModel(newRoot, update, cause);
          }
        }
        async doSubmitModel(newRoot, update, cause) {
          if (newRoot.revision !== this.state.revision) {
            return;
          }
          if (this.needsServerLayout && this.layoutEngine) {
            newRoot = await this.layoutEngine.layout(newRoot);
          }
          const modelType = newRoot.type;
          if (cause && cause.kind === actions_1.RequestModelAction.KIND) {
            const requestId = cause.requestId;
            const response = actions_1.SetModelAction.create(newRoot, requestId);
            await this.dispatch(response);
          } else if (update && modelType === this.state.lastSubmittedModelType) {
            await this.dispatch({ kind: actions_1.UpdateModelAction.KIND, newRoot, cause });
          } else {
            await this.dispatch({ kind: actions_1.SetModelAction.KIND, newRoot });
          }
          this.state.lastSubmittedModelType = modelType;
        }
        handleComputedBounds(action) {
          if (action.revision !== this.state.currentRoot.revision) {
            return Promise.reject();
          }
          (0, model_utils_1.applyBounds)(this.state.currentRoot, action);
          return Promise.resolve();
        }
        async handleLayout(action) {
          if (!this.layoutEngine) {
            return;
          }
          if (!this.needsServerLayout) {
            let newRoot = (0, model_utils_1.cloneModel)(this.state.currentRoot);
            newRoot = await this.layoutEngine.layout(newRoot);
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
          }
          await this.doSubmitModel(this.state.currentRoot, true, action);
        }
      };
      exports.DiagramServer = DiagramServer;
    }
  });

  // node_modules/sprotty-protocol/lib/diagram-services.js
  var require_diagram_services = __commonJS({
    "node_modules/sprotty-protocol/lib/diagram-services.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/sprotty-protocol/lib/model.js
  var require_model = __commonJS({
    "node_modules/sprotty-protocol/lib/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isZoomable = exports.isScrollable = void 0;
      var object_1 = require_object();
      function isScrollable(element) {
        return (0, object_1.hasOwnProperty)(element, "scroll");
      }
      exports.isScrollable = isScrollable;
      function isZoomable(element) {
        return (0, object_1.hasOwnProperty)(element, "zoom");
      }
      exports.isZoomable = isZoomable;
    }
  });

  // node_modules/sprotty-protocol/lib/utils/json.js
  var require_json = __commonJS({
    "node_modules/sprotty-protocol/lib/utils/json.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/sprotty-protocol/lib/index.js
  var require_lib = __commonJS({
    "node_modules/sprotty-protocol/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_action_handler2(), exports);
      __exportStar(require_actions(), exports);
      __exportStar(require_diagram_server(), exports);
      __exportStar(require_diagram_services(), exports);
      __exportStar(require_model(), exports);
      __exportStar(require_async2(), exports);
      __exportStar(require_geometry(), exports);
      __exportStar(require_json(), exports);
      __exportStar(require_model_utils(), exports);
      __exportStar(require_object(), exports);
    }
  });

  // node_modules/sprotty/lib/base/commands/command.js
  var require_command = __commonJS({
    "node_modules/sprotty/lib/base/commands/command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResetCommand = exports.SystemCommand = exports.PopupCommand = exports.HiddenCommand = exports.MergeableCommand = exports.Command = exports.isStoppableCommand = void 0;
      require_Reflect();
      var inversify_1 = require_cjs4();
      var sprotty_protocol_1 = require_lib();
      function isStoppableCommand(command) {
        return command && (0, sprotty_protocol_1.hasOwnProperty)(command, "stoppableCommandKey") && "stopExecution" in command && typeof command.stopExecution === "function";
      }
      exports.isStoppableCommand = isStoppableCommand;
      var Command = class Command {
      };
      exports.Command = Command;
      exports.Command = Command = __decorate([
        (0, inversify_1.injectable)()
      ], Command);
      var MergeableCommand = class MergeableCommand extends Command {
        /**
         * Tries to merge the given command with this.
         *
         * @param command
         * @param context
         */
        merge(command, context) {
          return false;
        }
      };
      exports.MergeableCommand = MergeableCommand;
      exports.MergeableCommand = MergeableCommand = __decorate([
        (0, inversify_1.injectable)()
      ], MergeableCommand);
      var HiddenCommand = class HiddenCommand extends Command {
        undo(context) {
          context.logger.error(this, "Cannot undo a hidden command");
          return context.root;
        }
        redo(context) {
          context.logger.error(this, "Cannot redo a hidden command");
          return context.root;
        }
      };
      exports.HiddenCommand = HiddenCommand;
      exports.HiddenCommand = HiddenCommand = __decorate([
        (0, inversify_1.injectable)()
      ], HiddenCommand);
      var PopupCommand = class PopupCommand extends Command {
      };
      exports.PopupCommand = PopupCommand;
      exports.PopupCommand = PopupCommand = __decorate([
        (0, inversify_1.injectable)()
      ], PopupCommand);
      var SystemCommand = class SystemCommand extends Command {
      };
      exports.SystemCommand = SystemCommand;
      exports.SystemCommand = SystemCommand = __decorate([
        (0, inversify_1.injectable)()
      ], SystemCommand);
      var ResetCommand = class ResetCommand extends Command {
      };
      exports.ResetCommand = ResetCommand;
      exports.ResetCommand = ResetCommand = __decorate([
        (0, inversify_1.injectable)()
      ], ResetCommand);
    }
  });

  // node_modules/sprotty/lib/base/commands/command-registration.js
  var require_command_registration = __commonJS({
    "node_modules/sprotty/lib/base/commands/command-registration.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureCommand = exports.CommandActionHandlerInitializer = exports.CommandActionHandler = void 0;
      var inversify_1 = require_cjs4();
      var inversify_2 = require_inversify();
      var types_1 = require_types();
      var CommandActionHandler = class {
        constructor(commandRegistration) {
          this.commandRegistration = commandRegistration;
        }
        handle(action) {
          return this.commandRegistration.factory(action);
        }
      };
      exports.CommandActionHandler = CommandActionHandler;
      var CommandActionHandlerInitializer = class CommandActionHandlerInitializer {
        constructor(registrations) {
          this.registrations = registrations;
        }
        initialize(registry) {
          this.registrations.forEach((registration) => registry.register(registration.kind, new CommandActionHandler(registration)));
        }
      };
      exports.CommandActionHandlerInitializer = CommandActionHandlerInitializer;
      exports.CommandActionHandlerInitializer = CommandActionHandlerInitializer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.CommandRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], CommandActionHandlerInitializer);
      function configureCommand(context, constr) {
        if (!(0, inversify_2.isInjectable)(constr)) {
          throw new Error(`Commands should be @injectable: ${constr.name}`);
        }
        if (!context.isBound(constr)) {
          context.bind(constr).toSelf();
        }
        context.bind(types_1.TYPES.CommandRegistration).toDynamicValue((ctx) => ({
          kind: constr.KIND,
          factory: (action) => {
            const childContainer = new inversify_1.Container();
            childContainer.parent = ctx.container;
            childContainer.bind(types_1.TYPES.Action).toConstantValue(action);
            return childContainer.get(constr);
          }
        }));
      }
      exports.configureCommand = configureCommand;
    }
  });

  // node_modules/sprotty/lib/base/commands/command-stack-options.js
  var require_command_stack_options = __commonJS({
    "node_modules/sprotty/lib/base/commands/command-stack-options.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.overrideCommandStackOptions = exports.configureCommandStackOptions = exports.defaultCommandStackOptions = void 0;
      var object_1 = require_object();
      var types_1 = require_types();
      var defaultCommandStackOptions = () => ({
        defaultDuration: 250,
        undoHistoryLimit: 50
      });
      exports.defaultCommandStackOptions = defaultCommandStackOptions;
      function configureCommandStackOptions(context, options) {
        const opt = Object.assign(Object.assign({}, (0, exports.defaultCommandStackOptions)()), options);
        if (context.isBound(types_1.TYPES.CommandStackOptions)) {
          context.rebind(types_1.TYPES.CommandStackOptions).toConstantValue(opt);
        } else {
          context.bind(types_1.TYPES.CommandStackOptions).toConstantValue(opt);
        }
      }
      exports.configureCommandStackOptions = configureCommandStackOptions;
      function overrideCommandStackOptions(container, options) {
        const defaultOptions = container.get(types_1.TYPES.CommandStackOptions);
        (0, object_1.safeAssign)(defaultOptions, options);
        return defaultOptions;
      }
      exports.overrideCommandStackOptions = overrideCommandStackOptions;
    }
  });

  // node_modules/sprotty/lib/base/commands/command-stack.js
  var require_command_stack = __commonJS({
    "node_modules/sprotty/lib/base/commands/command-stack.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommandStack = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var smodel_factory_1 = require_smodel_factory();
      var smodel_1 = require_smodel();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      var command_1 = require_command();
      var CommandStack = class CommandStack {
        constructor() {
          this.undoStack = [];
          this.redoStack = [];
          this.stoppableCommands = /* @__PURE__ */ new Map();
          this.offStack = [];
        }
        initialize() {
          this.currentPromise = Promise.resolve({
            main: {
              model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
              modelChanged: false
            },
            hidden: {
              model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
              modelChanged: false
            },
            popup: {
              model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
              modelChanged: false
            }
          });
        }
        get currentModel() {
          return this.currentPromise.then((state) => state.main.model);
        }
        executeAll(commands) {
          commands.forEach((command) => {
            this.logger.log(this, "Executing", command);
            this.handleCommand(command, command.execute, this.mergeOrPush);
          });
          return this.thenUpdate();
        }
        execute(command) {
          this.logger.log(this, "Executing", command);
          this.handleCommand(command, command.execute, this.mergeOrPush);
          return this.thenUpdate();
        }
        undo() {
          this.undoOffStackSystemCommands();
          this.undoPreceedingSystemCommands();
          const command = this.undoStack[this.undoStack.length - 1];
          if (command !== void 0 && !this.isBlockUndo(command)) {
            this.undoStack.pop();
            this.logger.log(this, "Undoing", command);
            this.handleCommand(command, command.undo, (c3, context) => {
              this.redoStack.push(c3);
            });
          }
          return this.thenUpdate();
        }
        redo() {
          this.undoOffStackSystemCommands();
          const command = this.redoStack.pop();
          if (command !== void 0) {
            this.logger.log(this, "Redoing", command);
            this.handleCommand(command, command.redo, (c3, context) => {
              this.pushToUndoStack(c3);
            });
          }
          this.redoFollowingSystemCommands();
          return this.thenUpdate();
        }
        /**
         * Chains the current promise with another Promise that performs the
         * given operation on the given command.
         *
         * @param beforeResolve a function that is called directly before
         *      resolving the Promise to return the new model. Usually puts the
         *      command on the appropriate stack.
         */
        handleCommand(command, operation, beforeResolve) {
          if ((0, command_1.isStoppableCommand)(command)) {
            const stoppableCommand = this.stoppableCommands.get(command.stoppableCommandKey);
            if (stoppableCommand) {
              stoppableCommand.stopExecution();
            }
            this.stoppableCommands.set(command.stoppableCommandKey, command);
          }
          this.currentPromise = this.currentPromise.then((state) => new Promise((resolve) => {
            let target;
            if (command instanceof command_1.HiddenCommand)
              target = "hidden";
            else if (command instanceof command_1.PopupCommand)
              target = "popup";
            else
              target = "main";
            const context = this.createContext(state.main.model);
            let commandResult;
            try {
              commandResult = operation.call(command, context);
            } catch (error) {
              this.logger.error(this, "Failed to execute command:", error);
              commandResult = state[target].model;
            }
            const newState = copyState(state);
            if (commandResult instanceof Promise) {
              commandResult.then((newModel) => {
                if (target === "main")
                  beforeResolve.call(this, command, context);
                newState[target] = { model: newModel, modelChanged: true };
                resolve(newState);
              });
            } else if (commandResult instanceof smodel_1.SModelRootImpl) {
              if (target === "main")
                beforeResolve.call(this, command, context);
              newState[target] = { model: commandResult, modelChanged: true };
              resolve(newState);
            } else {
              if (target === "main")
                beforeResolve.call(this, command, context);
              newState[target] = {
                model: commandResult.model,
                modelChanged: state[target].modelChanged || commandResult.modelChanged,
                cause: commandResult.cause
              };
              resolve(newState);
            }
          }));
        }
        pushToUndoStack(command) {
          this.undoStack.push(command);
          if (this.options.undoHistoryLimit >= 0 && this.undoStack.length > this.options.undoHistoryLimit)
            this.undoStack.splice(0, this.undoStack.length - this.options.undoHistoryLimit);
        }
        /**
         * Notifies the Viewer to render the new model and/or the new hidden model
         * and returns a Promise for the new model.
         */
        thenUpdate() {
          this.currentPromise = this.currentPromise.then((state) => {
            const newState = copyState(state);
            if (state.hidden.modelChanged) {
              this.updateHidden(state.hidden.model, state.hidden.cause);
              newState.hidden.modelChanged = false;
              newState.hidden.cause = void 0;
            }
            if (state.main.modelChanged) {
              this.update(state.main.model, state.main.cause);
              newState.main.modelChanged = false;
              newState.main.cause = void 0;
            }
            if (state.popup.modelChanged) {
              this.updatePopup(state.popup.model, state.popup.cause);
              newState.popup.modelChanged = false;
              newState.popup.cause = void 0;
            }
            return newState;
          });
          return this.currentModel;
        }
        /**
         * Notify the `ModelViewer` that the model has changed.
         */
        update(model, cause) {
          if (this.modelViewer === void 0) {
            this.modelViewer = this.viewerProvider.modelViewer;
          }
          this.modelViewer.update(model, cause);
        }
        /**
         * Notify the `HiddenModelViewer` that the hidden model has changed.
         */
        updateHidden(model, cause) {
          if (this.hiddenModelViewer === void 0) {
            this.hiddenModelViewer = this.viewerProvider.hiddenModelViewer;
          }
          this.hiddenModelViewer.update(model, cause);
        }
        /**
         * Notify the `PopupModelViewer` that the popup model has changed.
         */
        updatePopup(model, cause) {
          if (this.popupModelViewer === void 0) {
            this.popupModelViewer = this.viewerProvider.popupModelViewer;
          }
          this.popupModelViewer.update(model, cause);
        }
        /**
         * Handling of commands after their execution.
         *
         * Hidden commands are not pushed to any stack.
         *
         * System commands are pushed to the <code>offStack</code> when the redo
         * stack is not empty, allowing to undo the before a redo to keep the chain
         * of commands consistent.
         *
         * Mergable commands are merged if possible.
         */
        mergeOrPush(command, context) {
          if (this.isBlockUndo(command)) {
            this.undoStack = [];
            this.redoStack = [];
            this.offStack = [];
            this.pushToUndoStack(command);
            return;
          }
          if (this.isPushToOffStack(command) && this.redoStack.length > 0) {
            if (this.offStack.length > 0) {
              const lastCommand = this.offStack[this.offStack.length - 1];
              if (lastCommand instanceof command_1.MergeableCommand && lastCommand.merge(command, context))
                return;
            }
            this.offStack.push(command);
            return;
          }
          if (this.isPushToUndoStack(command)) {
            this.offStack.forEach((c3) => this.undoStack.push(c3));
            this.offStack = [];
            this.redoStack = [];
            if (this.undoStack.length > 0) {
              const lastCommand = this.undoStack[this.undoStack.length - 1];
              if (lastCommand instanceof command_1.MergeableCommand && lastCommand.merge(command, context))
                return;
            }
            this.pushToUndoStack(command);
          }
        }
        /**
         * Reverts all system commands on the offStack.
         */
        undoOffStackSystemCommands() {
          let command = this.offStack.pop();
          while (command !== void 0) {
            this.logger.log(this, "Undoing off-stack", command);
            this.handleCommand(command, command.undo, () => {
            });
            command = this.offStack.pop();
          }
        }
        /**
         * System commands should be transparent to the user, so this method
         * is called from <code>undo()</code> to revert all system commands
         * at the top of the undoStack.
         */
        undoPreceedingSystemCommands() {
          let command = this.undoStack[this.undoStack.length - 1];
          while (command !== void 0 && this.isPushToOffStack(command)) {
            this.undoStack.pop();
            this.logger.log(this, "Undoing", command);
            this.handleCommand(command, command.undo, (c3, context) => {
              this.redoStack.push(c3);
            });
            command = this.undoStack[this.undoStack.length - 1];
          }
        }
        /**
         * System commands should be transparent to the user, so this method
         * is called from <code>redo()</code> to re-execute all system commands
         * at the top of the redoStack.
         */
        redoFollowingSystemCommands() {
          let command = this.redoStack[this.redoStack.length - 1];
          while (command !== void 0 && this.isPushToOffStack(command)) {
            this.redoStack.pop();
            this.logger.log(this, "Redoing ", command);
            this.handleCommand(command, command.redo, (c3, context) => {
              this.pushToUndoStack(c3);
            });
            command = this.redoStack[this.redoStack.length - 1];
          }
        }
        /**
         * Assembles the context object that is passed to the commands execution method.
         */
        createContext(currentModel) {
          return {
            root: currentModel,
            modelChanged: this,
            modelFactory: this.modelFactory,
            duration: this.options.defaultDuration,
            logger: this.logger,
            syncer: this.syncer
          };
        }
        isPushToOffStack(command) {
          return command instanceof command_1.SystemCommand;
        }
        isPushToUndoStack(command) {
          return !(command instanceof command_1.HiddenCommand);
        }
        isBlockUndo(command) {
          return command instanceof command_1.ResetCommand;
        }
      };
      exports.CommandStack = CommandStack;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IModelFactory),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "modelFactory", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IViewerProvider),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "viewerProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
      ], CommandStack.prototype, "syncer", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.CommandStackOptions),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], CommandStack.prototype, "initialize", null);
      exports.CommandStack = CommandStack = __decorate([
        (0, inversify_1.injectable)()
      ], CommandStack);
      function copyState(state) {
        return {
          main: Object.assign({}, state.main),
          hidden: Object.assign({}, state.hidden),
          popup: Object.assign({}, state.popup)
        };
      }
    }
  });

  // node_modules/sprotty/lib/utils/browser.js
  var require_browser = __commonJS({
    "node_modules/sprotty/lib/utils/browser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSVGGraphicsElement = exports.hitsMouseEvent = exports.getWindowScroll = exports.isCrossSite = exports.isMac = exports.isCtrlOrCmd = void 0;
      var sprotty_protocol_1 = require_lib();
      function isCtrlOrCmd(event) {
        if (isMac())
          return event.metaKey;
        else
          return event.ctrlKey;
      }
      exports.isCtrlOrCmd = isCtrlOrCmd;
      function isMac() {
        return window.navigator.userAgent.indexOf("Mac") !== -1;
      }
      exports.isMac = isMac;
      function isCrossSite(url) {
        if (url && typeof window !== "undefined" && window.location) {
          let baseURL = "";
          if (window.location.protocol)
            baseURL += window.location.protocol + "//";
          if (window.location.host)
            baseURL += window.location.host;
          return baseURL.length > 0 && !url.startsWith(baseURL);
        }
        return false;
      }
      exports.isCrossSite = isCrossSite;
      function getWindowScroll() {
        if (typeof window === "undefined") {
          return sprotty_protocol_1.Point.ORIGIN;
        }
        return {
          x: window.pageXOffset,
          y: window.pageYOffset
        };
      }
      exports.getWindowScroll = getWindowScroll;
      function hitsMouseEvent(child, event) {
        const clientRect = child.getBoundingClientRect();
        return event.clientX >= clientRect.left && event.clientX <= clientRect.right && event.clientY >= clientRect.top && event.clientY <= clientRect.bottom;
      }
      exports.hitsMouseEvent = hitsMouseEvent;
      function isSVGGraphicsElement(node) {
        return typeof node.getBBox === "function";
      }
      exports.isSVGGraphicsElement = isSVGGraphicsElement;
    }
  });

  // node_modules/sprotty/lib/base/features/initialize-canvas.js
  var require_initialize_canvas = __commonJS({
    "node_modules/sprotty/lib/base/features/initialize-canvas.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InitializeCanvasBoundsCommand = exports.InitializeCanvasBoundsAction = exports.CanvasBoundsInitializer = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var command_1 = require_command();
      var browser_1 = require_browser();
      var CanvasBoundsInitializer = class CanvasBoundsInitializer {
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl && !geometry_1.Dimension.isValid(element.canvasBounds)) {
            this.rootAndVnode = [element, vnode];
          }
          return vnode;
        }
        postUpdate() {
          if (this.rootAndVnode !== void 0) {
            const domElement = this.rootAndVnode[1].elm;
            const oldBounds = this.rootAndVnode[0].canvasBounds;
            if (domElement !== void 0) {
              const newBounds = this.getBoundsInPage(domElement);
              if (!((0, geometry_1.almostEquals)(newBounds.x, oldBounds.x) && (0, geometry_1.almostEquals)(newBounds.y, oldBounds.y) && (0, geometry_1.almostEquals)(newBounds.width, oldBounds.width) && (0, geometry_1.almostEquals)(newBounds.height, oldBounds.width)))
                this.actionDispatcher.dispatch(InitializeCanvasBoundsAction.create(newBounds));
            }
            this.rootAndVnode = void 0;
          }
        }
        getBoundsInPage(element) {
          const bounds = element.getBoundingClientRect();
          const scroll = (0, browser_1.getWindowScroll)();
          return {
            x: bounds.left + scroll.x,
            y: bounds.top + scroll.y,
            width: bounds.width,
            height: bounds.height
          };
        }
      };
      exports.CanvasBoundsInitializer = CanvasBoundsInitializer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], CanvasBoundsInitializer.prototype, "actionDispatcher", void 0);
      exports.CanvasBoundsInitializer = CanvasBoundsInitializer = __decorate([
        (0, inversify_1.injectable)()
      ], CanvasBoundsInitializer);
      var InitializeCanvasBoundsAction;
      (function(InitializeCanvasBoundsAction2) {
        InitializeCanvasBoundsAction2.KIND = "initializeCanvasBounds";
        function create(newCanvasBounds) {
          return {
            kind: InitializeCanvasBoundsAction2.KIND,
            newCanvasBounds
          };
        }
        InitializeCanvasBoundsAction2.create = create;
      })(InitializeCanvasBoundsAction || (exports.InitializeCanvasBoundsAction = InitializeCanvasBoundsAction = {}));
      var InitializeCanvasBoundsCommand = class InitializeCanvasBoundsCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.newCanvasBounds = this.action.newCanvasBounds;
          context.root.canvasBounds = this.newCanvasBounds;
          return context.root;
        }
        undo(context) {
          return context.root;
        }
        redo(context) {
          return context.root;
        }
      };
      exports.InitializeCanvasBoundsCommand = InitializeCanvasBoundsCommand;
      InitializeCanvasBoundsCommand.KIND = InitializeCanvasBoundsAction.KIND;
      exports.InitializeCanvasBoundsCommand = InitializeCanvasBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], InitializeCanvasBoundsCommand);
    }
  });

  // node_modules/sprotty/lib/base/features/set-model.js
  var require_set_model = __commonJS({
    "node_modules/sprotty/lib/base/features/set-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetModelCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var initialize_canvas_1 = require_initialize_canvas();
      var SetModelCommand = class SetModelCommand extends command_1.ResetCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.oldRoot = context.modelFactory.createRoot(context.root);
          this.newRoot = context.modelFactory.createRoot(this.action.newRoot);
          return this.newRoot;
        }
        undo(context) {
          return this.oldRoot;
        }
        redo(context) {
          return this.newRoot;
        }
        get blockUntil() {
          return (action) => action.kind === initialize_canvas_1.InitializeCanvasBoundsCommand.KIND;
        }
      };
      exports.SetModelCommand = SetModelCommand;
      SetModelCommand.KIND = actions_1.SetModelAction.KIND;
      exports.SetModelCommand = SetModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetModelCommand);
    }
  });

  // node_modules/sprotty/lib/base/model/smodel-utils.js
  var require_smodel_utils = __commonJS({
    "node_modules/sprotty/lib/base/model/smodel-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.transformToRootBounds = exports.containsSome = exports.translateBounds = exports.translatePoint = exports.findParentByFeature = exports.findParent = exports.registerModelElement = void 0;
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      function registerModelElement(context, type, constr, features, isOverride) {
        context.bind(types_1.TYPES.SModelElementRegistration).toConstantValue({
          type,
          constr,
          features,
          isOverride
        });
      }
      exports.registerModelElement = registerModelElement;
      function findParent(element, predicate) {
        let current = element;
        while (current !== void 0) {
          if (predicate(current))
            return current;
          else if (current instanceof smodel_1.SChildElementImpl)
            current = current.parent;
          else
            current = void 0;
        }
        return current;
      }
      exports.findParent = findParent;
      function findParentByFeature(element, predicate) {
        let current = element;
        while (current !== void 0) {
          if (predicate(current))
            return current;
          else if (current instanceof smodel_1.SChildElementImpl)
            current = current.parent;
          else
            current = void 0;
        }
        return current;
      }
      exports.findParentByFeature = findParentByFeature;
      function translatePoint(point, source, target) {
        if (source !== target) {
          while (source instanceof smodel_1.SChildElementImpl) {
            point = source.localToParent(point);
            source = source.parent;
            if (source === target)
              return point;
          }
          const targetTrace = [];
          while (target instanceof smodel_1.SChildElementImpl) {
            targetTrace.push(target);
            target = target.parent;
          }
          if (source !== target)
            throw new Error("Incompatible source and target: " + source.id + ", " + target.id);
          for (let i2 = targetTrace.length - 1; i2 >= 0; i2--) {
            point = targetTrace[i2].parentToLocal(point);
          }
        }
        return point;
      }
      exports.translatePoint = translatePoint;
      function translateBounds(bounds, source, target) {
        const upperLeft = translatePoint(bounds, source, target);
        const lowerRight = translatePoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, source, target);
        return {
          x: upperLeft.x,
          y: upperLeft.y,
          width: lowerRight.x - upperLeft.x,
          height: lowerRight.y - upperLeft.y
        };
      }
      exports.translateBounds = translateBounds;
      function containsSome(root, element) {
        const test = (el) => root.index.getById(el.id) !== void 0;
        const find = (elements) => elements.some((el) => test(el) || find(el.children));
        return find([element]);
      }
      exports.containsSome = containsSome;
      function transformToRootBounds(parent, bounds) {
        while (parent instanceof smodel_1.SChildElementImpl) {
          bounds = parent.localToParent(bounds);
          parent = parent.parent;
        }
        return bounds;
      }
      exports.transformToRootBounds = transformToRootBounds;
    }
  });

  // node_modules/sprotty/lib/base/ui-extensions/ui-extension-registry.js
  var require_ui_extension_registry = __commonJS({
    "node_modules/sprotty/lib/base/ui-extensions/ui-extension-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetUIExtensionVisibilityCommand = exports.SetUIExtensionVisibilityAction = exports.UIExtensionRegistry = void 0;
      var inversify_1 = require_cjs4();
      var registry_1 = require_registry();
      var command_1 = require_command();
      var types_1 = require_types();
      var UIExtensionRegistry = class UIExtensionRegistry extends registry_1.InstanceRegistry {
        constructor(extensions = []) {
          super();
          extensions.forEach((extension) => this.register(extension.id(), extension));
        }
      };
      exports.UIExtensionRegistry = UIExtensionRegistry;
      exports.UIExtensionRegistry = UIExtensionRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IUIExtension)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], UIExtensionRegistry);
      var SetUIExtensionVisibilityAction;
      (function(SetUIExtensionVisibilityAction2) {
        SetUIExtensionVisibilityAction2.KIND = "setUIExtensionVisibility";
        function create(options) {
          var _a4;
          return {
            kind: SetUIExtensionVisibilityAction2.KIND,
            extensionId: options.extensionId,
            visible: options.visible,
            contextElementsId: (_a4 = options.contextElementsId) !== null && _a4 !== void 0 ? _a4 : []
          };
        }
        SetUIExtensionVisibilityAction2.create = create;
      })(SetUIExtensionVisibilityAction || (exports.SetUIExtensionVisibilityAction = SetUIExtensionVisibilityAction = {}));
      var SetUIExtensionVisibilityCommand = class SetUIExtensionVisibilityCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const extension = this.registry.get(this.action.extensionId);
          if (extension) {
            this.action.visible ? extension.show(context.root, ...this.action.contextElementsId) : extension.hide();
          }
          return { model: context.root, modelChanged: false };
        }
        undo(context) {
          return { model: context.root, modelChanged: false };
        }
        redo(context) {
          return { model: context.root, modelChanged: false };
        }
      };
      exports.SetUIExtensionVisibilityCommand = SetUIExtensionVisibilityCommand;
      SetUIExtensionVisibilityCommand.KIND = SetUIExtensionVisibilityAction.KIND;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.UIExtensionRegistry),
        __metadata("design:type", UIExtensionRegistry)
      ], SetUIExtensionVisibilityCommand.prototype, "registry", void 0);
      exports.SetUIExtensionVisibilityCommand = SetUIExtensionVisibilityCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetUIExtensionVisibilityCommand);
    }
  });

  // node_modules/sprotty/lib/base/ui-extensions/ui-extension.js
  var require_ui_extension = __commonJS({
    "node_modules/sprotty/lib/base/ui-extensions/ui-extension.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractUIExtension = exports.isUIExtension = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_protocol_1 = require_lib();
      var types_1 = require_types();
      function isUIExtension(object) {
        return (0, sprotty_protocol_1.hasOwnProperty)(object, "id", "function") && (0, sprotty_protocol_1.hasOwnProperty)(object, "show", "function") && (0, sprotty_protocol_1.hasOwnProperty)(object, "hide", "function");
      }
      exports.isUIExtension = isUIExtension;
      var AbstractUIExtension = class AbstractUIExtension {
        show(root, ...contextElementIds) {
          this.activeElement = document.activeElement;
          if (!this.containerElement) {
            if (!this.initialize())
              return;
          }
          this.onBeforeShow(this.containerElement, root, ...contextElementIds);
          this.setContainerVisible(true);
        }
        hide() {
          this.setContainerVisible(false);
          this.restoreFocus();
          this.activeElement = null;
        }
        restoreFocus() {
          const focusedElement = this.activeElement;
          if (focusedElement) {
            focusedElement.focus();
          }
        }
        initialize() {
          const baseDiv = document.getElementById(this.options.baseDiv);
          if (!baseDiv) {
            this.logger.warn(this, `Could not obtain sprotty base container for initializing UI extension ${this.id}`, this);
            return false;
          }
          this.containerElement = this.getOrCreateContainer(baseDiv.id);
          this.initializeContents(this.containerElement);
          if (baseDiv) {
            baseDiv.insertBefore(this.containerElement, baseDiv.firstChild);
          }
          return true;
        }
        getOrCreateContainer(baseDivId) {
          let container = document.getElementById(this.id());
          if (container === null) {
            container = document.createElement("div");
            container.id = baseDivId + "_" + this.id();
            container.classList.add(this.containerClass());
          }
          return container;
        }
        setContainerVisible(visible) {
          if (this.containerElement) {
            if (visible) {
              this.containerElement.style.visibility = "visible";
              this.containerElement.style.opacity = "1";
            } else {
              this.containerElement.style.visibility = "hidden";
              this.containerElement.style.opacity = "0";
            }
          }
        }
        /**
         * Updates the `containerElement` under the given `context` before it becomes visible.
         *
         * Subclasses may override this method to, for instance, modifying the position of the
         * `containerElement`, add or remove elements, etc. depending on the specified `root`
         * or `contextElementIds`.
         */
        onBeforeShow(containerElement, root, ...contextElementIds) {
        }
      };
      exports.AbstractUIExtension = AbstractUIExtension;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], AbstractUIExtension.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], AbstractUIExtension.prototype, "logger", void 0);
      exports.AbstractUIExtension = AbstractUIExtension = __decorate([
        (0, inversify_1.injectable)()
      ], AbstractUIExtension);
    }
  });

  // node_modules/sprotty/lib/base/views/vnode-utils.js
  var require_vnode_utils = __commonJS({
    "node_modules/sprotty/lib/base/views/vnode-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getAttrs = exports.on = exports.mergeStyle = exports.copyClassesFromElement = exports.copyClassesFromVNode = exports.setNamespace = exports.setClass = exports.setAttr = void 0;
      function setAttr(vnode, name, value) {
        getAttrs(vnode)[name] = value;
      }
      exports.setAttr = setAttr;
      function setClass(vnode, name, value) {
        getClass(vnode)[name] = value;
      }
      exports.setClass = setClass;
      function setNamespace(node, ns) {
        if (node.data === void 0)
          node.data = {};
        node.data.ns = ns;
        const children = node.children;
        if (children !== void 0) {
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (typeof child !== "string")
              setNamespace(child, ns);
          }
        }
      }
      exports.setNamespace = setNamespace;
      function copyClassesFromVNode(source, target) {
        const classList = getClass(source);
        Object.keys(classList).forEach((c3) => setClass(target, c3, true));
      }
      exports.copyClassesFromVNode = copyClassesFromVNode;
      function copyClassesFromElement(element, target) {
        const classList = element.classList;
        for (let i2 = 0; i2 < classList.length; i2++) {
          const item = classList.item(i2);
          if (item)
            setClass(target, item, true);
        }
      }
      exports.copyClassesFromElement = copyClassesFromElement;
      function mergeStyle(vnode, style) {
        getData(vnode).style = Object.assign(Object.assign({}, getData(vnode).style || {}), style);
      }
      exports.mergeStyle = mergeStyle;
      function on(vnode, event, listener) {
        const val = getOn(vnode);
        if (val[event]) {
          throw new Error("EventListener for " + event + " already registered on VNode");
        }
        val[event] = listener;
      }
      exports.on = on;
      function getAttrs(vnode) {
        const data = getData(vnode);
        if (!data.attrs)
          data.attrs = {};
        return data.attrs;
      }
      exports.getAttrs = getAttrs;
      function getData(vnode) {
        if (!vnode.data)
          vnode.data = {};
        return vnode.data;
      }
      function getClass(vnode) {
        const data = getData(vnode);
        if (!data.class)
          data.class = {};
        return data.class;
      }
      function getOn(vnode) {
        const data = getData(vnode);
        if (!data.on)
          data.on = {};
        return data.on;
      }
    }
  });

  // node_modules/sprotty/lib/base/views/key-tool.js
  var require_key_tool = __commonJS({
    "node_modules/sprotty/lib/base/views/key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyListener = exports.KeyTool = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var vnode_utils_1 = require_vnode_utils();
      var KeyTool = class KeyTool {
        constructor(keyListeners = []) {
          this.keyListeners = keyListeners;
        }
        register(keyListener) {
          this.keyListeners.push(keyListener);
        }
        deregister(keyListener) {
          const index = this.keyListeners.indexOf(keyListener);
          if (index >= 0)
            this.keyListeners.splice(index, 1);
        }
        handleEvent(methodName, model, event) {
          const actions = this.keyListeners.map((listener) => listener[methodName].apply(listener, [model, event])).reduce((a3, b3) => a3.concat(b3));
          if (actions.length > 0) {
            event.preventDefault();
            this.actionDispatcher.dispatchAll(actions);
          }
        }
        keyDown(element, event) {
          this.handleEvent("keyDown", element, event);
        }
        keyUp(element, event) {
          this.handleEvent("keyUp", element, event);
        }
        focus() {
        }
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl) {
            (0, vnode_utils_1.on)(vnode, "focus", this.focus.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "keydown", this.keyDown.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "keyup", this.keyUp.bind(this, element));
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.KeyTool = KeyTool;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], KeyTool.prototype, "actionDispatcher", void 0);
      exports.KeyTool = KeyTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.KeyListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], KeyTool);
      var KeyListener = class KeyListener {
        keyDown(element, event) {
          return [];
        }
        keyUp(element, event) {
          return [];
        }
      };
      exports.KeyListener = KeyListener;
      exports.KeyListener = KeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], KeyListener);
    }
  });

  // node_modules/sprotty/lib/base/views/dom-helper.js
  var require_dom_helper = __commonJS({
    "node_modules/sprotty/lib/base/views/dom-helper.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DOMHelper = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var DOMHelper = class DOMHelper {
        getPrefix() {
          const prefix = this.viewerOptions !== void 0 && this.viewerOptions.baseDiv !== void 0 ? this.viewerOptions.baseDiv + "_" : "";
          return prefix;
        }
        createUniqueDOMElementId(element) {
          return this.getPrefix() + element.id;
        }
        findSModelIdByDOMElement(element) {
          return element.id.replace(this.getPrefix(), "");
        }
      };
      exports.DOMHelper = DOMHelper;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], DOMHelper.prototype, "viewerOptions", void 0);
      exports.DOMHelper = DOMHelper = __decorate([
        (0, inversify_1.injectable)()
      ], DOMHelper);
    }
  });

  // node_modules/sprotty/lib/base/views/mouse-tool.js
  var require_mouse_tool = __commonJS({
    "node_modules/sprotty/lib/base/views/mouse-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MousePositionTracker = exports.MouseListener = exports.PopupMouseTool = exports.MouseTool = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var dom_helper_1 = require_dom_helper();
      var vnode_utils_1 = require_vnode_utils();
      var MouseTool = class MouseTool {
        constructor(mouseListeners = []) {
          this.mouseListeners = mouseListeners;
        }
        register(mouseListener) {
          this.mouseListeners.push(mouseListener);
        }
        deregister(mouseListener) {
          const index = this.mouseListeners.indexOf(mouseListener);
          if (index >= 0)
            this.mouseListeners.splice(index, 1);
        }
        getTargetElement(model, event) {
          let target = event.target;
          const index = model.index;
          while (target) {
            if (target.id) {
              const element = index.getById(this.domHelper.findSModelIdByDOMElement(target));
              if (element !== void 0)
                return element;
            }
            target = target.parentNode;
          }
          return void 0;
        }
        handleEvent(methodName, model, event) {
          this.focusOnMouseEvent(methodName, model);
          const element = this.getTargetElement(model, event);
          if (!element)
            return;
          const actions = this.mouseListeners.map((listener) => listener[methodName](element, event)).reduce((a3, b3) => a3.concat(b3));
          if (actions.length > 0) {
            event.preventDefault();
            for (const actionOrPromise of actions) {
              if ((0, actions_1.isAction)(actionOrPromise)) {
                this.actionDispatcher.dispatch(actionOrPromise);
              } else {
                actionOrPromise.then((action) => {
                  this.actionDispatcher.dispatch(action);
                });
              }
            }
          }
        }
        focusOnMouseEvent(methodName, model) {
          if (document && methodName === "mouseDown") {
            const domElement = document.getElementById(this.domHelper.createUniqueDOMElementId(model));
            if (domElement !== null && typeof domElement.focus === "function")
              domElement.focus();
          }
        }
        mouseOver(model, event) {
          this.handleEvent("mouseOver", model, event);
        }
        mouseOut(model, event) {
          this.handleEvent("mouseOut", model, event);
        }
        mouseEnter(model, event) {
          this.handleEvent("mouseEnter", model, event);
        }
        mouseLeave(model, event) {
          this.handleEvent("mouseLeave", model, event);
        }
        mouseDown(model, event) {
          this.handleEvent("mouseDown", model, event);
        }
        mouseMove(model, event) {
          this.handleEvent("mouseMove", model, event);
        }
        mouseUp(model, event) {
          this.handleEvent("mouseUp", model, event);
        }
        wheel(model, event) {
          this.handleEvent("wheel", model, event);
        }
        contextMenu(model, event) {
          event.preventDefault();
          this.handleEvent("contextMenu", model, event);
        }
        doubleClick(model, event) {
          this.handleEvent("doubleClick", model, event);
        }
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl) {
            (0, vnode_utils_1.on)(vnode, "mouseover", this.mouseOver.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseout", this.mouseOut.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseenter", this.mouseEnter.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseleave", this.mouseLeave.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mousedown", this.mouseDown.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseup", this.mouseUp.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mousemove", this.mouseMove.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "wheel", this.wheel.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "contextmenu", this.contextMenu.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "dblclick", this.doubleClick.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "dragover", (event) => this.handleEvent("dragOver", element, event));
            (0, vnode_utils_1.on)(vnode, "drop", (event) => this.handleEvent("drop", element, event));
          }
          vnode = this.mouseListeners.reduce((n, listener) => listener.decorate(n, element), vnode);
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.MouseTool = MouseTool;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], MouseTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], MouseTool.prototype, "domHelper", void 0);
      exports.MouseTool = MouseTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.MouseListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], MouseTool);
      var PopupMouseTool = class PopupMouseTool extends MouseTool {
        constructor(mouseListeners = []) {
          super(mouseListeners);
          this.mouseListeners = mouseListeners;
        }
      };
      exports.PopupMouseTool = PopupMouseTool;
      exports.PopupMouseTool = PopupMouseTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.PopupMouseListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], PopupMouseTool);
      var MouseListener = class MouseListener {
        mouseOver(target, event) {
          return [];
        }
        mouseOut(target, event) {
          return [];
        }
        mouseEnter(target, event) {
          return [];
        }
        mouseLeave(target, event) {
          return [];
        }
        mouseDown(target, event) {
          return [];
        }
        mouseMove(target, event) {
          return [];
        }
        mouseUp(target, event) {
          return [];
        }
        wheel(target, event) {
          return [];
        }
        doubleClick(target, event) {
          return [];
        }
        contextMenu(target, event) {
          return [];
        }
        dragOver(target, event) {
          return [];
        }
        drop(target, event) {
          return [];
        }
        decorate(vnode, element) {
          return vnode;
        }
      };
      exports.MouseListener = MouseListener;
      exports.MouseListener = MouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], MouseListener);
      var MousePositionTracker = class MousePositionTracker extends MouseListener {
        mouseMove(target, event) {
          this.lastPosition = target.root.parentToLocal({ x: event.offsetX, y: event.offsetY });
          return [];
        }
        /**
         * Returns the last tracked mouse cursor position relative to the diagram root or `undefined`
         * if no mouse cursor position was ever tracked yet.
         */
        get lastPositionOnDiagram() {
          return this.lastPosition;
        }
      };
      exports.MousePositionTracker = MousePositionTracker;
      exports.MousePositionTracker = MousePositionTracker = __decorate([
        (0, inversify_1.injectable)()
      ], MousePositionTracker);
    }
  });

  // node_modules/snabbdom/build/snabbdom.cjs.js
  var require_snabbdom_cjs = __commonJS({
    "node_modules/snabbdom/build/snabbdom.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function createElement(tagName2, options) {
        return document.createElement(tagName2, options);
      }
      function createElementNS(namespaceURI, qualifiedName, options) {
        return document.createElementNS(namespaceURI, qualifiedName, options);
      }
      function createDocumentFragment() {
        return parseFragment(document.createDocumentFragment());
      }
      function createTextNode(text) {
        return document.createTextNode(text);
      }
      function createComment(text) {
        return document.createComment(text);
      }
      function insertBefore(parentNode2, newNode, referenceNode) {
        if (isDocumentFragment$1(parentNode2)) {
          let node = parentNode2;
          while (node && isDocumentFragment$1(node)) {
            const fragment2 = parseFragment(node);
            node = fragment2.parent;
          }
          parentNode2 = node !== null && node !== void 0 ? node : parentNode2;
        }
        if (isDocumentFragment$1(newNode)) {
          newNode = parseFragment(newNode, parentNode2);
        }
        if (referenceNode && isDocumentFragment$1(referenceNode)) {
          referenceNode = parseFragment(referenceNode).firstChildNode;
        }
        parentNode2.insertBefore(newNode, referenceNode);
      }
      function removeChild(node, child) {
        node.removeChild(child);
      }
      function appendChild(node, child) {
        if (isDocumentFragment$1(child)) {
          child = parseFragment(child, node);
        }
        node.appendChild(child);
      }
      function parentNode(node) {
        if (isDocumentFragment$1(node)) {
          while (node && isDocumentFragment$1(node)) {
            const fragment2 = parseFragment(node);
            node = fragment2.parent;
          }
          return node !== null && node !== void 0 ? node : null;
        }
        return node.parentNode;
      }
      function nextSibling(node) {
        var _a4;
        if (isDocumentFragment$1(node)) {
          const fragment2 = parseFragment(node);
          const parent = parentNode(fragment2);
          if (parent && fragment2.lastChildNode) {
            const children = Array.from(parent.childNodes);
            const index = children.indexOf(fragment2.lastChildNode);
            return (_a4 = children[index + 1]) !== null && _a4 !== void 0 ? _a4 : null;
          }
          return null;
        }
        return node.nextSibling;
      }
      function tagName(elm) {
        return elm.tagName;
      }
      function setTextContent(node, text) {
        node.textContent = text;
      }
      function getTextContent(node) {
        return node.textContent;
      }
      function isElement$1(node) {
        return node.nodeType === 1;
      }
      function isText(node) {
        return node.nodeType === 3;
      }
      function isComment(node) {
        return node.nodeType === 8;
      }
      function isDocumentFragment$1(node) {
        return node.nodeType === 11;
      }
      function parseFragment(fragmentNode, parentNode2) {
        var _a4, _b2, _c;
        const fragment2 = fragmentNode;
        (_a4 = fragment2.parent) !== null && _a4 !== void 0 ? _a4 : fragment2.parent = parentNode2 !== null && parentNode2 !== void 0 ? parentNode2 : null;
        (_b2 = fragment2.firstChildNode) !== null && _b2 !== void 0 ? _b2 : fragment2.firstChildNode = fragmentNode.firstChild;
        (_c = fragment2.lastChildNode) !== null && _c !== void 0 ? _c : fragment2.lastChildNode = fragmentNode.lastChild;
        return fragment2;
      }
      var htmlDomApi = {
        createElement,
        createElementNS,
        createTextNode,
        createDocumentFragment,
        createComment,
        insertBefore,
        removeChild,
        appendChild,
        parentNode,
        nextSibling,
        tagName,
        setTextContent,
        getTextContent,
        isElement: isElement$1,
        isText,
        isComment,
        isDocumentFragment: isDocumentFragment$1
      };
      function vnode(sel, data, children, text, elm) {
        const key = data === void 0 ? void 0 : data.key;
        return { sel, data, children, text, elm, key };
      }
      var array = Array.isArray;
      function primitive(s3) {
        return typeof s3 === "string" || typeof s3 === "number" || s3 instanceof String || s3 instanceof Number;
      }
      function isUndef(s3) {
        return s3 === void 0;
      }
      function isDef(s3) {
        return s3 !== void 0;
      }
      var emptyNode = vnode("", {}, [], void 0, void 0);
      function sameVnode(vnode1, vnode2) {
        var _a4, _b2;
        const isSameKey = vnode1.key === vnode2.key;
        const isSameIs = ((_a4 = vnode1.data) === null || _a4 === void 0 ? void 0 : _a4.is) === ((_b2 = vnode2.data) === null || _b2 === void 0 ? void 0 : _b2.is);
        const isSameSel = vnode1.sel === vnode2.sel;
        const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel ? typeof vnode1.text === typeof vnode2.text : true;
        return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;
      }
      function documentFragmentIsNotSupported() {
        throw new Error("The document fragment is not supported on this platform.");
      }
      function isElement(api, vnode2) {
        return api.isElement(vnode2);
      }
      function isDocumentFragment(api, vnode2) {
        return api.isDocumentFragment(vnode2);
      }
      function createKeyToOldIdx(children, beginIdx, endIdx) {
        var _a4;
        const map = {};
        for (let i2 = beginIdx; i2 <= endIdx; ++i2) {
          const key = (_a4 = children[i2]) === null || _a4 === void 0 ? void 0 : _a4.key;
          if (key !== void 0) {
            map[key] = i2;
          }
        }
        return map;
      }
      var hooks = [
        "create",
        "update",
        "remove",
        "destroy",
        "pre",
        "post"
      ];
      function init$1(modules, domApi, options) {
        const cbs = {
          create: [],
          update: [],
          remove: [],
          destroy: [],
          pre: [],
          post: []
        };
        const api = domApi !== void 0 ? domApi : htmlDomApi;
        for (const hook of hooks) {
          for (const module2 of modules) {
            const currentHook = module2[hook];
            if (currentHook !== void 0) {
              cbs[hook].push(currentHook);
            }
          }
        }
        function emptyNodeAt(elm) {
          const id = elm.id ? "#" + elm.id : "";
          const classes = elm.getAttribute("class");
          const c3 = classes ? "." + classes.split(" ").join(".") : "";
          return vnode(api.tagName(elm).toLowerCase() + id + c3, {}, [], void 0, elm);
        }
        function emptyDocumentFragmentAt(frag) {
          return vnode(void 0, {}, [], void 0, frag);
        }
        function createRmCb(childElm, listeners) {
          return function rmCb() {
            if (--listeners === 0) {
              const parent = api.parentNode(childElm);
              api.removeChild(parent, childElm);
            }
          };
        }
        function createElm(vnode2, insertedVnodeQueue) {
          var _a4, _b2, _c, _d;
          let i2;
          let data = vnode2.data;
          if (data !== void 0) {
            const init2 = (_a4 = data.hook) === null || _a4 === void 0 ? void 0 : _a4.init;
            if (isDef(init2)) {
              init2(vnode2);
              data = vnode2.data;
            }
          }
          const children = vnode2.children;
          const sel = vnode2.sel;
          if (sel === "!") {
            if (isUndef(vnode2.text)) {
              vnode2.text = "";
            }
            vnode2.elm = api.createComment(vnode2.text);
          } else if (sel !== void 0) {
            const hashIdx = sel.indexOf("#");
            const dotIdx = sel.indexOf(".", hashIdx);
            const hash = hashIdx > 0 ? hashIdx : sel.length;
            const dot = dotIdx > 0 ? dotIdx : sel.length;
            const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            const elm = vnode2.elm = isDef(data) && isDef(i2 = data.ns) ? api.createElementNS(i2, tag, data) : api.createElement(tag, data);
            if (hash < dot)
              elm.setAttribute("id", sel.slice(hash + 1, dot));
            if (dotIdx > 0)
              elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
            for (i2 = 0; i2 < cbs.create.length; ++i2)
              cbs.create[i2](emptyNode, vnode2);
            if (array(children)) {
              for (i2 = 0; i2 < children.length; ++i2) {
                const ch = children[i2];
                if (ch != null) {
                  api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                }
              }
            } else if (primitive(vnode2.text)) {
              api.appendChild(elm, api.createTextNode(vnode2.text));
            }
            const hook = vnode2.data.hook;
            if (isDef(hook)) {
              (_b2 = hook.create) === null || _b2 === void 0 ? void 0 : _b2.call(hook, emptyNode, vnode2);
              if (hook.insert) {
                insertedVnodeQueue.push(vnode2);
              }
            }
          } else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode2.children) {
            vnode2.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();
            for (i2 = 0; i2 < cbs.create.length; ++i2)
              cbs.create[i2](emptyNode, vnode2);
            for (i2 = 0; i2 < vnode2.children.length; ++i2) {
              const ch = vnode2.children[i2];
              if (ch != null) {
                api.appendChild(vnode2.elm, createElm(ch, insertedVnodeQueue));
              }
            }
          } else {
            vnode2.elm = api.createTextNode(vnode2.text);
          }
          return vnode2.elm;
        }
        function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
          for (; startIdx <= endIdx; ++startIdx) {
            const ch = vnodes[startIdx];
            if (ch != null) {
              api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
          }
        }
        function invokeDestroyHook(vnode2) {
          var _a4, _b2;
          const data = vnode2.data;
          if (data !== void 0) {
            (_b2 = (_a4 = data === null || data === void 0 ? void 0 : data.hook) === null || _a4 === void 0 ? void 0 : _a4.destroy) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, vnode2);
            for (let i2 = 0; i2 < cbs.destroy.length; ++i2)
              cbs.destroy[i2](vnode2);
            if (vnode2.children !== void 0) {
              for (let j3 = 0; j3 < vnode2.children.length; ++j3) {
                const child = vnode2.children[j3];
                if (child != null && typeof child !== "string") {
                  invokeDestroyHook(child);
                }
              }
            }
          }
        }
        function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
          var _a4, _b2;
          for (; startIdx <= endIdx; ++startIdx) {
            let listeners;
            let rm;
            const ch = vnodes[startIdx];
            if (ch != null) {
              if (isDef(ch.sel)) {
                invokeDestroyHook(ch);
                listeners = cbs.remove.length + 1;
                rm = createRmCb(ch.elm, listeners);
                for (let i2 = 0; i2 < cbs.remove.length; ++i2)
                  cbs.remove[i2](ch, rm);
                const removeHook = (_b2 = (_a4 = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a4 === void 0 ? void 0 : _a4.hook) === null || _b2 === void 0 ? void 0 : _b2.remove;
                if (isDef(removeHook)) {
                  removeHook(ch, rm);
                } else {
                  rm();
                }
              } else if (ch.children) {
                invokeDestroyHook(ch);
                removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);
              } else {
                api.removeChild(parentElm, ch.elm);
              }
            }
          }
        }
        function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
          let oldStartIdx = 0;
          let newStartIdx = 0;
          let oldEndIdx = oldCh.length - 1;
          let oldStartVnode = oldCh[0];
          let oldEndVnode = oldCh[oldEndIdx];
          let newEndIdx = newCh.length - 1;
          let newStartVnode = newCh[0];
          let newEndVnode = newCh[newEndIdx];
          let oldKeyToIdx;
          let idxInOld;
          let elmToMove;
          let before;
          while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
              oldStartVnode = oldCh[++oldStartIdx];
            } else if (oldEndVnode == null) {
              oldEndVnode = oldCh[--oldEndIdx];
            } else if (newStartVnode == null) {
              newStartVnode = newCh[++newStartIdx];
            } else if (newEndVnode == null) {
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newStartVnode)) {
              patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
              oldStartVnode = oldCh[++oldStartIdx];
              newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
              patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
              oldEndVnode = oldCh[--oldEndIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) {
              patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
              api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
              oldStartVnode = oldCh[++oldStartIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) {
              patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
              api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
              oldEndVnode = oldCh[--oldEndIdx];
              newStartVnode = newCh[++newStartIdx];
            } else {
              if (oldKeyToIdx === void 0) {
                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
              }
              idxInOld = oldKeyToIdx[newStartVnode.key];
              if (isUndef(idxInOld)) {
                api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
              } else {
                elmToMove = oldCh[idxInOld];
                if (elmToMove.sel !== newStartVnode.sel) {
                  api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                } else {
                  patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                  oldCh[idxInOld] = void 0;
                  api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                }
              }
              newStartVnode = newCh[++newStartIdx];
            }
          }
          if (newStartIdx <= newEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
          }
          if (oldStartIdx <= oldEndIdx) {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
          }
        }
        function patchVnode(oldVnode, vnode2, insertedVnodeQueue) {
          var _a4, _b2, _c, _d, _e3, _f, _g, _h;
          const hook = (_a4 = vnode2.data) === null || _a4 === void 0 ? void 0 : _a4.hook;
          (_b2 = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b2 === void 0 ? void 0 : _b2.call(hook, oldVnode, vnode2);
          const elm = vnode2.elm = oldVnode.elm;
          if (oldVnode === vnode2)
            return;
          if (vnode2.data !== void 0 || isDef(vnode2.text) && vnode2.text !== oldVnode.text) {
            (_c = vnode2.data) !== null && _c !== void 0 ? _c : vnode2.data = {};
            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : oldVnode.data = {};
            for (let i2 = 0; i2 < cbs.update.length; ++i2)
              cbs.update[i2](oldVnode, vnode2);
            (_g = (_f = (_e3 = vnode2.data) === null || _e3 === void 0 ? void 0 : _e3.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode2);
          }
          const oldCh = oldVnode.children;
          const ch = vnode2.children;
          if (isUndef(vnode2.text)) {
            if (isDef(oldCh) && isDef(ch)) {
              if (oldCh !== ch)
                updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            } else if (isDef(ch)) {
              if (isDef(oldVnode.text))
                api.setTextContent(elm, "");
              addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (isDef(oldCh)) {
              removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            } else if (isDef(oldVnode.text)) {
              api.setTextContent(elm, "");
            }
          } else if (oldVnode.text !== vnode2.text) {
            if (isDef(oldCh)) {
              removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            api.setTextContent(elm, vnode2.text);
          }
          (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 ? void 0 : _h.call(hook, oldVnode, vnode2);
        }
        return function patch(oldVnode, vnode2) {
          let i2, elm, parent;
          const insertedVnodeQueue = [];
          for (i2 = 0; i2 < cbs.pre.length; ++i2)
            cbs.pre[i2]();
          if (isElement(api, oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
          } else if (isDocumentFragment(api, oldVnode)) {
            oldVnode = emptyDocumentFragmentAt(oldVnode);
          }
          if (sameVnode(oldVnode, vnode2)) {
            patchVnode(oldVnode, vnode2, insertedVnodeQueue);
          } else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode2, insertedVnodeQueue);
            if (parent !== null) {
              api.insertBefore(parent, vnode2.elm, api.nextSibling(elm));
              removeVnodes(parent, [oldVnode], 0, 0);
            }
          }
          for (i2 = 0; i2 < insertedVnodeQueue.length; ++i2) {
            insertedVnodeQueue[i2].data.hook.insert(insertedVnodeQueue[i2]);
          }
          for (i2 = 0; i2 < cbs.post.length; ++i2)
            cbs.post[i2]();
          return vnode2;
        };
      }
      function addNS(data, children, sel) {
        data.ns = "http://www.w3.org/2000/svg";
        if (sel !== "foreignObject" && children !== void 0) {
          for (let i2 = 0; i2 < children.length; ++i2) {
            const child = children[i2];
            if (typeof child === "string")
              continue;
            const childData = child.data;
            if (childData !== void 0) {
              addNS(childData, child.children, child.sel);
            }
          }
        }
      }
      function h3(sel, b3, c3) {
        let data = {};
        let children;
        let text;
        let i2;
        if (c3 !== void 0) {
          if (b3 !== null) {
            data = b3;
          }
          if (array(c3)) {
            children = c3;
          } else if (primitive(c3)) {
            text = c3.toString();
          } else if (c3 && c3.sel) {
            children = [c3];
          }
        } else if (b3 !== void 0 && b3 !== null) {
          if (array(b3)) {
            children = b3;
          } else if (primitive(b3)) {
            text = b3.toString();
          } else if (b3 && b3.sel) {
            children = [b3];
          } else {
            data = b3;
          }
        }
        if (children !== void 0) {
          for (i2 = 0; i2 < children.length; ++i2) {
            if (primitive(children[i2]))
              children[i2] = vnode(void 0, void 0, void 0, children[i2], void 0);
          }
        }
        if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
          addNS(data, children, sel);
        }
        return vnode(sel, data, children, text, void 0);
      }
      function fragment(children) {
        let c3;
        let text;
        if (array(children)) {
          c3 = children;
        } else if (primitive(c3)) {
          text = children;
        } else if (c3 && c3.sel) {
          c3 = [children];
        }
        if (c3 !== void 0) {
          for (let i2 = 0; i2 < c3.length; ++i2) {
            if (primitive(c3[i2]))
              c3[i2] = vnode(void 0, void 0, void 0, c3[i2], void 0);
          }
        }
        return vnode(void 0, {}, c3, text, void 0);
      }
      function copyToThunk(vnode2, thunk2) {
        var _a4;
        const ns = (_a4 = thunk2.data) === null || _a4 === void 0 ? void 0 : _a4.ns;
        vnode2.data.fn = thunk2.data.fn;
        vnode2.data.args = thunk2.data.args;
        thunk2.data = vnode2.data;
        thunk2.children = vnode2.children;
        thunk2.text = vnode2.text;
        thunk2.elm = vnode2.elm;
        if (ns)
          addNS(thunk2.data, thunk2.children, thunk2.sel);
      }
      function init(thunk2) {
        const cur = thunk2.data;
        const vnode2 = cur.fn(...cur.args);
        copyToThunk(vnode2, thunk2);
      }
      function prepatch(oldVnode, thunk2) {
        let i2;
        const old = oldVnode.data;
        const cur = thunk2.data;
        const oldArgs = old.args;
        const args = cur.args;
        if (old.fn !== cur.fn || oldArgs.length !== args.length) {
          copyToThunk(cur.fn(...args), thunk2);
          return;
        }
        for (i2 = 0; i2 < args.length; ++i2) {
          if (oldArgs[i2] !== args[i2]) {
            copyToThunk(cur.fn(...args), thunk2);
            return;
          }
        }
        copyToThunk(oldVnode, thunk2);
      }
      var thunk = function thunk2(sel, key, fn, args) {
        if (args === void 0) {
          args = fn;
          fn = key;
          key = void 0;
        }
        return h3(sel, {
          key,
          hook: { init, prepatch },
          fn,
          args
        });
      };
      function pre(vnode2, newVnode) {
        const attachData = vnode2.data.attachData;
        newVnode.data.attachData.placeholder = attachData.placeholder;
        newVnode.data.attachData.real = attachData.real;
        vnode2.elm = vnode2.data.attachData.real;
      }
      function post(_3, vnode2) {
        vnode2.elm = vnode2.data.attachData.placeholder;
      }
      function destroy(vnode2) {
        if (vnode2.elm !== void 0) {
          vnode2.elm.parentNode.removeChild(vnode2.elm);
        }
        vnode2.elm = vnode2.data.attachData.real;
      }
      function create(_3, vnode2) {
        const real = vnode2.elm;
        const attachData = vnode2.data.attachData;
        const placeholder = document.createElement("span");
        vnode2.elm = placeholder;
        attachData.target.appendChild(real);
        attachData.real = real;
        attachData.placeholder = placeholder;
      }
      function attachTo(target, vnode2) {
        if (vnode2.data === void 0)
          vnode2.data = {};
        if (vnode2.data.hook === void 0)
          vnode2.data.hook = {};
        const data = vnode2.data;
        const hook = vnode2.data.hook;
        data.attachData = { target, placeholder: void 0, real: void 0 };
        hook.create = create;
        hook.prepatch = pre;
        hook.postpatch = post;
        hook.destroy = destroy;
        return vnode2;
      }
      function toVNode(node, domApi) {
        const api = domApi !== void 0 ? domApi : htmlDomApi;
        let text;
        if (api.isElement(node)) {
          const id = node.id ? "#" + node.id : "";
          const cn = node.getAttribute("class");
          const c3 = cn ? "." + cn.split(" ").join(".") : "";
          const sel = api.tagName(node).toLowerCase() + id + c3;
          const attrs = {};
          const dataset = {};
          const data = {};
          const children = [];
          let name;
          let i2, n;
          const elmAttrs = node.attributes;
          const elmChildren = node.childNodes;
          for (i2 = 0, n = elmAttrs.length; i2 < n; i2++) {
            name = elmAttrs[i2].nodeName;
            if (name[0] === "d" && name[1] === "a" && name[2] === "t" && name[3] === "a" && name[4] === "-") {
              dataset[name.slice(5)] = elmAttrs[i2].nodeValue || "";
            } else if (name !== "id" && name !== "class") {
              attrs[name] = elmAttrs[i2].nodeValue;
            }
          }
          for (i2 = 0, n = elmChildren.length; i2 < n; i2++) {
            children.push(toVNode(elmChildren[i2], domApi));
          }
          if (Object.keys(attrs).length > 0)
            data.attrs = attrs;
          if (Object.keys(dataset).length > 0)
            data.dataset = dataset;
          if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
            addNS(data, children, sel);
          }
          return vnode(sel, data, children, void 0, node);
        } else if (api.isText(node)) {
          text = api.getTextContent(node);
          return vnode(void 0, void 0, void 0, text, node);
        } else if (api.isComment(node)) {
          text = api.getTextContent(node);
          return vnode("!", {}, [], text, node);
        } else {
          return vnode("", {}, [], void 0, node);
        }
      }
      var xlinkNS = "http://www.w3.org/1999/xlink";
      var xmlNS = "http://www.w3.org/XML/1998/namespace";
      var colonChar = 58;
      var xChar = 120;
      function updateAttrs(oldVnode, vnode2) {
        let key;
        const elm = vnode2.elm;
        let oldAttrs = oldVnode.data.attrs;
        let attrs = vnode2.data.attrs;
        if (!oldAttrs && !attrs)
          return;
        if (oldAttrs === attrs)
          return;
        oldAttrs = oldAttrs || {};
        attrs = attrs || {};
        for (key in attrs) {
          const cur = attrs[key];
          const old = oldAttrs[key];
          if (old !== cur) {
            if (cur === true) {
              elm.setAttribute(key, "");
            } else if (cur === false) {
              elm.removeAttribute(key);
            } else {
              if (key.charCodeAt(0) !== xChar) {
                elm.setAttribute(key, cur);
              } else if (key.charCodeAt(3) === colonChar) {
                elm.setAttributeNS(xmlNS, key, cur);
              } else if (key.charCodeAt(5) === colonChar) {
                elm.setAttributeNS(xlinkNS, key, cur);
              } else {
                elm.setAttribute(key, cur);
              }
            }
          }
        }
        for (key in oldAttrs) {
          if (!(key in attrs)) {
            elm.removeAttribute(key);
          }
        }
      }
      var attributesModule = {
        create: updateAttrs,
        update: updateAttrs
      };
      function updateClass(oldVnode, vnode2) {
        let cur;
        let name;
        const elm = vnode2.elm;
        let oldClass = oldVnode.data.class;
        let klass = vnode2.data.class;
        if (!oldClass && !klass)
          return;
        if (oldClass === klass)
          return;
        oldClass = oldClass || {};
        klass = klass || {};
        for (name in oldClass) {
          if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {
            elm.classList.remove(name);
          }
        }
        for (name in klass) {
          cur = klass[name];
          if (cur !== oldClass[name]) {
            elm.classList[cur ? "add" : "remove"](name);
          }
        }
      }
      var classModule = { create: updateClass, update: updateClass };
      var CAPS_REGEX = /[A-Z]/g;
      function updateDataset(oldVnode, vnode2) {
        const elm = vnode2.elm;
        let oldDataset = oldVnode.data.dataset;
        let dataset = vnode2.data.dataset;
        let key;
        if (!oldDataset && !dataset)
          return;
        if (oldDataset === dataset)
          return;
        oldDataset = oldDataset || {};
        dataset = dataset || {};
        const d3 = elm.dataset;
        for (key in oldDataset) {
          if (!dataset[key]) {
            if (d3) {
              if (key in d3) {
                delete d3[key];
              }
            } else {
              elm.removeAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase());
            }
          }
        }
        for (key in dataset) {
          if (oldDataset[key] !== dataset[key]) {
            if (d3) {
              d3[key] = dataset[key];
            } else {
              elm.setAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase(), dataset[key]);
            }
          }
        }
      }
      var datasetModule = {
        create: updateDataset,
        update: updateDataset
      };
      function invokeHandler(handler, vnode2, event) {
        if (typeof handler === "function") {
          handler.call(vnode2, event, vnode2);
        } else if (typeof handler === "object") {
          for (let i2 = 0; i2 < handler.length; i2++) {
            invokeHandler(handler[i2], vnode2, event);
          }
        }
      }
      function handleEvent(event, vnode2) {
        const name = event.type;
        const on = vnode2.data.on;
        if (on && on[name]) {
          invokeHandler(on[name], vnode2, event);
        }
      }
      function createListener() {
        return function handler(event) {
          handleEvent(event, handler.vnode);
        };
      }
      function updateEventListeners(oldVnode, vnode2) {
        const oldOn = oldVnode.data.on;
        const oldListener = oldVnode.listener;
        const oldElm = oldVnode.elm;
        const on = vnode2 && vnode2.data.on;
        const elm = vnode2 && vnode2.elm;
        let name;
        if (oldOn === on) {
          return;
        }
        if (oldOn && oldListener) {
          if (!on) {
            for (name in oldOn) {
              oldElm.removeEventListener(name, oldListener, false);
            }
          } else {
            for (name in oldOn) {
              if (!on[name]) {
                oldElm.removeEventListener(name, oldListener, false);
              }
            }
          }
        }
        if (on) {
          const listener = vnode2.listener = oldVnode.listener || createListener();
          listener.vnode = vnode2;
          if (!oldOn) {
            for (name in on) {
              elm.addEventListener(name, listener, false);
            }
          } else {
            for (name in on) {
              if (!oldOn[name]) {
                elm.addEventListener(name, listener, false);
              }
            }
          }
        }
      }
      var eventListenersModule = {
        create: updateEventListeners,
        update: updateEventListeners,
        destroy: updateEventListeners
      };
      function updateProps(oldVnode, vnode2) {
        let key;
        let cur;
        let old;
        const elm = vnode2.elm;
        let oldProps = oldVnode.data.props;
        let props = vnode2.data.props;
        if (!oldProps && !props)
          return;
        if (oldProps === props)
          return;
        oldProps = oldProps || {};
        props = props || {};
        for (key in props) {
          cur = props[key];
          old = oldProps[key];
          if (old !== cur && (key !== "value" || elm[key] !== cur)) {
            elm[key] = cur;
          }
        }
      }
      var propsModule = { create: updateProps, update: updateProps };
      var raf = typeof window !== "undefined" && window.requestAnimationFrame.bind(window) || setTimeout;
      var nextFrame = function(fn) {
        raf(function() {
          raf(fn);
        });
      };
      var reflowForced = false;
      function setNextFrame(obj, prop, val) {
        nextFrame(function() {
          obj[prop] = val;
        });
      }
      function updateStyle(oldVnode, vnode2) {
        let cur;
        let name;
        const elm = vnode2.elm;
        let oldStyle = oldVnode.data.style;
        let style = vnode2.data.style;
        if (!oldStyle && !style)
          return;
        if (oldStyle === style)
          return;
        oldStyle = oldStyle || {};
        style = style || {};
        const oldHasDel = "delayed" in oldStyle;
        for (name in oldStyle) {
          if (!style[name]) {
            if (name[0] === "-" && name[1] === "-") {
              elm.style.removeProperty(name);
            } else {
              elm.style[name] = "";
            }
          }
        }
        for (name in style) {
          cur = style[name];
          if (name === "delayed" && style.delayed) {
            for (const name2 in style.delayed) {
              cur = style.delayed[name2];
              if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                setNextFrame(elm.style, name2, cur);
              }
            }
          } else if (name !== "remove" && cur !== oldStyle[name]) {
            if (name[0] === "-" && name[1] === "-") {
              elm.style.setProperty(name, cur);
            } else {
              elm.style[name] = cur;
            }
          }
        }
      }
      function applyDestroyStyle(vnode2) {
        let style;
        let name;
        const elm = vnode2.elm;
        const s3 = vnode2.data.style;
        if (!s3 || !(style = s3.destroy))
          return;
        for (name in style) {
          elm.style[name] = style[name];
        }
      }
      function applyRemoveStyle(vnode2, rm) {
        const s3 = vnode2.data.style;
        if (!s3 || !s3.remove) {
          rm();
          return;
        }
        if (!reflowForced) {
          vnode2.elm.offsetLeft;
          reflowForced = true;
        }
        let name;
        const elm = vnode2.elm;
        let i2 = 0;
        const style = s3.remove;
        let amount = 0;
        const applied = [];
        for (name in style) {
          applied.push(name);
          elm.style[name] = style[name];
        }
        const compStyle = getComputedStyle(elm);
        const props = compStyle["transition-property"].split(", ");
        for (; i2 < props.length; ++i2) {
          if (applied.indexOf(props[i2]) !== -1)
            amount++;
        }
        elm.addEventListener("transitionend", function(ev) {
          if (ev.target === elm)
            --amount;
          if (amount === 0)
            rm();
        });
      }
      function forceReflow() {
        reflowForced = false;
      }
      var styleModule = {
        pre: forceReflow,
        create: updateStyle,
        update: updateStyle,
        destroy: applyDestroyStyle,
        remove: applyRemoveStyle
      };
      function Fragment(data, ...children) {
        const flatChildren = flattenAndFilter(children, []);
        if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
          return vnode(void 0, void 0, void 0, flatChildren[0].text, void 0);
        } else {
          return vnode(void 0, data !== null && data !== void 0 ? data : {}, flatChildren, void 0, void 0);
        }
      }
      function flattenAndFilter(children, flattened) {
        for (const child of children) {
          if (child !== void 0 && child !== null && child !== false && child !== "") {
            if (Array.isArray(child)) {
              flattenAndFilter(child, flattened);
            } else if (typeof child === "string" || typeof child === "number" || typeof child === "boolean") {
              flattened.push(vnode(void 0, void 0, void 0, String(child), void 0));
            } else {
              flattened.push(child);
            }
          }
        }
        return flattened;
      }
      function jsx(tag, data, ...children) {
        const flatChildren = flattenAndFilter(children, []);
        if (typeof tag === "function") {
          return tag(data, flatChildren);
        } else {
          if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
            return h3(tag, data, flatChildren[0].text);
          } else {
            return h3(tag, data, flatChildren);
          }
        }
      }
      /* @__PURE__ */ (function(jsx2) {
      })(jsx || (jsx = {}));
      exports.Fragment = Fragment;
      exports.array = array;
      exports.attachTo = attachTo;
      exports.attributesModule = attributesModule;
      exports.classModule = classModule;
      exports.datasetModule = datasetModule;
      exports.eventListenersModule = eventListenersModule;
      exports.fragment = fragment;
      exports.h = h3;
      exports.htmlDomApi = htmlDomApi;
      exports.init = init$1;
      exports.jsx = jsx;
      exports.primitive = primitive;
      exports.propsModule = propsModule;
      exports.styleModule = styleModule;
      exports.thunk = thunk;
      exports.toVNode = toVNode;
      exports.vnode = vnode;
    }
  });

  // node_modules/sprotty/lib/base/views/thunk-view.js
  var require_thunk_view = __commonJS({
    "node_modules/sprotty/lib/base/views/thunk-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isThunk = exports.ThunkView = void 0;
      var snabbdom_1 = require_snabbdom_cjs();
      var inversify_1 = require_cjs4();
      var ThunkView = class ThunkView {
        render(model, context) {
          return (0, snabbdom_1.h)(this.selector(model), {
            key: model.id,
            hook: {
              init: this.init.bind(this),
              prepatch: this.prepatch.bind(this)
            },
            fn: () => this.renderAndDecorate(model, context),
            args: this.watchedArgs(model),
            thunk: true
          });
        }
        renderAndDecorate(model, context) {
          const vnode = this.doRender(model, context);
          context.decorate(vnode, model);
          return vnode;
        }
        copyToThunk(vnode, thunk) {
          thunk.elm = vnode.elm;
          vnode.data.fn = thunk.data.fn;
          vnode.data.args = thunk.data.args;
          thunk.data = vnode.data;
          thunk.children = vnode.children;
          thunk.text = vnode.text;
          thunk.elm = vnode.elm;
        }
        init(thunk) {
          const cur = thunk.data;
          const vnode = cur.fn.apply(void 0, cur.args);
          this.copyToThunk(vnode, thunk);
        }
        prepatch(oldVnode, thunk) {
          const old = oldVnode.data, cur = thunk.data;
          if (!this.equals(old.args, cur.args))
            this.copyToThunk(cur.fn.apply(void 0, cur.args), thunk);
          else
            this.copyToThunk(oldVnode, thunk);
        }
        equals(oldArg, newArg) {
          if (Array.isArray(oldArg) && Array.isArray(newArg)) {
            if (oldArg.length !== newArg.length)
              return false;
            for (let i2 = 0; i2 < newArg.length; ++i2) {
              if (!this.equals(oldArg[i2], newArg[i2]))
                return false;
            }
          } else if (typeof oldArg === "object" && typeof newArg === "object") {
            if (Object.keys(oldArg).length !== Object.keys(newArg).length)
              return false;
            for (const key in oldArg) {
              if (key !== "parent" && key !== "root" && (!(key in newArg) || !this.equals(oldArg[key], newArg[key])))
                return false;
            }
          } else if (oldArg !== newArg) {
            return false;
          }
          return true;
        }
      };
      exports.ThunkView = ThunkView;
      exports.ThunkView = ThunkView = __decorate([
        (0, inversify_1.injectable)()
      ], ThunkView);
      function isThunk(vnode) {
        return "thunk" in vnode;
      }
      exports.isThunk = isThunk;
    }
  });

  // node_modules/sprotty/lib/lib/jsx.js
  var require_jsx = __commonJS({
    "node_modules/sprotty/lib/lib/jsx.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JSX = exports.svg = exports.html = void 0;
      var snabbdom_1 = require_snabbdom_cjs();
      var modulesNS = ["hook", "on", "style", "class", "props", "attrs", "dataset"];
      var SVGNS = "http://www.w3.org/2000/svg";
      function normalizeAttrs(source, defNS, namespace) {
        const data = {};
        if (namespace) {
          data.ns = namespace;
        }
        if (source === null) {
          return data;
        }
        modulesNS.forEach((mod) => {
          if (source[mod]) {
            data[mod] = source[mod];
          }
        });
        Object.keys(source).forEach((key) => {
          if (key === "key" || key === "classNames" || key === "selector")
            return;
          const idx = key.indexOf("-");
          if (idx > 0) {
            const modname = key.slice(0, idx);
            if (modulesNS.includes(modname)) {
              addAttr(modname, key.slice(idx + 1), source[key]);
            } else {
              addAttr(defNS, key, source[key]);
            }
          } else if (!data[key])
            addAttr(defNS, key, source[key]);
        });
        return data;
        function addAttr(modname, key, val) {
          const mod = data[modname] || (data[modname] = {});
          mod[key] = val;
        }
      }
      function JSX(namespace, defNS = "props") {
        return (tag, attrs, ...children) => {
          const isComponent = typeof tag === "function";
          return (0, snabbdom_1.jsx)(tag, isComponent ? attrs : normalizeAttrs(attrs, defNS, namespace), children);
        };
      }
      exports.JSX = JSX;
      var html = JSX();
      exports.html = html;
      var svg = JSX(SVGNS, "attrs");
      exports.svg = svg;
    }
  });

  // node_modules/sprotty/lib/base/views/view.js
  var require_view = __commonJS({
    "node_modules/sprotty/lib/base/views/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var MissingView_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MissingView = exports.EmptyView = exports.configureView = exports.overrideModelElement = exports.configureModelElement = exports.ViewRegistry = exports.findArgValue = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var inversify_2 = require_inversify();
      var smodel_factory_1 = require_smodel_factory();
      var smodel_utils_1 = require_smodel_utils();
      var sprotty_protocol_1 = require_lib();
      function findArgValue(arg, key) {
        while (arg !== void 0 && !(key in arg) && arg.parentArgs) {
          arg = arg.parentArgs;
        }
        return arg ? arg[key] : void 0;
      }
      exports.findArgValue = findArgValue;
      var ViewRegistry = class ViewRegistry extends registry_1.InstanceRegistry {
        constructor(registrations) {
          super();
          this.registerDefaults();
          registrations.forEach((registration) => {
            if (registration.isOverride) {
              this.override(registration.type, registration.factory());
            } else {
              this.register(registration.type, registration.factory());
            }
          });
        }
        registerDefaults() {
          this.register(smodel_factory_1.EMPTY_ROOT.type, new EmptyView());
        }
        missing(key) {
          this.logger.warn(this, `no registered view for type '${key}', please configure a view in the ContainerModule`);
          return new MissingView();
        }
      };
      exports.ViewRegistry = ViewRegistry;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], ViewRegistry.prototype, "logger", void 0);
      exports.ViewRegistry = ViewRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ViewRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], ViewRegistry);
      function configureModelElement2(context, type, modelConstr, viewConstr, features) {
        (0, smodel_utils_1.registerModelElement)(context, type, modelConstr, features);
        configureView(context, type, viewConstr);
      }
      exports.configureModelElement = configureModelElement2;
      function overrideModelElement(context, type, modelConstr, viewConstr, features) {
        (0, smodel_utils_1.registerModelElement)(context, type, modelConstr, features, true);
        configureView(context, type, viewConstr, true);
      }
      exports.overrideModelElement = overrideModelElement;
      function configureView(context, type, constr, isOverride) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Views should be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.ViewRegistration).toDynamicValue((ctx) => ({
          type,
          factory: () => ctx.container.get(constr),
          isOverride
        }));
      }
      exports.configureView = configureView;
      var EmptyView = class EmptyView {
        render(model, context) {
          return (0, jsx_1.svg)("svg", { "class-sprotty-empty": true });
        }
      };
      exports.EmptyView = EmptyView;
      exports.EmptyView = EmptyView = __decorate([
        (0, inversify_1.injectable)()
      ], EmptyView);
      var MissingView = MissingView_1 = class MissingView {
        render(model, context) {
          const position = model.position || this.getPostion(model.type);
          return (0, jsx_1.svg)(
            "text",
            { "class-sprotty-missing": true, x: position.x, y: position.y },
            'missing "',
            model.type,
            '" view'
          );
        }
        getPostion(type) {
          let position = MissingView_1.positionMap.get(type);
          if (!position) {
            position = sprotty_protocol_1.Point.ORIGIN;
            MissingView_1.positionMap.forEach((value) => position = value.y >= position.y ? { x: 0, y: value.y + 20 } : position);
            MissingView_1.positionMap.set(type, position);
          }
          return position;
        }
      };
      exports.MissingView = MissingView;
      MissingView.positionMap = /* @__PURE__ */ new Map();
      exports.MissingView = MissingView = MissingView_1 = __decorate([
        (0, inversify_1.injectable)()
      ], MissingView);
    }
  });

  // node_modules/sprotty/lib/base/views/viewer-cache.js
  var require_viewer_cache = __commonJS({
    "node_modules/sprotty/lib/base/views/viewer-cache.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewerCache = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      var ViewerCache = class ViewerCache {
        update(model, cause) {
          if (cause !== void 0) {
            this.delegate.update(model, cause);
            this.cachedModel = void 0;
          } else {
            const isCacheEmpty = this.cachedModel === void 0;
            this.cachedModel = model;
            if (isCacheEmpty) {
              this.scheduleUpdate();
            }
          }
        }
        scheduleUpdate() {
          this.syncer.onEndOfNextFrame(() => {
            if (this.cachedModel) {
              this.delegate.update(this.cachedModel);
              this.cachedModel = void 0;
            }
          });
        }
      };
      exports.ViewerCache = ViewerCache;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IViewer),
        __metadata("design:type", Object)
      ], ViewerCache.prototype, "delegate", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
      ], ViewerCache.prototype, "syncer", void 0);
      exports.ViewerCache = ViewerCache = __decorate([
        (0, inversify_1.injectable)()
      ], ViewerCache);
    }
  });

  // node_modules/sprotty/lib/base/views/viewer-options.js
  var require_viewer_options = __commonJS({
    "node_modules/sprotty/lib/base/views/viewer-options.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.overrideViewerOptions = exports.configureViewerOptions = exports.defaultViewerOptions = void 0;
      var object_1 = require_object();
      var types_1 = require_types();
      var defaultViewerOptions = () => ({
        baseDiv: "sprotty",
        baseClass: "sprotty",
        hiddenDiv: "sprotty-hidden",
        hiddenClass: "sprotty-hidden",
        popupDiv: "sprotty-popup",
        popupClass: "sprotty-popup",
        popupClosedClass: "sprotty-popup-closed",
        needsClientLayout: true,
        needsServerLayout: false,
        popupOpenDelay: 1e3,
        popupCloseDelay: 300,
        zoomLimits: { min: 0.01, max: 10 },
        horizontalScrollLimits: { min: -1e5, max: 1e5 },
        verticalScrollLimits: { min: -1e5, max: 1e5 }
      });
      exports.defaultViewerOptions = defaultViewerOptions;
      function configureViewerOptions(context, options) {
        const opt = Object.assign(Object.assign({}, (0, exports.defaultViewerOptions)()), options);
        if (context.isBound(types_1.TYPES.ViewerOptions)) {
          context.rebind(types_1.TYPES.ViewerOptions).toConstantValue(opt);
        } else {
          context.bind(types_1.TYPES.ViewerOptions).toConstantValue(opt);
        }
      }
      exports.configureViewerOptions = configureViewerOptions;
      function overrideViewerOptions(container, options) {
        const opt = container.get(types_1.TYPES.ViewerOptions);
        (0, object_1.safeAssign)(opt, options);
        return opt;
      }
      exports.overrideViewerOptions = overrideViewerOptions;
    }
  });

  // node_modules/sprotty/lib/base/views/viewer.js
  var require_viewer = __commonJS({
    "node_modules/sprotty/lib/base/views/viewer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PopupModelViewer = exports.HiddenModelViewer = exports.ModelViewer = exports.PatcherProvider = exports.ModelRenderer = void 0;
      var inversify_1 = require_cjs4();
      var snabbdom_1 = require_snabbdom_cjs();
      var jsx_1 = require_jsx();
      var browser_1 = require_browser();
      var initialize_canvas_1 = require_initialize_canvas();
      var smodel_factory_1 = require_smodel_factory();
      var types_1 = require_types();
      var thunk_view_1 = require_thunk_view();
      var vnode_utils_1 = require_vnode_utils();
      var ModelRenderer = class _ModelRenderer {
        constructor(viewRegistry, targetKind, postprocessors, args = {}) {
          this.viewRegistry = viewRegistry;
          this.targetKind = targetKind;
          this.postprocessors = postprocessors;
          this.args = args;
        }
        decorate(vnode, element) {
          if ((0, thunk_view_1.isThunk)(vnode)) {
            return vnode;
          }
          return this.postprocessors.reduce((n, processor) => processor.decorate(n, element), vnode);
        }
        renderElement(element) {
          const view = this.viewRegistry.get(element.type);
          const vnode = view.render(element, this, this.args);
          if (vnode) {
            return this.decorate(vnode, element);
          } else {
            return void 0;
          }
        }
        renderChildren(element, args) {
          const context = args ? new _ModelRenderer(this.viewRegistry, this.targetKind, this.postprocessors, Object.assign(Object.assign({}, args), { parentArgs: this.args })) : this;
          return element.children.map((child) => context.renderElement(child)).filter((vnode) => vnode !== void 0);
        }
        postUpdate(cause) {
          this.postprocessors.forEach((processor) => processor.postUpdate(cause));
        }
      };
      exports.ModelRenderer = ModelRenderer;
      var PatcherProvider = class PatcherProvider {
        constructor() {
          this.patcher = (0, snabbdom_1.init)(this.createModules());
        }
        createModules() {
          return [
            snabbdom_1.propsModule,
            snabbdom_1.attributesModule,
            snabbdom_1.classModule,
            snabbdom_1.styleModule,
            snabbdom_1.eventListenersModule
          ];
        }
      };
      exports.PatcherProvider = PatcherProvider;
      exports.PatcherProvider = PatcherProvider = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [])
      ], PatcherProvider);
      var ModelViewer = class ModelViewer {
        constructor(modelRendererFactory, patcherProvider, postprocessors) {
          this.renderer = modelRendererFactory("main", postprocessors);
          this.patcher = patcherProvider.patcher;
        }
        update(model, cause) {
          var _a4;
          this.logger.log(this, "rendering", model);
          const newVDOM = (0, jsx_1.html)("div", { id: this.options.baseDiv }, this.renderer.renderElement(model));
          if (this.lastVDOM !== void 0) {
            const hadFocus = this.hasFocus();
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastVDOM, newVDOM);
            this.lastVDOM = this.patcher.call(this, this.lastVDOM, newVDOM);
            this.restoreFocus(hadFocus);
          } else if (typeof document !== "undefined") {
            let placeholder = null;
            if (this.options.shadowRoot) {
              const shadowRoot = (_a4 = document.getElementById(this.options.shadowRoot)) === null || _a4 === void 0 ? void 0 : _a4.shadowRoot;
              if (shadowRoot) {
                placeholder = shadowRoot.getElementById(this.options.baseDiv);
              }
            } else {
              placeholder = document.getElementById(this.options.baseDiv);
            }
            if (placeholder !== null) {
              if (typeof window !== "undefined") {
                window.addEventListener("resize", () => {
                  this.onWindowResize(newVDOM);
                });
              }
              (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
              (0, vnode_utils_1.setClass)(newVDOM, this.options.baseClass, true);
              this.lastVDOM = this.patcher.call(this, placeholder, newVDOM);
            } else {
              this.logger.error(this, "element not in DOM:", this.options.baseDiv);
            }
          }
          this.renderer.postUpdate(cause);
        }
        hasFocus() {
          if (typeof document !== "undefined" && document.activeElement && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            const lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === "object") {
              const lastElement = lastRootVNode.elm;
              return document.activeElement === lastElement;
            }
          }
          return false;
        }
        restoreFocus(focus) {
          if (focus && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            const lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === "object") {
              const lastElement = lastRootVNode.elm;
              if (lastElement && typeof lastElement.focus === "function")
                lastElement.focus();
            }
          }
        }
        onWindowResize(vdom) {
          const baseDiv = document.getElementById(this.options.baseDiv);
          if (baseDiv !== null) {
            const newBounds = this.getBoundsInPage(baseDiv);
            this.actiondispatcher.dispatch(initialize_canvas_1.InitializeCanvasBoundsAction.create(newBounds));
          }
        }
        getBoundsInPage(element) {
          const bounds = element.getBoundingClientRect();
          const scroll = (0, browser_1.getWindowScroll)();
          return {
            x: bounds.left + scroll.x,
            y: bounds.top + scroll.y,
            width: bounds.width,
            height: bounds.height
          };
        }
      };
      exports.ModelViewer = ModelViewer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ModelViewer.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], ModelViewer.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ModelViewer.prototype, "actiondispatcher", void 0);
      exports.ModelViewer = ModelViewer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
        __param(2, (0, inversify_1.multiInject)(types_1.TYPES.IVNodePostprocessor)),
        __param(2, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
      ], ModelViewer);
      var HiddenModelViewer = class HiddenModelViewer {
        constructor(modelRendererFactory, patcherProvider, hiddenPostprocessors) {
          this.hiddenRenderer = modelRendererFactory("hidden", hiddenPostprocessors);
          this.patcher = patcherProvider.patcher;
        }
        update(hiddenModel, cause) {
          this.logger.log(this, "rendering hidden");
          let newVDOM;
          if (hiddenModel.type === smodel_factory_1.EMPTY_ROOT.type) {
            newVDOM = (0, jsx_1.html)("div", { id: this.options.hiddenDiv });
          } else {
            const hiddenVNode = this.hiddenRenderer.renderElement(hiddenModel);
            if (hiddenVNode) {
              (0, vnode_utils_1.setAttr)(hiddenVNode, "opacity", 0);
            }
            newVDOM = (0, jsx_1.html)("div", { id: this.options.hiddenDiv }, hiddenVNode);
          }
          if (this.lastHiddenVDOM !== void 0) {
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastHiddenVDOM, newVDOM);
            this.lastHiddenVDOM = this.patcher.call(this, this.lastHiddenVDOM, newVDOM);
          } else {
            let placeholder = document.getElementById(this.options.hiddenDiv);
            if (placeholder === null) {
              placeholder = document.createElement("div");
              document.body.appendChild(placeholder);
            } else {
              (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
            }
            (0, vnode_utils_1.setClass)(newVDOM, this.options.baseClass, true);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.hiddenClass, true);
            this.lastHiddenVDOM = this.patcher.call(this, placeholder, newVDOM);
          }
          this.hiddenRenderer.postUpdate(cause);
        }
      };
      exports.HiddenModelViewer = HiddenModelViewer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], HiddenModelViewer.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], HiddenModelViewer.prototype, "logger", void 0);
      exports.HiddenModelViewer = HiddenModelViewer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
        __param(2, (0, inversify_1.multiInject)(types_1.TYPES.HiddenVNodePostprocessor)),
        __param(2, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
      ], HiddenModelViewer);
      var PopupModelViewer = class PopupModelViewer {
        constructor(modelRendererFactory, patcherProvider, popupPostprocessors) {
          this.modelRendererFactory = modelRendererFactory;
          this.popupRenderer = this.modelRendererFactory("popup", popupPostprocessors);
          this.patcher = patcherProvider.patcher;
        }
        update(model, cause) {
          this.logger.log(this, "rendering popup", model);
          const popupClosed = model.type === smodel_factory_1.EMPTY_ROOT.type;
          let newVDOM;
          if (popupClosed) {
            newVDOM = (0, jsx_1.html)("div", { id: this.options.popupDiv });
          } else {
            const position = model.canvasBounds;
            const inlineStyle = {
              top: position.y + "px",
              left: position.x + "px"
            };
            newVDOM = (0, jsx_1.html)("div", { id: this.options.popupDiv, style: inlineStyle }, this.popupRenderer.renderElement(model));
          }
          if (this.lastPopupVDOM !== void 0) {
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastPopupVDOM, newVDOM);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, this.lastPopupVDOM, newVDOM);
          } else if (typeof document !== "undefined") {
            let placeholder = document.getElementById(this.options.popupDiv);
            if (placeholder === null) {
              placeholder = document.createElement("div");
              document.body.appendChild(placeholder);
            } else {
              (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
            }
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClass, true);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, placeholder, newVDOM);
          }
          this.popupRenderer.postUpdate(cause);
        }
      };
      exports.PopupModelViewer = PopupModelViewer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], PopupModelViewer.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], PopupModelViewer.prototype, "logger", void 0);
      exports.PopupModelViewer = PopupModelViewer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
        __param(2, (0, inversify_1.multiInject)(types_1.TYPES.PopupVNodePostprocessor)),
        __param(2, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
      ], PopupModelViewer);
    }
  });

  // node_modules/sprotty/lib/base/views/vnode-postprocessor.js
  var require_vnode_postprocessor = __commonJS({
    "node_modules/sprotty/lib/base/views/vnode-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusFixPostprocessor = void 0;
      var inversify_1 = require_cjs4();
      var vnode_utils_1 = require_vnode_utils();
      var FocusFixPostprocessor = class FocusFixPostprocessor {
        decorate(vnode, element) {
          if (vnode.sel && vnode.sel.startsWith("svg"))
            (0, vnode_utils_1.setAttr)(vnode, "tabindex", 0);
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.FocusFixPostprocessor = FocusFixPostprocessor;
      exports.FocusFixPostprocessor = FocusFixPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], FocusFixPostprocessor);
    }
  });

  // node_modules/sprotty/lib/utils/logging.js
  var require_logging = __commonJS({
    "node_modules/sprotty/lib/utils/logging.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConsoleLogger = exports.NullLogger = exports.LogLevel = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var LogLevel2;
      (function(LogLevel3) {
        LogLevel3[LogLevel3["none"] = 0] = "none";
        LogLevel3[LogLevel3["error"] = 1] = "error";
        LogLevel3[LogLevel3["warn"] = 2] = "warn";
        LogLevel3[LogLevel3["info"] = 3] = "info";
        LogLevel3[LogLevel3["log"] = 4] = "log";
      })(LogLevel2 || (exports.LogLevel = LogLevel2 = {}));
      var NullLogger = class NullLogger {
        constructor() {
          this.logLevel = LogLevel2.none;
        }
        error(thisArg, message, ...params) {
        }
        warn(thisArg, message, ...params) {
        }
        info(thisArg, message, ...params) {
        }
        log(thisArg, message, ...params) {
        }
      };
      exports.NullLogger = NullLogger;
      exports.NullLogger = NullLogger = __decorate([
        (0, inversify_1.injectable)()
      ], NullLogger);
      var ConsoleLogger2 = class ConsoleLogger {
        constructor() {
          this.logLevel = LogLevel2.log;
          this.viewOptions = { baseDiv: "" };
        }
        error(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.error)
            try {
              console.error.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        warn(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.warn)
            try {
              console.warn.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        info(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.info)
            try {
              console.info.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        log(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.log)
            try {
              console.log.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        consoleArguments(thisArg, message, params) {
          let caller;
          if (typeof thisArg === "object")
            caller = thisArg.constructor.name;
          else
            caller = thisArg;
          const date = /* @__PURE__ */ new Date();
          return [date.toLocaleTimeString() + " " + this.viewOptions.baseDiv + " " + caller + ": " + message, ...params];
        }
      };
      exports.ConsoleLogger = ConsoleLogger2;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.LogLevel),
        __metadata("design:type", Number)
      ], ConsoleLogger2.prototype, "logLevel", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ConsoleLogger2.prototype, "viewOptions", void 0);
      exports.ConsoleLogger = ConsoleLogger2 = __decorate([
        (0, inversify_1.injectable)()
      ], ConsoleLogger2);
    }
  });

  // node_modules/sprotty/lib/base/views/id-postprocessor.js
  var require_id_postprocessor = __commonJS({
    "node_modules/sprotty/lib/base/views/id-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IdPostprocessor = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var dom_helper_1 = require_dom_helper();
      var vnode_utils_1 = require_vnode_utils();
      var IdPostprocessor = class IdPostprocessor {
        decorate(vnode, element) {
          const attrs = (0, vnode_utils_1.getAttrs)(vnode);
          if (attrs.id !== void 0)
            this.logger.warn(vnode, "Overriding id of vnode (" + attrs.id + "). Make sure not to set it manually in view.");
          attrs.id = this.domHelper.createUniqueDOMElementId(element);
          if (!vnode.key)
            vnode.key = element.id;
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.IdPostprocessor = IdPostprocessor;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], IdPostprocessor.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], IdPostprocessor.prototype, "domHelper", void 0);
      exports.IdPostprocessor = IdPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], IdPostprocessor);
    }
  });

  // node_modules/sprotty/lib/base/views/css-class-postprocessor.js
  var require_css_class_postprocessor = __commonJS({
    "node_modules/sprotty/lib/base/views/css-class-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CssClassPostprocessor = void 0;
      var model_utils_1 = require_model_utils();
      var vnode_utils_1 = require_vnode_utils();
      var inversify_1 = require_cjs4();
      var CssClassPostprocessor = class CssClassPostprocessor {
        decorate(vnode, element) {
          if (element.cssClasses) {
            for (const cssClass of element.cssClasses)
              (0, vnode_utils_1.setClass)(vnode, cssClass, true);
          }
          const subType = (0, model_utils_1.getSubType)(element);
          if (subType && subType !== element.type) {
            (0, vnode_utils_1.setClass)(vnode, subType, true);
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.CssClassPostprocessor = CssClassPostprocessor;
      exports.CssClassPostprocessor = CssClassPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], CssClassPostprocessor);
    }
  });

  // node_modules/sprotty/lib/base/di.config.js
  var require_di_config = __commonJS({
    "node_modules/sprotty/lib/base/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var initialize_canvas_1 = require_initialize_canvas();
      var logging_1 = require_logging();
      var action_dispatcher_1 = require_action_dispatcher();
      var action_handler_1 = require_action_handler();
      var command_stack_1 = require_command_stack();
      var command_stack_options_1 = require_command_stack_options();
      var smodel_factory_1 = require_smodel_factory();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      var viewer_1 = require_viewer();
      var viewer_options_1 = require_viewer_options();
      var mouse_tool_1 = require_mouse_tool();
      var key_tool_1 = require_key_tool();
      var vnode_postprocessor_1 = require_vnode_postprocessor();
      var view_1 = require_view();
      var viewer_cache_1 = require_viewer_cache();
      var dom_helper_1 = require_dom_helper();
      var id_postprocessor_1 = require_id_postprocessor();
      var command_registration_1 = require_command_registration();
      var css_class_postprocessor_1 = require_css_class_postprocessor();
      var set_model_1 = require_set_model();
      var ui_extension_registry_1 = require_ui_extension_registry();
      var diagram_locker_1 = require_diagram_locker();
      var defaultContainerModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(types_1.TYPES.ILogger).to(logging_1.NullLogger).inSingletonScope();
        bind(types_1.TYPES.LogLevel).toConstantValue(logging_1.LogLevel.warn);
        bind(types_1.TYPES.SModelRegistry).to(smodel_factory_1.SModelRegistry).inSingletonScope();
        bind(action_handler_1.ActionHandlerRegistry).toSelf().inSingletonScope();
        bind(types_1.TYPES.ActionHandlerRegistryProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve) => {
              resolve(ctx.container.get(action_handler_1.ActionHandlerRegistry));
            });
          };
        });
        bind(types_1.TYPES.ViewRegistry).to(view_1.ViewRegistry).inSingletonScope();
        bind(types_1.TYPES.IModelFactory).to(smodel_factory_1.SModelFactory).inSingletonScope();
        bind(types_1.TYPES.IActionDispatcher).to(action_dispatcher_1.ActionDispatcher).inSingletonScope();
        bind(types_1.TYPES.IActionDispatcherProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve) => {
              resolve(ctx.container.get(types_1.TYPES.IActionDispatcher));
            });
          };
        });
        bind(types_1.TYPES.IDiagramLocker).to(diagram_locker_1.DefaultDiagramLocker).inSingletonScope();
        bind(command_registration_1.CommandActionHandlerInitializer).toSelf().inSingletonScope();
        bind(types_1.TYPES.IActionHandlerInitializer).toService(command_registration_1.CommandActionHandlerInitializer);
        bind(types_1.TYPES.ICommandStack).to(command_stack_1.CommandStack).inSingletonScope();
        bind(types_1.TYPES.ICommandStackProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve) => {
              resolve(ctx.container.get(types_1.TYPES.ICommandStack));
            });
          };
        });
        bind(types_1.TYPES.CommandStackOptions).toConstantValue((0, command_stack_options_1.defaultCommandStackOptions)());
        bind(viewer_1.ModelViewer).toSelf().inSingletonScope();
        bind(viewer_1.HiddenModelViewer).toSelf().inSingletonScope();
        bind(viewer_1.PopupModelViewer).toSelf().inSingletonScope();
        bind(types_1.TYPES.ModelViewer).toDynamicValue((ctx) => {
          const container = ctx.container.createChild();
          container.bind(types_1.TYPES.IViewer).toService(viewer_1.ModelViewer);
          container.bind(viewer_cache_1.ViewerCache).toSelf();
          return container.get(viewer_cache_1.ViewerCache);
        }).inSingletonScope();
        bind(types_1.TYPES.PopupModelViewer).toDynamicValue((ctx) => {
          const container = ctx.container.createChild();
          container.bind(types_1.TYPES.IViewer).toService(viewer_1.PopupModelViewer);
          container.bind(viewer_cache_1.ViewerCache).toSelf();
          return container.get(viewer_cache_1.ViewerCache);
        }).inSingletonScope();
        bind(types_1.TYPES.HiddenModelViewer).toService(viewer_1.HiddenModelViewer);
        bind(types_1.TYPES.IViewerProvider).toDynamicValue((ctx) => {
          return {
            get modelViewer() {
              return ctx.container.get(types_1.TYPES.ModelViewer);
            },
            get hiddenModelViewer() {
              return ctx.container.get(types_1.TYPES.HiddenModelViewer);
            },
            get popupModelViewer() {
              return ctx.container.get(types_1.TYPES.PopupModelViewer);
            }
          };
        });
        bind(types_1.TYPES.ViewerOptions).toConstantValue((0, viewer_options_1.defaultViewerOptions)());
        bind(types_1.TYPES.PatcherProvider).to(viewer_1.PatcherProvider).inSingletonScope();
        bind(types_1.TYPES.DOMHelper).to(dom_helper_1.DOMHelper).inSingletonScope();
        bind(types_1.TYPES.ModelRendererFactory).toFactory((ctx) => {
          return (targetKind, processors, args = {}) => {
            const viewRegistry = ctx.container.get(types_1.TYPES.ViewRegistry);
            return new viewer_1.ModelRenderer(viewRegistry, targetKind, processors, args);
          };
        });
        bind(id_postprocessor_1.IdPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
        bind(css_class_postprocessor_1.CssClassPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(css_class_postprocessor_1.CssClassPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(css_class_postprocessor_1.CssClassPostprocessor);
        bind(mouse_tool_1.MouseTool).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(mouse_tool_1.MouseTool);
        bind(key_tool_1.KeyTool).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(key_tool_1.KeyTool);
        bind(vnode_postprocessor_1.FocusFixPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(vnode_postprocessor_1.FocusFixPostprocessor);
        bind(types_1.TYPES.PopupVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
        bind(mouse_tool_1.PopupMouseTool).toSelf().inSingletonScope();
        bind(types_1.TYPES.PopupVNodePostprocessor).toService(mouse_tool_1.PopupMouseTool);
        bind(types_1.TYPES.AnimationFrameSyncer).to(animation_frame_syncer_1.AnimationFrameSyncer).inSingletonScope();
        const context = { bind, isBound };
        (0, command_registration_1.configureCommand)(context, initialize_canvas_1.InitializeCanvasBoundsCommand);
        bind(initialize_canvas_1.CanvasBoundsInitializer).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(initialize_canvas_1.CanvasBoundsInitializer);
        (0, command_registration_1.configureCommand)(context, set_model_1.SetModelCommand);
        bind(types_1.TYPES.UIExtensionRegistry).to(ui_extension_registry_1.UIExtensionRegistry).inSingletonScope();
        (0, command_registration_1.configureCommand)(context, ui_extension_registry_1.SetUIExtensionVisibilityCommand);
        bind(mouse_tool_1.MousePositionTracker).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(mouse_tool_1.MousePositionTracker);
      });
      exports.default = defaultContainerModule;
    }
  });

  // node_modules/sprotty/lib/features/bounds/model.js
  var require_model2 = __commonJS({
    "node_modules/sprotty/lib/features/bounds/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SShapeElementImpl = exports.findChildrenAtPosition = exports.getAbsoluteClientBounds = exports.getAbsoluteBounds = exports.isAlignable = exports.isSizeable = exports.isLayoutableChild = exports.isLayoutContainer = exports.isBoundsAware = exports.alignFeature = exports.layoutableChildFeature = exports.layoutContainerFeature = exports.boundsFeature = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var smodel_utils_1 = require_smodel_utils();
      var browser_1 = require_browser();
      exports.boundsFeature = Symbol("boundsFeature");
      exports.layoutContainerFeature = Symbol("layoutContainerFeature");
      exports.layoutableChildFeature = Symbol("layoutableChildFeature");
      exports.alignFeature = Symbol("alignFeature");
      function isBoundsAware(element) {
        return "bounds" in element;
      }
      exports.isBoundsAware = isBoundsAware;
      function isLayoutContainer(element) {
        return isBoundsAware(element) && element.hasFeature(exports.layoutContainerFeature) && "layout" in element;
      }
      exports.isLayoutContainer = isLayoutContainer;
      function isLayoutableChild(element) {
        return isBoundsAware(element) && element.hasFeature(exports.layoutableChildFeature);
      }
      exports.isLayoutableChild = isLayoutableChild;
      function isSizeable(element) {
        return element.hasFeature(exports.boundsFeature) && isBoundsAware(element);
      }
      exports.isSizeable = isSizeable;
      function isAlignable(element) {
        return element.hasFeature(exports.alignFeature) && "alignment" in element;
      }
      exports.isAlignable = isAlignable;
      function getAbsoluteBounds(element) {
        const boundsAware = (0, smodel_utils_1.findParentByFeature)(element, isBoundsAware);
        if (boundsAware !== void 0) {
          let bounds = boundsAware.bounds;
          let current = boundsAware;
          while (current instanceof smodel_1.SChildElementImpl) {
            const parent = current.parent;
            bounds = parent.localToParent(bounds);
            current = parent;
          }
          return bounds;
        } else if (element instanceof smodel_1.SModelRootImpl) {
          const canvasBounds = element.canvasBounds;
          return { x: 0, y: 0, width: canvasBounds.width, height: canvasBounds.height };
        } else {
          return geometry_1.Bounds.EMPTY;
        }
      }
      exports.getAbsoluteBounds = getAbsoluteBounds;
      function getAbsoluteClientBounds(element, domHelper, viewerOptions) {
        let x3 = 0;
        let y3 = 0;
        let width = 0;
        let height = 0;
        const svgElementId = domHelper.createUniqueDOMElementId(element);
        const svgElement = document.getElementById(svgElementId);
        if (svgElement) {
          const rect = svgElement.getBoundingClientRect();
          const scroll = (0, browser_1.getWindowScroll)();
          x3 = rect.left + scroll.x;
          y3 = rect.top + scroll.y;
          width = rect.width;
          height = rect.height;
        }
        let container = document.getElementById(viewerOptions.baseDiv);
        if (container) {
          while (container.offsetParent instanceof HTMLElement && (container = container.offsetParent)) {
            x3 -= container.offsetLeft;
            y3 -= container.offsetTop;
          }
        }
        return { x: x3, y: y3, width, height };
      }
      exports.getAbsoluteClientBounds = getAbsoluteClientBounds;
      function findChildrenAtPosition(parent, point) {
        const matches = [];
        doFindChildrenAtPosition(parent, point, matches);
        return matches;
      }
      exports.findChildrenAtPosition = findChildrenAtPosition;
      function doFindChildrenAtPosition(parent, point, matches) {
        parent.children.forEach((child) => {
          if (isBoundsAware(child) && geometry_1.Bounds.includes(child.bounds, point))
            matches.push(child);
          if (child instanceof smodel_1.SParentElementImpl) {
            const newPoint = child.parentToLocal(point);
            doFindChildrenAtPosition(child, newPoint, matches);
          }
        });
      }
      var SShapeElementImpl = class extends smodel_1.SChildElementImpl {
        constructor() {
          super(...arguments);
          this.position = geometry_1.Point.ORIGIN;
          this.size = geometry_1.Dimension.EMPTY;
        }
        get bounds() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
          };
        }
        set bounds(newBounds) {
          this.position = {
            x: newBounds.x,
            y: newBounds.y
          };
          this.size = {
            width: newBounds.width,
            height: newBounds.height
          };
        }
        localToParent(point) {
          const result = {
            x: point.x + this.position.x,
            y: point.y + this.position.y,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
        parentToLocal(point) {
          const result = {
            x: point.x - this.position.x,
            y: point.y - this.position.y,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
      };
      exports.SShapeElementImpl = SShapeElementImpl;
    }
  });

  // node_modules/sprotty/lib/features/bounds/bounds-manipulation.js
  var require_bounds_manipulation = __commonJS({
    "node_modules/sprotty/lib/features/bounds/bounds-manipulation.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RequestBoundsCommand = exports.SetBoundsCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var model_1 = require_model2();
      var SetBoundsCommand = class SetBoundsCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
          this.bounds = [];
        }
        execute(context) {
          this.action.bounds.forEach((b3) => {
            const element = context.root.index.getById(b3.elementId);
            if (element && (0, model_1.isBoundsAware)(element)) {
              this.bounds.push({
                element,
                oldBounds: element.bounds,
                newPosition: b3.newPosition,
                newSize: b3.newSize
              });
            }
          });
          return this.redo(context);
        }
        undo(context) {
          this.bounds.forEach((b3) => b3.element.bounds = b3.oldBounds);
          return context.root;
        }
        redo(context) {
          this.bounds.forEach((b3) => {
            if (b3.newPosition)
              b3.element.bounds = Object.assign(Object.assign({}, b3.newPosition), b3.newSize);
            else
              b3.element.bounds = Object.assign({ x: b3.element.bounds.x, y: b3.element.bounds.y }, b3.newSize);
          });
          return context.root;
        }
      };
      exports.SetBoundsCommand = SetBoundsCommand;
      SetBoundsCommand.KIND = actions_1.SetBoundsAction.KIND;
      exports.SetBoundsCommand = SetBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetBoundsCommand);
      var RequestBoundsCommand = class RequestBoundsCommand extends command_1.HiddenCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          return {
            model: context.modelFactory.createRoot(this.action.newRoot),
            modelChanged: true,
            cause: this.action
          };
        }
        get blockUntil() {
          return (action) => action.kind === actions_1.ComputedBoundsAction.KIND;
        }
      };
      exports.RequestBoundsCommand = RequestBoundsCommand;
      RequestBoundsCommand.KIND = actions_1.RequestBoundsAction.KIND;
      exports.RequestBoundsCommand = RequestBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], RequestBoundsCommand);
    }
  });

  // node_modules/sprotty/lib/features/bounds/layout.js
  var require_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureLayout = exports.StatefulLayouter = exports.Layouter = exports.LayoutRegistry = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var model_1 = require_model2();
      var inversify_2 = require_inversify();
      var LayoutRegistry = class LayoutRegistry extends registry_1.InstanceRegistry {
        constructor(layouts = []) {
          super();
          layouts.forEach((layout) => {
            if (this.hasKey(layout.layoutKind)) {
              this.logger.warn("Layout kind is already defined: ", layout.layoutKind);
            } else {
              this.register(layout.layoutKind, layout.factory());
            }
          });
        }
      };
      exports.LayoutRegistry = LayoutRegistry;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], LayoutRegistry.prototype, "logger", void 0);
      exports.LayoutRegistry = LayoutRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.LayoutRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], LayoutRegistry);
      var Layouter = class Layouter {
        layout(element2boundsData) {
          new StatefulLayouter(element2boundsData, this.layoutRegistry, this.logger).layout();
        }
      };
      exports.Layouter = Layouter;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.LayoutRegistry),
        __metadata("design:type", LayoutRegistry)
      ], Layouter.prototype, "layoutRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], Layouter.prototype, "logger", void 0);
      exports.Layouter = Layouter = __decorate([
        (0, inversify_1.injectable)()
      ], Layouter);
      var StatefulLayouter = class {
        constructor(element2boundsData, layoutRegistry, log) {
          this.element2boundsData = element2boundsData;
          this.layoutRegistry = layoutRegistry;
          this.log = log;
          this.toBeLayouted = [];
          element2boundsData.forEach((data, element) => {
            if ((0, model_1.isLayoutContainer)(element))
              this.toBeLayouted.push(element);
          });
        }
        getBoundsData(element) {
          let boundsData = this.element2boundsData.get(element);
          let bounds = element.bounds;
          if ((0, model_1.isLayoutContainer)(element) && this.toBeLayouted.indexOf(element) >= 0) {
            bounds = this.doLayout(element);
          }
          if (!boundsData) {
            boundsData = {
              bounds,
              boundsChanged: false,
              alignmentChanged: false
            };
            this.element2boundsData.set(element, boundsData);
          }
          return boundsData;
        }
        layout() {
          while (this.toBeLayouted.length > 0) {
            const element = this.toBeLayouted[0];
            this.doLayout(element);
          }
        }
        doLayout(element) {
          const index = this.toBeLayouted.indexOf(element);
          if (index >= 0)
            this.toBeLayouted.splice(index, 1);
          const layout = this.layoutRegistry.get(element.layout);
          if (layout)
            layout.layout(element, this);
          const boundsData = this.element2boundsData.get(element);
          if (boundsData !== void 0 && boundsData.bounds !== void 0) {
            return boundsData.bounds;
          } else {
            this.log.error(element, "Layout failed");
            return geometry_1.Bounds.EMPTY;
          }
        }
      };
      exports.StatefulLayouter = StatefulLayouter;
      function configureLayout(context, kind, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Layouts be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.LayoutRegistration).toDynamicValue((ctx) => ({
          layoutKind: kind,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureLayout = configureLayout;
    }
  });

  // node_modules/sprotty/lib/features/bounds/hidden-bounds-updater.js
  var require_hidden_bounds_updater = __commonJS({
    "node_modules/sprotty/lib/features/bounds/hidden-bounds-updater.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATTR_BBOX_ELEMENT = exports.HiddenBoundsUpdater = exports.BoundsData = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var browser_1 = require_browser();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var layout_1 = require_layout();
      var model_1 = require_model2();
      var BoundsData = class {
      };
      exports.BoundsData = BoundsData;
      var HiddenBoundsUpdater = class HiddenBoundsUpdater {
        constructor() {
          this.element2boundsData = /* @__PURE__ */ new Map();
        }
        decorate(vnode, element) {
          if ((0, model_1.isSizeable)(element) || (0, model_1.isLayoutContainer)(element)) {
            this.element2boundsData.set(element, {
              vnode,
              bounds: element.bounds,
              boundsChanged: false,
              alignmentChanged: false
            });
          }
          if (element instanceof smodel_1.SModelRootImpl) {
            this.root = element;
          }
          return vnode;
        }
        postUpdate(cause) {
          if (cause === void 0 || cause.kind !== actions_1.RequestBoundsAction.KIND) {
            return;
          }
          const request = cause;
          this.getBoundsFromDOM();
          this.layouter.layout(this.element2boundsData);
          const resizes = [];
          const alignments = [];
          this.element2boundsData.forEach((boundsData, element) => {
            if (boundsData.boundsChanged && boundsData.bounds !== void 0) {
              const resize = {
                elementId: element.id,
                newSize: {
                  width: boundsData.bounds.width,
                  height: boundsData.bounds.height
                }
              };
              if (element instanceof smodel_1.SChildElementImpl && (0, model_1.isLayoutContainer)(element.parent)) {
                resize.newPosition = {
                  x: boundsData.bounds.x,
                  y: boundsData.bounds.y
                };
              }
              resizes.push(resize);
            }
            if (boundsData.alignmentChanged && boundsData.alignment !== void 0) {
              alignments.push({
                elementId: element.id,
                newAlignment: boundsData.alignment
              });
            }
          });
          const revision = this.root !== void 0 ? this.root.revision : void 0;
          this.actionDispatcher.dispatch(actions_1.ComputedBoundsAction.create(resizes, { revision, alignments, requestId: request.requestId }));
          this.element2boundsData.clear();
        }
        getBoundsFromDOM() {
          this.element2boundsData.forEach((boundsData, element) => {
            if (boundsData.bounds && (0, model_1.isSizeable)(element)) {
              const vnode = boundsData.vnode;
              if (vnode && vnode.elm) {
                const boundingBox = this.getBounds(vnode.elm, element);
                if ((0, model_1.isAlignable)(element) && !((0, geometry_1.almostEquals)(boundingBox.x, 0) && (0, geometry_1.almostEquals)(boundingBox.y, 0))) {
                  boundsData.alignment = {
                    x: -boundingBox.x,
                    y: -boundingBox.y
                  };
                  boundsData.alignmentChanged = true;
                }
                const newBounds = {
                  x: element.bounds.x,
                  y: element.bounds.y,
                  width: boundingBox.width,
                  height: boundingBox.height
                };
                if (!((0, geometry_1.almostEquals)(newBounds.x, element.bounds.x) && (0, geometry_1.almostEquals)(newBounds.y, element.bounds.y) && (0, geometry_1.almostEquals)(newBounds.width, element.bounds.width) && (0, geometry_1.almostEquals)(newBounds.height, element.bounds.height))) {
                  boundsData.bounds = newBounds;
                  boundsData.boundsChanged = true;
                }
              }
            }
          });
        }
        /**
         * Compute the bounds of the given DOM element. Override this method to customize how
         * the bounding box of a rendered view is determined.
         *
         * In case your Sprotty model element contains children that are rendered outside of
         * their parent, you can add the `ATTR_BBOX_ELEMENT` attribute to the SVG element
         * that shall be used to compute the bounding box.
         */
        getBounds(elm, element) {
          if (!(0, browser_1.isSVGGraphicsElement)(elm)) {
            this.logger.error(this, "Not an SVG element:", elm);
            return geometry_1.Bounds.EMPTY;
          }
          if (elm.tagName === "g") {
            for (const child of Array.from(elm.children)) {
              if (child.getAttribute(exports.ATTR_BBOX_ELEMENT) !== null) {
                return this.getBounds(child, element);
              }
            }
          }
          const bounds = elm.getBBox();
          return {
            x: bounds.x,
            y: bounds.y,
            width: bounds.width,
            height: bounds.height
          };
        }
      };
      exports.HiddenBoundsUpdater = HiddenBoundsUpdater;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], HiddenBoundsUpdater.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], HiddenBoundsUpdater.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.Layouter),
        __metadata("design:type", layout_1.Layouter)
      ], HiddenBoundsUpdater.prototype, "layouter", void 0);
      exports.HiddenBoundsUpdater = HiddenBoundsUpdater = __decorate([
        (0, inversify_1.injectable)()
      ], HiddenBoundsUpdater);
      exports.ATTR_BBOX_ELEMENT = "bboxElement";
    }
  });

  // node_modules/sprotty/lib/features/bounds/abstract-layout.js
  var require_abstract_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/abstract-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractLayout = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var inversify_1 = require_cjs4();
      var AbstractLayout = class AbstractLayout {
        layout(container, layouter) {
          const boundsData = layouter.getBoundsData(container);
          const options = this.getLayoutOptions(container);
          const childrenSize = this.getChildrenSize(container, options, layouter);
          const maxWidth = options.paddingFactor * (options.resizeContainer ? Math.max(childrenSize.width, options.minWidth) : Math.max(0, this.getFixedContainerBounds(container, options, layouter).width) - options.paddingLeft - options.paddingRight);
          const maxHeight = options.paddingFactor * (options.resizeContainer ? Math.max(childrenSize.height, options.minHeight) : Math.max(0, this.getFixedContainerBounds(container, options, layouter).height) - options.paddingTop - options.paddingBottom);
          if (maxWidth > 0 && maxHeight > 0) {
            const offset = this.layoutChildren(container, layouter, options, maxWidth, maxHeight);
            boundsData.bounds = this.getFinalContainerBounds(container, offset, options, maxWidth, maxHeight);
            boundsData.boundsChanged = true;
          }
        }
        getFinalContainerBounds(container, lastOffset, options, maxWidth, maxHeight) {
          return {
            x: container.bounds.x,
            y: container.bounds.y,
            width: Math.max(options.minWidth, maxWidth + options.paddingLeft + options.paddingRight),
            height: Math.max(options.minHeight, maxHeight + options.paddingTop + options.paddingBottom)
          };
        }
        getFixedContainerBounds(container, layoutOptions, layouter) {
          let currentContainer = container;
          while (true) {
            if ((0, model_1.isBoundsAware)(currentContainer)) {
              const bounds = currentContainer.bounds;
              if ((0, model_1.isLayoutContainer)(currentContainer) && layoutOptions.resizeContainer)
                layouter.log.error(currentContainer, "Resizable container found while detecting fixed bounds");
              if (geometry_1.Dimension.isValid(bounds))
                return bounds;
            }
            if (currentContainer instanceof smodel_1.SChildElementImpl) {
              currentContainer = currentContainer.parent;
            } else {
              layouter.log.error(currentContainer, "Cannot detect fixed bounds");
              return geometry_1.Bounds.EMPTY;
            }
          }
        }
        layoutChildren(container, layouter, containerOptions, maxWidth, maxHeight) {
          let currentOffset = {
            x: containerOptions.paddingLeft + 0.5 * (maxWidth - maxWidth / containerOptions.paddingFactor),
            y: containerOptions.paddingTop + 0.5 * (maxHeight - maxHeight / containerOptions.paddingFactor)
          };
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const boundsData = layouter.getBoundsData(child);
              const bounds = boundsData.bounds;
              const childOptions = this.getChildLayoutOptions(child, containerOptions);
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                currentOffset = this.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight);
              }
            }
          });
          return currentOffset;
        }
        getDx(hAlign, bounds, maxWidth) {
          switch (hAlign) {
            case "left":
              return 0;
            case "center":
              return 0.5 * (maxWidth - bounds.width);
            case "right":
              return maxWidth - bounds.width;
          }
        }
        getDy(vAlign, bounds, maxHeight) {
          switch (vAlign) {
            case "top":
              return 0;
            case "center":
              return 0.5 * (maxHeight - bounds.height);
            case "bottom":
              return maxHeight - bounds.height;
          }
        }
        getChildLayoutOptions(child, containerOptions) {
          const layoutOptions = child.layoutOptions;
          if (layoutOptions === void 0)
            return containerOptions;
          else
            return this.spread(containerOptions, layoutOptions);
        }
        getLayoutOptions(element) {
          let current = element;
          const allOptions = [];
          while (current !== void 0) {
            const layoutOptions = current.layoutOptions;
            if (layoutOptions !== void 0)
              allOptions.push(layoutOptions);
            if (current instanceof smodel_1.SChildElementImpl)
              current = current.parent;
            else
              break;
          }
          return allOptions.reverse().reduce((a3, b3) => {
            return this.spread(a3, b3);
          }, this.getDefaultLayoutOptions());
        }
      };
      exports.AbstractLayout = AbstractLayout;
      exports.AbstractLayout = AbstractLayout = __decorate([
        (0, inversify_1.injectable)()
      ], AbstractLayout);
    }
  });

  // node_modules/sprotty/lib/features/bounds/vbox-layout.js
  var require_vbox_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/vbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VBoxLayouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var abstract_layout_1 = require_abstract_layout();
      var model_1 = require_model2();
      var VBoxLayouter = class VBoxLayouter extends abstract_layout_1.AbstractLayout {
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = -1;
          let maxHeight = 0;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                maxHeight += bounds.height;
                if (isFirst)
                  isFirst = false;
                else
                  maxHeight += containerOptions.vGap;
                maxWidth = Math.max(maxWidth, bounds.width);
              }
            }
          });
          return {
            width: maxWidth,
            height: maxHeight
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          const dx = this.getDx(childOptions.hAlign, bounds, maxWidth);
          boundsData.bounds = {
            x: containerOptions.paddingLeft + child.bounds.x - bounds.x + dx,
            y: currentOffset.y + child.bounds.y - bounds.y,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return {
            x: currentOffset.x,
            y: currentOffset.y + bounds.height + containerOptions.vGap
          };
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            vGap: 1,
            hAlign: "center",
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a3, b3) {
          return Object.assign(Object.assign({}, a3), b3);
        }
      };
      exports.VBoxLayouter = VBoxLayouter;
      VBoxLayouter.KIND = "vbox";
      exports.VBoxLayouter = VBoxLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], VBoxLayouter);
    }
  });

  // node_modules/sprotty/lib/features/bounds/hbox-layout.js
  var require_hbox_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/hbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HBoxLayouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var abstract_layout_1 = require_abstract_layout();
      var model_1 = require_model2();
      var HBoxLayouter = class HBoxLayouter extends abstract_layout_1.AbstractLayout {
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = 0;
          let maxHeight = -1;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                if (isFirst)
                  isFirst = false;
                else
                  maxWidth += containerOptions.hGap;
                maxWidth += bounds.width;
                maxHeight = Math.max(maxHeight, bounds.height);
              }
            }
          });
          return {
            width: maxWidth,
            height: maxHeight
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          const dy = this.getDy(childOptions.vAlign, bounds, maxHeight);
          boundsData.bounds = {
            x: currentOffset.x + child.bounds.x - bounds.x,
            y: containerOptions.paddingTop + child.bounds.y - bounds.y + dy,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return {
            x: currentOffset.x + bounds.width + containerOptions.hGap,
            y: currentOffset.y
          };
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            hGap: 1,
            vAlign: "center",
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a3, b3) {
          return Object.assign(Object.assign({}, a3), b3);
        }
      };
      exports.HBoxLayouter = HBoxLayouter;
      HBoxLayouter.KIND = "hbox";
      exports.HBoxLayouter = HBoxLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], HBoxLayouter);
    }
  });

  // node_modules/sprotty/lib/features/bounds/stack-layout.js
  var require_stack_layout = __commonJS({
    "node_modules/sprotty/lib/features/bounds/stack-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StackLayouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var abstract_layout_1 = require_abstract_layout();
      var model_1 = require_model2();
      var StackLayouter = class StackLayouter extends abstract_layout_1.AbstractLayout {
        getChildrenSize(container, options, layouter) {
          let maxWidth = -1;
          let maxHeight = -1;
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                maxWidth = Math.max(maxWidth, bounds.width);
                maxHeight = Math.max(maxHeight, bounds.height);
              }
            }
          });
          return {
            width: maxWidth,
            height: maxHeight
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          const dx = this.getDx(childOptions.hAlign, bounds, maxWidth);
          const dy = this.getDy(childOptions.vAlign, bounds, maxHeight);
          boundsData.bounds = {
            x: containerOptions.paddingLeft + child.bounds.x - bounds.x + dx,
            y: containerOptions.paddingTop + child.bounds.y - bounds.y + dy,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return currentOffset;
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            hAlign: "center",
            vAlign: "center",
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a3, b3) {
          return Object.assign(Object.assign({}, a3), b3);
        }
      };
      exports.StackLayouter = StackLayouter;
      StackLayouter.KIND = "stack";
      exports.StackLayouter = StackLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], StackLayouter);
    }
  });

  // node_modules/sprotty/lib/features/bounds/views.js
  var require_views = __commonJS({
    "node_modules/sprotty/lib/features/bounds/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShapeView = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var model_1 = require_model2();
      var ShapeView = class ShapeView {
        /**
         * Check whether the given model element is in the current viewport. Use this method
         * in your `render` implementation to skip rendering in case the element is not visible.
         * This can greatly enhance performance for large models.
         */
        isVisible(model, context) {
          if (context.targetKind === "hidden") {
            return true;
          }
          if (!geometry_1.Dimension.isValid(model.bounds)) {
            return true;
          }
          const ab = (0, model_1.getAbsoluteBounds)(model);
          const canvasBounds = model.root.canvasBounds;
          return ab.x <= canvasBounds.width && ab.x + ab.width >= 0 && ab.y <= canvasBounds.height && ab.y + ab.height >= 0;
        }
      };
      exports.ShapeView = ShapeView;
      exports.ShapeView = ShapeView = __decorate([
        (0, inversify_1.injectable)()
      ], ShapeView);
    }
  });

  // node_modules/sprotty/lib/features/button/button-handler.js
  var require_button_handler = __commonJS({
    "node_modules/sprotty/lib/features/button/button-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureButtonHandler = exports.ButtonHandlerRegistry = void 0;
      var inversify_1 = require_cjs4();
      var registry_1 = require_registry();
      var types_1 = require_types();
      var inversify_2 = require_inversify();
      var ButtonHandlerRegistry = class ButtonHandlerRegistry extends registry_1.InstanceRegistry {
        constructor(buttonHandlerRegistrations) {
          super();
          buttonHandlerRegistrations.forEach((factory) => this.register(factory.TYPE, factory.factory()));
        }
      };
      exports.ButtonHandlerRegistry = ButtonHandlerRegistry;
      exports.ButtonHandlerRegistry = ButtonHandlerRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IButtonHandlerRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], ButtonHandlerRegistry);
      function configureButtonHandler(context, type, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Button handlers should be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.IButtonHandlerRegistration).toDynamicValue((ctx) => ({
          TYPE: type,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureButtonHandler = configureButtonHandler;
    }
  });

  // node_modules/sprotty/lib/features/fade/model.js
  var require_model3 = __commonJS({
    "node_modules/sprotty/lib/features/fade/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isFadeable = exports.fadeFeature = void 0;
      exports.fadeFeature = Symbol("fadeFeature");
      function isFadeable(element) {
        return element.hasFeature(exports.fadeFeature) && element["opacity"] !== void 0;
      }
      exports.isFadeable = isFadeable;
    }
  });

  // node_modules/sprotty/lib/features/button/model.js
  var require_model4 = __commonJS({
    "node_modules/sprotty/lib/features/button/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SButtonImpl = void 0;
      var model_1 = require_model2();
      var model_2 = require_model3();
      var SButtonImpl = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.enabled = true;
        }
      };
      exports.SButtonImpl = SButtonImpl;
      SButtonImpl.DEFAULT_FEATURES = [model_1.boundsFeature, model_1.layoutableChildFeature, model_2.fadeFeature];
    }
  });

  // node_modules/sprotty/lib/features/nameable/model.js
  var require_model5 = __commonJS({
    "node_modules/sprotty/lib/features/nameable/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.name = exports.isNameable = exports.nameFeature = void 0;
      exports.nameFeature = Symbol("nameableFeature");
      function isNameable(element) {
        return element.hasFeature(exports.nameFeature);
      }
      exports.isNameable = isNameable;
      function name(element) {
        if (isNameable(element)) {
          return element.name;
        } else {
          return void 0;
        }
      }
      exports.name = name;
    }
  });

  // node_modules/sprotty/lib/features/command-palette/action-providers.js
  var require_action_providers = __commonJS({
    "node_modules/sprotty/lib/features/command-palette/action-providers.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RevealNamedElementActionProvider = exports.CommandPaletteActionProviderRegistry = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var action_1 = require_action();
      var types_1 = require_types();
      var iterable_1 = require_iterable();
      var model_1 = require_model5();
      var CommandPaletteActionProviderRegistry = class CommandPaletteActionProviderRegistry {
        constructor(actionProviders = []) {
          this.actionProviders = actionProviders;
        }
        getActions(root, text, lastMousePosition, index) {
          const actionLists = this.actionProviders.map((provider) => provider.getActions(root, text, lastMousePosition, index));
          return Promise.all(actionLists).then((p3) => p3.reduce((acc, promise) => promise !== void 0 ? acc.concat(promise) : acc));
        }
      };
      exports.CommandPaletteActionProviderRegistry = CommandPaletteActionProviderRegistry;
      exports.CommandPaletteActionProviderRegistry = CommandPaletteActionProviderRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ICommandPaletteActionProvider)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], CommandPaletteActionProviderRegistry);
      var RevealNamedElementActionProvider = class RevealNamedElementActionProvider {
        constructor(logger) {
          this.logger = logger;
        }
        getActions(root, text, lastMousePosition, index) {
          if (index !== void 0 && index % 2 === 0)
            return Promise.resolve(this.createSelectActions(root));
          else
            return Promise.resolve([new action_1.LabeledAction("Select all", [actions_1.SelectAllAction.create()])]);
        }
        createSelectActions(modelRoot) {
          const nameables = (0, iterable_1.toArray)(modelRoot.index.all().filter((element) => (0, model_1.isNameable)(element)));
          return nameables.map((nameable) => new action_1.LabeledAction(`Reveal ${(0, model_1.name)(nameable)}`, [actions_1.SelectAction.create({ selectedElementsIDs: [nameable.id] }), actions_1.CenterAction.create([nameable.id])], "eye"));
        }
      };
      exports.RevealNamedElementActionProvider = RevealNamedElementActionProvider;
      exports.RevealNamedElementActionProvider = RevealNamedElementActionProvider = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ILogger)),
        __metadata("design:paramtypes", [Object])
      ], RevealNamedElementActionProvider);
    }
  });

  // node_modules/sprotty/lib/utils/codicon.js
  var require_codicon = __commonJS({
    "node_modules/sprotty/lib/utils/codicon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.codiconCSSClasses = exports.codiconCSSString = exports.ANIMATION_SPIN = exports.ACTION_ITEM = void 0;
      exports.ACTION_ITEM = "action-item";
      exports.ANIMATION_SPIN = "animation-spin";
      function codiconCSSString(codiconId, actionItem = false, animationSpin = false, additionalCSS = []) {
        return codiconCSSClasses(codiconId, actionItem, animationSpin, additionalCSS).join(" ");
      }
      exports.codiconCSSString = codiconCSSString;
      function codiconCSSClasses(codiconId, actionItem = false, animationSpin = false, additionalCSS = []) {
        const cssClassArray = ["codicon", `codicon-${codiconId}`];
        if (actionItem) {
          cssClassArray.push(exports.ACTION_ITEM);
        }
        if (animationSpin) {
          cssClassArray.push(exports.ANIMATION_SPIN);
        }
        if (additionalCSS.length > 0) {
          cssClassArray.push(...additionalCSS);
        }
        return cssClassArray;
      }
      exports.codiconCSSClasses = codiconCSSClasses;
    }
  });

  // node_modules/sprotty/lib/utils/keyboard.js
  var require_keyboard = __commonJS({
    "node_modules/sprotty/lib/utils/keyboard.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getActualCode = exports.matchesKeystroke = void 0;
      var browser_1 = require_browser();
      function matchesKeystroke(event, code, ...modifiers) {
        if (getActualCode(event) !== code)
          return false;
        if ((0, browser_1.isMac)()) {
          if (event.ctrlKey !== modifiers.findIndex((m3) => m3 === "ctrl") >= 0)
            return false;
          if (event.metaKey !== modifiers.findIndex((m3) => m3 === "meta" || m3 === "ctrlCmd") >= 0)
            return false;
        } else {
          if (event.ctrlKey !== modifiers.findIndex((m3) => m3 === "ctrl" || m3 === "ctrlCmd") >= 0)
            return false;
          if (event.metaKey !== modifiers.findIndex((m3) => m3 === "meta") >= 0)
            return false;
        }
        if (event.altKey !== modifiers.findIndex((m3) => m3 === "alt") >= 0)
          return false;
        if (event.shiftKey !== modifiers.findIndex((m3) => m3 === "shift") >= 0)
          return false;
        return true;
      }
      exports.matchesKeystroke = matchesKeystroke;
      function getActualCode(event) {
        if (event.keyCode) {
          const result = STRING_CODE[event.keyCode];
          if (result !== void 0)
            return result;
        }
        return event.code;
      }
      exports.getActualCode = getActualCode;
      var STRING_CODE = new Array(256);
      (() => {
        function addKeyCode(stringCode, numericCode) {
          if (STRING_CODE[numericCode] === void 0)
            STRING_CODE[numericCode] = stringCode;
        }
        addKeyCode("Pause", 3);
        addKeyCode("Backspace", 8);
        addKeyCode("Tab", 9);
        addKeyCode("Enter", 13);
        addKeyCode("ShiftLeft", 16);
        addKeyCode("ShiftRight", 16);
        addKeyCode("ControlLeft", 17);
        addKeyCode("ControlRight", 17);
        addKeyCode("AltLeft", 18);
        addKeyCode("AltRight", 18);
        addKeyCode("CapsLock", 20);
        addKeyCode("Escape", 27);
        addKeyCode("Space", 32);
        addKeyCode("PageUp", 33);
        addKeyCode("PageDown", 34);
        addKeyCode("End", 35);
        addKeyCode("Home", 36);
        addKeyCode("ArrowLeft", 37);
        addKeyCode("ArrowUp", 38);
        addKeyCode("ArrowRight", 39);
        addKeyCode("ArrowDown", 40);
        addKeyCode("Insert", 45);
        addKeyCode("Delete", 46);
        addKeyCode("Digit1", 49);
        addKeyCode("Digit2", 50);
        addKeyCode("Digit3", 51);
        addKeyCode("Digit4", 52);
        addKeyCode("Digit5", 53);
        addKeyCode("Digit6", 54);
        addKeyCode("Digit7", 55);
        addKeyCode("Digit8", 56);
        addKeyCode("Digit9", 57);
        addKeyCode("Digit0", 48);
        addKeyCode("KeyA", 65);
        addKeyCode("KeyB", 66);
        addKeyCode("KeyC", 67);
        addKeyCode("KeyD", 68);
        addKeyCode("KeyE", 69);
        addKeyCode("KeyF", 70);
        addKeyCode("KeyG", 71);
        addKeyCode("KeyH", 72);
        addKeyCode("KeyI", 73);
        addKeyCode("KeyJ", 74);
        addKeyCode("KeyK", 75);
        addKeyCode("KeyL", 76);
        addKeyCode("KeyM", 77);
        addKeyCode("KeyN", 78);
        addKeyCode("KeyO", 79);
        addKeyCode("KeyP", 80);
        addKeyCode("KeyQ", 81);
        addKeyCode("KeyR", 82);
        addKeyCode("KeyS", 83);
        addKeyCode("KeyT", 84);
        addKeyCode("KeyU", 85);
        addKeyCode("KeyV", 86);
        addKeyCode("KeyW", 87);
        addKeyCode("KeyX", 88);
        addKeyCode("KeyY", 89);
        addKeyCode("KeyZ", 90);
        addKeyCode("OSLeft", 91);
        addKeyCode("MetaLeft", 91);
        addKeyCode("OSRight", 92);
        addKeyCode("MetaRight", 92);
        addKeyCode("ContextMenu", 93);
        addKeyCode("Numpad0", 96);
        addKeyCode("Numpad1", 97);
        addKeyCode("Numpad2", 98);
        addKeyCode("Numpad3", 99);
        addKeyCode("Numpad4", 100);
        addKeyCode("Numpad5", 101);
        addKeyCode("Numpad6", 102);
        addKeyCode("Numpad7", 103);
        addKeyCode("Numpad8", 104);
        addKeyCode("Numpad9", 105);
        addKeyCode("NumpadMultiply", 106);
        addKeyCode("NumpadAdd", 107);
        addKeyCode("NumpadSeparator", 108);
        addKeyCode("NumpadSubtract", 109);
        addKeyCode("NumpadDecimal", 110);
        addKeyCode("NumpadDivide", 111);
        addKeyCode("F1", 112);
        addKeyCode("F2", 113);
        addKeyCode("F3", 114);
        addKeyCode("F4", 115);
        addKeyCode("F5", 116);
        addKeyCode("F6", 117);
        addKeyCode("F7", 118);
        addKeyCode("F8", 119);
        addKeyCode("F9", 120);
        addKeyCode("F10", 121);
        addKeyCode("F11", 122);
        addKeyCode("F12", 123);
        addKeyCode("F13", 124);
        addKeyCode("F14", 125);
        addKeyCode("F15", 126);
        addKeyCode("F16", 127);
        addKeyCode("F17", 128);
        addKeyCode("F18", 129);
        addKeyCode("F19", 130);
        addKeyCode("F20", 131);
        addKeyCode("F21", 132);
        addKeyCode("F22", 133);
        addKeyCode("F23", 134);
        addKeyCode("F24", 135);
        addKeyCode("NumLock", 144);
        addKeyCode("ScrollLock", 145);
        addKeyCode("Semicolon", 186);
        addKeyCode("Equal", 187);
        addKeyCode("Comma", 188);
        addKeyCode("Minus", 189);
        addKeyCode("Period", 190);
        addKeyCode("Slash", 191);
        addKeyCode("Backquote", 192);
        addKeyCode("IntlRo", 193);
        addKeyCode("BracketLeft", 219);
        addKeyCode("Backslash", 220);
        addKeyCode("BracketRight", 221);
        addKeyCode("Quote", 222);
        addKeyCode("IntlYen", 255);
      })();
    }
  });

  // node_modules/sprotty/lib/features/select/model.js
  var require_model6 = __commonJS({
    "node_modules/sprotty/lib/features/select/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSelected = exports.isSelectable = exports.selectFeature = void 0;
      exports.selectFeature = Symbol("selectFeature");
      function isSelectable(element) {
        return element.hasFeature(exports.selectFeature);
      }
      exports.isSelectable = isSelectable;
      function isSelected(element) {
        return element !== void 0 && isSelectable(element) && element.selected;
      }
      exports.isSelected = isSelected;
    }
  });

  // node_modules/autocompleter/autocomplete.js
  var require_autocomplete = __commonJS({
    "node_modules/autocompleter/autocomplete.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.autocomplete = factory());
      })(exports, function() {
        "use strict";
        function autocomplete(settings) {
          var doc = document;
          var container = settings.container || doc.createElement("div");
          var preventSubmit = settings.preventSubmit || 0;
          container.id = container.id || "autocomplete-" + uid();
          var containerStyle = container.style;
          var debounceWaitMs = settings.debounceWaitMs || 0;
          var disableAutoSelect = settings.disableAutoSelect || false;
          var customContainerParent = container.parentElement;
          var items = [];
          var inputValue = "";
          var minLen = 2;
          var showOnFocus = settings.showOnFocus;
          var selected;
          var fetchCounter = 0;
          var debounceTimer;
          var destroyed = false;
          var suppressAutocomplete = false;
          if (settings.minLength !== void 0) {
            minLen = settings.minLength;
          }
          if (!settings.input) {
            throw new Error("input undefined");
          }
          var input = settings.input;
          container.className = [container.className, "autocomplete", settings.className || ""].join(" ").trim();
          container.setAttribute("role", "listbox");
          input.setAttribute("role", "combobox");
          input.setAttribute("aria-expanded", "false");
          input.setAttribute("aria-autocomplete", "list");
          input.setAttribute("aria-controls", container.id);
          input.setAttribute("aria-owns", container.id);
          input.setAttribute("aria-activedescendant", "");
          input.setAttribute("aria-haspopup", "listbox");
          containerStyle.position = "absolute";
          function uid() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
          }
          function detach() {
            var parent = container.parentNode;
            if (parent) {
              parent.removeChild(container);
            }
          }
          function clearDebounceTimer() {
            if (debounceTimer) {
              window.clearTimeout(debounceTimer);
            }
          }
          function attach() {
            if (!container.parentNode) {
              (customContainerParent || doc.body).appendChild(container);
            }
          }
          function containerDisplayed() {
            return !!container.parentNode;
          }
          function clear() {
            fetchCounter++;
            items = [];
            inputValue = "";
            selected = void 0;
            input.setAttribute("aria-activedescendant", "");
            input.setAttribute("aria-expanded", "false");
            detach();
          }
          function updatePosition() {
            if (!containerDisplayed()) {
              return;
            }
            input.setAttribute("aria-expanded", "true");
            containerStyle.height = "auto";
            containerStyle.width = input.offsetWidth + "px";
            var maxHeight = 0;
            var inputRect;
            function calc() {
              var docEl = doc.documentElement;
              var clientTop = docEl.clientTop || doc.body.clientTop || 0;
              var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
              var scrollTop = window.pageYOffset || docEl.scrollTop;
              var scrollLeft = window.pageXOffset || docEl.scrollLeft;
              inputRect = input.getBoundingClientRect();
              var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
              var left = inputRect.left + scrollLeft - clientLeft;
              containerStyle.top = top + "px";
              containerStyle.left = left + "px";
              maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);
              if (maxHeight < 0) {
                maxHeight = 0;
              }
              containerStyle.top = top + "px";
              containerStyle.bottom = "";
              containerStyle.left = left + "px";
              containerStyle.maxHeight = maxHeight + "px";
            }
            calc();
            calc();
            if (settings.customize && inputRect) {
              settings.customize(input, inputRect, container, maxHeight);
            }
          }
          function update() {
            container.textContent = "";
            input.setAttribute("aria-activedescendant", "");
            var render = function(item, _3, __) {
              var itemElement = doc.createElement("div");
              itemElement.textContent = item.label || "";
              return itemElement;
            };
            if (settings.render) {
              render = settings.render;
            }
            var renderGroup = function(groupName, _3) {
              var groupDiv = doc.createElement("div");
              groupDiv.textContent = groupName;
              return groupDiv;
            };
            if (settings.renderGroup) {
              renderGroup = settings.renderGroup;
            }
            var fragment = doc.createDocumentFragment();
            var prevGroup = uid();
            items.forEach(function(item, index) {
              if (item.group && item.group !== prevGroup) {
                prevGroup = item.group;
                var groupDiv = renderGroup(item.group, inputValue);
                if (groupDiv) {
                  groupDiv.className += " group";
                  fragment.appendChild(groupDiv);
                }
              }
              var div = render(item, inputValue, index);
              if (div) {
                div.id = container.id + "_" + index;
                div.setAttribute("role", "option");
                div.addEventListener("click", function(ev) {
                  suppressAutocomplete = true;
                  try {
                    settings.onSelect(item, input);
                  } finally {
                    suppressAutocomplete = false;
                  }
                  clear();
                  ev.preventDefault();
                  ev.stopPropagation();
                });
                if (item === selected) {
                  div.className += " selected";
                  div.setAttribute("aria-selected", "true");
                  input.setAttribute("aria-activedescendant", div.id);
                }
                fragment.appendChild(div);
              }
            });
            container.appendChild(fragment);
            if (items.length < 1) {
              if (settings.emptyMsg) {
                var empty = doc.createElement("div");
                empty.id = container.id + "_" + uid();
                empty.className = "empty";
                empty.textContent = settings.emptyMsg;
                container.appendChild(empty);
                input.setAttribute("aria-activedescendant", empty.id);
              } else {
                clear();
                return;
              }
            }
            attach();
            updatePosition();
            updateScroll();
          }
          function updateIfDisplayed() {
            if (containerDisplayed()) {
              update();
            }
          }
          function resizeEventHandler() {
            updateIfDisplayed();
          }
          function scrollEventHandler(e2) {
            if (e2.target !== container) {
              updateIfDisplayed();
            } else {
              e2.preventDefault();
            }
          }
          function inputEventHandler() {
            if (!suppressAutocomplete) {
              fetch(
                0
                /* Keyboard */
              );
            }
          }
          function updateScroll() {
            var elements = container.getElementsByClassName("selected");
            if (elements.length > 0) {
              var element = elements[0];
              var previous = element.previousElementSibling;
              if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
                element = previous;
              }
              if (element.offsetTop < container.scrollTop) {
                container.scrollTop = element.offsetTop;
              } else {
                var selectBottom = element.offsetTop + element.offsetHeight;
                var containerBottom = container.scrollTop + container.offsetHeight;
                if (selectBottom > containerBottom) {
                  container.scrollTop += selectBottom - containerBottom;
                }
              }
            }
          }
          function selectPreviousSuggestion() {
            var index = items.indexOf(selected);
            selected = index === -1 ? void 0 : items[(index + items.length - 1) % items.length];
            updateSelectedSuggestion(index);
          }
          function selectNextSuggestion() {
            var index = items.indexOf(selected);
            selected = items.length < 1 ? void 0 : index === -1 ? items[0] : items[(index + 1) % items.length];
            updateSelectedSuggestion(index);
          }
          function updateSelectedSuggestion(index) {
            if (items.length > 0) {
              unselectSuggestion(index);
              selectSuggestion(items.indexOf(selected));
              updateScroll();
            }
          }
          function selectSuggestion(index) {
            var element = doc.getElementById(container.id + "_" + index);
            if (element) {
              element.classList.add("selected");
              element.setAttribute("aria-selected", "true");
              input.setAttribute("aria-activedescendant", element.id);
            }
          }
          function unselectSuggestion(index) {
            var element = doc.getElementById(container.id + "_" + index);
            if (element) {
              element.classList.remove("selected");
              element.removeAttribute("aria-selected");
              input.removeAttribute("aria-activedescendant");
            }
          }
          function handleArrowAndEscapeKeys(ev, key) {
            var containerIsDisplayed = containerDisplayed();
            if (key === "Escape") {
              clear();
            } else {
              if (!containerIsDisplayed || items.length < 1) {
                return;
              }
              key === "ArrowUp" ? selectPreviousSuggestion() : selectNextSuggestion();
            }
            ev.preventDefault();
            if (containerIsDisplayed) {
              ev.stopPropagation();
            }
          }
          function handleEnterKey(ev) {
            if (selected) {
              if (preventSubmit === 2) {
                ev.preventDefault();
              }
              suppressAutocomplete = true;
              try {
                settings.onSelect(selected, input);
              } finally {
                suppressAutocomplete = false;
              }
              clear();
            }
            if (preventSubmit === 1) {
              ev.preventDefault();
            }
          }
          function keydownEventHandler(ev) {
            var key = ev.key;
            switch (key) {
              case "ArrowUp":
              case "ArrowDown":
              case "Escape":
                handleArrowAndEscapeKeys(ev, key);
                break;
              case "Enter":
                handleEnterKey(ev);
                break;
            }
          }
          function focusEventHandler() {
            if (showOnFocus) {
              fetch(
                1
                /* Focus */
              );
            }
          }
          function fetch(trigger) {
            if (input.value.length >= minLen || trigger === 1) {
              clearDebounceTimer();
              debounceTimer = window.setTimeout(function() {
                return startFetch(input.value, trigger, input.selectionStart || 0);
              }, trigger === 0 || trigger === 2 ? debounceWaitMs : 0);
            } else {
              clear();
            }
          }
          function startFetch(inputText, trigger, cursorPos) {
            if (destroyed)
              return;
            var savedFetchCounter = ++fetchCounter;
            settings.fetch(inputText, function(elements) {
              if (fetchCounter === savedFetchCounter && elements) {
                items = elements;
                inputValue = inputText;
                selected = items.length < 1 || disableAutoSelect ? void 0 : items[0];
                update();
              }
            }, trigger, cursorPos);
          }
          function keyupEventHandler(e2) {
            if (settings.keyup) {
              settings.keyup({
                event: e2,
                fetch: function() {
                  return fetch(
                    0
                    /* Keyboard */
                  );
                }
              });
              return;
            }
            if (!containerDisplayed() && e2.key === "ArrowDown") {
              fetch(
                0
                /* Keyboard */
              );
            }
          }
          function clickEventHandler(e2) {
            settings.click && settings.click({
              event: e2,
              fetch: function() {
                return fetch(
                  2
                  /* Mouse */
                );
              }
            });
          }
          function blurEventHandler() {
            setTimeout(function() {
              if (doc.activeElement !== input) {
                clear();
              }
            }, 200);
          }
          function manualFetch() {
            startFetch(input.value, 3, input.selectionStart || 0);
          }
          container.addEventListener("mousedown", function(evt) {
            evt.stopPropagation();
            evt.preventDefault();
          });
          container.addEventListener("focus", function() {
            return input.focus();
          });
          detach();
          function destroy() {
            input.removeEventListener("focus", focusEventHandler);
            input.removeEventListener("keyup", keyupEventHandler);
            input.removeEventListener("click", clickEventHandler);
            input.removeEventListener("keydown", keydownEventHandler);
            input.removeEventListener("input", inputEventHandler);
            input.removeEventListener("blur", blurEventHandler);
            window.removeEventListener("resize", resizeEventHandler);
            doc.removeEventListener("scroll", scrollEventHandler, true);
            input.removeAttribute("role");
            input.removeAttribute("aria-expanded");
            input.removeAttribute("aria-autocomplete");
            input.removeAttribute("aria-controls");
            input.removeAttribute("aria-activedescendant");
            input.removeAttribute("aria-owns");
            input.removeAttribute("aria-haspopup");
            clearDebounceTimer();
            clear();
            destroyed = true;
          }
          input.addEventListener("keyup", keyupEventHandler);
          input.addEventListener("click", clickEventHandler);
          input.addEventListener("keydown", keydownEventHandler);
          input.addEventListener("input", inputEventHandler);
          input.addEventListener("blur", blurEventHandler);
          input.addEventListener("focus", focusEventHandler);
          window.addEventListener("resize", resizeEventHandler);
          doc.addEventListener("scroll", scrollEventHandler, true);
          return {
            destroy,
            fetch: manualFetch
          };
        }
        return autocomplete;
      });
    }
  });

  // node_modules/sprotty/lib/features/command-palette/command-palette.js
  var require_command_palette = __commonJS({
    "node_modules/sprotty/lib/features/command-palette/command-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var CommandPalette_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommandPaletteKeyListener = exports.CommandPalette = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var action_1 = require_action();
      var types_1 = require_types();
      var ui_extension_1 = require_ui_extension();
      var ui_extension_registry_1 = require_ui_extension_registry();
      var dom_helper_1 = require_dom_helper();
      var key_tool_1 = require_key_tool();
      var codicon_1 = require_codicon();
      var iterable_1 = require_iterable();
      var keyboard_1 = require_keyboard();
      var model_1 = require_model2();
      var model_2 = require_model6();
      var action_providers_1 = require_action_providers();
      var mouse_tool_1 = require_mouse_tool();
      var autocompleter_1 = __importDefault(require_autocomplete());
      var CommandPalette = CommandPalette_1 = class CommandPalette extends ui_extension_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.loadingIndicatorClasses = (0, codicon_1.codiconCSSClasses)("loading", false, true, ["loading"]);
          this.xOffset = 20;
          this.yOffset = 20;
          this.defaultWidth = 400;
          this.debounceWaitMs = 100;
          this.noCommandsMsg = "No commands available";
          this.paletteIndex = 0;
        }
        id() {
          return CommandPalette_1.ID;
        }
        containerClass() {
          return "command-palette";
        }
        show(root, ...contextElementIds) {
          super.show(root, ...contextElementIds);
          this.paletteIndex = 0;
          this.contextActions = void 0;
          this.inputElement.value = "";
          this.autoCompleteResult = (0, autocompleter_1.default)(this.autocompleteSettings(root));
          this.inputElement.focus();
        }
        initializeContents(containerElement) {
          containerElement.style.position = "absolute";
          this.inputElement = document.createElement("input");
          this.inputElement.style.width = "100%";
          this.inputElement.addEventListener("keydown", (event) => this.hideIfEscapeEvent(event));
          this.inputElement.addEventListener("keydown", (event) => this.cylceIfInvokePaletteKey(event));
          this.inputElement.onblur = () => window.setTimeout(() => this.hide(), 200);
          containerElement.appendChild(this.inputElement);
        }
        hideIfEscapeEvent(event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            this.hide();
          }
        }
        cylceIfInvokePaletteKey(event) {
          if (CommandPalette_1.isInvokePaletteKey(event)) {
            this.cycle();
          }
        }
        cycle() {
          this.contextActions = void 0;
          this.paletteIndex++;
        }
        onBeforeShow(containerElement, root, ...selectedElementIds) {
          let x3 = this.xOffset;
          let y3 = this.yOffset;
          const selectedElements = (0, iterable_1.toArray)(root.index.all().filter((e2) => (0, model_2.isSelectable)(e2) && e2.selected));
          if (selectedElements.length === 1) {
            const bounds = (0, model_1.getAbsoluteClientBounds)(selectedElements[0], this.domHelper, this.viewerOptions);
            x3 += bounds.x + bounds.width;
            y3 += bounds.y;
          } else {
            const bounds = (0, model_1.getAbsoluteClientBounds)(root, this.domHelper, this.viewerOptions);
            x3 += bounds.x;
            y3 += bounds.y;
          }
          containerElement.style.left = `${x3}px`;
          containerElement.style.top = `${y3}px`;
          containerElement.style.width = `${this.defaultWidth}px`;
        }
        autocompleteSettings(root) {
          return {
            input: this.inputElement,
            emptyMsg: this.noCommandsMsg,
            className: "command-palette-suggestions",
            debounceWaitMs: this.debounceWaitMs,
            showOnFocus: true,
            minLength: -1,
            fetch: (text, update) => this.updateAutoCompleteActions(update, text, root),
            onSelect: (item) => this.onSelect(item),
            render: (item, currentValue) => this.renderLabeledActionSuggestion(item, currentValue),
            customize: (input, inputRect, container, maxHeight) => {
              this.customizeSuggestionContainer(container, inputRect, maxHeight);
            }
          };
        }
        onSelect(item) {
          this.executeAction(item);
          this.hide();
        }
        updateAutoCompleteActions(update, text, root) {
          this.onLoading();
          if (this.contextActions) {
            update(this.filterActions(text, this.contextActions));
            this.onLoaded("success");
          } else {
            this.actionProviderRegistry.getActions(root, text, this.mousePositionTracker.lastPositionOnDiagram, this.paletteIndex).then((actions) => {
              this.contextActions = actions;
              update(this.filterActions(text, actions));
              this.onLoaded("success");
            }).catch((reason) => {
              this.logger.error(this, "Failed to obtain actions from command palette action providers", reason);
              this.onLoaded("error");
            });
          }
        }
        onLoading() {
          if (this.loadingIndicator && this.containerElement.contains(this.loadingIndicator)) {
            return;
          }
          this.loadingIndicator = document.createElement("span");
          this.loadingIndicator.classList.add(...this.loadingIndicatorClasses);
          this.containerElement.appendChild(this.loadingIndicator);
        }
        onLoaded(success) {
          if (this.containerElement.contains(this.loadingIndicator)) {
            this.containerElement.removeChild(this.loadingIndicator);
          }
        }
        renderLabeledActionSuggestion(item, value) {
          const itemElement = document.createElement("div");
          const wordMatcher = espaceForRegExp(value).split(" ").join("|");
          const regex = new RegExp(wordMatcher, "gi");
          if (item.icon) {
            this.renderIcon(itemElement, item.icon);
          }
          if (value.length > 0) {
            itemElement.innerHTML += item.label.replace(regex, (match) => "<em>" + match + "</em>").replace(/ /g, "&nbsp;");
          } else {
            itemElement.innerHTML += item.label.replace(/ /g, "&nbsp;");
          }
          return itemElement;
        }
        renderIcon(itemElement, iconId) {
          itemElement.innerHTML += `<span class="icon ${this.getCodicon(iconId)}"></span>`;
        }
        getFontAwesomeIcon(iconId) {
          return `fa fa-${iconId}`;
        }
        getCodicon(iconId) {
          return (0, codicon_1.codiconCSSString)(iconId);
        }
        filterActions(filterText, actions) {
          return (0, iterable_1.toArray)(actions.filter((action) => {
            const label = action.label.toLowerCase();
            const searchWords = filterText.split(" ");
            return searchWords.every((word) => label.indexOf(word.toLowerCase()) !== -1);
          }));
        }
        customizeSuggestionContainer(container, inputRect, maxHeight) {
          container.style.position = "fixed";
          if (this.containerElement) {
            this.containerElement.appendChild(container);
          }
        }
        hide() {
          super.hide();
          if (this.autoCompleteResult) {
            this.autoCompleteResult.destroy();
          }
        }
        executeAction(input) {
          this.actionDispatcherProvider().then((actionDispatcher) => actionDispatcher.dispatchAll(toActionArray(input))).catch((reason) => this.logger.error(this, "No action dispatcher available to execute command palette action", reason));
        }
      };
      exports.CommandPalette = CommandPalette;
      CommandPalette.ID = "command-palette";
      CommandPalette.isInvokePaletteKey = (event) => (0, keyboard_1.matchesKeystroke)(event, "Space", "ctrl");
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcherProvider),
        __metadata("design:type", Function)
      ], CommandPalette.prototype, "actionDispatcherProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ICommandPaletteActionProviderRegistry),
        __metadata("design:type", action_providers_1.CommandPaletteActionProviderRegistry)
      ], CommandPalette.prototype, "actionProviderRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], CommandPalette.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], CommandPalette.prototype, "domHelper", void 0);
      __decorate([
        (0, inversify_1.inject)(mouse_tool_1.MousePositionTracker),
        __metadata("design:type", mouse_tool_1.MousePositionTracker)
      ], CommandPalette.prototype, "mousePositionTracker", void 0);
      exports.CommandPalette = CommandPalette = CommandPalette_1 = __decorate([
        (0, inversify_1.injectable)()
      ], CommandPalette);
      function toActionArray(input) {
        if ((0, action_1.isLabeledAction)(input)) {
          return input.actions;
        } else if ((0, actions_1.isAction)(input)) {
          return [input];
        }
        return [];
      }
      function espaceForRegExp(value) {
        return value.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      }
      var CommandPaletteKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            return [ui_extension_registry_1.SetUIExtensionVisibilityAction.create({ extensionId: CommandPalette.ID, visible: false, contextElementsId: [] })];
          } else if (CommandPalette.isInvokePaletteKey(event)) {
            const selectedElements = (0, iterable_1.toArray)(element.index.all().filter((e2) => (0, model_2.isSelectable)(e2) && e2.selected).map((e2) => e2.id));
            return [ui_extension_registry_1.SetUIExtensionVisibilityAction.create({ extensionId: CommandPalette.ID, visible: true, contextElementsId: selectedElements })];
          }
          return [];
        }
      };
      exports.CommandPaletteKeyListener = CommandPaletteKeyListener;
    }
  });

  // node_modules/sprotty/lib/features/context-menu/context-menu-service.js
  var require_context_menu_service = __commonJS({
    "node_modules/sprotty/lib/features/context-menu/context-menu-service.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toAnchor = void 0;
      function toAnchor(anchor) {
        return anchor instanceof HTMLElement ? { x: anchor.offsetLeft, y: anchor.offsetTop } : anchor;
      }
      exports.toAnchor = toAnchor;
    }
  });

  // node_modules/sprotty/lib/features/edit/delete.js
  var require_delete = __commonJS({
    "node_modules/sprotty/lib/features/edit/delete.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteElementCommand = exports.ResolvedDelete = exports.isDeletable = exports.deletableFeature = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      exports.deletableFeature = Symbol("deletableFeature");
      function isDeletable(element) {
        return element instanceof smodel_1.SChildElementImpl && element.hasFeature(exports.deletableFeature);
      }
      exports.isDeletable = isDeletable;
      var ResolvedDelete = class {
      };
      exports.ResolvedDelete = ResolvedDelete;
      var DeleteElementCommand = class DeleteElementCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.resolvedDeletes = [];
        }
        execute(context) {
          const index = context.root.index;
          for (const id of this.action.elementIds) {
            const element = index.getById(id);
            if (element && isDeletable(element)) {
              this.resolvedDeletes.push({ child: element, parent: element.parent });
              element.parent.remove(element);
            }
          }
          return context.root;
        }
        undo(context) {
          for (const resolvedDelete of this.resolvedDeletes)
            resolvedDelete.parent.add(resolvedDelete.child);
          return context.root;
        }
        redo(context) {
          for (const resolvedDelete of this.resolvedDeletes)
            resolvedDelete.parent.remove(resolvedDelete.child);
          return context.root;
        }
      };
      exports.DeleteElementCommand = DeleteElementCommand;
      DeleteElementCommand.KIND = actions_1.DeleteElementAction.KIND;
      exports.DeleteElementCommand = DeleteElementCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DeleteElementCommand);
    }
  });

  // node_modules/sprotty/lib/features/context-menu/menu-providers.js
  var require_menu_providers = __commonJS({
    "node_modules/sprotty/lib/features/context-menu/menu-providers.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteContextMenuItemProvider = exports.ContextMenuProviderRegistry = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var delete_1 = require_delete();
      var model_1 = require_model6();
      var sprotty_protocol_1 = require_lib();
      var ContextMenuProviderRegistry = class ContextMenuProviderRegistry {
        constructor(menuProviders = []) {
          this.menuProviders = menuProviders;
        }
        getItems(root, lastMousePosition) {
          const menues = this.menuProviders.map((provider) => provider.getItems(root, lastMousePosition));
          return Promise.all(menues).then(this.flattenAndRestructure);
        }
        flattenAndRestructure(p3) {
          let menuItems = p3.reduce((acc, promise) => promise !== void 0 ? acc.concat(promise) : acc, []);
          const menuItemsWithParentId = menuItems.filter((menuItem) => menuItem.parentId);
          for (const menuItem of menuItemsWithParentId) {
            if (menuItem.parentId) {
              const fragments = menuItem.parentId.split(".");
              let matchingParent = void 0;
              let nextParents = menuItems;
              for (const fragment of fragments) {
                matchingParent = nextParents.find((item) => fragment === item.id);
                if (matchingParent && matchingParent.children)
                  nextParents = matchingParent.children;
              }
              if (matchingParent) {
                if (matchingParent.children) {
                  matchingParent.children.push(menuItem);
                } else {
                  matchingParent.children = [menuItem];
                }
                menuItems = menuItems.filter((item) => item !== menuItem);
              }
            }
          }
          return menuItems;
        }
      };
      exports.ContextMenuProviderRegistry = ContextMenuProviderRegistry;
      exports.ContextMenuProviderRegistry = ContextMenuProviderRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IContextMenuItemProvider)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], ContextMenuProviderRegistry);
      var DeleteContextMenuItemProvider = class DeleteContextMenuItemProvider {
        getItems(root, lastMousePosition) {
          const selectedElements = Array.from(root.index.all().filter(model_1.isSelected).filter(delete_1.isDeletable));
          return Promise.resolve([
            {
              id: "delete",
              label: "Delete",
              sortString: "d",
              group: "edit",
              actions: [sprotty_protocol_1.DeleteElementAction.create(selectedElements.map((e2) => e2.id))],
              isEnabled: () => selectedElements.length > 0
            }
          ]);
        }
      };
      exports.DeleteContextMenuItemProvider = DeleteContextMenuItemProvider;
      exports.DeleteContextMenuItemProvider = DeleteContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], DeleteContextMenuItemProvider);
    }
  });

  // node_modules/sprotty/lib/features/context-menu/mouse-listener.js
  var require_mouse_listener = __commonJS({
    "node_modules/sprotty/lib/features/context-menu/mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContextMenuMouseListener = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var model_1 = require_model6();
      var menu_providers_1 = require_menu_providers();
      var ContextMenuMouseListener = class ContextMenuMouseListener extends mouse_tool_1.MouseListener {
        constructor(contextMenuService, menuProvider) {
          super();
          this.contextMenuService = contextMenuService;
          this.menuProvider = menuProvider;
        }
        contextMenu(target, event) {
          this.showContextMenu(target, event);
          return [];
        }
        async showContextMenu(target, event) {
          let menuService;
          try {
            menuService = await this.contextMenuService();
          } catch (rejected) {
            return;
          }
          let isTargetSelected = false;
          const selectableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_1.isSelectable);
          if (selectableTarget) {
            isTargetSelected = selectableTarget.selected;
            selectableTarget.selected = true;
          }
          const root = target.root;
          const mousePosition = { x: event.x, y: event.y };
          if (target.id === root.id || (0, model_1.isSelected)(selectableTarget)) {
            const menuItems = await this.menuProvider.getItems(root, mousePosition);
            const restoreSelection = () => {
              if (selectableTarget)
                selectableTarget.selected = isTargetSelected;
            };
            menuService.show(menuItems, mousePosition, restoreSelection);
          } else {
            if ((0, model_1.isSelectable)(target)) {
              const options = { selectedElementsIDs: [target.id], deselectedElementsIDs: Array.from(root.index.all().filter(model_1.isSelected), (val) => {
                return val.id;
              }) };
              await this.actionDispatcher.dispatch(actions_1.SelectAction.create(options));
            }
            const items = await this.menuProvider.getItems(root, mousePosition);
            menuService.show(items, mousePosition);
          }
        }
      };
      exports.ContextMenuMouseListener = ContextMenuMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ContextMenuMouseListener.prototype, "actionDispatcher", void 0);
      exports.ContextMenuMouseListener = ContextMenuMouseListener = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.IContextMenuServiceProvider)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.IContextMenuProviderRegistry)),
        __metadata("design:paramtypes", [Function, menu_providers_1.ContextMenuProviderRegistry])
      ], ContextMenuMouseListener);
    }
  });

  // node_modules/sprotty/lib/features/hover/model.js
  var require_model7 = __commonJS({
    "node_modules/sprotty/lib/features/hover/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hasPopupFeature = exports.popupFeature = exports.isHoverable = exports.hoverFeedbackFeature = void 0;
      exports.hoverFeedbackFeature = Symbol("hoverFeedbackFeature");
      function isHoverable(element) {
        return element.hasFeature(exports.hoverFeedbackFeature);
      }
      exports.isHoverable = isHoverable;
      exports.popupFeature = Symbol("popupFeature");
      function hasPopupFeature(element) {
        return element.hasFeature(exports.popupFeature);
      }
      exports.hasPopupFeature = hasPopupFeature;
    }
  });

  // node_modules/sprotty/lib/features/move/model.js
  var require_model8 = __commonJS({
    "node_modules/sprotty/lib/features/move/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isMoveable = exports.isLocateable = exports.moveFeature = void 0;
      var object_1 = require_object();
      exports.moveFeature = Symbol("moveFeature");
      function isLocateable(element) {
        return (0, object_1.hasOwnProperty)(element, "position");
      }
      exports.isLocateable = isLocateable;
      function isMoveable(element) {
        return element.hasFeature(exports.moveFeature) && isLocateable(element);
      }
      exports.isMoveable = isMoveable;
    }
  });

  // node_modules/sprotty/lib/features/routing/model.js
  var require_model9 = __commonJS({
    "node_modules/sprotty/lib/features/routing/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.edgeInProgressTargetHandleID = exports.edgeInProgressID = exports.SDanglingAnchorImpl = exports.SRoutingHandleImpl = exports.SConnectableElementImpl = exports.getRouteBounds = exports.getAbsoluteRouteBounds = exports.isConnectable = exports.connectableFeature = exports.SRoutableElementImpl = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var delete_1 = require_delete();
      var model_2 = require_model6();
      var model_3 = require_model7();
      var model_4 = require_model8();
      var SRoutableElementImpl = class extends smodel_1.SChildElementImpl {
        constructor() {
          super(...arguments);
          this.routingPoints = [];
        }
        get source() {
          return this.index.getById(this.sourceId);
        }
        get target() {
          return this.index.getById(this.targetId);
        }
        get bounds() {
          return this.routingPoints.reduce((bounds, routingPoint) => geometry_1.Bounds.combine(bounds, {
            x: routingPoint.x,
            y: routingPoint.y,
            width: 0,
            height: 0
          }), geometry_1.Bounds.EMPTY);
        }
      };
      exports.SRoutableElementImpl = SRoutableElementImpl;
      exports.connectableFeature = Symbol("connectableFeature");
      function isConnectable(element) {
        return element.hasFeature(exports.connectableFeature) && element.canConnect;
      }
      exports.isConnectable = isConnectable;
      function getAbsoluteRouteBounds(model, route = model.routingPoints) {
        let bounds = getRouteBounds(route);
        let current = model;
        while (current instanceof smodel_1.SChildElementImpl) {
          const parent = current.parent;
          bounds = parent.localToParent(bounds);
          current = parent;
        }
        return bounds;
      }
      exports.getAbsoluteRouteBounds = getAbsoluteRouteBounds;
      function getRouteBounds(route) {
        const bounds = { x: NaN, y: NaN, width: 0, height: 0 };
        for (const point of route) {
          if (isNaN(bounds.x)) {
            bounds.x = point.x;
            bounds.y = point.y;
          } else {
            if (point.x < bounds.x) {
              bounds.width += bounds.x - point.x;
              bounds.x = point.x;
            } else if (point.x > bounds.x + bounds.width) {
              bounds.width = point.x - bounds.x;
            }
            if (point.y < bounds.y) {
              bounds.height += bounds.y - point.y;
              bounds.y = point.y;
            } else if (point.y > bounds.y + bounds.height) {
              bounds.height = point.y - bounds.y;
            }
          }
        }
        return bounds;
      }
      exports.getRouteBounds = getRouteBounds;
      var SConnectableElementImpl = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.strokeWidth = 0;
        }
        get anchorKind() {
          return void 0;
        }
        /**
         * The incoming edges of this connectable element. They are resolved by the index, which must
         * be an `SGraphIndex` for efficient lookup.
         */
        get incomingEdges() {
          const allEdges = this.index.all().filter((e2) => e2 instanceof SRoutableElementImpl);
          return allEdges.filter((e2) => e2.targetId === this.id);
        }
        /**
         * The outgoing edges of this connectable element. They are resolved by the index, which must
         * be an `SGraphIndex` for efficient lookup.
         */
        get outgoingEdges() {
          const allEdges = this.index.all().filter((e2) => e2 instanceof SRoutableElementImpl);
          return allEdges.filter((e2) => e2.sourceId === this.id);
        }
        canConnect(routable, role) {
          return true;
        }
      };
      exports.SConnectableElementImpl = SConnectableElementImpl;
      var SRoutingHandleImpl = class _SRoutingHandleImpl extends smodel_1.SChildElementImpl {
        constructor() {
          super(...arguments);
          this.editMode = false;
          this.hoverFeedback = false;
          this.selected = false;
        }
        /**
         * SRoutingHandles are created using the constructor, so we hard-wire the
         * default features
         */
        hasFeature(feature) {
          return _SRoutingHandleImpl.DEFAULT_FEATURES.indexOf(feature) !== -1;
        }
      };
      exports.SRoutingHandleImpl = SRoutingHandleImpl;
      SRoutingHandleImpl.DEFAULT_FEATURES = [model_2.selectFeature, model_4.moveFeature, model_3.hoverFeedbackFeature];
      var SDanglingAnchorImpl = class extends SConnectableElementImpl {
        constructor() {
          super();
          this.type = "dangling-anchor";
          this.size = { width: 0, height: 0 };
        }
      };
      exports.SDanglingAnchorImpl = SDanglingAnchorImpl;
      SDanglingAnchorImpl.DEFAULT_FEATURES = [delete_1.deletableFeature];
      exports.edgeInProgressID = "edge-in-progress";
      exports.edgeInProgressTargetHandleID = exports.edgeInProgressID + "-target-anchor";
    }
  });

  // node_modules/sprotty/lib/features/edge-layout/model.js
  var require_model10 = __commonJS({
    "node_modules/sprotty/lib/features/edge-layout/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DEFAULT_EDGE_PLACEMENT = exports.EdgePlacement = exports.checkEdgePlacement = exports.isEdgeLayoutable = exports.edgeLayoutFeature = void 0;
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var model_2 = require_model9();
      exports.edgeLayoutFeature = Symbol("edgeLayout");
      function isEdgeLayoutable(element) {
        return element instanceof smodel_1.SChildElementImpl && element.parent instanceof model_2.SRoutableElementImpl && (0, model_1.isBoundsAware)(element) && element.hasFeature(exports.edgeLayoutFeature);
      }
      exports.isEdgeLayoutable = isEdgeLayoutable;
      function checkEdgePlacement(element) {
        return "edgePlacement" in element;
      }
      exports.checkEdgePlacement = checkEdgePlacement;
      var EdgePlacement = class extends Object {
      };
      exports.EdgePlacement = EdgePlacement;
      exports.DEFAULT_EDGE_PLACEMENT = {
        rotate: true,
        side: "top",
        position: 0.5,
        offset: 7
      };
    }
  });

  // node_modules/sprotty/lib/features/edit/model.js
  var require_model11 = __commonJS({
    "node_modules/sprotty/lib/features/edit/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isWithEditableLabel = exports.withEditLabelFeature = exports.isEditableLabel = exports.editLabelFeature = exports.canEditRouting = exports.editFeature = void 0;
      var model_1 = require_model9();
      exports.editFeature = Symbol("editFeature");
      function canEditRouting(element) {
        return element instanceof model_1.SRoutableElementImpl && element.hasFeature(exports.editFeature);
      }
      exports.canEditRouting = canEditRouting;
      exports.editLabelFeature = Symbol("editLabelFeature");
      function isEditableLabel(element) {
        return "text" in element && element.hasFeature(exports.editLabelFeature);
      }
      exports.isEditableLabel = isEditableLabel;
      exports.withEditLabelFeature = Symbol("withEditLabelFeature");
      function isWithEditableLabel(element) {
        return "editableLabel" in element && element.hasFeature(exports.withEditLabelFeature);
      }
      exports.isWithEditableLabel = isWithEditableLabel;
    }
  });

  // node_modules/sprotty/lib/utils/geometry.js
  var require_geometry2 = __commonJS({
    "node_modules/sprotty/lib/utils/geometry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.limit = exports.intersection = exports.PointToPointLine = exports.Diamond = void 0;
      var sprotty_protocol_1 = require_lib();
      var Diamond = class {
        constructor(bounds) {
          this.bounds = bounds;
        }
        get topPoint() {
          return {
            x: this.bounds.x + this.bounds.width / 2,
            y: this.bounds.y
          };
        }
        get rightPoint() {
          return {
            x: this.bounds.x + this.bounds.width,
            y: this.bounds.y + this.bounds.height / 2
          };
        }
        get bottomPoint() {
          return {
            x: this.bounds.x + this.bounds.width / 2,
            y: this.bounds.y + this.bounds.height
          };
        }
        get leftPoint() {
          return {
            x: this.bounds.x,
            y: this.bounds.y + this.bounds.height / 2
          };
        }
        get topRightSideLine() {
          return new PointToPointLine(this.topPoint, this.rightPoint);
        }
        get topLeftSideLine() {
          return new PointToPointLine(this.topPoint, this.leftPoint);
        }
        get bottomRightSideLine() {
          return new PointToPointLine(this.bottomPoint, this.rightPoint);
        }
        get bottomLeftSideLine() {
          return new PointToPointLine(this.bottomPoint, this.leftPoint);
        }
        /**
         * Return the closest side of this diamond to the specified `refPoint`.
         * @param {Point} refPoint a reference point
         * @returns {Line} a line representing the closest side
         */
        closestSideLine(refPoint) {
          const c3 = sprotty_protocol_1.Bounds.center(this.bounds);
          if (refPoint.x > c3.x) {
            if (refPoint.y > c3.y) {
              return this.bottomRightSideLine;
            } else {
              return this.topRightSideLine;
            }
          } else {
            if (refPoint.y > c3.y) {
              return this.bottomLeftSideLine;
            } else {
              return this.topLeftSideLine;
            }
          }
        }
      };
      exports.Diamond = Diamond;
      var PointToPointLine = class {
        constructor(p1, p22) {
          this.p1 = p1;
          this.p2 = p22;
        }
        get a() {
          return this.p1.y - this.p2.y;
        }
        get b() {
          return this.p2.x - this.p1.x;
        }
        get c() {
          return this.p2.x * this.p1.y - this.p1.x * this.p2.y;
        }
        /**
         * The counter-clockwise angle of this line relative to the x-axis.
         */
        get angle() {
          return Math.atan2(-this.a, this.b);
        }
        /**
         * The slope of the line.
         * A vertical line returns `undefined`.
         */
        get slope() {
          if (this.b === 0)
            return void 0;
          return this.a / this.b;
        }
        /**
         * The slope of the line or `Number.MAX_SAFE_INTEGER` if vertical.
         */
        get slopeOrMax() {
          if (this.slope === void 0) {
            return Number.MAX_SAFE_INTEGER;
          }
          return this.slope;
        }
        /**
         * The direction of this line, such as 'north', 'south', or 'south-west'.
         */
        get direction() {
          const hDegrees = (0, sprotty_protocol_1.toDegrees)(this.angle);
          const degrees = hDegrees < 0 ? 360 + hDegrees : hDegrees;
          if (degrees === 90) {
            return "south";
          } else if (degrees === 0 || degrees === 360) {
            return "east";
          } else if (degrees === 270) {
            return "north";
          } else if (degrees === 180) {
            return "west";
          } else if (degrees > 0 && degrees < 90) {
            return "south-east";
          } else if (degrees > 90 && degrees < 180) {
            return "south-west";
          } else if (degrees > 180 && degrees < 270) {
            return "north-west";
          } else if (degrees > 270 && degrees < 360) {
            return "north-east";
          }
          throw new Error(`Cannot determine direction of line (${this.p1.x},${this.p1.y}) to (${this.p2.x},${this.p2.y})`);
        }
        /**
         * @param otherLine the other line
         * @returns the intersection point between `this` line and the `otherLine` if exists, or `undefined`.
         */
        intersection(otherLine) {
          if (this.hasIndistinctPoints(otherLine)) {
            return void 0;
          }
          const x1 = this.p1.x;
          const y1 = this.p1.y;
          const x22 = this.p2.x;
          const y22 = this.p2.y;
          const x3 = otherLine.p1.x;
          const y3 = otherLine.p1.y;
          const x4 = otherLine.p2.x;
          const y4 = otherLine.p2.y;
          const denominator = (y4 - y3) * (x22 - x1) - (x4 - x3) * (y22 - y1);
          if (denominator === 0) {
            return void 0;
          }
          const numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
          const numeratorB = (x22 - x1) * (y1 - y3) - (y22 - y1) * (x1 - x3);
          if (numeratorA === 0 && numeratorB === 0) {
            return void 0;
          }
          const determinantA = numeratorA / denominator;
          const determinantB = numeratorB / denominator;
          if (determinantA < 0 || determinantA > 1 || determinantB < 0 || determinantB > 1) {
            return void 0;
          }
          const x5 = x1 + determinantA * (x22 - x1);
          const y5 = y1 + determinantA * (y22 - y1);
          return { x: x5, y: y5 };
        }
        /**
         * @param otherLine the other line
         * @returns whether the start and end point of this line is does not have distinct start
         * or end points with the `otherLine`
         */
        hasIndistinctPoints(otherLine) {
          return sprotty_protocol_1.Point.equals(this.p1, otherLine.p1) || sprotty_protocol_1.Point.equals(this.p1, otherLine.p2) || sprotty_protocol_1.Point.equals(this.p2, otherLine.p1) || sprotty_protocol_1.Point.equals(this.p2, otherLine.p2);
        }
      };
      exports.PointToPointLine = PointToPointLine;
      function intersection(l1, l22) {
        return {
          x: (l1.c * l22.b - l22.c * l1.b) / (l1.a * l22.b - l22.a * l1.b),
          y: (l1.a * l22.c - l22.a * l1.c) / (l1.a * l22.b - l22.a * l1.b)
        };
      }
      exports.intersection = intersection;
      function limit(value, limits) {
        if (value < limits.min) {
          return limits.min;
        }
        if (value > limits.max) {
          return limits.max;
        }
        return value;
      }
      exports.limit = limit;
    }
  });

  // node_modules/sprotty/lib/features/viewport/model.js
  var require_model12 = __commonJS({
    "node_modules/sprotty/lib/features/viewport/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.limitViewport = exports.isViewport = exports.viewportFeature = void 0;
      var sprotty_protocol_1 = require_lib();
      var smodel_1 = require_smodel();
      var geometry_1 = require_geometry2();
      exports.viewportFeature = Symbol("viewportFeature");
      function isViewport2(element) {
        return element instanceof smodel_1.SModelRootImpl && element.hasFeature(exports.viewportFeature) && "zoom" in element && "scroll" in element;
      }
      exports.isViewport = isViewport2;
      function limitViewport(viewport, canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits) {
        if (canvasBounds && !sprotty_protocol_1.Dimension.isValid(canvasBounds)) {
          canvasBounds = void 0;
        }
        let zoom = zoomLimits ? (0, geometry_1.limit)(viewport.zoom, zoomLimits) : viewport.zoom;
        if (canvasBounds && horizontalScrollLimits) {
          const minZoom = canvasBounds.width / (horizontalScrollLimits.max - horizontalScrollLimits.min);
          if (zoom < minZoom) {
            zoom = minZoom;
          }
        }
        if (canvasBounds && verticalScrollLimits) {
          const minZoom = canvasBounds.height / (verticalScrollLimits.max - verticalScrollLimits.min);
          if (zoom < minZoom) {
            zoom = minZoom;
          }
        }
        let scrollX;
        if (horizontalScrollLimits) {
          const min = horizontalScrollLimits.min;
          const max = canvasBounds ? horizontalScrollLimits.max - canvasBounds.width / zoom : horizontalScrollLimits.max;
          scrollX = (0, geometry_1.limit)(viewport.scroll.x, { min, max });
        } else {
          scrollX = viewport.scroll.x;
        }
        let scrollY;
        if (verticalScrollLimits) {
          const min = verticalScrollLimits.min;
          const max = canvasBounds ? verticalScrollLimits.max - canvasBounds.height / zoom : verticalScrollLimits.max;
          scrollY = (0, geometry_1.limit)(viewport.scroll.y, { min, max });
        } else {
          scrollY = viewport.scroll.y;
        }
        return { scroll: { x: scrollX, y: scrollY }, zoom };
      }
      exports.limitViewport = limitViewport;
    }
  });

  // node_modules/sprotty/lib/features/export/model.js
  var require_model13 = __commonJS({
    "node_modules/sprotty/lib/features/export/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isExportable = exports.exportFeature = void 0;
      exports.exportFeature = Symbol("exportFeature");
      function isExportable(element) {
        return element.hasFeature(exports.exportFeature);
      }
      exports.isExportable = isExportable;
    }
  });

  // node_modules/sprotty/lib/features/viewport/viewport-root.js
  var require_viewport_root = __commonJS({
    "node_modules/sprotty/lib/features/viewport/viewport-root.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewportRootElementImpl = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model12();
      var model_2 = require_model13();
      var ViewportRootElementImpl = class extends smodel_1.SModelRootImpl {
        constructor(index) {
          super(index);
          this.scroll = { x: 0, y: 0 };
          this.zoom = 1;
          this.position = geometry_1.Point.ORIGIN;
          this.size = geometry_1.Dimension.EMPTY;
        }
        get bounds() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
          };
        }
        set bounds(newBounds) {
          this.position = {
            x: newBounds.x,
            y: newBounds.y
          };
          this.size = {
            width: newBounds.width,
            height: newBounds.height
          };
        }
        localToParent(point) {
          const result = {
            x: (point.x - this.scroll.x) * this.zoom,
            y: (point.y - this.scroll.y) * this.zoom,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point)) {
            result.width = point.width * this.zoom;
            result.height = point.height * this.zoom;
          }
          return result;
        }
        parentToLocal(point) {
          const result = {
            x: point.x / this.zoom + this.scroll.x,
            y: point.y / this.zoom + this.scroll.y,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point) && geometry_1.Dimension.isValid(point)) {
            result.width = point.width / this.zoom;
            result.height = point.height / this.zoom;
          }
          return result;
        }
      };
      exports.ViewportRootElementImpl = ViewportRootElementImpl;
      ViewportRootElementImpl.DEFAULT_FEATURES = [model_1.viewportFeature, model_2.exportFeature];
    }
  });

  // node_modules/sprotty/lib/graph/sgraph.js
  var require_sgraph = __commonJS({
    "node_modules/sprotty/lib/graph/sgraph.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SGraphIndex = exports.SCompartmentImpl = exports.SLabelImpl = exports.SEdgeImpl = exports.SPortImpl = exports.SNodeImpl = exports.SGraphImpl = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var model_2 = require_model10();
      var delete_1 = require_delete();
      var model_3 = require_model11();
      var model_4 = require_model3();
      var model_5 = require_model7();
      var model_6 = require_model8();
      var model_7 = require_model9();
      var model_8 = require_model6();
      var viewport_root_1 = require_viewport_root();
      var iterable_1 = require_iterable();
      var SGraphImpl = class extends viewport_root_1.ViewportRootElementImpl {
        constructor(index = new SGraphIndex()) {
          super(index);
        }
      };
      exports.SGraphImpl = SGraphImpl;
      var SNodeImpl = class extends model_7.SConnectableElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.hoverFeedback = false;
          this.opacity = 1;
        }
        canConnect(routable, role) {
          return this.children.find((c3) => c3 instanceof SPortImpl) === void 0;
        }
        get incomingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getIncomingEdges(this);
          }
          const allEdges = this.index.all().filter((e2) => e2 instanceof SEdgeImpl);
          return allEdges.filter((e2) => e2.targetId === this.id);
        }
        get outgoingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getOutgoingEdges(this);
          }
          const allEdges = this.index.all().filter((e2) => e2 instanceof SEdgeImpl);
          return allEdges.filter((e2) => e2.sourceId === this.id);
        }
      };
      exports.SNodeImpl = SNodeImpl;
      SNodeImpl.DEFAULT_FEATURES = [
        model_7.connectableFeature,
        delete_1.deletableFeature,
        model_8.selectFeature,
        model_1.boundsFeature,
        model_6.moveFeature,
        model_1.layoutContainerFeature,
        model_4.fadeFeature,
        model_5.hoverFeedbackFeature,
        model_5.popupFeature
      ];
      var SPortImpl = class extends model_7.SConnectableElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.hoverFeedback = false;
          this.opacity = 1;
        }
        get incomingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getIncomingEdges(this);
          }
          return super.incomingEdges.filter((e2) => e2 instanceof SEdgeImpl);
        }
        get outgoingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getOutgoingEdges(this);
          }
          return super.outgoingEdges.filter((e2) => e2 instanceof SEdgeImpl);
        }
      };
      exports.SPortImpl = SPortImpl;
      SPortImpl.DEFAULT_FEATURES = [
        model_7.connectableFeature,
        model_8.selectFeature,
        model_1.boundsFeature,
        model_4.fadeFeature,
        model_5.hoverFeedbackFeature
      ];
      var SEdgeImpl = class extends model_7.SRoutableElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.hoverFeedback = false;
          this.opacity = 1;
        }
      };
      exports.SEdgeImpl = SEdgeImpl;
      SEdgeImpl.DEFAULT_FEATURES = [
        model_3.editFeature,
        delete_1.deletableFeature,
        model_8.selectFeature,
        model_4.fadeFeature,
        model_5.hoverFeedbackFeature
      ];
      var SLabelImpl = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.alignment = geometry_1.Point.ORIGIN;
          this.opacity = 1;
        }
      };
      exports.SLabelImpl = SLabelImpl;
      SLabelImpl.DEFAULT_FEATURES = [
        model_1.boundsFeature,
        model_1.alignFeature,
        model_1.layoutableChildFeature,
        model_2.edgeLayoutFeature,
        model_4.fadeFeature
      ];
      var SCompartmentImpl = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.opacity = 1;
        }
      };
      exports.SCompartmentImpl = SCompartmentImpl;
      SCompartmentImpl.DEFAULT_FEATURES = [
        model_1.boundsFeature,
        model_1.layoutContainerFeature,
        model_1.layoutableChildFeature,
        model_4.fadeFeature
      ];
      var SGraphIndex = class extends smodel_1.ModelIndexImpl {
        constructor() {
          super(...arguments);
          this.outgoing = /* @__PURE__ */ new Map();
          this.incoming = /* @__PURE__ */ new Map();
        }
        add(element) {
          super.add(element);
          if (element instanceof SEdgeImpl) {
            if (element.sourceId) {
              const sourceArr = this.outgoing.get(element.sourceId);
              if (sourceArr === void 0)
                this.outgoing.set(element.sourceId, [element]);
              else
                sourceArr.push(element);
            }
            if (element.targetId) {
              const targetArr = this.incoming.get(element.targetId);
              if (targetArr === void 0)
                this.incoming.set(element.targetId, [element]);
              else
                targetArr.push(element);
            }
          }
        }
        remove(element) {
          super.remove(element);
          if (element instanceof SEdgeImpl) {
            const sourceArr = this.outgoing.get(element.sourceId);
            if (sourceArr !== void 0) {
              const index = sourceArr.indexOf(element);
              if (index >= 0) {
                if (sourceArr.length === 1)
                  this.outgoing.delete(element.sourceId);
                else
                  sourceArr.splice(index, 1);
              }
            }
            const targetArr = this.incoming.get(element.targetId);
            if (targetArr !== void 0) {
              const index = targetArr.indexOf(element);
              if (index >= 0) {
                if (targetArr.length === 1)
                  this.incoming.delete(element.targetId);
                else
                  targetArr.splice(index, 1);
              }
            }
          }
        }
        getAttachedElements(element) {
          return new iterable_1.FluentIterableImpl(() => ({
            outgoing: this.outgoing.get(element.id),
            incoming: this.incoming.get(element.id),
            nextOutgoingIndex: 0,
            nextIncomingIndex: 0
          }), (state) => {
            let index = state.nextOutgoingIndex;
            if (state.outgoing !== void 0 && index < state.outgoing.length) {
              state.nextOutgoingIndex = index + 1;
              return { done: false, value: state.outgoing[index] };
            }
            index = state.nextIncomingIndex;
            if (state.incoming !== void 0) {
              while (index < state.incoming.length) {
                const edge = state.incoming[index];
                if (edge.sourceId !== edge.targetId) {
                  state.nextIncomingIndex = index + 1;
                  return { done: false, value: edge };
                }
                index++;
              }
            }
            return { done: true, value: void 0 };
          });
        }
        getIncomingEdges(element) {
          return this.incoming.get(element.id) || [];
        }
        getOutgoingEdges(element) {
          return this.outgoing.get(element.id) || [];
        }
      };
      exports.SGraphIndex = SGraphIndex;
    }
  });

  // node_modules/sprotty/lib/features/routing/anchor.js
  var require_anchor = __commonJS({
    "node_modules/sprotty/lib/features/routing/anchor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnchorComputerRegistry = exports.RECTANGULAR_ANCHOR_KIND = exports.ELLIPTIC_ANCHOR_KIND = exports.DIAMOND_ANCHOR_KIND = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var registry_1 = require_registry();
      exports.DIAMOND_ANCHOR_KIND = "diamond";
      exports.ELLIPTIC_ANCHOR_KIND = "elliptic";
      exports.RECTANGULAR_ANCHOR_KIND = "rectangular";
      var AnchorComputerRegistry = class AnchorComputerRegistry extends registry_1.InstanceRegistry {
        constructor(anchors) {
          super();
          anchors.forEach((anchor) => this.register(anchor.kind, anchor));
        }
        get defaultAnchorKind() {
          return exports.RECTANGULAR_ANCHOR_KIND;
        }
        get(routerKind, anchorKind) {
          return super.get(`${routerKind}:${anchorKind || this.defaultAnchorKind}`);
        }
      };
      exports.AnchorComputerRegistry = AnchorComputerRegistry;
      exports.AnchorComputerRegistry = AnchorComputerRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IAnchorComputer)),
        __metadata("design:paramtypes", [Array])
      ], AnchorComputerRegistry);
    }
  });

  // node_modules/sprotty/lib/features/routing/abstract-edge-router.js
  var require_abstract_edge_router = __commonJS({
    "node_modules/sprotty/lib/features/routing/abstract-edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractEdgeRouter = exports.DefaultAnchors = exports.Side = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model9();
      var anchor_1 = require_anchor();
      var model_2 = require_model9();
      var Side;
      (function(Side2) {
        Side2[Side2["RIGHT"] = 0] = "RIGHT";
        Side2[Side2["LEFT"] = 1] = "LEFT";
        Side2[Side2["TOP"] = 2] = "TOP";
        Side2[Side2["BOTTOM"] = 3] = "BOTTOM";
      })(Side || (exports.Side = Side = {}));
      var DefaultAnchors = class {
        constructor(element, edgeParent, kind) {
          this.element = element;
          this.kind = kind;
          const bounds = element.bounds;
          this.bounds = (0, smodel_utils_1.translateBounds)(bounds, element.parent, edgeParent);
          this.left = { x: this.bounds.x, y: this.bounds.y + 0.5 * this.bounds.height, kind };
          this.right = { x: this.bounds.x + this.bounds.width, y: this.bounds.y + 0.5 * this.bounds.height, kind };
          this.top = { x: this.bounds.x + 0.5 * this.bounds.width, y: this.bounds.y, kind };
          this.bottom = { x: this.bounds.x + 0.5 * this.bounds.width, y: this.bounds.y + this.bounds.height, kind };
        }
        get(side) {
          return this[Side[side].toLowerCase()];
        }
        getNearestSide(point) {
          const leftDistance = geometry_1.Point.euclideanDistance(point, this.left);
          const rightDistance = geometry_1.Point.euclideanDistance(point, this.right);
          const topDistance = geometry_1.Point.euclideanDistance(point, this.top);
          const bottomDistance = geometry_1.Point.euclideanDistance(point, this.bottom);
          let currentNearestSide = Side.LEFT;
          let currentMinDist = leftDistance;
          if (rightDistance < currentMinDist) {
            currentMinDist = rightDistance;
            currentNearestSide = Side.RIGHT;
          }
          if (topDistance < currentMinDist) {
            currentMinDist = topDistance;
            currentNearestSide = Side.TOP;
          }
          if (bottomDistance < currentMinDist) {
            currentMinDist = bottomDistance;
            currentNearestSide = Side.BOTTOM;
          }
          return currentNearestSide;
        }
      };
      exports.DefaultAnchors = DefaultAnchors;
      var AbstractEdgeRouter = class AbstractEdgeRouter {
        findOrthogonalIntersection(edge, point) {
          const calcOrthogonalIntersectionForSegment = (p1, p22) => {
            const d3 = geometry_1.Point.subtract(p22, p1);
            const pq = geometry_1.Point.subtract(point, p1);
            const t3 = geometry_1.Point.dotProduct(pq, d3) / geometry_1.Point.dotProduct(d3, d3);
            if (t3 >= 0 && t3 <= 1) {
              return geometry_1.Point.linear(p1, p22, t3);
            } else if (t3 < 0) {
              return p1;
            } else {
              return p22;
            }
          };
          const routedPoints = this.route(edge);
          let intersectionPoint = routedPoints[0];
          let index = 0;
          for (let i2 = 0; i2 < routedPoints.length - 1; ++i2) {
            const intersection = calcOrthogonalIntersectionForSegment(routedPoints[i2], routedPoints[i2 + 1]);
            if (geometry_1.Point.euclideanDistance(point, intersection) < geometry_1.Point.euclideanDistance(point, intersectionPoint)) {
              intersectionPoint = intersection;
              index = i2;
            }
          }
          const derivative = geometry_1.Point.subtract(routedPoints[index + 1], routedPoints[index]);
          return { point: intersectionPoint, derivative };
        }
        pointAt(edge, t3) {
          const segments = this.calculateSegment(edge, t3);
          if (!segments)
            return void 0;
          const { segmentStart, segmentEnd, lambda } = segments;
          return geometry_1.Point.linear(segmentStart, segmentEnd, lambda);
        }
        derivativeAt(edge, t3) {
          const segments = this.calculateSegment(edge, t3);
          if (!segments)
            return void 0;
          const { segmentStart, segmentEnd } = segments;
          return {
            x: segmentEnd.x - segmentStart.x,
            y: segmentEnd.y - segmentStart.y
          };
        }
        calculateSegment(edge, t3) {
          if (t3 < 0 || t3 > 1)
            return void 0;
          const routedPoints = this.route(edge);
          if (routedPoints.length < 2)
            return void 0;
          const segmentLengths = [];
          let totalLength = 0;
          for (let i2 = 0; i2 < routedPoints.length - 1; ++i2) {
            segmentLengths[i2] = geometry_1.Point.euclideanDistance(routedPoints[i2], routedPoints[i2 + 1]);
            totalLength += segmentLengths[i2];
          }
          let currentLenght = 0;
          const tAsLenght = t3 * totalLength;
          for (let i2 = 0; i2 < routedPoints.length - 1; ++i2) {
            const newLength = currentLenght + segmentLengths[i2];
            if (segmentLengths[i2] > 1e-8) {
              if (newLength >= tAsLenght) {
                const lambda = Math.max(0, tAsLenght - currentLenght) / segmentLengths[i2];
                return {
                  segmentStart: routedPoints[i2],
                  segmentEnd: routedPoints[i2 + 1],
                  lambda
                };
              }
            }
            currentLenght = newLength;
          }
          return {
            segmentEnd: routedPoints.pop(),
            segmentStart: routedPoints.pop(),
            lambda: 1
          };
        }
        addHandle(edge, kind, type, routingPointIndex) {
          const handle = new model_1.SRoutingHandleImpl();
          handle.kind = kind;
          handle.pointIndex = routingPointIndex;
          handle.type = type;
          if (kind === "target" && edge.id === model_1.edgeInProgressID)
            handle.id = model_1.edgeInProgressTargetHandleID;
          edge.add(handle);
          return handle;
        }
        getHandlePosition(edge, route, handle) {
          switch (handle.kind) {
            case "source":
              if (edge.source instanceof model_1.SDanglingAnchorImpl)
                return edge.source.position;
              else
                return route[0];
            case "target":
              if (edge.target instanceof model_1.SDanglingAnchorImpl)
                return edge.target.position;
              else {
                return route[route.length - 1];
              }
            default:
              const position = this.getInnerHandlePosition(edge, route, handle);
              if (position !== void 0)
                return position;
              if (handle.pointIndex >= 0 && handle.pointIndex < edge.routingPoints.length)
                return edge.routingPoints[handle.pointIndex];
          }
          return void 0;
        }
        findRouteSegment(edge, route, handleIndex) {
          const getIndex = (rp) => {
            if (rp.pointIndex !== void 0)
              return rp.pointIndex;
            else if (rp.kind === "target")
              return edge.routingPoints.length;
            else
              return -2;
          };
          let start, end;
          for (const rp of route) {
            const i2 = getIndex(rp);
            if (i2 <= handleIndex && (start === void 0 || i2 > getIndex(start)))
              start = rp;
            if (i2 > handleIndex && (end === void 0 || i2 < getIndex(end)))
              end = rp;
          }
          return { start, end };
        }
        getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection = 0) {
          const translatedRefPoint = (0, smodel_utils_1.translatePoint)(refPoint, refContainer, connectable.parent);
          const anchorComputer = this.getAnchorComputer(connectable);
          const strokeCorrection = 0.5 * connectable.strokeWidth;
          const anchor = anchorComputer.getAnchor(connectable, translatedRefPoint, anchorCorrection + strokeCorrection);
          return (0, smodel_utils_1.translatePoint)(anchor, connectable.parent, edge.parent);
        }
        getAnchorComputer(connectable) {
          return this.anchorRegistry.get(this.kind, connectable.anchorKind);
        }
        applyHandleMoves(edge, moves) {
          const remainingMoves = moves.slice();
          moves.forEach((move) => {
            const handle = move.handle;
            if (handle.kind === "source" && !(edge.source instanceof model_1.SDanglingAnchorImpl)) {
              const anchor = new model_1.SDanglingAnchorImpl();
              anchor.id = edge.id + "_dangling-source";
              anchor.original = edge.source;
              anchor.position = move.toPosition;
              handle.root.add(anchor);
              handle.danglingAnchor = anchor;
              edge.sourceId = anchor.id;
            } else if (handle.kind === "target" && !(edge.target instanceof model_1.SDanglingAnchorImpl)) {
              const anchor = new model_1.SDanglingAnchorImpl();
              anchor.id = edge.id + "_dangling-target";
              anchor.original = edge.target;
              anchor.position = move.toPosition;
              handle.root.add(anchor);
              handle.danglingAnchor = anchor;
              edge.targetId = anchor.id;
            }
            if (handle.danglingAnchor) {
              handle.danglingAnchor.position = move.toPosition;
              remainingMoves.splice(remainingMoves.indexOf(move), 1);
            }
          });
          if (remainingMoves.length > 0)
            this.applyInnerHandleMoves(edge, remainingMoves);
          this.cleanupRoutingPoints(edge, edge.routingPoints, true, true);
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          const sourceAnchors = new DefaultAnchors(edge.source, edge.parent, "source");
          const targetAnchors = new DefaultAnchors(edge.target, edge.parent, "target");
          this.resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors);
        }
        resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors) {
          if (routingPoints.length === 0 || edge.source instanceof model_1.SDanglingAnchorImpl || edge.target instanceof model_1.SDanglingAnchorImpl) {
            const options = this.getOptions(edge);
            const corners = this.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
            routingPoints.splice(0, routingPoints.length, ...corners);
            if (updateHandles) {
              let maxPointIndex = -2;
              edge.children.forEach((child) => {
                if (child instanceof model_1.SRoutingHandleImpl) {
                  if (child.kind === "target")
                    child.pointIndex = routingPoints.length;
                  else if (child.kind === "line" && child.pointIndex >= routingPoints.length)
                    edge.remove(child);
                  else
                    maxPointIndex = Math.max(child.pointIndex, maxPointIndex);
                }
              });
              for (let i2 = maxPointIndex; i2 < routingPoints.length - 1; ++i2)
                this.addHandle(edge, "manhattan-50%", "volatile-routing-point", i2);
            }
            return true;
          }
          return false;
        }
        applyReconnect(edge, newSourceId, newTargetId) {
          let hasChanged = false;
          if (newSourceId) {
            const newSource = edge.root.index.getById(newSourceId);
            if (newSource instanceof model_2.SConnectableElementImpl) {
              edge.sourceId = newSource.id;
              hasChanged = true;
            }
          }
          if (newTargetId) {
            const newTarget = edge.root.index.getById(newTargetId);
            if (newTarget instanceof model_2.SConnectableElementImpl) {
              edge.targetId = newTarget.id;
              hasChanged = true;
            }
          }
          if (hasChanged) {
            edge.index.remove(edge);
            if (edge.id === model_1.edgeInProgressID) {
              const idGen = (counter) => `${edge.sourceId}_to_${edge.targetId}_${counter}`;
              let idx = 0;
              let newId = idGen(idx);
              while (edge.index.getById(newId) !== void 0) {
                newId = idGen(++idx);
              }
              edge.id = newId;
              const progressTargetHandle = edge.children.find((child) => child.id === model_1.edgeInProgressTargetHandleID);
              if (progressTargetHandle instanceof model_1.SRoutingHandleImpl) {
                edge.remove(progressTargetHandle);
                if (progressTargetHandle.danglingAnchor) {
                  progressTargetHandle.danglingAnchor.parent.remove(progressTargetHandle.danglingAnchor);
                }
              }
            }
            edge.index.add(edge);
            if (this.getSelfEdgeIndex(edge) > -1) {
              edge.routingPoints = [];
              this.cleanupRoutingPoints(edge, edge.routingPoints, true, true);
            }
          }
        }
        takeSnapshot(edge) {
          return {
            routingPoints: edge.routingPoints.slice(),
            routingHandles: edge.children.filter((child) => child instanceof model_1.SRoutingHandleImpl).map((child) => child),
            routedPoints: this.route(edge),
            router: this,
            source: edge.source,
            target: edge.target
          };
        }
        applySnapshot(edge, snapshot) {
          edge.routingPoints = snapshot.routingPoints;
          edge.removeAll((child) => child instanceof model_1.SRoutingHandleImpl);
          edge.routerKind = snapshot.router.kind;
          snapshot.routingHandles.forEach((handle) => edge.add(handle));
          if (snapshot.source)
            edge.sourceId = snapshot.source.id;
          if (snapshot.target)
            edge.targetId = snapshot.target.id;
          edge.root.index.remove(edge);
          edge.root.index.add(edge);
        }
        calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options) {
          const selfEdgeIndex = this.getSelfEdgeIndex(edge);
          if (selfEdgeIndex >= 0) {
            const standardDist = options.standardDistance;
            const delta = options.selfEdgeOffset * Math.min(sourceAnchors.bounds.width, sourceAnchors.bounds.height);
            switch (selfEdgeIndex % 4) {
              case 0:
                return [
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.RIGHT).y + delta },
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.BOTTOM).y + standardDist },
                  { x: sourceAnchors.get(Side.BOTTOM).x + delta, y: sourceAnchors.get(Side.BOTTOM).y + standardDist }
                ];
              case 1:
                return [
                  { x: sourceAnchors.get(Side.BOTTOM).x - delta, y: sourceAnchors.get(Side.BOTTOM).y + standardDist },
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.BOTTOM).y + standardDist },
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.LEFT).y + delta }
                ];
              case 2:
                return [
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.LEFT).y - delta },
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.TOP).y - standardDist },
                  { x: sourceAnchors.get(Side.TOP).x - delta, y: sourceAnchors.get(Side.TOP).y - standardDist }
                ];
              case 3:
                return [
                  { x: sourceAnchors.get(Side.TOP).x + delta, y: sourceAnchors.get(Side.TOP).y - standardDist },
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.TOP).y - standardDist },
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.RIGHT).y - delta }
                ];
            }
          }
          return [];
        }
        getSelfEdgeIndex(edge) {
          if (!edge.source || edge.source !== edge.target)
            return -1;
          return edge.source.outgoingEdges.filter((otherEdge) => otherEdge.target === edge.source).indexOf(edge);
        }
        commitRoute(edge, routedPoints) {
          const newRoutingPoints = [];
          for (let i2 = 1; i2 < routedPoints.length - 1; ++i2)
            newRoutingPoints.push({ x: routedPoints[i2].x, y: routedPoints[i2].y });
          edge.routingPoints = newRoutingPoints;
        }
      };
      exports.AbstractEdgeRouter = AbstractEdgeRouter;
      __decorate([
        (0, inversify_1.inject)(anchor_1.AnchorComputerRegistry),
        __metadata("design:type", anchor_1.AnchorComputerRegistry)
      ], AbstractEdgeRouter.prototype, "anchorRegistry", void 0);
      exports.AbstractEdgeRouter = AbstractEdgeRouter = __decorate([
        (0, inversify_1.injectable)()
      ], AbstractEdgeRouter);
    }
  });

  // node_modules/sprotty/lib/features/routing/polyline-edge-router.js
  var require_polyline_edge_router = __commonJS({
    "node_modules/sprotty/lib/features/routing/polyline-edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var PolylineEdgeRouter_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PolylineEdgeRouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var model_1 = require_model9();
      var anchor_1 = require_anchor();
      var abstract_edge_router_1 = require_abstract_edge_router();
      var PolylineEdgeRouter = PolylineEdgeRouter_1 = class PolylineEdgeRouter extends abstract_edge_router_1.AbstractEdgeRouter {
        get kind() {
          return PolylineEdgeRouter_1.KIND;
        }
        getOptions(edge) {
          return {
            minimalPointDistance: 2,
            removeAngleThreshold: 0.1,
            standardDistance: 20,
            selfEdgeOffset: 0.25
          };
        }
        route(edge) {
          const source = edge.source;
          const target = edge.target;
          if (source === void 0 || target === void 0) {
            return [];
          }
          let sourceAnchor;
          let targetAnchor;
          const options = this.getOptions(edge);
          const routingPoints = edge.routingPoints.length > 0 ? edge.routingPoints : [];
          this.cleanupRoutingPoints(edge, routingPoints, false, false);
          const rpCount = routingPoints !== void 0 ? routingPoints.length : 0;
          if (rpCount === 0) {
            const startRef = geometry_1.Bounds.center(target.bounds);
            sourceAnchor = this.getTranslatedAnchor(source, startRef, target.parent, edge, edge.sourceAnchorCorrection);
            const endRef = geometry_1.Bounds.center(source.bounds);
            targetAnchor = this.getTranslatedAnchor(target, endRef, source.parent, edge, edge.targetAnchorCorrection);
          } else {
            const p0 = routingPoints[0];
            sourceAnchor = this.getTranslatedAnchor(source, p0, edge.parent, edge, edge.sourceAnchorCorrection);
            const pn = routingPoints[rpCount - 1];
            targetAnchor = this.getTranslatedAnchor(target, pn, edge.parent, edge, edge.targetAnchorCorrection);
          }
          const result = [];
          result.push({ kind: "source", x: sourceAnchor.x, y: sourceAnchor.y });
          for (let i2 = 0; i2 < rpCount; i2++) {
            const p3 = routingPoints[i2];
            if (i2 > 0 && i2 < rpCount - 1 || i2 === 0 && geometry_1.Point.maxDistance(sourceAnchor, p3) >= options.minimalPointDistance + (edge.sourceAnchorCorrection || 0) || i2 === rpCount - 1 && geometry_1.Point.maxDistance(p3, targetAnchor) >= options.minimalPointDistance + (edge.targetAnchorCorrection || 0)) {
              result.push({ kind: "linear", x: p3.x, y: p3.y, pointIndex: i2 });
            }
          }
          result.push({ kind: "target", x: targetAnchor.x, y: targetAnchor.y });
          return this.filterEditModeHandles(result, edge, options);
        }
        /**
         * Remove routed points that are in edit mode and for which the angle between the preceding and
         * following points falls below a threshold.
         */
        filterEditModeHandles(route, edge, options) {
          if (edge.children.length === 0)
            return route;
          let i2 = 0;
          while (i2 < route.length) {
            const curr = route[i2];
            if (curr.pointIndex !== void 0) {
              const handle = edge.children.find((child) => child instanceof model_1.SRoutingHandleImpl && child.kind === "junction" && child.pointIndex === curr.pointIndex);
              if (handle !== void 0 && handle.editMode && i2 > 0 && i2 < route.length - 1) {
                const prev = route[i2 - 1], next = route[i2 + 1];
                const prevDiff = { x: prev.x - curr.x, y: prev.y - curr.y };
                const nextDiff = { x: next.x - curr.x, y: next.y - curr.y };
                const angle = (0, geometry_1.angleBetweenPoints)(prevDiff, nextDiff);
                if (Math.abs(Math.PI - angle) < options.removeAngleThreshold) {
                  route.splice(i2, 1);
                  continue;
                }
              }
            }
            i2++;
          }
          return route;
        }
        createRoutingHandles(edge) {
          const rpCount = edge.routingPoints.length;
          this.addHandle(edge, "source", "routing-point", -2);
          this.addHandle(edge, "line", "volatile-routing-point", -1);
          for (let i2 = 0; i2 < rpCount; i2++) {
            this.addHandle(edge, "junction", "routing-point", i2);
            this.addHandle(edge, "line", "volatile-routing-point", i2);
          }
          this.addHandle(edge, "target", "routing-point", rpCount);
        }
        getInnerHandlePosition(edge, route, handle) {
          if (handle.kind === "line") {
            const { start, end } = this.findRouteSegment(edge, route, handle.pointIndex);
            if (start !== void 0 && end !== void 0)
              return (0, geometry_1.centerOfLine)(start, end);
          }
          return void 0;
        }
        applyInnerHandleMoves(edge, moves) {
          moves.forEach((move) => {
            const handle = move.handle;
            const points = edge.routingPoints;
            let index = handle.pointIndex;
            if (handle.kind === "line") {
              handle.kind = "junction";
              handle.type = "routing-point";
              points.splice(index + 1, 0, move.fromPosition || points[Math.max(index, 0)]);
              edge.children.forEach((child) => {
                if (child instanceof model_1.SRoutingHandleImpl && (child === handle || child.pointIndex > index))
                  child.pointIndex++;
              });
              this.addHandle(edge, "line", "volatile-routing-point", index);
              index++;
              this.addHandle(edge, "line", "volatile-routing-point", index);
            }
            if (index >= 0 && index < points.length) {
              points[index] = move.toPosition;
            }
          });
        }
      };
      exports.PolylineEdgeRouter = PolylineEdgeRouter;
      PolylineEdgeRouter.KIND = "polyline";
      __decorate([
        (0, inversify_1.inject)(anchor_1.AnchorComputerRegistry),
        __metadata("design:type", anchor_1.AnchorComputerRegistry)
      ], PolylineEdgeRouter.prototype, "anchorRegistry", void 0);
      exports.PolylineEdgeRouter = PolylineEdgeRouter = PolylineEdgeRouter_1 = __decorate([
        (0, inversify_1.injectable)()
      ], PolylineEdgeRouter);
    }
  });

  // node_modules/sprotty/lib/features/routing/routing.js
  var require_routing = __commonJS({
    "node_modules/sprotty/lib/features/routing/routing.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeRouting = exports.EdgeRouterRegistry = void 0;
      var inversify_1 = require_cjs4();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var view_1 = require_view();
      var registry_1 = require_registry();
      var model_1 = require_model9();
      var polyline_edge_router_1 = require_polyline_edge_router();
      function isMultipleEdgesRouter(router) {
        return router.routeAll !== void 0;
      }
      var EdgeRouterRegistry = class EdgeRouterRegistry extends registry_1.InstanceRegistry {
        constructor(edgeRouters) {
          super();
          edgeRouters.forEach((router) => this.register(router.kind, router));
        }
        get defaultKind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND;
        }
        get(kind) {
          return super.get(kind || this.defaultKind);
        }
        /**
         * Computes the routes of all edges contained by the specified `parent`.
         * After all routes are available, it'll apply the registered `EdgeRoutePostProcessors`.
         * @param parent the parent to traverse for edges
         * @returns the routes of all edges that are children of `parent`
         */
        routeAllChildren(parent) {
          const routing = this.doRouteAllChildren(parent);
          for (const postProcessor of this.postProcessors) {
            postProcessor.apply(routing, parent);
          }
          return routing;
        }
        /**
         * Recursively traverses the children of `parent`, collects children grouped by router kind,
         * and then routes them either.
         * @param parent the parent to traverse for edges
         * @returns the routes of all edges that are children of `parent`
         */
        doRouteAllChildren(parent) {
          const routing = new EdgeRouting();
          const routersEdges = /* @__PURE__ */ new Map();
          const elementsToProcess = [parent];
          while (elementsToProcess.length > 0) {
            const element = elementsToProcess.shift();
            for (const child of element.children) {
              if (child instanceof model_1.SRoutableElementImpl) {
                const routerKind = child.routerKind || this.defaultKind;
                if (routersEdges.has(routerKind)) {
                  routersEdges.get(routerKind).push(child);
                } else {
                  routersEdges.set(routerKind, [child]);
                }
              }
              if (child instanceof smodel_1.SParentElementImpl) {
                elementsToProcess.push(child);
              }
            }
          }
          routersEdges.forEach((edges, routerKind) => {
            const childRouter = this.get(routerKind);
            if (isMultipleEdgesRouter(childRouter)) {
              routing.setAll(childRouter.routeAll(edges, parent));
            } else {
              for (const edge of edges) {
                routing.set(edge.id, this.route(edge));
              }
            }
          });
          return routing;
        }
        /**
         * Computes or obtains the route of a single edge.
         * @param edge the edge to be routed
         * @param args arguments that may contain an `EdgeRouting` already
         * @returns the route of the specified `edge`
         */
        route(edge, args) {
          const edgeRouting = (0, view_1.findArgValue)(args, "edgeRouting");
          if (edgeRouting) {
            const route = edgeRouting.get(edge.id);
            if (route) {
              return route;
            }
          }
          const router = this.get(edge.routerKind);
          return router.route(edge);
        }
      };
      exports.EdgeRouterRegistry = EdgeRouterRegistry;
      __decorate([
        (0, inversify_1.multiInject)(types_1.TYPES.IEdgeRoutePostprocessor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], EdgeRouterRegistry.prototype, "postProcessors", void 0);
      exports.EdgeRouterRegistry = EdgeRouterRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IEdgeRouter)),
        __metadata("design:paramtypes", [Array])
      ], EdgeRouterRegistry);
      var EdgeRouting = class {
        constructor() {
          this.routesMap = /* @__PURE__ */ new Map();
        }
        set(routableId, route) {
          this.routesMap.set(routableId, route);
        }
        setAll(otherRoutes) {
          otherRoutes.routes.forEach((route, routableId) => this.set(routableId, route));
        }
        get(routableId) {
          return this.routesMap.get(routableId);
        }
        get routes() {
          return this.routesMap;
        }
      };
      exports.EdgeRouting = EdgeRouting;
    }
  });

  // node_modules/sprotty/lib/features/edge-layout/edge-layout.js
  var require_edge_layout = __commonJS({
    "node_modules/sprotty/lib/features/edge-layout/edge-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeLayoutPostprocessor = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var vnode_utils_1 = require_vnode_utils();
      var sgraph_1 = require_sgraph();
      var model_1 = require_model2();
      var model_2 = require_model10();
      var routing_1 = require_routing();
      var types_1 = require_types();
      var model_3 = require_model8();
      var EdgeLayoutPostprocessor = class EdgeLayoutPostprocessor {
        /**
         * Decorates the vnode with the appropriate transformation based on the element's placement and bounds.
         * @param vnode - The vnode to decorate.
         * @param element - The SModelElementImpl to decorate.
         * @returns The decorated vnode.
         */
        decorate(vnode, element) {
          var _a4, _b2, _c, _d;
          if ((0, model_2.isEdgeLayoutable)(element) && element.parent instanceof sgraph_1.SEdgeImpl) {
            if (element.bounds !== geometry_1.Bounds.EMPTY) {
              const actualBounds = element.bounds;
              const hasOwnPlacement = (0, model_2.checkEdgePlacement)(element);
              const placement = this.getEdgePlacement(element);
              const edge = element.parent;
              const position = Math.min(1, Math.max(0, placement.position));
              const router = this.edgeRouterRegistry.get(edge.routerKind);
              const pointOnEdge = router.pointAt(edge, position);
              let transform = "";
              let derivativeOnEdge = router.derivativeAt(edge, position);
              ;
              if (pointOnEdge) {
                if (hasOwnPlacement) {
                  switch (placement.moveMode) {
                    case "edge":
                      const orthogonalPoint = router.findOrthogonalIntersection(edge, geometry_1.Point.add(pointOnEdge, actualBounds));
                      if (orthogonalPoint) {
                        derivativeOnEdge = orthogonalPoint.derivative;
                        transform += `translate(${orthogonalPoint.point.x}, ${orthogonalPoint.point.y})`;
                      }
                      break;
                    case "free":
                      transform += `translate(${((_a4 = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.x) !== null && _a4 !== void 0 ? _a4 : 0) + actualBounds.x}, ${((_b2 = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.y) !== null && _b2 !== void 0 ? _b2 : 0) + actualBounds.y})`;
                      ;
                      break;
                    case "none":
                      transform += `translate(${pointOnEdge.x}, ${pointOnEdge.y})`;
                      break;
                    default:
                      this.logger.error({}, "No moveMode set for edge label. Skipping edge placement.");
                      break;
                  }
                  if (derivativeOnEdge) {
                    const angle = (0, geometry_1.toDegrees)(Math.atan2(derivativeOnEdge.y, derivativeOnEdge.x));
                    if (placement.rotate) {
                      let flippedAngle = angle;
                      if (Math.abs(angle) > 90) {
                        if (angle < 0)
                          flippedAngle += 180;
                        else if (angle > 0)
                          flippedAngle -= 180;
                      }
                      transform += ` rotate(${flippedAngle})`;
                      const alignment = this.getRotatedAlignment(element, placement, flippedAngle !== angle);
                      transform += ` translate(${alignment.x}, ${alignment.y})`;
                    } else {
                      const alignment = this.getAlignment(element, placement, angle);
                      transform += ` translate(${alignment.x}, ${alignment.y})`;
                    }
                  }
                } else {
                  if ((0, model_3.isMoveable)(element)) {
                    transform += `translate(${((_c = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.x) !== null && _c !== void 0 ? _c : 0) + actualBounds.x}, ${((_d = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.y) !== null && _d !== void 0 ? _d : 0) + actualBounds.y})`;
                    ;
                  } else {
                    transform += `translate(${pointOnEdge.x}, ${pointOnEdge.y})`;
                  }
                }
              }
              (0, vnode_utils_1.setAttr)(vnode, "transform", transform);
            }
          }
          return vnode;
        }
        getRotatedAlignment(element, placement, flip) {
          let x3 = (0, model_1.isAlignable)(element) ? element.alignment.x : 0;
          let y3 = (0, model_1.isAlignable)(element) ? element.alignment.y : 0;
          const bounds = element.bounds;
          if (placement.side === "on")
            return { x: x3 - 0.5 * bounds.height, y: y3 - 0.5 * bounds.height };
          if (flip) {
            if (placement.position < 0.3333333)
              x3 -= bounds.width + placement.offset;
            else if (placement.position < 0.6666666)
              x3 -= 0.5 * bounds.width;
            else
              x3 += placement.offset;
            switch (placement.side) {
              case "left":
              case "bottom":
                y3 -= placement.offset + bounds.height;
                break;
              case "right":
              case "top":
                y3 += placement.offset;
            }
          } else {
            if (placement.position < 0.3333333)
              x3 += placement.offset;
            else if (placement.position < 0.6666666)
              x3 -= 0.5 * bounds.width;
            else
              x3 -= bounds.width + placement.offset;
            switch (placement.side) {
              case "right":
              case "bottom":
                y3 += -placement.offset - bounds.height;
                break;
              case "left":
              case "top":
                y3 += placement.offset;
            }
          }
          return { x: x3, y: y3 };
        }
        getEdgePlacement(element) {
          let current = element;
          const allPlacements = [];
          while (current !== void 0) {
            const placement = current.edgePlacement;
            if (placement !== void 0)
              allPlacements.push(placement);
            if (current instanceof smodel_1.SChildElementImpl)
              current = current.parent;
            else
              break;
          }
          const edgePlacement = allPlacements.reverse().reduce((a3, b3) => {
            return Object.assign(Object.assign({}, a3), b3);
          }, model_2.DEFAULT_EDGE_PLACEMENT);
          if (!edgePlacement.moveMode) {
            edgePlacement.moveMode = (0, model_3.isMoveable)(element) ? "edge" : "none";
          }
          return edgePlacement;
        }
        getAlignment(label, placement, angle) {
          const bounds = label.bounds;
          const x3 = (0, model_1.isAlignable)(label) ? label.alignment.x - bounds.width : 0;
          const y3 = (0, model_1.isAlignable)(label) ? label.alignment.y - bounds.height : 0;
          if (placement.side === "on") {
            return { x: x3 + 0.5 * bounds.width, y: y3 + 0.5 * bounds.height };
          }
          const quadrant = this.getQuadrant(angle);
          const midLeft = { x: placement.offset, y: y3 + 0.5 * bounds.height };
          const topLeft = { x: placement.offset, y: y3 + bounds.height + placement.offset };
          const topRight = { x: -bounds.width - placement.offset, y: y3 + bounds.height + placement.offset };
          const midRight = { x: -bounds.width - placement.offset, y: y3 + 0.5 * bounds.height };
          const bottomRight = { x: -bounds.width - placement.offset, y: y3 - placement.offset };
          const bottomLeft = { x: placement.offset, y: y3 - placement.offset };
          switch (placement.side) {
            case "left":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "north":
                  return geometry_1.Point.linear(topRight, bottomRight, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "south":
                  return geometry_1.Point.linear(bottomLeft, topLeft, quadrant.position);
              }
              break;
            case "right":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "north":
                  return geometry_1.Point.linear(bottomLeft, topLeft, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "south":
                  return geometry_1.Point.linear(topRight, bottomRight, quadrant.position);
              }
              break;
            case "top":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "north":
                  return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "south":
                  return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
              }
              break;
            case "bottom":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "north":
                  return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "south":
                  return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
              }
              break;
          }
          return { x: 0, y: 0 };
        }
        getQuadrant(angle) {
          if (Math.abs(angle) > 135)
            return { orientation: "west", position: (angle > 0 ? angle - 135 : angle + 225) / 90 };
          else if (angle < -45)
            return { orientation: "north", position: (angle + 135) / 90 };
          else if (angle < 45)
            return { orientation: "east", position: (angle + 45) / 90 };
          else
            return { orientation: "south", position: (angle - 45) / 90 };
        }
        linearFlip(p0, p1, p22, p3, position) {
          return position < 0.5 ? geometry_1.Point.linear(p0, p1, 2 * position) : geometry_1.Point.linear(p22, p3, 2 * position - 1);
        }
        postUpdate() {
        }
      };
      exports.EdgeLayoutPostprocessor = EdgeLayoutPostprocessor;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], EdgeLayoutPostprocessor.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], EdgeLayoutPostprocessor.prototype, "logger", void 0);
      exports.EdgeLayoutPostprocessor = EdgeLayoutPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeLayoutPostprocessor);
    }
  });

  // node_modules/sprotty/lib/features/edge-layout/di.config.js
  var require_di_config2 = __commonJS({
    "node_modules/sprotty/lib/features/edge-layout/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var edge_layout_1 = require_edge_layout();
      var edgeLayoutModule = new inversify_1.ContainerModule((bind) => {
        bind(edge_layout_1.EdgeLayoutPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(edge_layout_1.EdgeLayoutPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(edge_layout_1.EdgeLayoutPostprocessor);
      });
      exports.default = edgeLayoutModule;
    }
  });

  // node_modules/sprotty/lib/features/edit/create.js
  var require_create = __commonJS({
    "node_modules/sprotty/lib/features/edit/create.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CreateElementCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var CreateElementCommand = class CreateElementCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const container = context.root.index.getById(this.action.containerId);
          if (container instanceof smodel_1.SParentElementImpl) {
            this.container = container;
            this.newElement = context.modelFactory.createElement(this.action.elementSchema);
            this.container.add(this.newElement);
          }
          return context.root;
        }
        undo(context) {
          this.container.remove(this.newElement);
          return context.root;
        }
        redo(context) {
          this.container.add(this.newElement);
          return context.root;
        }
      };
      exports.CreateElementCommand = CreateElementCommand;
      CreateElementCommand.KIND = actions_1.CreateElementAction.KIND;
      exports.CreateElementCommand = CreateElementCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], CreateElementCommand);
    }
  });

  // node_modules/sprotty/lib/features/edit/create-on-drag.js
  var require_create_on_drag = __commonJS({
    "node_modules/sprotty/lib/features/edit/create-on-drag.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isCreatingOnDrag = exports.creatingOnDragFeature = void 0;
      exports.creatingOnDragFeature = Symbol("creatingOnDragFeature");
      function isCreatingOnDrag(element) {
        return element.hasFeature(exports.creatingOnDragFeature) && element.createAction !== void 0;
      }
      exports.isCreatingOnDrag = isCreatingOnDrag;
    }
  });

  // node_modules/sprotty/lib/lib/svg-views.js
  var require_svg_views = __commonJS({
    "node_modules/sprotty/lib/lib/svg-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EmptyGroupView = exports.DiamondNodeView = exports.RectangularNodeView = exports.CircularNodeView = exports.SvgViewportView = void 0;
      var jsx_1 = require_jsx();
      var sgraph_1 = require_sgraph();
      var views_1 = require_views();
      var geometry_1 = require_geometry2();
      var inversify_1 = require_cjs4();
      var SvgViewportView = class SvgViewportView {
        render(model, context, args) {
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          return (0, jsx_1.svg)(
            "svg",
            null,
            (0, jsx_1.svg)("g", { transform }, context.renderChildren(model))
          );
        }
      };
      exports.SvgViewportView = SvgViewportView;
      exports.SvgViewportView = SvgViewportView = __decorate([
        (0, inversify_1.injectable)()
      ], SvgViewportView);
      var CircularNodeView2 = class CircularNodeView extends views_1.ShapeView {
        render(node, context, args) {
          if (!this.isVisible(node, context)) {
            return void 0;
          }
          const radius = this.getRadius(node);
          return (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("circle", { "class-sprotty-node": node instanceof sgraph_1.SNodeImpl, "class-sprotty-port": node instanceof sgraph_1.SPortImpl, "class-mouseover": node.hoverFeedback, "class-selected": node.selected, r: radius, cx: radius, cy: radius }),
            context.renderChildren(node)
          );
        }
        getRadius(node) {
          const d3 = Math.min(node.size.width, node.size.height);
          return d3 > 0 ? d3 / 2 : 0;
        }
      };
      exports.CircularNodeView = CircularNodeView2;
      exports.CircularNodeView = CircularNodeView2 = __decorate([
        (0, inversify_1.injectable)()
      ], CircularNodeView2);
      var RectangularNodeView2 = class RectangularNodeView extends views_1.ShapeView {
        render(node, context, args) {
          if (!this.isVisible(node, context)) {
            return void 0;
          }
          return (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("rect", { "class-sprotty-node": node instanceof sgraph_1.SNodeImpl, "class-sprotty-port": node instanceof sgraph_1.SPortImpl, "class-mouseover": node.hoverFeedback, "class-selected": node.selected, x: "0", y: "0", width: Math.max(node.size.width, 0), height: Math.max(node.size.height, 0) }),
            context.renderChildren(node)
          );
        }
      };
      exports.RectangularNodeView = RectangularNodeView2;
      exports.RectangularNodeView = RectangularNodeView2 = __decorate([
        (0, inversify_1.injectable)()
      ], RectangularNodeView2);
      var DiamondNodeView = class DiamondNodeView extends views_1.ShapeView {
        render(node, context, args) {
          if (!this.isVisible(node, context)) {
            return void 0;
          }
          const diamond = new geometry_1.Diamond({ height: Math.max(node.size.height, 0), width: Math.max(node.size.width, 0), x: 0, y: 0 });
          const points = `${svgStr(diamond.topPoint)} ${svgStr(diamond.rightPoint)} ${svgStr(diamond.bottomPoint)} ${svgStr(diamond.leftPoint)}`;
          return (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("polygon", { "class-sprotty-node": node instanceof sgraph_1.SNodeImpl, "class-sprotty-port": node instanceof sgraph_1.SPortImpl, "class-mouseover": node.hoverFeedback, "class-selected": node.selected, points }),
            context.renderChildren(node)
          );
        }
      };
      exports.DiamondNodeView = DiamondNodeView;
      exports.DiamondNodeView = DiamondNodeView = __decorate([
        (0, inversify_1.injectable)()
      ], DiamondNodeView);
      function svgStr(point) {
        return `${point.x},${point.y}`;
      }
      var EmptyGroupView = class EmptyGroupView {
        render(model, context) {
          return (0, jsx_1.svg)("g", null);
        }
      };
      exports.EmptyGroupView = EmptyGroupView;
      exports.EmptyGroupView = EmptyGroupView = __decorate([
        (0, inversify_1.injectable)()
      ], EmptyGroupView);
    }
  });

  // node_modules/sprotty/lib/features/edit/edit-label.js
  var require_edit_label = __commonJS({
    "node_modules/sprotty/lib/features/edit/edit-label.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getEditableLabel = exports.EditLabelKeyListener = exports.EditLabelMouseListener = exports.ApplyLabelEditCommand = exports.ResolvedLabelEdit = exports.isApplyLabelEditAction = exports.isEditLabelAction = exports.EditLabelAction = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var key_tool_1 = require_key_tool();
      var keyboard_1 = require_keyboard();
      var model_1 = require_model6();
      var iterable_1 = require_iterable();
      var model_2 = require_model11();
      var EditLabelAction;
      (function(EditLabelAction2) {
        EditLabelAction2.KIND = "EditLabel";
        function create(labelId) {
          return {
            kind: EditLabelAction2.KIND,
            labelId
          };
        }
        EditLabelAction2.create = create;
      })(EditLabelAction || (exports.EditLabelAction = EditLabelAction = {}));
      function isEditLabelAction(element) {
        return (0, actions_1.isAction)(element) && element.kind === EditLabelAction.KIND && "labelId" in element;
      }
      exports.isEditLabelAction = isEditLabelAction;
      function isApplyLabelEditAction(element) {
        return (0, actions_1.isAction)(element) && element.kind === actions_1.ApplyLabelEditAction.KIND && "labelId" in element && "text" in element;
      }
      exports.isApplyLabelEditAction = isApplyLabelEditAction;
      var ResolvedLabelEdit = class {
      };
      exports.ResolvedLabelEdit = ResolvedLabelEdit;
      var ApplyLabelEditCommand = class ApplyLabelEditCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const index = context.root.index;
          const label = index.getById(this.action.labelId);
          if (label && (0, model_2.isEditableLabel)(label)) {
            this.resolvedLabelEdit = { label, oldLabel: label.text, newLabel: this.action.text };
            label.text = this.action.text;
          }
          return context.root;
        }
        undo(context) {
          if (this.resolvedLabelEdit) {
            this.resolvedLabelEdit.label.text = this.resolvedLabelEdit.oldLabel;
          }
          return context.root;
        }
        redo(context) {
          if (this.resolvedLabelEdit) {
            this.resolvedLabelEdit.label.text = this.resolvedLabelEdit.newLabel;
          }
          return context.root;
        }
      };
      exports.ApplyLabelEditCommand = ApplyLabelEditCommand;
      ApplyLabelEditCommand.KIND = actions_1.ApplyLabelEditAction.KIND;
      exports.ApplyLabelEditCommand = ApplyLabelEditCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ApplyLabelEditCommand);
      var EditLabelMouseListener = class extends mouse_tool_1.MouseListener {
        doubleClick(target, event) {
          const editableLabel = getEditableLabel(target);
          if (editableLabel) {
            return [EditLabelAction.create(editableLabel.id)];
          }
          return [];
        }
      };
      exports.EditLabelMouseListener = EditLabelMouseListener;
      var EditLabelKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "F2")) {
            const editableLabels = (0, iterable_1.toArray)(element.index.all().filter((e2) => (0, model_1.isSelectable)(e2) && e2.selected)).map(getEditableLabel).filter((e2) => e2 !== void 0);
            if (editableLabels.length === 1) {
              return [EditLabelAction.create(editableLabels[0].id)];
            }
          }
          return [];
        }
      };
      exports.EditLabelKeyListener = EditLabelKeyListener;
      function getEditableLabel(element) {
        if ((0, model_2.isEditableLabel)(element)) {
          return element;
        } else if ((0, model_2.isWithEditableLabel)(element) && element.editableLabel) {
          return element.editableLabel;
        }
        return void 0;
      }
      exports.getEditableLabel = getEditableLabel;
    }
  });

  // node_modules/sprotty/lib/model-source/model-source.js
  var require_model_source = __commonJS({
    "node_modules/sprotty/lib/model-source/model-source.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ComputedBoundsApplicator = exports.ModelSource = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var model_utils_1 = require_model_utils();
      var types_1 = require_types();
      var ModelSource = class ModelSource {
        initialize(registry) {
          registry.register(actions_1.RequestModelAction.KIND, this);
          registry.register(actions_1.ExportSvgAction.KIND, this);
        }
      };
      exports.ModelSource = ModelSource;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ModelSource.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ModelSource.prototype, "viewerOptions", void 0);
      exports.ModelSource = ModelSource = __decorate([
        (0, inversify_1.injectable)()
      ], ModelSource);
      var ComputedBoundsApplicator = class ComputedBoundsApplicator {
        apply(root, action) {
          const index = new model_utils_1.SModelIndex();
          index.add(root);
          for (const b3 of action.bounds) {
            const element = index.getById(b3.elementId);
            if (element !== void 0)
              this.applyBounds(element, b3.newPosition, b3.newSize);
          }
          if (action.alignments !== void 0) {
            for (const a3 of action.alignments) {
              const element = index.getById(a3.elementId);
              if (element !== void 0)
                this.applyAlignment(element, a3.newAlignment);
            }
          }
          return index;
        }
        applyAlignment(element, newAlignment) {
          const e2 = element;
          e2.alignment = { x: newAlignment.x, y: newAlignment.y };
        }
        applyBounds(element, newPosition, newSize) {
          const e2 = element;
          if (newPosition)
            e2.position = Object.assign({}, newPosition);
          e2.size = Object.assign({}, newSize);
        }
      };
      exports.ComputedBoundsApplicator = ComputedBoundsApplicator;
      exports.ComputedBoundsApplicator = ComputedBoundsApplicator = __decorate([
        (0, inversify_1.injectable)()
      ], ComputedBoundsApplicator);
    }
  });

  // node_modules/sprotty/lib/model-source/commit-model.js
  var require_commit_model = __commonJS({
    "node_modules/sprotty/lib/model-source/commit-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommitModelCommand = exports.CommitModelAction = void 0;
      var inversify_1 = require_cjs4();
      var command_1 = require_command();
      var types_1 = require_types();
      var model_source_1 = require_model_source();
      var CommitModelAction;
      (function(CommitModelAction2) {
        CommitModelAction2.KIND = "commitModel";
        function create() {
          return {
            kind: CommitModelAction2.KIND
          };
        }
        CommitModelAction2.create = create;
      })(CommitModelAction || (exports.CommitModelAction = CommitModelAction = {}));
      var CommitModelCommand = class CommitModelCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.newModel = context.modelFactory.createSchema(context.root);
          return this.doCommit(this.newModel, context.root, true);
        }
        doCommit(model, result, doSetOriginal) {
          const commitResult = this.modelSource.commitModel(model);
          if (commitResult instanceof Promise) {
            return commitResult.then((originalModel) => {
              if (doSetOriginal)
                this.originalModel = originalModel;
              return result;
            });
          } else {
            if (doSetOriginal)
              this.originalModel = commitResult;
            return result;
          }
        }
        undo(context) {
          return this.doCommit(this.originalModel, context.root, false);
        }
        redo(context) {
          return this.doCommit(this.newModel, context.root, false);
        }
      };
      exports.CommitModelCommand = CommitModelCommand;
      CommitModelCommand.KIND = CommitModelAction.KIND;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ModelSource),
        __metadata("design:type", model_source_1.ModelSource)
      ], CommitModelCommand.prototype, "modelSource", void 0);
      exports.CommitModelCommand = CommitModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], CommitModelCommand);
    }
  });

  // node_modules/sprotty/lib/features/viewport/zoom.js
  var require_zoom = __commonJS({
    "node_modules/sprotty/lib/features/viewport/zoom.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZoomMouseListener = exports.getZoom = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var browser_1 = require_browser();
      var model_1 = require_model12();
      var geometry_2 = require_geometry2();
      function getZoom(label) {
        let zoom = 1;
        const viewport = (0, smodel_utils_1.findParentByFeature)(label, model_1.isViewport);
        if (viewport) {
          zoom = viewport.zoom;
        }
        return zoom;
      }
      exports.getZoom = getZoom;
      var ZoomMouseListener = class extends mouse_tool_1.MouseListener {
        wheel(target, event) {
          const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
          if (!viewport) {
            return [];
          }
          const newViewport = this.isScrollMode(event) ? this.processScroll(viewport, event) : this.processZoom(viewport, target, event);
          if (newViewport) {
            return [actions_1.SetViewportAction.create(viewport.id, newViewport, { animate: false })];
          }
          return [];
        }
        isScrollMode(event) {
          return event.altKey;
        }
        processScroll(viewport, event) {
          return {
            scroll: {
              x: viewport.scroll.x + event.deltaX,
              y: viewport.scroll.y + event.deltaY
            },
            zoom: viewport.zoom
          };
        }
        processZoom(viewport, target, event) {
          const zoomFactor = this.getZoomFactor(event);
          if (zoomFactor > 1 && (0, geometry_1.almostEquals)(viewport.zoom, this.viewerOptions.zoomLimits.max) || zoomFactor < 1 && (0, geometry_1.almostEquals)(viewport.zoom, this.viewerOptions.zoomLimits.min)) {
            return;
          }
          const zoom = (0, geometry_2.limit)(viewport.zoom * zoomFactor, this.viewerOptions.zoomLimits);
          const viewportOffset = this.getViewportOffset(target.root, event);
          const offsetFactor = 1 / zoom - 1 / viewport.zoom;
          return {
            scroll: {
              x: viewport.scroll.x - offsetFactor * viewportOffset.x,
              y: viewport.scroll.y - offsetFactor * viewportOffset.y
            },
            zoom
          };
        }
        getViewportOffset(root, event) {
          const canvasBounds = root.canvasBounds;
          const windowScroll = (0, browser_1.getWindowScroll)();
          return {
            x: event.clientX + windowScroll.x - canvasBounds.x,
            y: event.clientY + windowScroll.y - canvasBounds.y
          };
        }
        getZoomFactor(event) {
          if (event.deltaMode === event.DOM_DELTA_PAGE)
            return Math.exp(-event.deltaY * 0.5);
          else if (event.deltaMode === event.DOM_DELTA_LINE)
            return Math.exp(-event.deltaY * 0.05);
          else
            return Math.exp(-event.deltaY * 5e-3);
        }
      };
      exports.ZoomMouseListener = ZoomMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ZoomMouseListener.prototype, "viewerOptions", void 0);
    }
  });

  // node_modules/sprotty/lib/features/edit/edit-label-ui.js
  var require_edit_label_ui = __commonJS({
    "node_modules/sprotty/lib/features/edit/edit-label-ui.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var EditLabelUI_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EditLabelUI = exports.EditLabelActionHandler = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var types_1 = require_types();
      var ui_extension_1 = require_ui_extension();
      var ui_extension_registry_1 = require_ui_extension_registry();
      var dom_helper_1 = require_dom_helper();
      var commit_model_1 = require_commit_model();
      var keyboard_1 = require_keyboard();
      var model_1 = require_model2();
      var zoom_1 = require_zoom();
      var edit_label_1 = require_edit_label();
      var model_2 = require_model11();
      var EditLabelActionHandler = class EditLabelActionHandler {
        handle(action) {
          if ((0, edit_label_1.isEditLabelAction)(action)) {
            return ui_extension_registry_1.SetUIExtensionVisibilityAction.create({ extensionId: EditLabelUI.ID, visible: true, contextElementsId: [action.labelId] });
          }
        }
      };
      exports.EditLabelActionHandler = EditLabelActionHandler;
      exports.EditLabelActionHandler = EditLabelActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], EditLabelActionHandler);
      var EditLabelUI = EditLabelUI_1 = class EditLabelUI extends ui_extension_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.validationTimeout = void 0;
          this.isActive = false;
          this.blockApplyEditOnInvalidInput = true;
          this.isCurrentLabelValid = true;
        }
        id() {
          return EditLabelUI_1.ID;
        }
        containerClass() {
          return "label-edit";
        }
        get labelId() {
          return this.label ? this.label.id : "unknown";
        }
        initializeContents(containerElement) {
          containerElement.style.position = "absolute";
          this.inputElement = document.createElement("input");
          this.textAreaElement = document.createElement("textarea");
          [this.inputElement, this.textAreaElement].forEach((element) => {
            element.onkeydown = (event) => this.applyLabelEditOnEvent(event, "Enter");
            this.configureAndAdd(element, containerElement);
          });
        }
        configureAndAdd(element, containerElement) {
          element.style.visibility = "hidden";
          element.style.position = "absolute";
          element.style.top = "0px";
          element.style.left = "0px";
          element.addEventListener("keydown", (event) => this.hideIfEscapeEvent(event));
          element.addEventListener("keyup", (event) => this.validateLabelIfContentChange(event, element.value));
          element.addEventListener("blur", () => window.setTimeout(() => this.applyLabelEdit(), 200));
          containerElement.appendChild(element);
        }
        get editControl() {
          if (this.label && this.label.isMultiLine) {
            return this.textAreaElement;
          }
          return this.inputElement;
        }
        hideIfEscapeEvent(event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            this.hide();
          }
        }
        applyLabelEditOnEvent(event, code, ...modifiers) {
          if ((0, keyboard_1.matchesKeystroke)(event, code ? code : "Enter", ...modifiers)) {
            event.preventDefault();
            this.applyLabelEdit();
          }
        }
        validateLabelIfContentChange(event, value) {
          if (this.previousLabelContent === void 0 || this.previousLabelContent !== value) {
            this.previousLabelContent = value;
            this.performLabelValidation(event, this.editControl.value);
          }
        }
        async applyLabelEdit() {
          var _a4;
          if (!this.isActive) {
            return;
          }
          if (((_a4 = this.label) === null || _a4 === void 0 ? void 0 : _a4.text) === this.editControl.value) {
            this.hide();
            return;
          }
          if (this.blockApplyEditOnInvalidInput) {
            const result = await this.validateLabel(this.editControl.value);
            if ("error" === result.severity) {
              this.editControl.focus();
              return;
            }
          }
          this.actionDispatcherProvider().then((actionDispatcher) => actionDispatcher.dispatchAll([actions_1.ApplyLabelEditAction.create(this.labelId, this.editControl.value), commit_model_1.CommitModelAction.create()])).catch((reason) => this.logger.error(this, "No action dispatcher available to execute apply label edit action", reason));
          this.hide();
        }
        performLabelValidation(event, value) {
          if (this.validationTimeout) {
            window.clearTimeout(this.validationTimeout);
          }
          this.validationTimeout = window.setTimeout(() => this.validateLabel(value), 200);
        }
        async validateLabel(value) {
          if (this.labelValidator && this.label) {
            try {
              const result = await this.labelValidator.validate(value, this.label);
              this.isCurrentLabelValid = "error" !== result.severity;
              this.showValidationResult(result);
              return result;
            } catch (reason) {
              this.logger.error(this, "Error validating edited label", reason);
            }
          }
          this.isCurrentLabelValid = true;
          return { severity: "ok", message: void 0 };
        }
        showValidationResult(result) {
          this.clearValidationResult();
          if (this.validationDecorator) {
            this.validationDecorator.decorate(this.editControl, result);
          }
        }
        clearValidationResult() {
          if (this.validationDecorator) {
            this.validationDecorator.dispose(this.editControl);
          }
        }
        show(root, ...contextElementIds) {
          if (!hasEditableLabel(contextElementIds, root) || this.isActive) {
            return;
          }
          super.show(root, ...contextElementIds);
          this.isActive = true;
        }
        hide() {
          this.editControl.style.visibility = "hidden";
          super.hide();
          this.clearValidationResult();
          this.isActive = false;
          this.isCurrentLabelValid = true;
          this.previousLabelContent = void 0;
          if (this.labelElement) {
            this.labelElement.style.visibility = "visible";
          }
        }
        onBeforeShow(containerElement, root, ...contextElementIds) {
          this.label = getEditableLabels(contextElementIds, root)[0];
          this.previousLabelContent = this.label.text;
          this.setPosition(containerElement);
          this.applyTextContents();
          this.applyFontStyling();
          this.editControl.style.visibility = "visible";
          this.editControl.focus();
        }
        setPosition(containerElement) {
          let x3 = 0;
          let y3 = 0;
          let width = 100;
          let height = 20;
          if (this.label) {
            const zoom = (0, zoom_1.getZoom)(this.label);
            const bounds = (0, model_1.getAbsoluteClientBounds)(this.label, this.domHelper, this.viewerOptions);
            x3 = bounds.x + (this.label.editControlPositionCorrection ? this.label.editControlPositionCorrection.x : 0) * zoom;
            y3 = bounds.y + (this.label.editControlPositionCorrection ? this.label.editControlPositionCorrection.y : 0) * zoom;
            height = (this.label.editControlDimension ? this.label.editControlDimension.height : height) * zoom;
            width = (this.label.editControlDimension ? this.label.editControlDimension.width : width) * zoom;
          }
          containerElement.style.left = `${x3}px`;
          containerElement.style.top = `${y3}px`;
          containerElement.style.width = `${width}px`;
          this.editControl.style.width = `${width}px`;
          containerElement.style.height = `${height}px`;
          this.editControl.style.height = `${height}px`;
        }
        applyTextContents() {
          if (this.label) {
            this.editControl.value = this.label.text;
            if (this.editControl instanceof HTMLTextAreaElement) {
              this.editControl.selectionStart = 0;
              this.editControl.selectionEnd = 0;
              this.editControl.scrollTop = 0;
              this.editControl.scrollLeft = 0;
            } else {
              this.editControl.setSelectionRange(0, this.editControl.value.length);
            }
          }
        }
        applyFontStyling() {
          if (this.label) {
            this.labelElement = document.getElementById(this.domHelper.createUniqueDOMElementId(this.label));
            if (this.labelElement) {
              this.labelElement.style.visibility = "hidden";
              const style = window.getComputedStyle(this.labelElement);
              this.editControl.style.font = style.font;
              this.editControl.style.fontStyle = style.fontStyle;
              this.editControl.style.fontFamily = style.fontFamily;
              this.editControl.style.fontSize = scaledFont(style.fontSize, (0, zoom_1.getZoom)(this.label));
              this.editControl.style.fontWeight = style.fontWeight;
              this.editControl.style.lineHeight = style.lineHeight;
            }
          }
        }
      };
      exports.EditLabelUI = EditLabelUI;
      EditLabelUI.ID = "editLabelUi";
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcherProvider),
        __metadata("design:type", Function)
      ], EditLabelUI.prototype, "actionDispatcherProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], EditLabelUI.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], EditLabelUI.prototype, "domHelper", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IEditLabelValidator),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], EditLabelUI.prototype, "labelValidator", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IEditLabelValidationDecorator),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], EditLabelUI.prototype, "validationDecorator", void 0);
      exports.EditLabelUI = EditLabelUI = EditLabelUI_1 = __decorate([
        (0, inversify_1.injectable)()
      ], EditLabelUI);
      function hasEditableLabel(contextElementIds, root) {
        return getEditableLabels(contextElementIds, root).length === 1;
      }
      function getEditableLabels(contextElementIds, root) {
        return contextElementIds.map((id) => root.index.getById(id)).filter(model_2.isEditableLabel);
      }
      function scaledFont(font, zoom) {
        return font.replace(/\d+(\.\d+)?/, (match) => {
          return String(Number.parseInt(match, 10) * zoom);
        });
      }
    }
  });

  // node_modules/sprotty/lib/features/edit/edit-routing.js
  var require_edit_routing = __commonJS({
    "node_modules/sprotty/lib/features/edit/edit-routing.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SwitchEditModeCommand = exports.SwitchEditModeAction = void 0;
      var inversify_1 = require_cjs4();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var model_1 = require_model9();
      var routing_1 = require_routing();
      var model_2 = require_model11();
      var SwitchEditModeAction;
      (function(SwitchEditModeAction2) {
        SwitchEditModeAction2.KIND = "switchEditMode";
        function create(options) {
          var _a4, _b2;
          return {
            kind: SwitchEditModeAction2.KIND,
            elementsToActivate: (_a4 = options.elementsToActivate) !== null && _a4 !== void 0 ? _a4 : [],
            elementsToDeactivate: (_b2 = options.elementsToDeactivate) !== null && _b2 !== void 0 ? _b2 : []
          };
        }
        SwitchEditModeAction2.create = create;
      })(SwitchEditModeAction || (exports.SwitchEditModeAction = SwitchEditModeAction = {}));
      var SwitchEditModeCommand = class SwitchEditModeCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.elementsToActivate = [];
          this.elementsToDeactivate = [];
          this.handlesToRemove = [];
        }
        execute(context) {
          const index = context.root.index;
          this.action.elementsToActivate.forEach((id) => {
            const element = index.getById(id);
            if (element !== void 0)
              this.elementsToActivate.push(element);
          });
          this.action.elementsToDeactivate.forEach((id) => {
            const element = index.getById(id);
            if (element !== void 0)
              this.elementsToDeactivate.push(element);
            if (element instanceof model_1.SRoutingHandleImpl && element.parent instanceof model_1.SRoutableElementImpl) {
              const parent = element.parent;
              if (this.shouldRemoveHandle(element, parent)) {
                this.handlesToRemove.push({ handle: element, parent });
                this.elementsToDeactivate.push(parent);
                this.elementsToActivate.push(parent);
              }
            }
          });
          return this.doExecute(context);
        }
        doExecute(context) {
          this.handlesToRemove.forEach((entry) => {
            entry.point = entry.parent.routingPoints.splice(entry.handle.pointIndex, 1)[0];
          });
          this.elementsToDeactivate.forEach((element) => {
            if (element instanceof model_1.SRoutableElementImpl)
              element.removeAll((child) => child instanceof model_1.SRoutingHandleImpl);
            else if (element instanceof model_1.SRoutingHandleImpl) {
              element.editMode = false;
              if (element.danglingAnchor) {
                if (element.parent instanceof model_1.SRoutableElementImpl && element.danglingAnchor.original) {
                  if (element.parent.source === element.danglingAnchor)
                    element.parent.sourceId = element.danglingAnchor.original.id;
                  else if (element.parent.target === element.danglingAnchor)
                    element.parent.targetId = element.danglingAnchor.original.id;
                  element.danglingAnchor.parent.remove(element.danglingAnchor);
                  element.danglingAnchor = void 0;
                }
              }
            }
          });
          this.elementsToActivate.forEach((element) => {
            if ((0, model_2.canEditRouting)(element) && element instanceof smodel_1.SParentElementImpl) {
              const router = this.edgeRouterRegistry.get(element.routerKind);
              router.createRoutingHandles(element);
            } else if (element instanceof model_1.SRoutingHandleImpl)
              element.editMode = true;
          });
          return context.root;
        }
        shouldRemoveHandle(handle, parent) {
          if (handle.kind === "junction") {
            const route = this.edgeRouterRegistry.route(parent);
            return route.find((rp) => rp.pointIndex === handle.pointIndex) === void 0;
          }
          return false;
        }
        undo(context) {
          this.handlesToRemove.forEach((entry) => {
            if (entry.point !== void 0)
              entry.parent.routingPoints.splice(entry.handle.pointIndex, 0, entry.point);
          });
          this.elementsToActivate.forEach((element) => {
            if (element instanceof model_1.SRoutableElementImpl)
              element.removeAll((child) => child instanceof model_1.SRoutingHandleImpl);
            else if (element instanceof model_1.SRoutingHandleImpl)
              element.editMode = false;
          });
          this.elementsToDeactivate.forEach((element) => {
            if ((0, model_2.canEditRouting)(element)) {
              const router = this.edgeRouterRegistry.get(element.routerKind);
              router.createRoutingHandles(element);
            } else if (element instanceof model_1.SRoutingHandleImpl)
              element.editMode = true;
          });
          return context.root;
        }
        redo(context) {
          return this.doExecute(context);
        }
      };
      exports.SwitchEditModeCommand = SwitchEditModeCommand;
      SwitchEditModeCommand.KIND = SwitchEditModeAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], SwitchEditModeCommand.prototype, "edgeRouterRegistry", void 0);
      exports.SwitchEditModeCommand = SwitchEditModeCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SwitchEditModeCommand);
    }
  });

  // node_modules/sprotty/lib/features/edit/reconnect.js
  var require_reconnect = __commonJS({
    "node_modules/sprotty/lib/features/edit/reconnect.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReconnectCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var model_1 = require_model9();
      var routing_1 = require_routing();
      var ReconnectCommand = class ReconnectCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.doExecute(context);
          return context.root;
        }
        doExecute(context) {
          const index = context.root.index;
          const edge = index.getById(this.action.routableId);
          if (edge instanceof model_1.SRoutableElementImpl) {
            const router = this.edgeRouterRegistry.get(edge.routerKind);
            const before = router.takeSnapshot(edge);
            router.applyReconnect(edge, this.action.newSourceId, this.action.newTargetId);
            const after = router.takeSnapshot(edge);
            this.memento = {
              edge,
              before,
              after
            };
          }
        }
        undo(context) {
          if (this.memento) {
            const router = this.edgeRouterRegistry.get(this.memento.edge.routerKind);
            router.applySnapshot(this.memento.edge, this.memento.before);
          }
          return context.root;
        }
        redo(context) {
          if (this.memento) {
            const router = this.edgeRouterRegistry.get(this.memento.edge.routerKind);
            router.applySnapshot(this.memento.edge, this.memento.after);
          }
          return context.root;
        }
      };
      exports.ReconnectCommand = ReconnectCommand;
      ReconnectCommand.KIND = actions_1.ReconnectAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], ReconnectCommand.prototype, "edgeRouterRegistry", void 0);
      exports.ReconnectCommand = ReconnectCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ReconnectCommand);
    }
  });

  // node_modules/sprotty/lib/features/edit/di.config.js
  var require_di_config3 = __commonJS({
    "node_modules/sprotty/lib/features/edit/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.labelEditUiModule = exports.labelEditModule = exports.edgeEditModule = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var command_registration_1 = require_command_registration();
      var action_handler_1 = require_action_handler();
      var view_1 = require_view();
      var model_1 = require_model9();
      var svg_views_1 = require_svg_views();
      var delete_1 = require_delete();
      var edit_label_1 = require_edit_label();
      var edit_label_ui_1 = require_edit_label_ui();
      var edit_routing_1 = require_edit_routing();
      var reconnect_1 = require_reconnect();
      exports.edgeEditModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, command_registration_1.configureCommand)(context, edit_routing_1.SwitchEditModeCommand);
        (0, command_registration_1.configureCommand)(context, reconnect_1.ReconnectCommand);
        (0, command_registration_1.configureCommand)(context, delete_1.DeleteElementCommand);
        (0, view_1.configureModelElement)(context, "dangling-anchor", model_1.SDanglingAnchorImpl, svg_views_1.EmptyGroupView);
      });
      exports.labelEditModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(edit_label_1.EditLabelMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(edit_label_1.EditLabelMouseListener);
        bind(edit_label_1.EditLabelKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(edit_label_1.EditLabelKeyListener);
        (0, command_registration_1.configureCommand)({ bind, isBound }, edit_label_1.ApplyLabelEditCommand);
      });
      exports.labelEditUiModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, action_handler_1.configureActionHandler)(context, edit_label_1.EditLabelAction.KIND, edit_label_ui_1.EditLabelActionHandler);
        bind(edit_label_ui_1.EditLabelUI).toSelf().inSingletonScope();
        bind(types_1.TYPES.IUIExtension).toService(edit_label_ui_1.EditLabelUI);
      });
    }
  });

  // node_modules/sprotty/lib/features/expand/model.js
  var require_model14 = __commonJS({
    "node_modules/sprotty/lib/features/expand/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isExpandable = exports.expandFeature = void 0;
      exports.expandFeature = Symbol("expandFeature");
      function isExpandable(element) {
        return element.hasFeature(exports.expandFeature) && "expanded" in element;
      }
      exports.isExpandable = isExpandable;
    }
  });

  // node_modules/sprotty/lib/features/expand/expand.js
  var require_expand = __commonJS({
    "node_modules/sprotty/lib/features/expand/expand.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExpandButtonHandler = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model14();
      var ExpandButtonHandler = class ExpandButtonHandler {
        buttonPressed(button) {
          const expandable = (0, smodel_utils_1.findParentByFeature)(button, model_1.isExpandable);
          if (expandable !== void 0) {
            return [actions_1.CollapseExpandAction.create({
              expandIds: expandable.expanded ? [] : [expandable.id],
              collapseIds: expandable.expanded ? [expandable.id] : []
            })];
          } else {
            return [];
          }
        }
      };
      exports.ExpandButtonHandler = ExpandButtonHandler;
      ExpandButtonHandler.TYPE = "button:expand";
      exports.ExpandButtonHandler = ExpandButtonHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ExpandButtonHandler);
    }
  });

  // node_modules/sprotty/lib/features/expand/views.js
  var require_views2 = __commonJS({
    "node_modules/sprotty/lib/features/expand/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExpandButtonView = void 0;
      var jsx_1 = require_jsx();
      var model_1 = require_model14();
      var smodel_utils_1 = require_smodel_utils();
      var inversify_1 = require_cjs4();
      var ExpandButtonView = class ExpandButtonView {
        render(button, context) {
          const expandable = (0, smodel_utils_1.findParentByFeature)(button, model_1.isExpandable);
          const path = expandable !== void 0 && expandable.expanded ? "M 1,5 L 8,12 L 15,5 Z" : "M 1,8 L 8,15 L 8,1 Z";
          return (0, jsx_1.svg)(
            "g",
            { "class-sprotty-button": "{true}", "class-enabled": "{button.enabled}" },
            (0, jsx_1.svg)("rect", { x: 0, y: 0, width: 16, height: 16, opacity: 0 }),
            (0, jsx_1.svg)("path", { d: path })
          );
        }
      };
      exports.ExpandButtonView = ExpandButtonView;
      exports.ExpandButtonView = ExpandButtonView = __decorate([
        (0, inversify_1.injectable)()
      ], ExpandButtonView);
    }
  });

  // node_modules/sprotty/lib/features/export/svg-exporter.js
  var require_svg_exporter = __commonJS({
    "node_modules/sprotty/lib/features/export/svg-exporter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SvgExporter = exports.ExportSvgAction = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var action_dispatcher_1 = require_action_dispatcher();
      var types_1 = require_types();
      var model_1 = require_model2();
      var ExportSvgAction;
      (function(ExportSvgAction2) {
        ExportSvgAction2.KIND = "exportSvg";
        function create(svg, requestId, options) {
          return {
            kind: ExportSvgAction2.KIND,
            svg,
            responseId: requestId,
            options
          };
        }
        ExportSvgAction2.create = create;
      })(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));
      var SvgExporter = class SvgExporter {
        constructor() {
          this.postprocessors = [];
        }
        export(root, request) {
          var _a4;
          if (typeof document !== "undefined") {
            const hiddenDiv = document.getElementById(this.options.hiddenDiv);
            if (hiddenDiv === null) {
              this.log.warn(this, `Element with id ${this.options.hiddenDiv} not found. Nothing to export.`);
              return;
            }
            const svgElement = hiddenDiv.querySelector("svg");
            if (svgElement === null) {
              this.log.warn(this, `No svg element found in ${this.options.hiddenDiv} div. Nothing to export.`);
              return;
            }
            const svg = this.createSvg(svgElement, root, (_a4 = request === null || request === void 0 ? void 0 : request.options) !== null && _a4 !== void 0 ? _a4 : {}, request);
            this.actionDispatcher.dispatch(ExportSvgAction.create(svg, request ? request.requestId : "", request === null || request === void 0 ? void 0 : request.options));
          }
        }
        createSvg(svgElementOrig, root, options, cause) {
          const serializer = new XMLSerializer();
          const svgCopy = serializer.serializeToString(svgElementOrig);
          const iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          if (!iframe.contentWindow)
            throw new Error("IFrame has no contentWindow");
          const docCopy = iframe.contentWindow.document;
          docCopy.open();
          docCopy.write(svgCopy);
          docCopy.close();
          const svgElementNew = docCopy.querySelector("svg");
          svgElementNew.removeAttribute("opacity");
          if (!(options === null || options === void 0 ? void 0 : options.skipCopyStyles)) {
            this.copyStyles(svgElementOrig, svgElementNew, ["width", "height", "opacity", "inline-size"]);
          }
          svgElementNew.setAttribute("version", "1.1");
          const bounds = this.getBounds(root, docCopy);
          svgElementNew.setAttribute("viewBox", `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
          svgElementNew.setAttribute("width", `${bounds.width}`);
          svgElementNew.setAttribute("height", `${bounds.height}`);
          this.postprocessors.forEach((postprocessor) => {
            postprocessor.postUpdate(svgElementNew, cause);
          });
          const svgCode = serializer.serializeToString(svgElementNew);
          document.body.removeChild(iframe);
          return svgCode;
        }
        copyStyles(source, target, skippedProperties) {
          const sourceStyle = getComputedStyle(source);
          const targetStyle = getComputedStyle(target);
          let diffStyle = "";
          for (let i2 = 0; i2 < sourceStyle.length; i2++) {
            const key = sourceStyle[i2];
            if (skippedProperties.indexOf(key) === -1) {
              const value = sourceStyle.getPropertyValue(key);
              if (targetStyle.getPropertyValue(key) !== value) {
                diffStyle += key + ":" + value + ";";
              }
            }
          }
          if (diffStyle !== "")
            target.setAttribute("style", diffStyle);
          for (let i2 = 0; i2 < source.childNodes.length; ++i2) {
            const sourceChild = source.childNodes[i2];
            const targetChild = target.childNodes[i2];
            if (sourceChild instanceof Element)
              this.copyStyles(sourceChild, targetChild, []);
          }
        }
        getBounds(root, document2) {
          const svgElement = document2.querySelector("svg");
          if (svgElement) {
            return svgElement.getBBox();
          }
          const allBounds = [geometry_1.Bounds.EMPTY];
          root.children.forEach((element) => {
            if ((0, model_1.isBoundsAware)(element)) {
              allBounds.push(element.bounds);
            }
          });
          return allBounds.reduce((one, two) => geometry_1.Bounds.combine(one, two));
        }
      };
      exports.SvgExporter = SvgExporter;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], SvgExporter.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.ActionDispatcher)
      ], SvgExporter.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], SvgExporter.prototype, "log", void 0);
      __decorate([
        (0, inversify_1.multiInject)(types_1.TYPES.ISvgExportPostprocessor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], SvgExporter.prototype, "postprocessors", void 0);
      exports.SvgExporter = SvgExporter = __decorate([
        (0, inversify_1.injectable)()
      ], SvgExporter);
    }
  });

  // node_modules/sprotty/lib/features/export/export.js
  var require_export = __commonJS({
    "node_modules/sprotty/lib/features/export/export.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExportSvgPostprocessor = exports.ExportSvgCommand = exports.RequestExportSvgAction = exports.ExportSvgKeyListener = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var model_1 = require_model6();
      var smodel_1 = require_smodel();
      var key_tool_1 = require_key_tool();
      var keyboard_1 = require_keyboard();
      var model_2 = require_model13();
      var svg_exporter_1 = require_svg_exporter();
      var model_3 = require_model12();
      var model_4 = require_model7();
      var types_1 = require_types();
      var ExportSvgKeyListener = class ExportSvgKeyListener extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyE", "ctrlCmd", "shift"))
            return [RequestExportSvgAction.create()];
          else
            return [];
        }
      };
      exports.ExportSvgKeyListener = ExportSvgKeyListener;
      exports.ExportSvgKeyListener = ExportSvgKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], ExportSvgKeyListener);
      var RequestExportSvgAction;
      (function(RequestExportSvgAction2) {
        RequestExportSvgAction2.KIND = "requestExportSvg";
        function create(options = {}) {
          return {
            kind: RequestExportSvgAction2.KIND,
            requestId: (0, actions_1.generateRequestId)(),
            options
          };
        }
        RequestExportSvgAction2.create = create;
      })(RequestExportSvgAction || (exports.RequestExportSvgAction = RequestExportSvgAction = {}));
      var ExportSvgCommand = class ExportSvgCommand extends command_1.HiddenCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          if ((0, model_2.isExportable)(context.root)) {
            const root = context.modelFactory.createRoot(context.root);
            if ((0, model_2.isExportable)(root)) {
              if ((0, model_3.isViewport)(root)) {
                root.zoom = 1;
                root.scroll = { x: 0, y: 0 };
              }
              root.index.all().forEach((element) => {
                if ((0, model_1.isSelectable)(element) && element.selected)
                  element.selected = false;
                if ((0, model_4.isHoverable)(element) && element.hoverFeedback)
                  element.hoverFeedback = false;
              });
              return {
                model: root,
                modelChanged: true,
                cause: this.action
              };
            }
          }
          return {
            model: context.root,
            modelChanged: false
          };
        }
      };
      exports.ExportSvgCommand = ExportSvgCommand;
      ExportSvgCommand.KIND = RequestExportSvgAction.KIND;
      exports.ExportSvgCommand = ExportSvgCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ExportSvgCommand);
      var ExportSvgPostprocessor = class ExportSvgPostprocessor {
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl)
            this.root = element;
          return vnode;
        }
        postUpdate(cause) {
          if (this.root && cause !== void 0 && cause.kind === RequestExportSvgAction.KIND) {
            this.svgExporter.export(this.root, cause);
          }
        }
      };
      exports.ExportSvgPostprocessor = ExportSvgPostprocessor;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.SvgExporter),
        __metadata("design:type", svg_exporter_1.SvgExporter)
      ], ExportSvgPostprocessor.prototype, "svgExporter", void 0);
      exports.ExportSvgPostprocessor = ExportSvgPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], ExportSvgPostprocessor);
    }
  });

  // node_modules/sprotty/lib/features/export/svg-export-postprocessor.js
  var require_svg_export_postprocessor = __commonJS({
    "node_modules/sprotty/lib/features/export/svg-export-postprocessor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/sprotty/lib/features/fade/fade.js
  var require_fade = __commonJS({
    "node_modules/sprotty/lib/features/fade/fade.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ElementFader = exports.FadeAnimation = void 0;
      var inversify_1 = require_cjs4();
      var animation_1 = require_animation();
      var smodel_1 = require_smodel();
      var vnode_utils_1 = require_vnode_utils();
      var model_1 = require_model3();
      var FadeAnimation = class extends animation_1.Animation {
        constructor(model, elementFades, context, removeAfterFadeOut = false) {
          super(context);
          this.model = model;
          this.elementFades = elementFades;
          this.removeAfterFadeOut = removeAfterFadeOut;
        }
        tween(t3, context) {
          for (const elementFade of this.elementFades) {
            const element = elementFade.element;
            if (elementFade.type === "in") {
              element.opacity = t3;
            } else if (elementFade.type === "out") {
              element.opacity = 1 - t3;
              if (t3 === 1 && this.removeAfterFadeOut && element instanceof smodel_1.SChildElementImpl) {
                element.parent.remove(element);
              }
            }
          }
          return this.model;
        }
      };
      exports.FadeAnimation = FadeAnimation;
      var ElementFader = class ElementFader {
        decorate(vnode, element) {
          if ((0, model_1.isFadeable)(element) && element.opacity !== 1) {
            (0, vnode_utils_1.setAttr)(vnode, "opacity", element.opacity);
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.ElementFader = ElementFader;
      exports.ElementFader = ElementFader = __decorate([
        (0, inversify_1.injectable)()
      ], ElementFader);
    }
  });

  // node_modules/sprotty/lib/features/hover/hover.js
  var require_hover = __commonJS({
    "node_modules/sprotty/lib/features/hover/hover.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClosePopupActionHandler = exports.HoverKeyListener = exports.PopupHoverMouseListener = exports.HoverMouseListener = exports.AbstractHoverMouseListener = exports.SetPopupModelCommand = exports.HoverFeedbackCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var keyboard_1 = require_keyboard();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var mouse_tool_1 = require_mouse_tool();
      var command_1 = require_command();
      var smodel_factory_1 = require_smodel_factory();
      var key_tool_1 = require_key_tool();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model2();
      var model_2 = require_model7();
      var HoverFeedbackCommand = class HoverFeedbackCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const model = context.root;
          const modelElement = model.index.getById(this.action.mouseoverElement);
          if (modelElement) {
            if ((0, model_2.isHoverable)(modelElement)) {
              modelElement.hoverFeedback = this.action.mouseIsOver;
            }
          }
          return this.redo(context);
        }
        undo(context) {
          return context.root;
        }
        redo(context) {
          return context.root;
        }
      };
      exports.HoverFeedbackCommand = HoverFeedbackCommand;
      HoverFeedbackCommand.KIND = actions_1.HoverFeedbackAction.KIND;
      exports.HoverFeedbackCommand = HoverFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], HoverFeedbackCommand);
      var SetPopupModelCommand = class SetPopupModelCommand extends command_1.PopupCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.oldRoot = context.root;
          this.newRoot = context.modelFactory.createRoot(this.action.newRoot);
          return this.newRoot;
        }
        undo(context) {
          return this.oldRoot;
        }
        redo(context) {
          return this.newRoot;
        }
      };
      exports.SetPopupModelCommand = SetPopupModelCommand;
      SetPopupModelCommand.KIND = actions_1.SetPopupModelAction.KIND;
      exports.SetPopupModelCommand = SetPopupModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetPopupModelCommand);
      var AbstractHoverMouseListener = class extends mouse_tool_1.MouseListener {
        mouseDown(target, event) {
          this.mouseIsDown = true;
          return [];
        }
        mouseUp(target, event) {
          this.mouseIsDown = false;
          return [];
        }
        stopMouseOutTimer() {
          if (this.state.mouseOutTimer !== void 0) {
            window.clearTimeout(this.state.mouseOutTimer);
            this.state.mouseOutTimer = void 0;
          }
        }
        startMouseOutTimer() {
          this.stopMouseOutTimer();
          return new Promise((resolve) => {
            this.state.mouseOutTimer = window.setTimeout(() => {
              this.state.popupOpen = false;
              this.state.previousPopupElement = void 0;
              resolve(actions_1.SetPopupModelAction.create({ type: smodel_factory_1.EMPTY_ROOT.type, id: smodel_factory_1.EMPTY_ROOT.id }));
            }, this.options.popupCloseDelay);
          });
        }
        stopMouseOverTimer() {
          if (this.state.mouseOverTimer !== void 0) {
            window.clearTimeout(this.state.mouseOverTimer);
            this.state.mouseOverTimer = void 0;
          }
        }
      };
      exports.AbstractHoverMouseListener = AbstractHoverMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], AbstractHoverMouseListener.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.HoverState),
        __metadata("design:type", Object)
      ], AbstractHoverMouseListener.prototype, "state", void 0);
      var HoverMouseListener = class HoverMouseListener extends AbstractHoverMouseListener {
        computePopupBounds(target, mousePosition) {
          let offset = { x: -5, y: 20 };
          const targetBounds = (0, model_1.getAbsoluteBounds)(target);
          const canvasBounds = target.root.canvasBounds;
          const boundsInWindow = geometry_1.Bounds.translate(targetBounds, canvasBounds);
          const distRight = boundsInWindow.x + boundsInWindow.width - mousePosition.x;
          const distBottom = boundsInWindow.y + boundsInWindow.height - mousePosition.y;
          if (distBottom <= distRight && this.allowSidePosition(target, "below", distBottom)) {
            offset = { x: -5, y: Math.round(distBottom + 5) };
          } else if (distRight <= distBottom && this.allowSidePosition(target, "right", distRight)) {
            offset = { x: Math.round(distRight + 5), y: -5 };
          }
          let leftPopupPosition = mousePosition.x + offset.x;
          const canvasRightBorderPosition = canvasBounds.x + canvasBounds.width;
          if (leftPopupPosition > canvasRightBorderPosition) {
            leftPopupPosition = canvasRightBorderPosition;
          }
          let topPopupPosition = mousePosition.y + offset.y;
          const canvasBottomBorderPosition = canvasBounds.y + canvasBounds.height;
          if (topPopupPosition > canvasBottomBorderPosition) {
            topPopupPosition = canvasBottomBorderPosition;
          }
          return { x: leftPopupPosition, y: topPopupPosition, width: -1, height: -1 };
        }
        allowSidePosition(target, side, distance) {
          return !(target instanceof smodel_1.SModelRootImpl) && distance <= 150;
        }
        startMouseOverTimer(target, event) {
          this.stopMouseOverTimer();
          return new Promise((resolve) => {
            this.state.mouseOverTimer = window.setTimeout(() => {
              const popupBounds = this.computePopupBounds(target, { x: event.pageX, y: event.pageY });
              resolve(actions_1.RequestPopupModelAction.create({ elementId: target.id, bounds: popupBounds }));
              this.state.popupOpen = true;
              this.state.previousPopupElement = target;
            }, this.options.popupOpenDelay);
          });
        }
        mouseOver(target, event) {
          const result = [];
          if (!this.mouseIsDown) {
            const popupTarget = (0, smodel_utils_1.findParent)(target, model_2.hasPopupFeature);
            if (this.state.popupOpen && (popupTarget === void 0 || this.state.previousPopupElement !== void 0 && this.state.previousPopupElement.id !== popupTarget.id)) {
              result.push(this.startMouseOutTimer());
            } else {
              this.stopMouseOverTimer();
              this.stopMouseOutTimer();
            }
            if (popupTarget !== void 0 && (this.state.previousPopupElement === void 0 || this.state.previousPopupElement.id !== popupTarget.id)) {
              result.push(this.startMouseOverTimer(popupTarget, event));
            }
            if (this.lastHoverFeedbackElementId) {
              result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: this.lastHoverFeedbackElementId, mouseIsOver: false }));
              this.lastHoverFeedbackElementId = void 0;
            }
            const hoverTarget = (0, smodel_utils_1.findParentByFeature)(target, model_2.isHoverable);
            if (hoverTarget !== void 0) {
              result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: hoverTarget.id, mouseIsOver: true }));
              this.lastHoverFeedbackElementId = hoverTarget.id;
            }
          }
          return result;
        }
        mouseOut(target, event) {
          const result = [];
          if (!this.mouseIsDown) {
            const elementUnderMouse = this.getElementFromEventPosition(event);
            if (!this.isSprottyPopup(elementUnderMouse)) {
              if (this.state.popupOpen) {
                const popupTarget = (0, smodel_utils_1.findParent)(target, model_2.hasPopupFeature);
                if (this.state.previousPopupElement !== void 0 && popupTarget !== void 0 && this.state.previousPopupElement.id === popupTarget.id)
                  result.push(this.startMouseOutTimer());
              }
              this.stopMouseOverTimer();
              const hoverTarget = (0, smodel_utils_1.findParentByFeature)(target, model_2.isHoverable);
              if (hoverTarget !== void 0) {
                result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: hoverTarget.id, mouseIsOver: false }));
                if (this.lastHoverFeedbackElementId && this.lastHoverFeedbackElementId !== hoverTarget.id) {
                  result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: this.lastHoverFeedbackElementId, mouseIsOver: false }));
                }
                this.lastHoverFeedbackElementId = void 0;
              }
            }
          }
          return result;
        }
        getElementFromEventPosition(event) {
          return document.elementFromPoint(event.x, event.y);
        }
        isSprottyPopup(element) {
          return element ? element.id === this.options.popupDiv || !!element.parentElement && this.isSprottyPopup(element.parentElement) : false;
        }
        mouseMove(target, event) {
          const result = [];
          if (!this.mouseIsDown) {
            if (this.state.previousPopupElement !== void 0 && this.closeOnMouseMove(this.state.previousPopupElement, event)) {
              result.push(this.startMouseOutTimer());
            }
            const popupTarget = (0, smodel_utils_1.findParent)(target, model_2.hasPopupFeature);
            if (popupTarget !== void 0 && (this.state.previousPopupElement === void 0 || this.state.previousPopupElement.id !== popupTarget.id)) {
              result.push(this.startMouseOverTimer(popupTarget, event));
            }
          }
          return result;
        }
        closeOnMouseMove(target, event) {
          return target instanceof smodel_1.SModelRootImpl;
        }
      };
      exports.HoverMouseListener = HoverMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], HoverMouseListener.prototype, "options", void 0);
      exports.HoverMouseListener = HoverMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], HoverMouseListener);
      var PopupHoverMouseListener = class PopupHoverMouseListener extends AbstractHoverMouseListener {
        mouseOut(target, event) {
          return [this.startMouseOutTimer()];
        }
        mouseOver(target, event) {
          this.stopMouseOutTimer();
          this.stopMouseOverTimer();
          return [];
        }
      };
      exports.PopupHoverMouseListener = PopupHoverMouseListener;
      exports.PopupHoverMouseListener = PopupHoverMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], PopupHoverMouseListener);
      var HoverKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            return [actions_1.SetPopupModelAction.create({ type: smodel_factory_1.EMPTY_ROOT.type, id: smodel_factory_1.EMPTY_ROOT.id })];
          }
          return [];
        }
      };
      exports.HoverKeyListener = HoverKeyListener;
      var ClosePopupActionHandler = class ClosePopupActionHandler {
        constructor() {
          this.popupOpen = false;
        }
        handle(action) {
          if (action.kind === SetPopupModelCommand.KIND) {
            this.popupOpen = action.newRoot.type !== smodel_factory_1.EMPTY_ROOT.type;
          } else if (this.popupOpen) {
            return actions_1.SetPopupModelAction.create({ id: smodel_factory_1.EMPTY_ROOT.id, type: smodel_factory_1.EMPTY_ROOT.type });
          }
        }
      };
      exports.ClosePopupActionHandler = ClosePopupActionHandler;
      exports.ClosePopupActionHandler = ClosePopupActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ClosePopupActionHandler);
    }
  });

  // node_modules/sprotty/lib/features/decoration/model.js
  var require_model15 = __commonJS({
    "node_modules/sprotty/lib/features/decoration/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SIssue = exports.SIssueMarker = exports.SIssueMarkerImpl = exports.SDecoration = exports.isDecoration = exports.decorationFeature = void 0;
      var model_1 = require_model2();
      var model_2 = require_model7();
      exports.decorationFeature = Symbol("decorationFeature");
      function isDecoration(e2) {
        return e2.hasFeature(exports.decorationFeature);
      }
      exports.isDecoration = isDecoration;
      var SDecoration = class extends model_1.SShapeElementImpl {
      };
      exports.SDecoration = SDecoration;
      SDecoration.DEFAULT_FEATURES = [exports.decorationFeature, model_1.boundsFeature, model_2.hoverFeedbackFeature, model_2.popupFeature];
      var SIssueMarkerImpl = class extends SDecoration {
      };
      exports.SIssueMarkerImpl = SIssueMarkerImpl;
      exports.SIssueMarker = SIssueMarkerImpl;
      var SIssue = class {
      };
      exports.SIssue = SIssue;
    }
  });

  // node_modules/sprotty/lib/features/decoration/views.js
  var require_views3 = __commonJS({
    "node_modules/sprotty/lib/features/decoration/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IssueMarkerView = void 0;
      var jsx_1 = require_jsx();
      var vnode_utils_1 = require_vnode_utils();
      var inversify_1 = require_cjs4();
      var IssueMarkerView = class IssueMarkerView {
        render(marker, context) {
          const scale = 16 / 1792;
          const trafo = `scale(${scale}, ${scale})`;
          const maxSeverity = this.getMaxSeverity(marker);
          const group = (0, jsx_1.svg)(
            "g",
            { "class-sprotty-issue": true },
            (0, jsx_1.svg)(
              "g",
              { transform: trafo },
              (0, jsx_1.svg)("path", { d: this.getPath(maxSeverity) })
            )
          );
          (0, vnode_utils_1.setClass)(group, "sprotty-" + maxSeverity, true);
          return group;
        }
        getMaxSeverity(marker) {
          let currentSeverity = "info";
          for (const severity of marker.issues.map((s3) => s3.severity)) {
            if (severity === "error" || severity === "warning" && currentSeverity === "info")
              currentSeverity = severity;
          }
          return currentSeverity;
        }
        getPath(severity) {
          switch (severity) {
            case "error":
            case "warning":
              return "M768 128q209 0 385.5 103t279.5 279.5 103 385.5-103 385.5-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103zm128 1247v-190q0-14-9-23.5t-22-9.5h-192q-13 0-23 10t-10 23v190q0 13 10 23t23 10h192q13 0 22-9.5t9-23.5zm-2-344l18-621q0-12-10-18-10-8-24-8h-220q-14 0-24 8-10 6-10 18l17 621q0 10 10 17.5t24 7.5h185q14 0 23.5-7.5t10.5-17.5z";
            case "info":
              return "M1024 1376v-160q0-14-9-23t-23-9h-96v-512q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v160q0 14 9 23t23 9h96v320h-96q-14 0-23 9t-9 23v160q0 14 9 23t23 9h448q14 0 23-9t9-23zm-128-896v-160q0-14-9-23t-23-9h-192q-14 0-23 9t-9 23v160q0 14 9 23t23 9h192q14 0 23-9t9-23zm640 416q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z";
          }
        }
      };
      exports.IssueMarkerView = IssueMarkerView;
      exports.IssueMarkerView = IssueMarkerView = __decorate([
        (0, inversify_1.injectable)()
      ], IssueMarkerView);
    }
  });

  // node_modules/sprotty/lib/features/decoration/decoration-placer.js
  var require_decoration_placer = __commonJS({
    "node_modules/sprotty/lib/features/decoration/decoration-placer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DecorationPlacer = void 0;
      var inversify_1 = require_cjs4();
      var smodel_1 = require_smodel();
      var model_1 = require_model15();
      var vnode_utils_1 = require_vnode_utils();
      var model_2 = require_model2();
      var model_3 = require_model9();
      var routing_1 = require_routing();
      var sprotty_protocol_1 = require_lib();
      var DecorationPlacer = class DecorationPlacer {
        decorate(vnode, element) {
          if ((0, model_1.isDecoration)(element)) {
            const position = this.getPosition(element);
            const translate = "translate(" + position.x + ", " + position.y + ")";
            (0, vnode_utils_1.setAttr)(vnode, "transform", translate);
          }
          return vnode;
        }
        getPosition(element) {
          if (element instanceof smodel_1.SChildElementImpl && element.parent instanceof model_3.SRoutableElementImpl) {
            const route = this.edgeRouterRegistry.route(element.parent);
            if (route.length > 1) {
              const index = Math.floor(0.5 * (route.length - 1));
              const offset = (0, model_2.isSizeable)(element) ? {
                x: -0.5 * element.bounds.width,
                y: -0.5 * element.bounds.width
              } : sprotty_protocol_1.Point.ORIGIN;
              return {
                x: 0.5 * (route[index].x + route[index + 1].x) + offset.x,
                y: 0.5 * (route[index].y + route[index + 1].y) + offset.y
              };
            }
          }
          if ((0, model_2.isSizeable)(element))
            return {
              x: -0.666 * element.bounds.width,
              y: -0.666 * element.bounds.height
            };
          return sprotty_protocol_1.Point.ORIGIN;
        }
        postUpdate() {
        }
      };
      exports.DecorationPlacer = DecorationPlacer;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], DecorationPlacer.prototype, "edgeRouterRegistry", void 0);
      exports.DecorationPlacer = DecorationPlacer = __decorate([
        (0, inversify_1.injectable)()
      ], DecorationPlacer);
    }
  });

  // node_modules/tinyqueue/tinyqueue.js
  var require_tinyqueue = __commonJS({
    "node_modules/tinyqueue/tinyqueue.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.TinyQueue = factory());
      })(exports, function() {
        "use strict";
        var TinyQueue = function TinyQueue2(data, compare) {
          if (data === void 0) data = [];
          if (compare === void 0) compare = defaultCompare;
          this.data = data;
          this.length = this.data.length;
          this.compare = compare;
          if (this.length > 0) {
            for (var i2 = (this.length >> 1) - 1; i2 >= 0; i2--) {
              this._down(i2);
            }
          }
        };
        TinyQueue.prototype.push = function push(item) {
          this.data.push(item);
          this.length++;
          this._up(this.length - 1);
        };
        TinyQueue.prototype.pop = function pop() {
          if (this.length === 0) {
            return void 0;
          }
          var top = this.data[0];
          var bottom = this.data.pop();
          this.length--;
          if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
          }
          return top;
        };
        TinyQueue.prototype.peek = function peek() {
          return this.data[0];
        };
        TinyQueue.prototype._up = function _up(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var item = data[pos];
          while (pos > 0) {
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) {
              break;
            }
            data[pos] = current;
            pos = parent;
          }
          data[pos] = item;
        };
        TinyQueue.prototype._down = function _down(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var halfLength = this.length >> 1;
          var item = data[pos];
          while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var best = data[left];
            var right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
              left = right;
              best = data[right];
            }
            if (compare(best, item) >= 0) {
              break;
            }
            data[pos] = best;
            pos = left;
          }
          data[pos] = item;
        };
        function defaultCompare(a3, b3) {
          return a3 < b3 ? -1 : a3 > b3 ? 1 : 0;
        }
        return TinyQueue;
      });
    }
  });

  // node_modules/sprotty/lib/features/edge-intersection/sweepline.js
  var require_sweepline = __commonJS({
    "node_modules/sprotty/lib/features/edge-intersection/sweepline.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.intersectionOfSegments = exports.getSegmentIndex = exports.checkWhichSegmentHasRightEndpointFirst = exports.runSweep = exports.Segment = exports.SweepEvent = exports.checkWhichEventIsLeft = exports.addRoute = void 0;
      var tinyqueue_1 = __importDefault(require_tinyqueue());
      var geometry_1 = require_geometry2();
      function addRoute(routeId, route, queue) {
        if (route.length < 1)
          return;
        let currentPoint = route[0];
        let nextPoint = void 0;
        for (let i2 = 0; i2 < route.length - 1; i2++) {
          nextPoint = route[i2 + 1];
          const e1 = new SweepEvent(routeId, currentPoint, i2);
          const e2 = new SweepEvent(routeId, nextPoint, i2 + 1);
          e1.otherEvent = e2;
          e2.otherEvent = e1;
          if (checkWhichEventIsLeft(e1, e2) > 0) {
            e2.isLeftEndpoint = true;
            e1.isLeftEndpoint = false;
          } else {
            e1.isLeftEndpoint = true;
            e2.isLeftEndpoint = false;
          }
          queue.push(e1);
          queue.push(e2);
          currentPoint = nextPoint;
        }
      }
      exports.addRoute = addRoute;
      function checkWhichEventIsLeft(e1, e2) {
        if (e1.point.x > e2.point.x)
          return 1;
        if (e1.point.x < e2.point.x)
          return -1;
        if (e1.point.y !== e2.point.y)
          return e1.point.y > e2.point.y ? 1 : -1;
        return 1;
      }
      exports.checkWhichEventIsLeft = checkWhichEventIsLeft;
      var SweepEvent = class {
        constructor(edgeId, point, segmentIndex) {
          this.edgeId = edgeId;
          this.point = point;
          this.segmentIndex = segmentIndex;
        }
      };
      exports.SweepEvent = SweepEvent;
      var Segment = class {
        constructor(event) {
          this.leftSweepEvent = event;
          this.rightSweepEvent = event.otherEvent;
        }
      };
      exports.Segment = Segment;
      function runSweep(eventQueue) {
        const intersectionPoints = [];
        const outQueue = new tinyqueue_1.default([], checkWhichSegmentHasRightEndpointFirst);
        while (eventQueue.length) {
          const event = eventQueue.pop();
          if (event === null || event === void 0 ? void 0 : event.isLeftEndpoint) {
            const segment = new Segment(event);
            for (let i2 = 0; i2 < outQueue.data.length; i2++) {
              const otherSegment = outQueue.data[i2];
              const intersection = intersectionOfSegments(segment, otherSegment);
              if (intersection) {
                intersectionPoints.push({
                  routable1: event.edgeId,
                  routable2: otherSegment.leftSweepEvent.edgeId,
                  segmentIndex1: getSegmentIndex(segment),
                  segmentIndex2: getSegmentIndex(otherSegment),
                  intersectionPoint: intersection
                });
              }
            }
            outQueue.push(segment);
          } else if ((event === null || event === void 0 ? void 0 : event.isLeftEndpoint) === false) {
            outQueue.pop();
          }
        }
        return intersectionPoints;
      }
      exports.runSweep = runSweep;
      function checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {
        if (seg1.rightSweepEvent.point.x > seg2.rightSweepEvent.point.x)
          return 1;
        if (seg1.rightSweepEvent.point.x < seg2.rightSweepEvent.point.x)
          return -1;
        if (seg1.rightSweepEvent.point.y !== seg2.rightSweepEvent.point.y)
          return seg1.rightSweepEvent.point.y < seg2.rightSweepEvent.point.y ? 1 : -1;
        return 1;
      }
      exports.checkWhichSegmentHasRightEndpointFirst = checkWhichSegmentHasRightEndpointFirst;
      function getSegmentIndex(segment) {
        return Math.min(segment.leftSweepEvent.segmentIndex, segment.rightSweepEvent.segmentIndex);
      }
      exports.getSegmentIndex = getSegmentIndex;
      function intersectionOfSegments(seg1, seg2) {
        if (seg1.leftSweepEvent.edgeId === seg2.leftSweepEvent.edgeId) {
          return void 0;
        }
        const seg1Line = new geometry_1.PointToPointLine(seg1.leftSweepEvent.point, seg1.rightSweepEvent.point);
        const seg2Line = new geometry_1.PointToPointLine(seg2.leftSweepEvent.point, seg2.rightSweepEvent.point);
        return seg1Line.intersection(seg2Line);
      }
      exports.intersectionOfSegments = intersectionOfSegments;
    }
  });

  // node_modules/sprotty/lib/features/edge-intersection/intersection-finder.js
  var require_intersection_finder = __commonJS({
    "node_modules/sprotty/lib/features/edge-intersection/intersection-finder.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntersectionFinder = exports.BY_DESCENDING_X_THEN_DESCENDING_Y = exports.BY_X_THEN_DESCENDING_Y = exports.BY_DESCENDING_X_THEN_Y = exports.BY_X_THEN_Y = exports.isIntersectingRoutedPoint = void 0;
      var inversify_1 = require_cjs4();
      var tinyqueue_1 = __importDefault(require_tinyqueue());
      var sweepline_1 = require_sweepline();
      function isIntersectingRoutedPoint(routedPoint) {
        return routedPoint !== void 0 && "intersections" in routedPoint && "kind" in routedPoint;
      }
      exports.isIntersectingRoutedPoint = isIntersectingRoutedPoint;
      var BY_X_THEN_Y = (a3, b3) => {
        if (a3.intersectionPoint.x === b3.intersectionPoint.x) {
          return a3.intersectionPoint.y - b3.intersectionPoint.y;
        }
        return a3.intersectionPoint.x - b3.intersectionPoint.x;
      };
      exports.BY_X_THEN_Y = BY_X_THEN_Y;
      var BY_DESCENDING_X_THEN_Y = (a3, b3) => {
        if (a3.intersectionPoint.x === b3.intersectionPoint.x) {
          return a3.intersectionPoint.y - b3.intersectionPoint.y;
        }
        return b3.intersectionPoint.x - a3.intersectionPoint.x;
      };
      exports.BY_DESCENDING_X_THEN_Y = BY_DESCENDING_X_THEN_Y;
      var BY_X_THEN_DESCENDING_Y = (a3, b3) => {
        if (a3.intersectionPoint.x === b3.intersectionPoint.x) {
          return b3.intersectionPoint.y - a3.intersectionPoint.y;
        }
        return a3.intersectionPoint.x - b3.intersectionPoint.x;
      };
      exports.BY_X_THEN_DESCENDING_Y = BY_X_THEN_DESCENDING_Y;
      var BY_DESCENDING_X_THEN_DESCENDING_Y = (a3, b3) => {
        if (a3.intersectionPoint.x === b3.intersectionPoint.x) {
          return b3.intersectionPoint.y - a3.intersectionPoint.y;
        }
        return b3.intersectionPoint.x - a3.intersectionPoint.x;
      };
      exports.BY_DESCENDING_X_THEN_DESCENDING_Y = BY_DESCENDING_X_THEN_DESCENDING_Y;
      var IntersectionFinder = class IntersectionFinder {
        /**
         * Finds all intersections in the specified `routing` and replaces the `RoutedPoints` that are
         * intersecting by adding intersection information to routing points (@see `IntersectingRoutedPoints`).
         * @param routing the edge routing to find intersections for and update.
         */
        apply(routing) {
          const intersections = this.find(routing);
          this.addToRouting(intersections, routing);
        }
        /**
         * Finds the intersections in the specified `routing` and returns them.
         * @param routing the edge routing to find intersections for and update.
         * @returns the identified intersections.
         */
        find(routing) {
          const eventQueue = new tinyqueue_1.default(void 0, sweepline_1.checkWhichEventIsLeft);
          routing.routes.forEach((route, routeId) => {
            if (this.isSupportedRoute(route)) {
              (0, sweepline_1.addRoute)(routeId, route, eventQueue);
            }
          });
          return (0, sweepline_1.runSweep)(eventQueue);
        }
        /**
         * Specifies whether or not a specific route should be included in this intersection search or not.
         *
         * As this intersection finder only supports linear line segments, this method only returns `true`
         * for routes that only contain routed points, which are either 'source', 'target' or 'linear'.
         */
        isSupportedRoute(route) {
          return route.find((point) => point.kind !== "source" && point.kind !== "target" && point.kind !== "linear") === void 0;
        }
        addToRouting(intersections, routing) {
          for (const intersection of intersections) {
            const routable1 = routing.get(intersection.routable1);
            const routable2 = routing.get(intersection.routable2);
            this.addIntersectionToRoutedPoint(intersection, routable1, intersection.segmentIndex1);
            this.addIntersectionToRoutedPoint(intersection, routable2, intersection.segmentIndex2);
          }
        }
        addIntersectionToRoutedPoint(intersection, routedPoint, segmentIndex) {
          if (routedPoint && routedPoint.length > segmentIndex) {
            const segment = routedPoint[segmentIndex + 1];
            if (isIntersectingRoutedPoint(segment)) {
              segment.intersections.push(intersection);
            } else {
              const intersectingRoutedPoint = Object.assign(Object.assign({}, segment), { intersections: [intersection] });
              routedPoint[segmentIndex + 1] = intersectingRoutedPoint;
            }
          }
        }
      };
      exports.IntersectionFinder = IntersectionFinder;
      exports.IntersectionFinder = IntersectionFinder = __decorate([
        (0, inversify_1.injectable)()
      ], IntersectionFinder);
    }
  });

  // node_modules/sprotty/lib/features/edge-junction/junction-finder.js
  var require_junction_finder = __commonJS({
    "node_modules/sprotty/lib/features/edge-junction/junction-finder.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JunctionFinder = void 0;
      var inversify_1 = require_cjs4();
      var sgraph_1 = require_sgraph();
      var JunctionFinder = class JunctionFinder {
        constructor() {
          this.edgesMap = /* @__PURE__ */ new Map();
          this.sourcesMap = /* @__PURE__ */ new Map();
          this.targetsMap = /* @__PURE__ */ new Map();
        }
        apply(routing, parent) {
          this.findJunctions(routing, parent);
        }
        findJunctions(routing, parent) {
          const edges = Array.from(parent.index.all().filter((child) => child instanceof sgraph_1.SEdgeImpl));
          edges.forEach((edge) => {
            this.edgesMap.set(edge.id, edge);
            const sameSources = this.sourcesMap.get(edge.sourceId);
            if (sameSources) {
              sameSources.add(edge.id);
            } else {
              this.sourcesMap.set(edge.sourceId, /* @__PURE__ */ new Set([edge.id]));
            }
            const sameTargets = this.targetsMap.get(edge.targetId);
            if (sameTargets) {
              sameTargets.add(edge.id);
            } else {
              this.targetsMap.set(edge.targetId, /* @__PURE__ */ new Set([edge.id]));
            }
          });
          routing.routes.forEach((route, routeId) => {
            const edge = this.edgesMap.get(routeId);
            if (!edge) {
              return;
            }
            this.findJunctionPointsWithSameSource(edge, route, routing);
            this.findJunctionPointsWithSameTarget(edge, route, routing);
          });
        }
        /**
         * Finds the junction points of routes with the same source
         */
        findJunctionPointsWithSameSource(edge, route, routing) {
          const sourcesSet = this.sourcesMap.get(edge.sourceId);
          if (!sourcesSet) {
            return;
          }
          const otherRoutesIds = Array.from(sourcesSet).filter((id) => id !== edge.id);
          const otherRoutes = otherRoutesIds.map((id) => routing.get(id)).filter((r3) => r3 !== void 0);
          for (const otherRoute of otherRoutes) {
            const junctionIndex = this.getJunctionIndex(route, otherRoute);
            if (junctionIndex === -1 || junctionIndex === 0) {
              continue;
            }
            this.setJunctionPoints(route, otherRoute, junctionIndex);
          }
        }
        /**
         * Finds the junction points of routes with the same target
         */
        findJunctionPointsWithSameTarget(edge, route, routing) {
          const targetsSet = this.targetsMap.get(edge.targetId);
          if (!targetsSet) {
            return;
          }
          const otherRoutesIds = Array.from(targetsSet).filter((id) => id !== edge.id);
          const otherRoutes = otherRoutesIds.map((id) => routing.get(id)).filter((r3) => r3 !== void 0);
          route.reverse();
          for (const otherRoute of otherRoutes) {
            otherRoute.reverse();
            const junctionIndex = this.getJunctionIndex(route, otherRoute);
            if (junctionIndex === -1 || junctionIndex === 0) {
              continue;
            }
            this.setJunctionPoints(route, otherRoute, junctionIndex);
            otherRoute.reverse();
          }
          route.reverse();
        }
        /**
         * Set the junction points of two routes according to the segments direction.
         * If the segments have different directions, the junction point is the previous common point.
         * If the segments have the same direction, the junction point is the point with the greatest or lowest value axis value depending on the direction.
         */
        setJunctionPoints(route, otherRoute, junctionIndex) {
          const firstSegmentDirection = this.getSegmentDirection(route[junctionIndex - 1], route[junctionIndex]);
          const secondSegmentDirection = this.getSegmentDirection(otherRoute[junctionIndex - 1], otherRoute[junctionIndex]);
          if (firstSegmentDirection !== secondSegmentDirection) {
            this.setPreviousPointAsJunction(route, otherRoute, junctionIndex);
          } else {
            if (firstSegmentDirection === "left" || firstSegmentDirection === "right") {
              if (route[junctionIndex].y !== otherRoute[junctionIndex].y) {
                this.setPreviousPointAsJunction(route, otherRoute, junctionIndex);
                return;
              }
              route[junctionIndex].isJunction = firstSegmentDirection === "left" ? route[junctionIndex].x > otherRoute[junctionIndex].x : route[junctionIndex].x < otherRoute[junctionIndex].x;
              otherRoute[junctionIndex].isJunction = firstSegmentDirection === "left" ? otherRoute[junctionIndex].x > route[junctionIndex].x : otherRoute[junctionIndex].x < route[junctionIndex].x;
            } else {
              if (route[junctionIndex].x !== otherRoute[junctionIndex].x) {
                this.setPreviousPointAsJunction(route, otherRoute, junctionIndex);
                return;
              }
              route[junctionIndex].isJunction = firstSegmentDirection === "up" ? route[junctionIndex].y > otherRoute[junctionIndex].y : route[junctionIndex].y < otherRoute[junctionIndex].y;
              otherRoute[junctionIndex].isJunction = firstSegmentDirection === "up" ? otherRoute[junctionIndex].y > route[junctionIndex].y : otherRoute[junctionIndex].y < route[junctionIndex].y;
            }
          }
        }
        /**
         * Set the previous point as a junction point.
         * This is used when two segments have the same direction but the other axis is different.
         * For example if the routes are going in opposite directions, or if the route don't split orthogonally.
         */
        setPreviousPointAsJunction(route, sameSourceRoute, junctionIndex) {
          route[junctionIndex - 1].isJunction = true;
          sameSourceRoute[junctionIndex - 1].isJunction = true;
        }
        /**
         * Get the main direction of a segment.
         * The main direction is the axis with the greatest difference between the two points.
         */
        getSegmentDirection(firstPoint, secondPoint) {
          const dX = secondPoint.x - firstPoint.x;
          const dY = secondPoint.y - firstPoint.y;
          let mainDirection = "horizontal";
          if (Math.abs(dX) < Math.abs(dY)) {
            mainDirection = "vertical";
          }
          if (mainDirection === "horizontal") {
            if (dX > 0) {
              return "right";
            } else {
              return "left";
            }
          } else {
            if (dY > 0) {
              return "down";
            } else {
              return "up";
            }
          }
        }
        /**
         * Finds the index where two routes diverge.
         * Returns -1 if no divergence can be found.
         */
        getJunctionIndex(firstRoute, secondRoute) {
          let idx = 0;
          while (idx < firstRoute.length && idx < secondRoute.length) {
            if (firstRoute[idx].x !== secondRoute[idx].x || firstRoute[idx].y !== secondRoute[idx].y) {
              return idx;
            }
            idx++;
          }
          return -1;
        }
      };
      exports.JunctionFinder = JunctionFinder;
      exports.JunctionFinder = JunctionFinder = __decorate([
        (0, inversify_1.injectable)()
      ], JunctionFinder);
    }
  });

  // node_modules/sprotty/lib/features/edge-junction/junction-postprocessor.js
  var require_junction_postprocessor = __commonJS({
    "node_modules/sprotty/lib/features/edge-junction/junction-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JunctionPostProcessor = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_protocol_1 = require_lib();
      var types_1 = require_types();
      var model_source_1 = require_model_source();
      var JunctionPostProcessor = class JunctionPostProcessor {
        constructor() {
          this.isFirstRender = true;
        }
        decorate(vnode, element) {
          return vnode;
        }
        postUpdate(cause) {
          if (this.currentModel !== this.modelSource.model) {
            this.isFirstRender = true;
          }
          if ((cause === null || cause === void 0 ? void 0 : cause.kind) === sprotty_protocol_1.RequestBoundsAction.KIND && this.isFirstRender) {
            const junctionPointsInHiddenDiv = document.querySelectorAll(`#${this.viewerOptions.hiddenDiv} > svg > g > g.sprotty-junction`);
            junctionPointsInHiddenDiv.forEach((e2) => e2.remove());
            const junctionPointsInBaseDiv = document.querySelectorAll(`#${this.viewerOptions.baseDiv} > svg > g > g.sprotty-junction`);
            junctionPointsInBaseDiv.forEach((e2) => e2.remove());
          }
          const hiddenSvg = document.querySelector(`#${this.viewerOptions.hiddenDiv} > svg > g`);
          const baseSvg = document.querySelector(`#${this.viewerOptions.baseDiv} > svg > g`);
          if (hiddenSvg) {
            const junctionGroups = Array.from(document.querySelectorAll(`#${this.viewerOptions.hiddenDiv} > svg > g > g > g.sprotty-junction`));
            junctionGroups.forEach((junctionGroup) => {
              junctionGroup.remove();
            });
            hiddenSvg.append(...junctionGroups);
          }
          if (baseSvg) {
            const junctionGroups = Array.from(document.querySelectorAll(`#${this.viewerOptions.baseDiv} > svg > g > g > g.sprotty-junction`));
            junctionGroups.forEach((junctionGroup) => {
              junctionGroup.remove();
            });
            baseSvg.append(...junctionGroups);
          }
          this.currentModel = this.modelSource.model;
          this.isFirstRender = false;
        }
      };
      exports.JunctionPostProcessor = JunctionPostProcessor;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], JunctionPostProcessor.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ModelSource),
        __metadata("design:type", model_source_1.ModelSource)
      ], JunctionPostProcessor.prototype, "modelSource", void 0);
      exports.JunctionPostProcessor = JunctionPostProcessor = __decorate([
        (0, inversify_1.injectable)()
      ], JunctionPostProcessor);
    }
  });

  // node_modules/sprotty/lib/features/move/move.js
  var require_move = __commonJS({
    "node_modules/sprotty/lib/features/move/move.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var MoveCommand_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocationPostprocessor = exports.MoveMouseListener = exports.MorphEdgesAnimation = exports.MoveAnimation = exports.MoveCommand = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var actions_1 = require_actions();
      var animation_1 = require_animation();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var vnode_utils_1 = require_vnode_utils();
      var sgraph_1 = require_sgraph();
      var commit_model_1 = require_commit_model();
      var model_1 = require_model2();
      var create_on_drag_1 = require_create_on_drag();
      var edit_routing_1 = require_edit_routing();
      var reconnect_1 = require_reconnect();
      var model_2 = require_model9();
      var routing_1 = require_routing();
      var model_3 = require_model10();
      var model_4 = require_model6();
      var model_5 = require_model12();
      var model_6 = require_model8();
      var MoveCommand = MoveCommand_1 = class MoveCommand extends command_1.MergeableCommand {
        constructor(action) {
          super();
          this.action = action;
          this.resolvedMoves = /* @__PURE__ */ new Map();
          this.edgeMementi = [];
          this.stoppableCommandKey = MoveCommand_1.KIND;
        }
        // stop the execution of the CompoundAnimation started below
        stopExecution() {
          if (this.animation) {
            this.animation.stop();
            this.animation = void 0;
          }
        }
        execute(context) {
          const index = context.root.index;
          const edge2handleMoves = /* @__PURE__ */ new Map();
          const attachedEdgeShifts = /* @__PURE__ */ new Map();
          this.action.moves.forEach((move) => {
            const element = index.getById(move.elementId);
            if (element instanceof model_2.SRoutingHandleImpl && this.edgeRouterRegistry) {
              const edge = element.parent;
              if (edge instanceof model_2.SRoutableElementImpl) {
                const resolvedMove = this.resolveHandleMove(element, edge, move);
                if (resolvedMove) {
                  let movesByEdge = edge2handleMoves.get(edge);
                  if (!movesByEdge) {
                    movesByEdge = [];
                    edge2handleMoves.set(edge, movesByEdge);
                  }
                  movesByEdge.push(resolvedMove);
                }
              }
            } else if (element && (0, model_6.isLocateable)(element)) {
              const resolvedMove = this.resolveElementMove(element, move);
              if (resolvedMove) {
                this.resolvedMoves.set(resolvedMove.element.id, resolvedMove);
                if (this.edgeRouterRegistry) {
                  const handleEdges = (el) => {
                    index.getAttachedElements(el).forEach((edge) => {
                      if (edge instanceof model_2.SRoutableElementImpl && !this.isChildOfMovedElements(edge)) {
                        const existingDelta = attachedEdgeShifts.get(edge);
                        const newDelta = geometry_1.Point.subtract(resolvedMove.toPosition, resolvedMove.fromPosition);
                        const delta = existingDelta ? geometry_1.Point.linear(existingDelta, newDelta, 0.5) : newDelta;
                        attachedEdgeShifts.set(edge, delta);
                      }
                    });
                  };
                  const handleEdgesForChildren = (el) => {
                    if ((0, smodel_1.isParent)(el)) {
                      el.children.forEach((childEl) => {
                        if (childEl instanceof smodel_1.SModelElementImpl) {
                          if (childEl instanceof model_2.SConnectableElementImpl) {
                            handleEdges(childEl);
                          }
                          handleEdgesForChildren(childEl);
                        }
                      });
                    }
                  };
                  handleEdgesForChildren(element);
                  handleEdges(element);
                }
              }
            }
          });
          this.doMove(edge2handleMoves, attachedEdgeShifts);
          if (this.action.animate) {
            this.undoMove();
            return (this.animation = new animation_1.CompoundAnimation(context.root, context, [
              new MoveAnimation(context.root, this.resolvedMoves, context, false),
              new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)
            ])).start();
          }
          return context.root;
        }
        resolveHandleMove(handle, edge, move) {
          let fromPosition = move.fromPosition;
          if (!fromPosition) {
            const router = this.edgeRouterRegistry.get(edge.routerKind);
            fromPosition = router.getHandlePosition(edge, router.route(edge), handle);
          }
          if (fromPosition)
            return {
              handle,
              fromPosition,
              toPosition: move.toPosition
            };
          return void 0;
        }
        resolveElementMove(element, move) {
          const fromPosition = move.fromPosition || { x: element.position.x, y: element.position.y };
          return {
            element,
            fromPosition,
            toPosition: move.toPosition
          };
        }
        doMove(edge2move, attachedEdgeShifts) {
          this.resolvedMoves.forEach((res) => {
            res.element.position = res.toPosition;
          });
          edge2move.forEach((moves, edge) => {
            const router = this.edgeRouterRegistry.get(edge.routerKind);
            const before = router.takeSnapshot(edge);
            router.applyHandleMoves(edge, moves);
            const after = router.takeSnapshot(edge);
            this.edgeMementi.push({ edge, before, after });
          });
          attachedEdgeShifts.forEach((delta, edge) => {
            if (!edge2move.get(edge)) {
              const router = this.edgeRouterRegistry.get(edge.routerKind);
              const before = router.takeSnapshot(edge);
              if (this.isAttachedEdge(edge)) {
                edge.routingPoints = edge.routingPoints.map((rp) => geometry_1.Point.add(rp, delta));
              } else {
                const updateHandles = (0, model_4.isSelectable)(edge) && edge.selected;
                router.cleanupRoutingPoints(edge, edge.routingPoints, updateHandles, this.action.finished);
              }
              const after = router.takeSnapshot(edge);
              this.edgeMementi.push({ edge, before, after });
            }
          });
        }
        isChildOfMovedElements(el) {
          const parent = el.parent;
          if (Array.from(this.resolvedMoves.values()).map((rm) => rm.element.id).includes(parent.id)) {
            return true;
          }
          if (parent instanceof smodel_1.SChildElementImpl) {
            return this.isChildOfMovedElements(parent);
          }
          return false;
        }
        // tests if the edge is attached to the moved element directly or to on of their children
        isAttachedEdge(edge) {
          const source = edge.source;
          const target = edge.target;
          const checkMovedElementsAndChildren = (sourceOrTarget) => {
            return Boolean(this.resolvedMoves.get(sourceOrTarget.id)) || this.isChildOfMovedElements(sourceOrTarget);
          };
          return Boolean(source && target && checkMovedElementsAndChildren(source) && checkMovedElementsAndChildren(target));
        }
        undoMove() {
          this.resolvedMoves.forEach((res) => {
            res.element.position = res.fromPosition;
          });
          this.edgeMementi.forEach((memento) => {
            const router = this.edgeRouterRegistry.get(memento.edge.routerKind);
            router.applySnapshot(memento.edge, memento.before);
          });
        }
        undo(context) {
          return new animation_1.CompoundAnimation(context.root, context, [
            new MoveAnimation(context.root, this.resolvedMoves, context, true),
            new MorphEdgesAnimation(context.root, this.edgeMementi, context, true)
          ]).start();
        }
        redo(context) {
          return new animation_1.CompoundAnimation(context.root, context, [
            new MoveAnimation(context.root, this.resolvedMoves, context, false),
            new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)
          ]).start();
        }
        merge(other, context) {
          if (!this.action.animate && other instanceof MoveCommand_1) {
            other.resolvedMoves.forEach((otherMove, otherElementId) => {
              const existingMove = this.resolvedMoves.get(otherElementId);
              if (existingMove) {
                existingMove.toPosition = otherMove.toPosition;
              } else {
                this.resolvedMoves.set(otherElementId, otherMove);
              }
            });
            other.edgeMementi.forEach((otherMemento) => {
              const existingMemento = this.edgeMementi.find((edgeMemento) => edgeMemento.edge.id === otherMemento.edge.id);
              if (existingMemento) {
                existingMemento.after = otherMemento.after;
              } else {
                this.edgeMementi.push(otherMemento);
              }
            });
            return true;
          } else if (other instanceof reconnect_1.ReconnectCommand) {
            const otherMemento = other.memento;
            if (otherMemento) {
              const existingMemento = this.edgeMementi.find((edgeMemento) => edgeMemento.edge.id === otherMemento.edge.id);
              if (existingMemento) {
                existingMemento.after = otherMemento.after;
              } else {
                this.edgeMementi.push(otherMemento);
              }
            }
            return true;
          }
          return false;
        }
      };
      exports.MoveCommand = MoveCommand;
      MoveCommand.KIND = actions_1.MoveAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], MoveCommand.prototype, "edgeRouterRegistry", void 0);
      exports.MoveCommand = MoveCommand = MoveCommand_1 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], MoveCommand);
      var MoveAnimation = class extends animation_1.Animation {
        constructor(model, elementMoves, context, reverse = false) {
          super(context);
          this.model = model;
          this.elementMoves = elementMoves;
          this.reverse = reverse;
        }
        tween(t3) {
          this.elementMoves.forEach((elementMove) => {
            if (this.reverse) {
              elementMove.element.position = {
                x: (1 - t3) * elementMove.toPosition.x + t3 * elementMove.fromPosition.x,
                y: (1 - t3) * elementMove.toPosition.y + t3 * elementMove.fromPosition.y
              };
            } else {
              elementMove.element.position = {
                x: (1 - t3) * elementMove.fromPosition.x + t3 * elementMove.toPosition.x,
                y: (1 - t3) * elementMove.fromPosition.y + t3 * elementMove.toPosition.y
              };
            }
          });
          return this.model;
        }
      };
      exports.MoveAnimation = MoveAnimation;
      var MorphEdgesAnimation = class extends animation_1.Animation {
        constructor(model, originalMementi, context, reverse = false) {
          super(context);
          this.model = model;
          this.reverse = reverse;
          this.expanded = [];
          originalMementi.forEach((edgeMemento) => {
            const start = this.reverse ? edgeMemento.after : edgeMemento.before;
            const end = this.reverse ? edgeMemento.before : edgeMemento.after;
            const startRoute = start.routedPoints;
            const endRoute = end.routedPoints;
            const maxRoutingPoints = Math.max(startRoute.length, endRoute.length);
            this.expanded.push({
              startExpandedRoute: this.growToSize(startRoute, maxRoutingPoints),
              endExpandedRoute: this.growToSize(endRoute, maxRoutingPoints),
              memento: edgeMemento
            });
          });
        }
        midPoint(edgeMemento) {
          const edge = edgeMemento.edge;
          const source = edgeMemento.edge.source;
          const target = edgeMemento.edge.target;
          return geometry_1.Point.linear((0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(source.bounds), source.parent, edge.parent), (0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(target.bounds), target.parent, edge.parent), 0.5);
        }
        start() {
          this.expanded.forEach((morph) => {
            morph.memento.edge.removeAll((e2) => e2 instanceof model_2.SRoutingHandleImpl);
          });
          return super.start();
        }
        tween(t3) {
          if (t3 === 1) {
            this.expanded.forEach((morph) => {
              const memento = morph.memento;
              if (this.reverse)
                memento.before.router.applySnapshot(memento.edge, memento.before);
              else
                memento.after.router.applySnapshot(memento.edge, memento.after);
            });
          } else {
            this.expanded.forEach((morph) => {
              const newRoutingPoints = [];
              for (let i2 = 1; i2 < morph.startExpandedRoute.length - 1; ++i2)
                newRoutingPoints.push(geometry_1.Point.linear(morph.startExpandedRoute[i2], morph.endExpandedRoute[i2], t3));
              const closestSnapshot = t3 < 0.5 ? morph.memento.before : morph.memento.after;
              const newSnapshot = Object.assign(Object.assign({}, closestSnapshot), { routingPoints: newRoutingPoints, routingHandles: [] });
              closestSnapshot.router.applySnapshot(morph.memento.edge, newSnapshot);
            });
          }
          return this.model;
        }
        growToSize(route, targetSize) {
          const diff = targetSize - route.length;
          if (diff <= 0)
            return route;
          const result = [];
          result.push(route[0]);
          const deltaDiff = 1 / (diff + 1);
          const deltaSmaller = 1 / (route.length - 1);
          let nextInsertion = 1;
          for (let i2 = 1; i2 < route.length; ++i2) {
            const pos = deltaSmaller * i2;
            let insertions = 0;
            while (pos > (nextInsertion + insertions) * deltaDiff)
              ++insertions;
            nextInsertion += insertions;
            for (let j3 = 0; j3 < insertions; ++j3) {
              const p3 = geometry_1.Point.linear(route[i2 - 1], route[i2], (j3 + 1) / (insertions + 1));
              result.push(p3);
            }
            result.push(route[i2]);
          }
          return result;
        }
      };
      exports.MorphEdgesAnimation = MorphEdgesAnimation;
      var MoveMouseListener = class extends mouse_tool_1.MouseListener {
        constructor() {
          super(...arguments);
          this.hasDragged = false;
          this.elementId2startPos = /* @__PURE__ */ new Map();
        }
        mouseDown(target, event) {
          if (event.button === 0) {
            const moveable = (0, smodel_utils_1.findParentByFeature)(target, model_6.isMoveable);
            const isRoutingHandle = target instanceof model_2.SRoutingHandleImpl;
            if (moveable !== void 0 || isRoutingHandle || (0, create_on_drag_1.isCreatingOnDrag)(target)) {
              this.startDragPosition = { x: event.pageX, y: event.pageY };
            } else {
              this.startDragPosition = void 0;
            }
            this.hasDragged = false;
            if ((0, create_on_drag_1.isCreatingOnDrag)(target)) {
              return this.startCreatingOnDrag(target, event);
            } else if (isRoutingHandle) {
              return this.activateRoutingHandle(target, event);
            }
          }
          return [];
        }
        startCreatingOnDrag(target, event) {
          const result = [];
          result.push(actions_1.SelectAllAction.create({ select: false }));
          result.push(target.createAction(model_2.edgeInProgressID));
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [model_2.edgeInProgressID] }));
          result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [model_2.edgeInProgressID] }));
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [model_2.edgeInProgressTargetHandleID] }));
          result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [model_2.edgeInProgressTargetHandleID] }));
          return result;
        }
        activateRoutingHandle(target, event) {
          return [edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [target.id] })];
        }
        mouseMove(target, event) {
          const result = [];
          if (event.buttons === 0)
            this.mouseUp(target, event);
          else if (this.startDragPosition) {
            if (this.elementId2startPos.size === 0) {
              this.collectStartPositions(target.root);
            }
            this.hasDragged = true;
            const moveAction = this.getElementMoves(target, event, false);
            if (moveAction)
              result.push(moveAction);
          }
          return result;
        }
        collectStartPositions(root) {
          const selectedElements = new Set(root.index.all().filter((element) => (0, model_4.isSelectable)(element) && element.selected));
          selectedElements.forEach((element) => {
            if (!this.isChildOfSelected(selectedElements, element)) {
              if ((0, model_6.isMoveable)(element))
                this.elementId2startPos.set(element.id, element.position);
              else if (element instanceof model_2.SRoutingHandleImpl) {
                const position = this.getHandlePosition(element);
                if (position)
                  this.elementId2startPos.set(element.id, position);
              }
            }
          });
        }
        isChildOfSelected(selectedElements, element) {
          while (element instanceof smodel_1.SChildElementImpl) {
            element = element.parent;
            if ((0, model_6.isMoveable)(element) && selectedElements.has(element)) {
              return true;
            }
          }
          return false;
        }
        getElementMoves(target, event, isFinished) {
          if (!this.startDragPosition)
            return void 0;
          const elementMoves = [];
          const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_5.isViewport);
          const zoom = viewport ? viewport.zoom : 1;
          const delta = {
            x: (event.pageX - this.startDragPosition.x) / zoom,
            y: (event.pageY - this.startDragPosition.y) / zoom
          };
          this.elementId2startPos.forEach((startPosition, elementId) => {
            const element = target.root.index.getById(elementId);
            if (element) {
              const move = this.createElementMove(element, startPosition, delta, event);
              if (move) {
                elementMoves.push(move);
              }
            }
          });
          if (elementMoves.length > 0)
            return actions_1.MoveAction.create(elementMoves, { animate: false, finished: isFinished });
          else
            return void 0;
        }
        createElementMove(element, startPosition, delta, event) {
          const toPosition = this.snap({
            x: startPosition.x + delta.x,
            y: startPosition.y + delta.y
          }, element, !event.shiftKey);
          if ((0, model_6.isMoveable)(element)) {
            return {
              elementId: element.id,
              elementType: element.type,
              fromPosition: {
                x: element.position.x,
                y: element.position.y
              },
              toPosition
            };
          } else if (element instanceof model_2.SRoutingHandleImpl) {
            const point = this.getHandlePosition(element);
            if (point !== void 0) {
              return {
                elementId: element.id,
                elementType: element.type,
                fromPosition: point,
                toPosition
              };
            }
          }
          return void 0;
        }
        snap(position, element, isSnap) {
          if (isSnap && this.snapper)
            return this.snapper.snap(position, element);
          else
            return position;
        }
        getHandlePosition(handle) {
          if (this.edgeRouterRegistry) {
            const parent = handle.parent;
            if (!(parent instanceof model_2.SRoutableElementImpl))
              return void 0;
            const router = this.edgeRouterRegistry.get(parent.routerKind);
            const route = router.route(parent);
            return router.getHandlePosition(parent, route, handle);
          }
          return void 0;
        }
        mouseEnter(target, event) {
          if (target instanceof smodel_1.SModelRootImpl && event.buttons === 0 && !this.startDragPosition)
            this.mouseUp(target, event);
          return [];
        }
        mouseUp(target, event) {
          const result = [];
          if (this.startDragPosition) {
            const moveAction = this.getElementMoves(target, event, true);
            if (moveAction) {
              result.push(moveAction);
            }
            target.root.index.all().forEach((element) => {
              if (element instanceof model_2.SRoutingHandleImpl) {
                result.push(...this.deactivateRoutingHandle(element, target, event));
              }
            });
          }
          if (!result.some((a3) => a3.kind === actions_1.ReconnectAction.KIND)) {
            const edgeInProgress = target.root.index.getById(model_2.edgeInProgressID);
            if (edgeInProgress instanceof smodel_1.SChildElementImpl) {
              result.push(this.deleteEdgeInProgress(edgeInProgress));
            }
          }
          if (this.hasDragged) {
            result.push(commit_model_1.CommitModelAction.create());
          }
          this.hasDragged = false;
          this.startDragPosition = void 0;
          this.elementId2startPos.clear();
          return result;
        }
        deactivateRoutingHandle(element, target, event) {
          const result = [];
          const parent = element.parent;
          if (parent instanceof model_2.SRoutableElementImpl && element.danglingAnchor) {
            const handlePos = this.getHandlePosition(element);
            if (handlePos) {
              const handlePosAbs = (0, smodel_utils_1.translatePoint)(handlePos, element.parent, element.root);
              const newEnd = (0, model_1.findChildrenAtPosition)(target.root, handlePosAbs).find((e2) => (0, model_2.isConnectable)(e2) && e2.canConnect(parent, element.kind));
              if (newEnd && this.hasDragged) {
                result.push(actions_1.ReconnectAction.create({
                  routableId: element.parent.id,
                  newSourceId: element.kind === "source" ? newEnd.id : parent.sourceId,
                  newTargetId: element.kind === "target" ? newEnd.id : parent.targetId
                }));
              }
            }
          }
          if (element.editMode) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: [element.id] }));
          }
          return result;
        }
        deleteEdgeInProgress(edgeInProgress) {
          const deleteIds = [];
          deleteIds.push(model_2.edgeInProgressID);
          edgeInProgress.children.forEach((c3) => {
            if (c3 instanceof model_2.SRoutingHandleImpl && c3.danglingAnchor)
              deleteIds.push(c3.danglingAnchor.id);
          });
          return actions_1.DeleteElementAction.create(deleteIds);
        }
        decorate(vnode, element) {
          return vnode;
        }
      };
      exports.MoveMouseListener = MoveMouseListener;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], MoveMouseListener.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], MoveMouseListener.prototype, "snapper", void 0);
      var LocationPostprocessor = class LocationPostprocessor {
        decorate(vnode, element) {
          if ((0, model_3.isEdgeLayoutable)(element) && element.parent instanceof sgraph_1.SEdgeImpl) {
            return vnode;
          }
          let translate = "";
          if ((0, model_6.isLocateable)(element) && element instanceof smodel_1.SChildElementImpl && element.parent !== void 0) {
            const pos = element.position;
            if (pos.x !== 0 || pos.y !== 0) {
              translate = "translate(" + pos.x + ", " + pos.y + ")";
            }
          }
          if ((0, model_1.isAlignable)(element)) {
            const ali = element.alignment;
            if (ali.x !== 0 || ali.y !== 0) {
              if (translate.length > 0) {
                translate += " ";
              }
              translate += "translate(" + ali.x + ", " + ali.y + ")";
            }
          }
          if (translate.length > 0) {
            (0, vnode_utils_1.setAttr)(vnode, "transform", translate);
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.LocationPostprocessor = LocationPostprocessor;
      exports.LocationPostprocessor = LocationPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], LocationPostprocessor);
    }
  });

  // node_modules/sprotty/lib/features/move/snap.js
  var require_snap = __commonJS({
    "node_modules/sprotty/lib/features/move/snap.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CenterGridSnapper = void 0;
      var inversify_1 = require_cjs4();
      var model_1 = require_model2();
      var CenterGridSnapper = class CenterGridSnapper {
        get gridX() {
          return 10;
        }
        get gridY() {
          return 10;
        }
        snap(position, element) {
          if (element && (0, model_1.isBoundsAware)(element))
            return {
              x: Math.round((position.x + 0.5 * element.bounds.width) / this.gridX) * this.gridX - 0.5 * element.bounds.width,
              y: Math.round((position.y + 0.5 * element.bounds.height) / this.gridY) * this.gridY - 0.5 * element.bounds.height
            };
          else
            return {
              x: Math.round(position.x / this.gridX) * this.gridX,
              y: Math.round(position.y / this.gridY) * this.gridY
            };
        }
      };
      exports.CenterGridSnapper = CenterGridSnapper;
      exports.CenterGridSnapper = CenterGridSnapper = __decorate([
        (0, inversify_1.injectable)()
      ], CenterGridSnapper);
    }
  });

  // node_modules/sprotty/lib/features/open/model.js
  var require_model16 = __commonJS({
    "node_modules/sprotty/lib/features/open/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isOpenable = exports.openFeature = void 0;
      exports.openFeature = Symbol("openFeature");
      function isOpenable(element) {
        return element.hasFeature(exports.openFeature);
      }
      exports.isOpenable = isOpenable;
    }
  });

  // node_modules/sprotty/lib/features/open/open.js
  var require_open = __commonJS({
    "node_modules/sprotty/lib/features/open/open.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OpenMouseListener = void 0;
      var actions_1 = require_actions();
      var mouse_tool_1 = require_mouse_tool();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model16();
      var OpenMouseListener = class extends mouse_tool_1.MouseListener {
        doubleClick(target, event) {
          const openableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_1.isOpenable);
          if (openableTarget !== void 0) {
            return [actions_1.OpenAction.create(openableTarget.id)];
          }
          return [];
        }
      };
      exports.OpenMouseListener = OpenMouseListener;
    }
  });

  // node_modules/sprotty/lib/features/projection/model.js
  var require_model17 = __commonJS({
    "node_modules/sprotty/lib/features/projection/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getModelBounds = exports.getProjectedBounds = exports.getProjections = exports.isProjectable = void 0;
      var geometry_1 = require_geometry();
      var object_1 = require_object();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model2();
      function isProjectable(arg) {
        return (0, object_1.hasOwnProperty)(arg, "projectionCssClasses");
      }
      exports.isProjectable = isProjectable;
      function getProjections(parent) {
        let result;
        for (const child of parent.children) {
          if (isProjectable(child) && child.projectionCssClasses.length > 0) {
            const projectedBounds = getProjectedBounds(child);
            if (projectedBounds) {
              const projection = {
                elementId: child.id,
                projectedBounds,
                cssClasses: child.projectionCssClasses
              };
              if (result) {
                result.push(projection);
              } else {
                result = [projection];
              }
            }
          }
          if (child.children.length > 0) {
            const childProj = getProjections(child);
            if (childProj) {
              if (result) {
                result.push(...childProj);
              } else {
                result = childProj;
              }
            }
          }
        }
        return result;
      }
      exports.getProjections = getProjections;
      function getProjectedBounds(model) {
        const parent = model.parent;
        if (model.projectedBounds) {
          let bounds = model.projectedBounds;
          if ((0, model_1.isBoundsAware)(parent)) {
            bounds = (0, smodel_utils_1.transformToRootBounds)(parent, bounds);
          }
          return bounds;
        } else if ((0, model_1.isBoundsAware)(model)) {
          let bounds = model.bounds;
          bounds = (0, smodel_utils_1.transformToRootBounds)(parent, bounds);
          return bounds;
        }
        return void 0;
      }
      exports.getProjectedBounds = getProjectedBounds;
      var MAX_COORD = 1e9;
      function getModelBounds(model) {
        let minX = MAX_COORD;
        let minY = MAX_COORD;
        let maxX = -MAX_COORD;
        let maxY = -MAX_COORD;
        const bounds = (0, model_1.isBoundsAware)(model) ? model.bounds : void 0;
        if (bounds && geometry_1.Dimension.isValid(bounds)) {
          minX = bounds.x;
          minY = bounds.y;
          maxX = minX + bounds.width;
          maxY = minY + bounds.height;
        } else {
          for (const element of model.children) {
            if ((0, model_1.isBoundsAware)(element)) {
              const b3 = element.bounds;
              minX = Math.min(minX, b3.x);
              minY = Math.min(minY, b3.y);
              maxX = Math.max(maxX, b3.x + b3.width);
              maxY = Math.max(maxY, b3.y + b3.height);
            }
          }
        }
        minX = Math.min(minX, model.scroll.x);
        minY = Math.min(minY, model.scroll.y);
        maxX = Math.max(maxX, model.scroll.x + model.canvasBounds.width / model.zoom);
        maxY = Math.max(maxY, model.scroll.y + model.canvasBounds.height / model.zoom);
        if (minX < maxX && minY < maxY) {
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        }
        return void 0;
      }
      exports.getModelBounds = getModelBounds;
    }
  });

  // node_modules/sprotty/lib/features/projection/views.js
  var require_views4 = __commonJS({
    "node_modules/sprotty/lib/features/projection/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProjectedViewportView = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_cjs4();
      var snabbdom_1 = require_snabbdom_cjs();
      var vnode_utils_1 = require_vnode_utils();
      var model_1 = require_model17();
      var ProjectedViewportView = class ProjectedViewportView {
        render(model, context, args) {
          const rootNode = (0, jsx_1.html)(
            "div",
            { "class-sprotty-root": true },
            this.renderSvg(model, context, args),
            this.renderProjections(model, context, args)
          );
          (0, vnode_utils_1.setAttr)(rootNode, "tabindex", 0);
          return rootNode;
        }
        renderSvg(model, context, args) {
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          const ns = "http://www.w3.org/2000/svg";
          return (0, snabbdom_1.h)("svg", { ns }, (0, snabbdom_1.h)("g", { ns, attrs: { transform } }, context.renderChildren(model)));
        }
        renderProjections(model, context, args) {
          var _a4;
          if (model.zoom <= 0) {
            return [];
          }
          const modelBounds = (0, model_1.getModelBounds)(model);
          if (!modelBounds) {
            return [];
          }
          const projections = (_a4 = (0, model_1.getProjections)(model)) !== null && _a4 !== void 0 ? _a4 : [];
          return [
            this.renderProjectionBar(projections, model, modelBounds, "vertical"),
            this.renderProjectionBar(projections, model, modelBounds, "horizontal")
          ];
        }
        renderProjectionBar(projections, model, modelBounds, orientation) {
          const params = { modelBounds, orientation };
          params.factor = orientation === "horizontal" ? model.canvasBounds.width / modelBounds.width : model.canvasBounds.height / modelBounds.height;
          params.zoomedFactor = params.factor / model.zoom;
          return (0, jsx_1.html)(
            "div",
            { "class-sprotty-projection-bar": true, "class-horizontal": orientation === "horizontal", "class-vertical": orientation === "vertical" },
            this.renderViewport(model, params),
            projections.map((p3) => this.renderProjection(p3, model, params))
          );
        }
        renderViewport(model, params) {
          let canvasSize, viewportPos;
          if (params.orientation === "horizontal") {
            canvasSize = model.canvasBounds.width;
            viewportPos = (model.scroll.x - params.modelBounds.x) * params.factor;
          } else {
            canvasSize = model.canvasBounds.height;
            viewportPos = (model.scroll.y - params.modelBounds.y) * params.factor;
          }
          let viewportSize = canvasSize * params.zoomedFactor;
          if (viewportPos < 0) {
            viewportSize += viewportPos;
            viewportPos = 0;
          } else if (viewportPos > canvasSize) {
            viewportPos = canvasSize;
          }
          if (viewportSize < 0) {
            viewportSize = 0;
          } else if (viewportPos + viewportSize > canvasSize) {
            viewportSize = canvasSize - viewportPos;
          }
          const style = params.orientation === "horizontal" ? {
            left: `${viewportPos}px`,
            width: `${viewportSize}px`
          } : {
            top: `${viewportPos}px`,
            height: `${viewportSize}px`
          };
          return (0, jsx_1.html)("div", { "class-sprotty-viewport": true, style });
        }
        renderProjection(projection, model, params) {
          let canvasSize, projPos, projSize;
          if (params.orientation === "horizontal") {
            canvasSize = model.canvasBounds.width;
            projPos = (projection.projectedBounds.x - params.modelBounds.x) * params.factor;
            projSize = projection.projectedBounds.width * params.factor;
          } else {
            canvasSize = model.canvasBounds.height;
            projPos = (projection.projectedBounds.y - params.modelBounds.y) * params.factor;
            projSize = projection.projectedBounds.height * params.factor;
          }
          if (projPos < 0) {
            projSize += projPos;
            projPos = 0;
          } else if (projPos > canvasSize) {
            projPos = canvasSize;
          }
          if (projSize < 0) {
            projSize = 0;
          } else if (projPos + projSize > canvasSize) {
            projSize = canvasSize - projPos;
          }
          const style = params.orientation === "horizontal" ? {
            left: `${projPos}px`,
            width: `${projSize}px`
          } : {
            top: `${projPos}px`,
            height: `${projSize}px`
          };
          const result = (0, jsx_1.html)("div", { id: `${params.orientation}-projection:${projection.elementId}`, "class-sprotty-projection": true, style });
          projection.cssClasses.forEach((cl) => (0, vnode_utils_1.setClass)(result, cl, true));
          return result;
        }
      };
      exports.ProjectedViewportView = ProjectedViewportView;
      exports.ProjectedViewportView = ProjectedViewportView = __decorate([
        (0, inversify_1.injectable)()
      ], ProjectedViewportView);
    }
  });

  // node_modules/sprotty/lib/features/routing/polyline-anchors.js
  var require_polyline_anchors = __commonJS({
    "node_modules/sprotty/lib/features/routing/polyline-anchors.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiamondAnchor = exports.RectangleAnchor = exports.EllipseAnchor = void 0;
      var anchor_1 = require_anchor();
      var geometry_1 = require_geometry2();
      var inversify_1 = require_cjs4();
      var polyline_edge_router_1 = require_polyline_edge_router();
      var geometry_2 = require_geometry();
      var EllipseAnchor = class EllipseAnchor {
        get kind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND + ":" + anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const bounds = connectable.bounds;
          const c3 = geometry_2.Bounds.center(bounds);
          const dx = c3.x - refPoint.x;
          const dy = c3.y - refPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const normX = dx / distance || 0;
          const normY = dy / distance || 0;
          return {
            x: c3.x - normX * (0.5 * bounds.width + offset),
            y: c3.y - normY * (0.5 * bounds.height + offset)
          };
        }
      };
      exports.EllipseAnchor = EllipseAnchor;
      exports.EllipseAnchor = EllipseAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], EllipseAnchor);
      var RectangleAnchor = class RectangleAnchor {
        get kind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND + ":" + anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const bounds = connectable.bounds;
          const c3 = geometry_2.Bounds.center(bounds);
          const finder = new NearestPointFinder(c3, refPoint);
          if (!(0, geometry_2.almostEquals)(c3.y, refPoint.y)) {
            const xTop = this.getXIntersection(bounds.y, c3, refPoint);
            if (xTop >= bounds.x && xTop <= bounds.x + bounds.width)
              finder.addCandidate(xTop, bounds.y - offset);
            const xBottom = this.getXIntersection(bounds.y + bounds.height, c3, refPoint);
            if (xBottom >= bounds.x && xBottom <= bounds.x + bounds.width)
              finder.addCandidate(xBottom, bounds.y + bounds.height + offset);
          }
          if (!(0, geometry_2.almostEquals)(c3.x, refPoint.x)) {
            const yLeft = this.getYIntersection(bounds.x, c3, refPoint);
            if (yLeft >= bounds.y && yLeft <= bounds.y + bounds.height)
              finder.addCandidate(bounds.x - offset, yLeft);
            const yRight = this.getYIntersection(bounds.x + bounds.width, c3, refPoint);
            if (yRight >= bounds.y && yRight <= bounds.y + bounds.height)
              finder.addCandidate(bounds.x + bounds.width + offset, yRight);
          }
          return finder.best;
        }
        getXIntersection(yIntersection, centerPoint, point) {
          const t3 = (yIntersection - centerPoint.y) / (point.y - centerPoint.y);
          return (point.x - centerPoint.x) * t3 + centerPoint.x;
        }
        getYIntersection(xIntersection, centerPoint, point) {
          const t3 = (xIntersection - centerPoint.x) / (point.x - centerPoint.x);
          return (point.y - centerPoint.y) * t3 + centerPoint.y;
        }
      };
      exports.RectangleAnchor = RectangleAnchor;
      exports.RectangleAnchor = RectangleAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], RectangleAnchor);
      var NearestPointFinder = class {
        constructor(centerPoint, refPoint) {
          this.centerPoint = centerPoint;
          this.refPoint = refPoint;
          this.currentDist = -1;
        }
        addCandidate(x3, y3) {
          const dx = this.refPoint.x - x3;
          const dy = this.refPoint.y - y3;
          const dist = dx * dx + dy * dy;
          if (this.currentDist < 0 || dist < this.currentDist) {
            this.currentBest = {
              x: x3,
              y: y3
            };
            this.currentDist = dist;
          }
        }
        get best() {
          if (this.currentBest === void 0)
            return this.centerPoint;
          else
            return this.currentBest;
        }
      };
      var DiamondAnchor = class DiamondAnchor {
        get kind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND + ":" + anchor_1.DIAMOND_ANCHOR_KIND;
        }
        getAnchor(connectable, refPoint, offset) {
          const bounds = connectable.bounds;
          const referenceLine = new geometry_1.PointToPointLine(geometry_2.Bounds.center(bounds), refPoint);
          const closestDiamondSide = new geometry_1.Diamond(bounds).closestSideLine(refPoint);
          const anchorPoint = (0, geometry_1.intersection)(closestDiamondSide, referenceLine);
          return geometry_2.Point.shiftTowards(anchorPoint, refPoint, offset);
        }
      };
      exports.DiamondAnchor = DiamondAnchor;
      exports.DiamondAnchor = DiamondAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], DiamondAnchor);
    }
  });

  // node_modules/sprotty/lib/features/routing/bezier-edge-router.js
  var require_bezier_edge_router = __commonJS({
    "node_modules/sprotty/lib/features/routing/bezier-edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var BezierEdgeRouter_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AddRemoveBezierSegmentCommand = exports.AddRemoveBezierSegmentAction = exports.BezierMouseListener = exports.BezierEdgeRouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var model_1 = require_model9();
      var routing_1 = require_routing();
      var abstract_edge_router_1 = require_abstract_edge_router();
      var mouse_tool_1 = require_mouse_tool();
      var command_1 = require_command();
      var types_1 = require_types();
      var BezierEdgeRouter = BezierEdgeRouter_1 = class BezierEdgeRouter extends abstract_edge_router_1.AbstractEdgeRouter {
        get kind() {
          return BezierEdgeRouter_1.KIND;
        }
        route(edge) {
          if (!edge.source || !edge.target)
            return [];
          const rpCount = edge.routingPoints.length;
          const source = edge.source;
          const target = edge.target;
          const result = [];
          result.push({ kind: "source", x: 0, y: 0 });
          if (rpCount === 0) {
            const [h1, h22] = this.createDefaultBezierHandles(source.position, target.position);
            result.push({ kind: "bezier-control-after", x: h1.x, y: h1.y, pointIndex: 0 });
            result.push({ kind: "bezier-control-before", x: h22.x, y: h22.y, pointIndex: 1 });
            edge.routingPoints.push(h1);
            edge.routingPoints.push(h22);
          } else if (rpCount >= 2) {
            for (let i2 = 0; i2 < rpCount; i2++) {
              const p3 = edge.routingPoints[i2];
              if (i2 % 3 === 0) {
                result.push({ kind: "bezier-control-after", x: p3.x, y: p3.y, pointIndex: i2 });
              }
              if ((i2 + 1) % 3 === 0) {
                result.push({ kind: "bezier-junction", x: p3.x, y: p3.y, pointIndex: i2 });
              } else if ((i2 + 2) % 3 === 0) {
                result.push({ kind: "bezier-control-before", x: p3.x, y: p3.y, pointIndex: i2 });
              }
            }
          }
          result.push({ kind: "target", x: 0, y: 0 });
          const p0 = rpCount > 2 ? edge.routingPoints[2] : target.position;
          const pn = rpCount > 2 ? edge.routingPoints[edge.routingPoints.length - 3] : source.position;
          const sourceAnchor = this.getTranslatedAnchor(source, p0, target.parent, edge, edge.sourceAnchorCorrection);
          const targetAnchor = this.getTranslatedAnchor(target, pn, source.parent, edge, edge.targetAnchorCorrection);
          result[0] = { kind: "source", x: sourceAnchor.x, y: sourceAnchor.y };
          result[result.length - 1] = { kind: "target", x: targetAnchor.x, y: targetAnchor.y };
          return result;
        }
        createDefaultBezierHandles(relH1, relH2) {
          const h1 = {
            x: relH1.x - BezierEdgeRouter_1.DEFAULT_BEZIER_HANDLE_OFFSET,
            y: relH1.y
          };
          const h22 = {
            x: relH2.x + BezierEdgeRouter_1.DEFAULT_BEZIER_HANDLE_OFFSET,
            y: relH2.y
          };
          return [h1, h22];
        }
        createRoutingHandles(edge) {
          this.route(edge);
          this.rebuildHandles(edge);
        }
        rebuildHandles(edge) {
          this.addHandle(edge, "source", "routing-point", -2);
          this.addHandle(edge, "bezier-control-after", "bezier-routing-point", 0);
          this.addHandle(edge, "bezier-add", "bezier-create-routing-point", 0);
          const rpCount = edge.routingPoints.length;
          if (rpCount > 2) {
            for (let i2 = 1; i2 < rpCount - 1; i2 += 3) {
              this.addHandle(edge, "bezier-control-before", "bezier-routing-point", i2);
              this.addHandle(edge, "bezier-add", "bezier-create-routing-point", i2 + 1);
              this.addHandle(edge, "bezier-junction", "routing-point", i2 + 1);
              this.addHandle(edge, "bezier-remove", "bezier-remove-routing-point", i2 + 1);
              this.addHandle(edge, "bezier-control-after", "bezier-routing-point", i2 + 2);
              this.moveBezierControlPair(edge.routingPoints[i2], i2, edge);
            }
          }
          this.addHandle(edge, "bezier-control-before", "bezier-routing-point", rpCount - 1);
          this.addHandle(edge, "target", "routing-point", -1);
        }
        getInnerHandlePosition(edge, route, handle) {
          if (handle.kind === "bezier-control-before" || handle.kind === "bezier-junction" || handle.kind === "bezier-control-after") {
            for (let i2 = 0; i2 < route.length; i2++) {
              const p3 = route[i2];
              if (p3.pointIndex === handle.pointIndex && p3.kind === handle.kind)
                return p3;
            }
          } else if (handle.kind === "bezier-add") {
            const ctrlPoint = this.findBezierControl(edge, route, handle.pointIndex);
            return { x: ctrlPoint.x, y: ctrlPoint.y + 12.5 };
          } else if (handle.kind === "bezier-remove") {
            const ctrlPoint = this.findBezierControl(edge, route, handle.pointIndex);
            return { x: ctrlPoint.x, y: ctrlPoint.y - 12.5 };
          }
          return void 0;
        }
        findBezierControl(edge, route, handleIndex) {
          let result = { x: route[0].x, y: route[0].y };
          if (handleIndex > 0) {
            for (const rp of route) {
              if (rp.pointIndex !== void 0 && rp.pointIndex === handleIndex && rp.kind === "bezier-junction") {
                result = { x: rp.x, y: rp.y };
                break;
              }
            }
          }
          return result;
        }
        applyHandleMoves(edge, moves) {
          moves.forEach((move) => {
            const handle = move.handle;
            let orgPosition = { x: 0, y: 0 };
            let relativePos, newControlPos, ctrlPointIndex;
            const moveToPos = move.toPosition;
            switch (handle.kind) {
              case "bezier-control-before":
              case "bezier-control-after":
                this.moveBezierControlPair(moveToPos, move.handle.pointIndex, edge);
                break;
              case "bezier-junction":
                const index = handle.pointIndex;
                if (index >= 0 && index < edge.routingPoints.length) {
                  ctrlPointIndex = index - 1;
                  orgPosition = edge.routingPoints[index];
                  relativePos = edge.routingPoints[ctrlPointIndex];
                  newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
                  edge.routingPoints[index] = moveToPos;
                  this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
                }
                break;
              case "source":
                ctrlPointIndex = 0;
                relativePos = edge.routingPoints[ctrlPointIndex];
                if (!(edge.source instanceof model_1.SDanglingAnchorImpl)) {
                  const anchor = new model_1.SDanglingAnchorImpl();
                  anchor.id = edge.id + "_dangling-source";
                  anchor.original = edge.source;
                  anchor.position = move.toPosition;
                  handle.root.add(anchor);
                  handle.danglingAnchor = anchor;
                  edge.sourceId = anchor.id;
                  if (edge.source)
                    orgPosition = edge.source.position;
                } else if (handle.danglingAnchor) {
                  orgPosition = handle.danglingAnchor.position;
                  handle.danglingAnchor.position = moveToPos;
                }
                newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
                this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
                break;
              case "target":
                ctrlPointIndex = edge.routingPoints.length - 1;
                relativePos = edge.routingPoints[ctrlPointIndex];
                if (!(edge.target instanceof model_1.SDanglingAnchorImpl)) {
                  const anchor = new model_1.SDanglingAnchorImpl();
                  anchor.id = edge.id + "_dangling-target";
                  anchor.original = edge.target;
                  anchor.position = moveToPos;
                  handle.root.add(anchor);
                  handle.danglingAnchor = anchor;
                  edge.targetId = anchor.id;
                  if (edge.target)
                    orgPosition = edge.target.position;
                } else if (handle.danglingAnchor) {
                  orgPosition = handle.danglingAnchor.position;
                  handle.danglingAnchor.position = moveToPos;
                }
                newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
                this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
                break;
              default:
                break;
            }
          });
        }
        applyInnerHandleMoves(edge, moves) {
        }
        getOptions(edge) {
          return {
            minimalPointDistance: 2,
            standardDistance: 0.1,
            selfEdgeOffset: 20
          };
        }
        calcRelativeMove(oldPos, newPos, relativePoint) {
          return {
            x: relativePoint.x - (oldPos.x - newPos.x),
            y: relativePoint.y - (oldPos.y - newPos.y)
          };
        }
        createNewBezierSegment(index, edge) {
          const routingPoints = edge.routingPoints;
          let bezierJunctionPos, start, end;
          if (routingPoints.length === 2) {
            start = routingPoints[index < 0 ? 0 : index];
            end = routingPoints[routingPoints.length - 1];
            bezierJunctionPos = (0, geometry_1.centerOfLine)(start, end);
          } else {
            start = routingPoints[index];
            end = routingPoints[index + 2];
            bezierJunctionPos = (0, geometry_1.centerOfLine)(start, end);
          }
          const [h1, h22] = this.createDefaultBezierHandles(bezierJunctionPos, bezierJunctionPos);
          routingPoints.splice(index + 1, 0, h1);
          routingPoints.splice(index + 2, 0, bezierJunctionPos);
          routingPoints.splice(index + 3, 0, h22);
          this.moveBezierControlPair(h1, index + 1, edge);
          edge.removeAll((c3) => c3 instanceof model_1.SRoutingHandleImpl);
          this.rebuildHandles(edge);
        }
        removeBezierSegment(index, edge) {
          const routingPoints = edge.routingPoints;
          routingPoints.splice(index - 1, 3);
          edge.removeAll((c3) => c3 instanceof model_1.SRoutingHandleImpl);
          this.rebuildHandles(edge);
        }
        moveBezierControlPair(newPos, ctrlPointIndex, edge) {
          if (ctrlPointIndex >= 0 && ctrlPointIndex < edge.routingPoints.length) {
            const before = ctrlPointIndex - 1;
            const after = ctrlPointIndex + 1;
            if (before < 0 || after === edge.routingPoints.length) {
              edge.routingPoints[ctrlPointIndex] = newPos;
            } else {
              if (ctrlPointIndex % 3 === 0) {
                this.setBezierMirror(edge, newPos, ctrlPointIndex, false);
              } else if ((ctrlPointIndex + 2) % 3 === 0) {
                this.setBezierMirror(edge, newPos, ctrlPointIndex, true);
              }
            }
          }
        }
        setBezierMirror(edge, newPos, pointIndex, before) {
          edge.routingPoints[pointIndex] = newPos;
          const jct = edge.routingPoints[before ? pointIndex + 1 : pointIndex - 1];
          edge.routingPoints[before ? pointIndex + 2 : pointIndex - 2] = {
            x: jct.x - (newPos.x - jct.x),
            y: jct.y - (newPos.y - jct.y)
          };
        }
      };
      exports.BezierEdgeRouter = BezierEdgeRouter;
      BezierEdgeRouter.KIND = "bezier";
      BezierEdgeRouter.DEFAULT_BEZIER_HANDLE_OFFSET = 25;
      exports.BezierEdgeRouter = BezierEdgeRouter = BezierEdgeRouter_1 = __decorate([
        (0, inversify_1.injectable)()
      ], BezierEdgeRouter);
      var BezierMouseListener = class extends mouse_tool_1.MouseListener {
        mouseDown(target, event) {
          const result = [];
          if (target instanceof model_1.SRoutingHandleImpl && (target.kind === "bezier-add" || target.kind === "bezier-remove")) {
            if (target.type === "bezier-create-routing-point") {
              result.push(AddRemoveBezierSegmentAction.create("add", target.id));
            } else if (target.type === "bezier-remove-routing-point") {
              result.push(AddRemoveBezierSegmentAction.create("remove", target.id));
            }
          }
          return result;
        }
      };
      exports.BezierMouseListener = BezierMouseListener;
      var AddRemoveBezierSegmentAction;
      (function(AddRemoveBezierSegmentAction2) {
        AddRemoveBezierSegmentAction2.KIND = "addRemoveBezierSegment";
        function create(actionTask, targetId) {
          return {
            kind: AddRemoveBezierSegmentAction2.KIND,
            actionTask,
            targetId
          };
        }
        AddRemoveBezierSegmentAction2.create = create;
      })(AddRemoveBezierSegmentAction || (exports.AddRemoveBezierSegmentAction = AddRemoveBezierSegmentAction = {}));
      var AddRemoveBezierSegmentCommand = class AddRemoveBezierSegmentCommand extends command_1.Command {
        constructor(action, edgeRouterRegistry) {
          super();
          this.action = action;
          this.edgeRouterRegistry = edgeRouterRegistry;
        }
        execute(context) {
          const index = context.root.index;
          const target = index.getById(this.action.targetId);
          if (this.edgeRouterRegistry && target instanceof model_1.SRoutingHandleImpl) {
            const raw = this.edgeRouterRegistry.get(target.parent.routerKind);
            if (raw instanceof BezierEdgeRouter) {
              const router = raw;
              for (const child of context.root.children) {
                if (child.id === target.parent.id) {
                  if (this.action.actionTask === "add") {
                    router.createNewBezierSegment(target.pointIndex, child);
                  } else if (this.action.actionTask === "remove") {
                    router.removeBezierSegment(target.pointIndex, child);
                  }
                  break;
                }
              }
            }
          }
          return context.root;
        }
        undo(context) {
          throw new Error("Method not implemented.");
        }
        redo(context) {
          throw new Error("Method not implemented.");
        }
      };
      exports.AddRemoveBezierSegmentCommand = AddRemoveBezierSegmentCommand;
      AddRemoveBezierSegmentCommand.KIND = AddRemoveBezierSegmentAction.KIND;
      exports.AddRemoveBezierSegmentCommand = AddRemoveBezierSegmentCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __param(1, (0, inversify_1.inject)(routing_1.EdgeRouterRegistry)),
        __metadata("design:paramtypes", [Object, routing_1.EdgeRouterRegistry])
      ], AddRemoveBezierSegmentCommand);
    }
  });

  // node_modules/sprotty/lib/features/routing/bezier-anchors.js
  var require_bezier_anchors = __commonJS({
    "node_modules/sprotty/lib/features/routing/bezier-anchors.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BezierDiamondAnchor = exports.BezierRectangleAnchor = exports.BezierEllipseAnchor = void 0;
      var anchor_1 = require_anchor();
      var inversify_1 = require_cjs4();
      var polyline_anchors_1 = require_polyline_anchors();
      var bezier_edge_router_1 = require_bezier_edge_router();
      var BezierEllipseAnchor = class BezierEllipseAnchor extends polyline_anchors_1.EllipseAnchor {
        get kind() {
          return bezier_edge_router_1.BezierEdgeRouter.KIND + ":" + anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
      };
      exports.BezierEllipseAnchor = BezierEllipseAnchor;
      exports.BezierEllipseAnchor = BezierEllipseAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], BezierEllipseAnchor);
      var BezierRectangleAnchor = class BezierRectangleAnchor extends polyline_anchors_1.RectangleAnchor {
        get kind() {
          return bezier_edge_router_1.BezierEdgeRouter.KIND + ":" + anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
      };
      exports.BezierRectangleAnchor = BezierRectangleAnchor;
      exports.BezierRectangleAnchor = BezierRectangleAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], BezierRectangleAnchor);
      var BezierDiamondAnchor = class BezierDiamondAnchor extends polyline_anchors_1.DiamondAnchor {
        get kind() {
          return bezier_edge_router_1.BezierEdgeRouter.KIND + ":" + anchor_1.DIAMOND_ANCHOR_KIND;
        }
      };
      exports.BezierDiamondAnchor = BezierDiamondAnchor;
      exports.BezierDiamondAnchor = BezierDiamondAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], BezierDiamondAnchor);
    }
  });

  // node_modules/sprotty/lib/features/routing/manhattan-edge-router.js
  var require_manhattan_edge_router = __commonJS({
    "node_modules/sprotty/lib/features/routing/manhattan-edge-router.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ManhattanEdgeRouter = void 0;
      var geometry_1 = require_geometry();
      var smodel_utils_1 = require_smodel_utils();
      var abstract_edge_router_1 = require_abstract_edge_router();
      var model_1 = require_model9();
      var ManhattanEdgeRouter = class _ManhattanEdgeRouter extends abstract_edge_router_1.AbstractEdgeRouter {
        get kind() {
          return _ManhattanEdgeRouter.KIND;
        }
        getOptions(edge) {
          return {
            standardDistance: 20,
            minimalPointDistance: 3,
            selfEdgeOffset: 0.25
          };
        }
        route(edge) {
          if (!edge.source || !edge.target)
            return [];
          const routedCorners = this.createRoutedCorners(edge);
          const sourceRefPoint = routedCorners[0] || (0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(edge.target.bounds), edge.target.parent, edge.parent);
          const sourceAnchor = this.getTranslatedAnchor(edge.source, sourceRefPoint, edge.parent, edge, edge.sourceAnchorCorrection);
          const targetRefPoint = routedCorners[routedCorners.length - 1] || (0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(edge.source.bounds), edge.source.parent, edge.parent);
          const targetAnchor = this.getTranslatedAnchor(edge.target, targetRefPoint, edge.parent, edge, edge.targetAnchorCorrection);
          if (!sourceAnchor || !targetAnchor)
            return [];
          const routedPoints = [];
          routedPoints.push(Object.assign({ kind: "source" }, sourceAnchor));
          routedCorners.forEach((corner) => routedPoints.push(corner));
          routedPoints.push(Object.assign({ kind: "target" }, targetAnchor));
          return routedPoints;
        }
        createRoutedCorners(edge) {
          const sourceAnchors = new abstract_edge_router_1.DefaultAnchors(edge.source, edge.parent, "source");
          const targetAnchors = new abstract_edge_router_1.DefaultAnchors(edge.target, edge.parent, "target");
          if (edge.routingPoints.length > 0) {
            const routingPointsCopy = edge.routingPoints.slice();
            this.cleanupRoutingPoints(edge, routingPointsCopy, false, true);
            if (routingPointsCopy.length > 0)
              return routingPointsCopy.map((routingPoint, index) => {
                return Object.assign({ kind: "linear", pointIndex: index }, routingPoint);
              });
          }
          const options = this.getOptions(edge);
          const corners = this.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
          return corners.map((corner) => {
            return Object.assign({ kind: "linear" }, corner);
          });
        }
        createRoutingHandles(edge) {
          const routedPoints = this.route(edge);
          this.commitRoute(edge, routedPoints);
          if (routedPoints.length > 0) {
            this.addHandle(edge, "source", "routing-point", -2);
            for (let i2 = 0; i2 < routedPoints.length - 1; ++i2)
              this.addHandle(edge, "manhattan-50%", "volatile-routing-point", i2 - 1);
            this.addHandle(edge, "target", "routing-point", routedPoints.length - 2);
          }
        }
        getInnerHandlePosition(edge, route, handle) {
          const fraction = this.getFraction(handle.kind);
          if (fraction !== void 0) {
            const { start, end } = this.findRouteSegment(edge, route, handle.pointIndex);
            if (start !== void 0 && end !== void 0)
              return geometry_1.Point.linear(start, end, fraction);
          }
          return void 0;
        }
        getFraction(kind) {
          switch (kind) {
            case "manhattan-50%":
              return 0.5;
            default:
              return void 0;
          }
        }
        applyInnerHandleMoves(edge, moves) {
          const route = this.route(edge);
          const routingPoints = edge.routingPoints;
          const minimalPointDistance = this.getOptions(edge).minimalPointDistance;
          moves.forEach((move) => {
            const handle = move.handle;
            const index = handle.pointIndex;
            const correctedX = this.correctX(routingPoints, index, move.toPosition.x, minimalPointDistance);
            const correctedY = this.correctY(routingPoints, index, move.toPosition.y, minimalPointDistance);
            switch (handle.kind) {
              case "manhattan-50%":
                if (index < 0) {
                  if (routingPoints.length === 0) {
                    routingPoints.push({ x: correctedX, y: correctedY });
                    handle.pointIndex = 0;
                  } else if ((0, geometry_1.almostEquals)(route[0].x, route[1].x)) {
                    this.alignX(routingPoints, 0, correctedX);
                  } else {
                    this.alignY(routingPoints, 0, correctedY);
                  }
                } else if (index < routingPoints.length - 1) {
                  if ((0, geometry_1.almostEquals)(routingPoints[index].x, routingPoints[index + 1].x)) {
                    this.alignX(routingPoints, index, correctedX);
                    this.alignX(routingPoints, index + 1, correctedX);
                  } else {
                    this.alignY(routingPoints, index, correctedY);
                    this.alignY(routingPoints, index + 1, correctedY);
                  }
                } else {
                  if ((0, geometry_1.almostEquals)(route[route.length - 2].x, route[route.length - 1].x)) {
                    this.alignX(routingPoints, routingPoints.length - 1, correctedX);
                  } else {
                    this.alignY(routingPoints, routingPoints.length - 1, correctedY);
                  }
                }
                break;
            }
          });
        }
        correctX(routingPoints, index, x3, minimalPointDistance) {
          if (index > 0 && Math.abs(x3 - routingPoints[index - 1].x) < minimalPointDistance)
            return routingPoints[index - 1].x;
          else if (index < routingPoints.length - 2 && Math.abs(x3 - routingPoints[index + 2].x) < minimalPointDistance)
            return routingPoints[index + 2].x;
          else
            return x3;
        }
        alignX(routingPoints, index, x3) {
          if (index >= 0 && index < routingPoints.length)
            routingPoints[index] = {
              x: x3,
              y: routingPoints[index].y
            };
        }
        correctY(routingPoints, index, y3, minimalPointDistance) {
          if (index > 0 && Math.abs(y3 - routingPoints[index - 1].y) < minimalPointDistance)
            return routingPoints[index - 1].y;
          else if (index < routingPoints.length - 2 && Math.abs(y3 - routingPoints[index + 2].y) < minimalPointDistance)
            return routingPoints[index + 2].y;
          else
            return y3;
        }
        alignY(routingPoints, index, y3) {
          if (index >= 0 && index < routingPoints.length)
            routingPoints[index] = {
              x: routingPoints[index].x,
              y: y3
            };
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          const sourceAnchors = new abstract_edge_router_1.DefaultAnchors(edge.source, edge.parent, "source");
          const targetAnchors = new abstract_edge_router_1.DefaultAnchors(edge.target, edge.parent, "target");
          if (this.resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors))
            return;
          for (let i2 = 0; i2 < routingPoints.length; ++i2)
            if (geometry_1.Bounds.includes(sourceAnchors.bounds, routingPoints[i2])) {
              routingPoints.splice(0, 1);
              if (updateHandles) {
                this.removeHandle(edge, -1);
              }
            } else {
              break;
            }
          for (let i2 = routingPoints.length - 1; i2 >= 0; --i2)
            if (geometry_1.Bounds.includes(targetAnchors.bounds, routingPoints[i2])) {
              routingPoints.splice(i2, 1);
              if (updateHandles) {
                this.removeHandle(edge, i2);
              }
            } else {
              break;
            }
          if (routingPoints.length >= 2) {
            const options = this.getOptions(edge);
            for (let i2 = routingPoints.length - 2; i2 >= 0; --i2) {
              if (geometry_1.Point.manhattanDistance(routingPoints[i2], routingPoints[i2 + 1]) < options.minimalPointDistance) {
                routingPoints.splice(i2, 2);
                --i2;
                if (updateHandles) {
                  this.removeHandle(edge, i2 - 1);
                  this.removeHandle(edge, i2);
                }
              }
            }
          }
          if (addRoutingPoints) {
            this.addAdditionalCorner(edge, routingPoints, sourceAnchors, targetAnchors, updateHandles);
            this.addAdditionalCorner(edge, routingPoints, targetAnchors, sourceAnchors, updateHandles);
            this.manhattanify(edge, routingPoints);
          }
        }
        removeHandle(edge, pointIndex) {
          const toBeRemoved = [];
          edge.children.forEach((child) => {
            if (child instanceof model_1.SRoutingHandleImpl) {
              if (child.pointIndex > pointIndex)
                --child.pointIndex;
              else if (child.pointIndex === pointIndex)
                toBeRemoved.push(child);
            }
          });
          toBeRemoved.forEach((child) => edge.remove(child));
        }
        addAdditionalCorner(edge, routingPoints, currentAnchors, otherAnchors, updateHandles) {
          if (routingPoints.length === 0)
            return;
          const refPoint = currentAnchors.kind === "source" ? routingPoints[0] : routingPoints[routingPoints.length - 1];
          const index = currentAnchors.kind === "source" ? 0 : routingPoints.length;
          const shiftIndex = index - (currentAnchors.kind === "source" ? 1 : 0);
          let isHorizontal;
          if (routingPoints.length > 1) {
            isHorizontal = index === 0 ? (0, geometry_1.almostEquals)(routingPoints[0].x, routingPoints[1].x) : (0, geometry_1.almostEquals)(routingPoints[routingPoints.length - 1].x, routingPoints[routingPoints.length - 2].x);
          } else {
            const nearestSide = otherAnchors.getNearestSide(refPoint);
            isHorizontal = nearestSide === abstract_edge_router_1.Side.TOP || nearestSide === abstract_edge_router_1.Side.BOTTOM;
          }
          if (isHorizontal) {
            if (refPoint.y < currentAnchors.get(abstract_edge_router_1.Side.TOP).y || refPoint.y > currentAnchors.get(abstract_edge_router_1.Side.BOTTOM).y) {
              const newPoint = { x: currentAnchors.get(abstract_edge_router_1.Side.TOP).x, y: refPoint.y };
              routingPoints.splice(index, 0, newPoint);
              if (updateHandles) {
                edge.children.forEach((child) => {
                  if (child instanceof model_1.SRoutingHandleImpl && child.pointIndex >= shiftIndex)
                    ++child.pointIndex;
                });
                this.addHandle(edge, "manhattan-50%", "volatile-routing-point", shiftIndex);
              }
            }
          } else {
            if (refPoint.x < currentAnchors.get(abstract_edge_router_1.Side.LEFT).x || refPoint.x > currentAnchors.get(abstract_edge_router_1.Side.RIGHT).x) {
              const newPoint = { x: refPoint.x, y: currentAnchors.get(abstract_edge_router_1.Side.LEFT).y };
              routingPoints.splice(index, 0, newPoint);
              if (updateHandles) {
                edge.children.forEach((child) => {
                  if (child instanceof model_1.SRoutingHandleImpl && child.pointIndex >= shiftIndex)
                    ++child.pointIndex;
                });
                this.addHandle(edge, "manhattan-50%", "volatile-routing-point", shiftIndex);
              }
            }
          }
        }
        /**
         * Add artificial routing points to keep all angles rectilinear.
         *
         * This makes edge morphing look a lot smoother, where RP positions are interpolated
         * linearly probably resulting in non-rectilinear angles. We don't add handles for
         * these additional RPs.
         */
        manhattanify(edge, routingPoints) {
          for (let i2 = 1; i2 < routingPoints.length; ++i2) {
            const isVertical = Math.abs(routingPoints[i2 - 1].x - routingPoints[i2].x) < 1;
            const isHorizontal = Math.abs(routingPoints[i2 - 1].y - routingPoints[i2].y) < 1;
            if (!isVertical && !isHorizontal) {
              routingPoints.splice(i2, 0, {
                x: routingPoints[i2 - 1].x,
                y: routingPoints[i2].y
              });
              ++i2;
            }
          }
        }
        calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options) {
          const selfEdge = super.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
          if (selfEdge.length > 0)
            return selfEdge;
          const bestAnchors = this.getBestConnectionAnchors(edge, sourceAnchors, targetAnchors, options);
          const sourceSide = bestAnchors.source;
          const targetSide = bestAnchors.target;
          const corners = [];
          const startPoint = sourceAnchors.get(sourceSide);
          let endPoint = targetAnchors.get(targetSide);
          switch (sourceSide) {
            case abstract_edge_router_1.Side.RIGHT:
              switch (targetSide) {
                case abstract_edge_router_1.Side.BOTTOM:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                case abstract_edge_router_1.Side.TOP:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                case abstract_edge_router_1.Side.RIGHT:
                  corners.push({ x: Math.max(startPoint.x, endPoint.x) + 1.5 * options.standardDistance, y: startPoint.y });
                  corners.push({ x: Math.max(startPoint.x, endPoint.x) + 1.5 * options.standardDistance, y: endPoint.y });
                  break;
                case abstract_edge_router_1.Side.LEFT:
                  if (endPoint.y !== startPoint.y) {
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: startPoint.y });
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: endPoint.y });
                  }
                  break;
              }
              break;
            case abstract_edge_router_1.Side.LEFT:
              switch (targetSide) {
                case abstract_edge_router_1.Side.BOTTOM:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                case abstract_edge_router_1.Side.TOP:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                default:
                  endPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
                  if (endPoint.y !== startPoint.y) {
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: startPoint.y });
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: endPoint.y });
                  }
                  break;
              }
              break;
            case abstract_edge_router_1.Side.TOP:
              switch (targetSide) {
                case abstract_edge_router_1.Side.RIGHT:
                  if (endPoint.x - startPoint.x > 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                case abstract_edge_router_1.Side.LEFT:
                  if (endPoint.x - startPoint.x < 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                case abstract_edge_router_1.Side.TOP:
                  corners.push({ x: startPoint.x, y: Math.min(startPoint.y, endPoint.y) - 1.5 * options.standardDistance });
                  corners.push({ x: endPoint.x, y: Math.min(startPoint.y, endPoint.y) - 1.5 * options.standardDistance });
                  break;
                case abstract_edge_router_1.Side.BOTTOM:
                  if (endPoint.x !== startPoint.x) {
                    corners.push({ x: startPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                    corners.push({ x: endPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                  }
                  break;
              }
              break;
            case abstract_edge_router_1.Side.BOTTOM:
              switch (targetSide) {
                case abstract_edge_router_1.Side.RIGHT:
                  if (endPoint.x - startPoint.x > 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                case abstract_edge_router_1.Side.LEFT:
                  if (endPoint.x - startPoint.x < 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                default:
                  endPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
                  if (endPoint.x !== startPoint.x) {
                    corners.push({ x: startPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                    corners.push({ x: endPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                  }
                  break;
              }
              break;
          }
          return corners;
        }
        getBestConnectionAnchors(edge, sourceAnchors, targetAnchors, options) {
          let sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
          let targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (targetPoint.x - sourcePoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.LEFT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (sourcePoint.x - targetPoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.LEFT, target: abstract_edge_router_1.Side.RIGHT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          if (sourcePoint.y - targetPoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.BOTTOM };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (targetPoint.y - sourcePoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.TOP };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (targetPoint.x - sourcePoint.x > 0.5 * options.standardDistance && targetPoint.y - sourcePoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.TOP };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          if (targetPoint.x - sourcePoint.x > 0.5 * options.standardDistance && sourcePoint.y - targetPoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.BOTTOM };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.LEFT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          if (sourcePoint.x - targetPoint.x > 0.5 * options.standardDistance && sourcePoint.y - targetPoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.LEFT, target: abstract_edge_router_1.Side.BOTTOM };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (sourcePoint.x - targetPoint.x > 0.5 * options.standardDistance && targetPoint.y - sourcePoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.LEFT, target: abstract_edge_router_1.Side.TOP };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (sourcePoint.y - targetPoint.y > 0.5 * options.standardDistance && sourcePoint.x - targetPoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (sourcePoint.y - targetPoint.y > 0.5 * options.standardDistance && targetPoint.x - sourcePoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (targetPoint.y - sourcePoint.y > 0.5 * options.standardDistance && sourcePoint.x - targetPoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (targetPoint.y - sourcePoint.y > 0.5 * options.standardDistance && targetPoint.x - sourcePoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint)) {
            if (sourcePoint.y - targetPoint.y < 0) {
              if (Math.abs(sourcePoint.x - targetPoint.x) > (sourceAnchors.bounds.width + options.standardDistance) / 2)
                return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.TOP };
            } else {
              if (Math.abs(sourcePoint.x - targetPoint.x) > targetAnchors.bounds.width / 2)
                return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.TOP };
            }
          }
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint)) {
            if (sourcePoint.x - targetPoint.x > 0) {
              if (Math.abs(sourcePoint.y - targetPoint.y) > (sourceAnchors.bounds.height + options.standardDistance) / 2)
                return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.RIGHT };
            } else if (Math.abs(sourcePoint.y - targetPoint.y) > targetAnchors.bounds.height / 2)
              return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.RIGHT };
          }
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.LEFT };
          return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.BOTTOM };
        }
      };
      exports.ManhattanEdgeRouter = ManhattanEdgeRouter;
      ManhattanEdgeRouter.KIND = "manhattan";
    }
  });

  // node_modules/sprotty/lib/features/routing/manhattan-anchors.js
  var require_manhattan_anchors = __commonJS({
    "node_modules/sprotty/lib/features/routing/manhattan-anchors.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var ManhattanRectangularAnchor_1;
      var ManhattanDiamondAnchor_1;
      var ManhattanEllipticAnchor_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ManhattanEllipticAnchor = exports.ManhattanDiamondAnchor = exports.ManhattanRectangularAnchor = void 0;
      var geometry_1 = require_geometry();
      var geometry_2 = require_geometry2();
      var anchor_1 = require_anchor();
      var manhattan_edge_router_1 = require_manhattan_edge_router();
      var inversify_1 = require_cjs4();
      var ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = class ManhattanRectangularAnchor {
        get kind() {
          return ManhattanRectangularAnchor_1.KIND;
        }
        getAnchor(connectable, refPoint, offset) {
          const b3 = connectable.bounds;
          if (b3.width <= 0 || b3.height <= 0) {
            return b3;
          }
          const bounds = {
            x: b3.x - offset,
            y: b3.y - offset,
            width: b3.width + 2 * offset,
            height: b3.height + 2 * offset
          };
          if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
            if (refPoint.y < bounds.y + 0.5 * bounds.height)
              return { x: refPoint.x, y: bounds.y };
            else
              return { x: refPoint.x, y: bounds.y + bounds.height };
          }
          if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
            if (refPoint.x < bounds.x + 0.5 * bounds.width)
              return { x: bounds.x, y: refPoint.y };
            else
              return { x: bounds.x + bounds.width, y: refPoint.y };
          }
          return geometry_1.Bounds.center(bounds);
        }
      };
      exports.ManhattanRectangularAnchor = ManhattanRectangularAnchor;
      ManhattanRectangularAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ":" + anchor_1.RECTANGULAR_ANCHOR_KIND;
      exports.ManhattanRectangularAnchor = ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ManhattanRectangularAnchor);
      var ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = class ManhattanDiamondAnchor {
        get kind() {
          return ManhattanDiamondAnchor_1.KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const b3 = connectable.bounds;
          if (b3.width <= 0 || b3.height <= 0) {
            return b3;
          }
          const bounds = {
            x: b3.x - offset,
            y: b3.y - offset,
            width: b3.width + 2 * offset,
            height: b3.height + 2 * offset
          };
          const c3 = geometry_1.Bounds.center(bounds);
          let outline = void 0;
          let refLine = void 0;
          if (refPoint.x >= bounds.x && refPoint.x <= bounds.x + bounds.width) {
            if (bounds.x + 0.5 * bounds.width >= refPoint.x) {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: refPoint.x, y: c3.y });
              if (refPoint.y < c3.y)
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c3.y }, { x: c3.x, y: bounds.y });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c3.y }, { x: c3.x, y: bounds.y + bounds.height });
            } else {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: refPoint.x, y: c3.y });
              if (refPoint.y < c3.y)
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c3.y }, { x: c3.x, y: bounds.y });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c3.y }, { x: c3.x, y: bounds.y + bounds.height });
            }
          } else if (refPoint.y >= bounds.y && refPoint.y <= bounds.y + bounds.height) {
            if (bounds.y + 0.5 * bounds.height >= refPoint.y) {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: c3.x, y: refPoint.y });
              if (refPoint.x < c3.x)
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c3.y }, { x: c3.x, y: bounds.y });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c3.y }, { x: c3.x, y: bounds.y });
            } else {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: c3.x, y: refPoint.y });
              if (refPoint.x < c3.x)
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c3.y }, { x: c3.x, y: bounds.y + bounds.height });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c3.y }, { x: c3.x, y: bounds.y + bounds.height });
            }
          }
          if (!!refLine && !!outline)
            return (0, geometry_2.intersection)(outline, refLine);
          else
            return c3;
        }
      };
      exports.ManhattanDiamondAnchor = ManhattanDiamondAnchor;
      ManhattanDiamondAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ":" + anchor_1.DIAMOND_ANCHOR_KIND;
      exports.ManhattanDiamondAnchor = ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ManhattanDiamondAnchor);
      var ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = class ManhattanEllipticAnchor {
        get kind() {
          return ManhattanEllipticAnchor_1.KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const b3 = connectable.bounds;
          if (b3.width <= 0 || b3.height <= 0) {
            return b3;
          }
          const bounds = {
            x: b3.x - offset,
            y: b3.y - offset,
            width: b3.width + 2 * offset,
            height: b3.height + 2 * offset
          };
          const c3 = geometry_1.Bounds.center(bounds);
          const refRelative = geometry_1.Point.subtract(refPoint, c3);
          let x3 = c3.x;
          let y3 = c3.y;
          if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
            x3 += refRelative.x;
            const dy = 0.5 * bounds.height * Math.sqrt(1 - refRelative.x * refRelative.x / (0.25 * bounds.width * bounds.width));
            if (refRelative.y < 0)
              y3 -= dy;
            else
              y3 += dy;
          } else if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
            y3 += refRelative.y;
            const dx = 0.5 * bounds.width * Math.sqrt(1 - refRelative.y * refRelative.y / (0.25 * bounds.height * bounds.height));
            if (refRelative.x < 0)
              x3 -= dx;
            else
              x3 += dx;
          }
          return { x: x3, y: y3 };
        }
      };
      exports.ManhattanEllipticAnchor = ManhattanEllipticAnchor;
      ManhattanEllipticAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ":" + anchor_1.ELLIPTIC_ANCHOR_KIND;
      exports.ManhattanEllipticAnchor = ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ManhattanEllipticAnchor);
    }
  });

  // node_modules/sprotty/lib/features/routing/views.js
  var require_views5 = __commonJS({
    "node_modules/sprotty/lib/features/routing/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RoutableView = void 0;
      var inversify_1 = require_cjs4();
      var model_1 = require_model9();
      var RoutableView = class RoutableView {
        /**
         * Check whether the given model element is in the current viewport. Use this method
         * in your `render` implementation to skip rendering in case the element is not visible.
         * This can greatly enhance performance for large models.
         */
        isVisible(model, route, context) {
          if (context.targetKind === "hidden") {
            return true;
          }
          if (route.length === 0) {
            return true;
          }
          const ab = (0, model_1.getAbsoluteRouteBounds)(model, route);
          const canvasBounds = model.root.canvasBounds;
          return ab.x <= canvasBounds.width && ab.x + ab.width >= 0 && ab.y <= canvasBounds.height && ab.y + ab.height >= 0;
        }
      };
      exports.RoutableView = RoutableView;
      exports.RoutableView = RoutableView = __decorate([
        (0, inversify_1.injectable)()
      ], RoutableView);
    }
  });

  // node_modules/sprotty/lib/base/commands/request-command.js
  var require_request_command = __commonJS({
    "node_modules/sprotty/lib/base/commands/request-command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ModelRequestCommand = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var command_1 = require_command();
      var ModelRequestCommand = class ModelRequestCommand extends command_1.SystemCommand {
        execute(context) {
          const result = this.retrieveResult(context);
          this.actionDispatcher.dispatch(result);
          return { model: context.root, modelChanged: false };
        }
        undo(context) {
          return { model: context.root, modelChanged: false };
        }
        redo(context) {
          return { model: context.root, modelChanged: false };
        }
      };
      exports.ModelRequestCommand = ModelRequestCommand;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ModelRequestCommand.prototype, "actionDispatcher", void 0);
      exports.ModelRequestCommand = ModelRequestCommand = __decorate([
        (0, inversify_1.injectable)()
      ], ModelRequestCommand);
    }
  });

  // node_modules/sprotty/lib/features/viewport/scroll.js
  var require_scroll = __commonJS({
    "node_modules/sprotty/lib/features/viewport/scroll.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findViewportScrollbar = exports.ScrollMouseListener = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var mouse_tool_1 = require_mouse_tool();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model12();
      var model_2 = require_model8();
      var model_3 = require_model9();
      var model_4 = require_model17();
      var browser_1 = require_browser();
      var types_1 = require_types();
      var ScrollMouseListener = class extends mouse_tool_1.MouseListener {
        constructor() {
          super(...arguments);
          this.scrollbarMouseDownDelay = 200;
        }
        mouseDown(target, event) {
          const moveable = (0, smodel_utils_1.findParentByFeature)(target, model_2.isMoveable);
          if (moveable === void 0 && !(target instanceof model_3.SRoutingHandleImpl)) {
            const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
            if (viewport) {
              this.lastScrollPosition = { x: event.pageX, y: event.pageY };
              this.scrollbar = this.getScrollbar(event);
              if (this.scrollbar) {
                window.clearTimeout(this.scrollbarMouseDownTimeout);
                return this.moveScrollBar(viewport, event, this.scrollbar, true).map((action) => new Promise((resolve) => {
                  this.scrollbarMouseDownTimeout = window.setTimeout(() => resolve(action), this.scrollbarMouseDownDelay);
                }));
              }
            } else {
              this.lastScrollPosition = void 0;
              this.scrollbar = void 0;
            }
          }
          return [];
        }
        mouseMove(target, event) {
          if (event.buttons === 0) {
            return this.mouseUp(target, event);
          }
          if (this.scrollbar) {
            window.clearTimeout(this.scrollbarMouseDownTimeout);
            const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
            if (viewport) {
              return this.moveScrollBar(viewport, event, this.scrollbar);
            }
          }
          if (this.lastScrollPosition) {
            const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
            if (viewport) {
              return this.dragCanvas(viewport, event, this.lastScrollPosition);
            }
          }
          return [];
        }
        mouseEnter(target, event) {
          if (target instanceof smodel_1.SModelRootImpl && event.buttons === 0) {
            this.mouseUp(target, event);
          }
          return [];
        }
        mouseUp(target, event) {
          this.lastScrollPosition = void 0;
          this.scrollbar = void 0;
          return [];
        }
        doubleClick(target, event) {
          const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
          if (viewport) {
            const scrollbar = this.getScrollbar(event);
            if (scrollbar) {
              window.clearTimeout(this.scrollbarMouseDownTimeout);
              const targetElement = this.findClickTarget(scrollbar, event);
              let elementId;
              if (targetElement && targetElement.id.startsWith("horizontal-projection:")) {
                elementId = targetElement.id.substring("horizontal-projection:".length);
              } else if (targetElement && targetElement.id.startsWith("vertical-projection:")) {
                elementId = targetElement.id.substring("vertical-projection:".length);
              }
              if (elementId) {
                return [actions_1.CenterAction.create([elementId], { animate: true, retainZoom: true })];
              }
            }
          }
          return [];
        }
        dragCanvas(model, event, lastScrollPosition) {
          let dx = (event.pageX - lastScrollPosition.x) / model.zoom;
          if (dx > 0 && (0, geometry_1.almostEquals)(model.scroll.x, this.viewerOptions.horizontalScrollLimits.min) || dx < 0 && (0, geometry_1.almostEquals)(model.scroll.x, this.viewerOptions.horizontalScrollLimits.max - model.canvasBounds.width / model.zoom)) {
            dx = 0;
          }
          let dy = (event.pageY - lastScrollPosition.y) / model.zoom;
          if (dy > 0 && (0, geometry_1.almostEquals)(model.scroll.y, this.viewerOptions.verticalScrollLimits.min) || dy < 0 && (0, geometry_1.almostEquals)(model.scroll.y, this.viewerOptions.verticalScrollLimits.max - model.canvasBounds.height / model.zoom)) {
            dy = 0;
          }
          if (dx === 0 && dy === 0) {
            return [];
          }
          const newViewport = {
            scroll: {
              x: model.scroll.x - dx,
              y: model.scroll.y - dy
            },
            zoom: model.zoom
          };
          this.lastScrollPosition = { x: event.pageX, y: event.pageY };
          return [actions_1.SetViewportAction.create(model.id, newViewport, { animate: false })];
        }
        moveScrollBar(model, event, scrollbar, animate = false) {
          const modelBounds = (0, model_4.getModelBounds)(model);
          if (!modelBounds || model.zoom <= 0) {
            return [];
          }
          const scrollbarRect = scrollbar.getBoundingClientRect();
          let newScroll;
          if (this.getScrollbarOrientation(scrollbar) === "horizontal") {
            if (scrollbarRect.width <= 0) {
              return [];
            }
            const viewportSize = model.canvasBounds.width / (model.zoom * modelBounds.width) * scrollbarRect.width;
            let position = event.clientX - scrollbarRect.x - viewportSize / 2;
            if (position < 0) {
              position = 0;
            } else if (position > scrollbarRect.width - viewportSize) {
              position = scrollbarRect.width - viewportSize;
            }
            newScroll = {
              x: modelBounds.x + position / scrollbarRect.width * modelBounds.width,
              y: model.scroll.y
            };
            if (newScroll.x < this.viewerOptions.horizontalScrollLimits.min) {
              newScroll.x = this.viewerOptions.horizontalScrollLimits.min;
            } else if (newScroll.x > this.viewerOptions.horizontalScrollLimits.max - model.canvasBounds.width / model.zoom) {
              newScroll.x = this.viewerOptions.horizontalScrollLimits.max - model.canvasBounds.width / model.zoom;
            }
            if ((0, geometry_1.almostEquals)(newScroll.x, model.scroll.x)) {
              return [];
            }
          } else {
            if (scrollbarRect.height <= 0) {
              return [];
            }
            const viewportSize = model.canvasBounds.height / (model.zoom * modelBounds.height) * scrollbarRect.height;
            let position = event.clientY - scrollbarRect.y - viewportSize / 2;
            if (position < 0) {
              position = 0;
            } else if (position > scrollbarRect.height - viewportSize) {
              position = scrollbarRect.height - viewportSize;
            }
            newScroll = {
              x: model.scroll.x,
              y: modelBounds.y + position / scrollbarRect.height * modelBounds.height
            };
            if (newScroll.y < this.viewerOptions.verticalScrollLimits.min) {
              newScroll.y = this.viewerOptions.verticalScrollLimits.min;
            } else if (newScroll.y > this.viewerOptions.verticalScrollLimits.max - model.canvasBounds.height / model.zoom) {
              newScroll.y = this.viewerOptions.verticalScrollLimits.max - model.canvasBounds.height / model.zoom;
            }
            if ((0, geometry_1.almostEquals)(newScroll.y, model.scroll.y)) {
              return [];
            }
          }
          return [actions_1.SetViewportAction.create(model.id, { scroll: newScroll, zoom: model.zoom }, { animate })];
        }
        getScrollbar(event) {
          return findViewportScrollbar(event);
        }
        getScrollbarOrientation(scrollbar) {
          if (scrollbar.classList.contains("horizontal")) {
            return "horizontal";
          } else {
            return "vertical";
          }
        }
        findClickTarget(scrollbar, event) {
          const matching = Array.from(scrollbar.children).filter((child) => child.id && child.classList.contains("sprotty-projection") && (0, browser_1.hitsMouseEvent)(child, event));
          if (matching.length > 0) {
            return matching[matching.length - 1];
          }
          return void 0;
        }
      };
      exports.ScrollMouseListener = ScrollMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ScrollMouseListener.prototype, "viewerOptions", void 0);
      function findViewportScrollbar(event) {
        let element = event.target;
        while (element) {
          if (element.classList && element.classList.contains("sprotty-projection-bar")) {
            return element;
          }
          element = element.parentElement;
        }
        return void 0;
      }
      exports.findViewportScrollbar = findViewportScrollbar;
    }
  });

  // node_modules/sprotty/lib/features/select/select.js
  var require_select = __commonJS({
    "node_modules/sprotty/lib/features/select/select.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectKeyboardListener = exports.GetSelectionCommand = exports.SelectMouseListener = exports.SelectAllCommand = exports.SelectCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var request_command_1 = require_request_command();
      var smodel_1 = require_smodel();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var key_tool_1 = require_key_tool();
      var mouse_tool_1 = require_mouse_tool();
      var vnode_utils_1 = require_vnode_utils();
      var browser_1 = require_browser();
      var iterable_1 = require_iterable();
      var keyboard_1 = require_keyboard();
      var button_handler_1 = require_button_handler();
      var model_1 = require_model4();
      var edit_routing_1 = require_edit_routing();
      var model_2 = require_model9();
      var model_3 = require_model9();
      var scroll_1 = require_scroll();
      var model_4 = require_model6();
      var SelectCommand = class SelectCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.selected = [];
          this.deselected = [];
        }
        execute(context) {
          const model = context.root;
          this.action.selectedElementsIDs.forEach((id) => {
            const element = model.index.getById(id);
            if (element instanceof smodel_1.SChildElementImpl && (0, model_4.isSelectable)(element)) {
              this.selected.push(element);
            }
          });
          this.action.deselectedElementsIDs.forEach((id) => {
            const element = model.index.getById(id);
            if (element instanceof smodel_1.SChildElementImpl && (0, model_4.isSelectable)(element)) {
              this.deselected.push(element);
            }
          });
          return this.redo(context);
        }
        undo(context) {
          for (const element of this.selected) {
            element.selected = false;
          }
          for (const element of this.deselected) {
            element.selected = true;
          }
          return context.root;
        }
        redo(context) {
          for (const element of this.deselected) {
            element.selected = false;
          }
          for (const element of this.selected) {
            element.selected = true;
          }
          return context.root;
        }
      };
      exports.SelectCommand = SelectCommand;
      SelectCommand.KIND = actions_1.SelectAction.KIND;
      exports.SelectCommand = SelectCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SelectCommand);
      var SelectAllCommand = class SelectAllCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.previousSelection = {};
        }
        execute(context) {
          this.selectAll(context.root, this.action.select);
          return context.root;
        }
        selectAll(element, newState) {
          if ((0, model_4.isSelectable)(element)) {
            this.previousSelection[element.id] = element.selected;
            element.selected = newState;
          }
          for (const child of element.children) {
            this.selectAll(child, newState);
          }
        }
        undo(context) {
          const index = context.root.index;
          Object.keys(this.previousSelection).forEach((id) => {
            const element = index.getById(id);
            if (element !== void 0 && (0, model_4.isSelectable)(element))
              element.selected = this.previousSelection[id];
          });
          return context.root;
        }
        redo(context) {
          this.selectAll(context.root, this.action.select);
          return context.root;
        }
      };
      exports.SelectAllCommand = SelectAllCommand;
      SelectAllCommand.KIND = actions_1.SelectAllAction.KIND;
      exports.SelectAllCommand = SelectAllCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SelectAllCommand);
      var SelectMouseListener = class extends mouse_tool_1.MouseListener {
        constructor() {
          super(...arguments);
          this.wasSelected = false;
          this.hasDragged = false;
          this.isMouseDown = false;
        }
        mouseDown(target, event) {
          if (event.button !== 0) {
            return [];
          }
          this.isMouseDown = true;
          const buttonHandled = this.handleButton(target, event);
          if (buttonHandled) {
            return buttonHandled;
          }
          const selectableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_4.isSelectable);
          if (selectableTarget !== void 0 || target instanceof smodel_1.SModelRootImpl) {
            this.hasDragged = false;
          }
          if (selectableTarget !== void 0) {
            let deselectedElements = [];
            if (!(0, browser_1.isCtrlOrCmd)(event)) {
              deselectedElements = this.collectElementsToDeselect(target, selectableTarget);
            }
            if (!selectableTarget.selected) {
              this.wasSelected = false;
              return this.handleSelectTarget(selectableTarget, deselectedElements, event);
            } else if ((0, browser_1.isCtrlOrCmd)(event)) {
              this.wasSelected = false;
              return this.handleDeselectTarget(selectableTarget, event);
            } else {
              this.wasSelected = true;
            }
          }
          return [];
        }
        collectElementsToDeselect(target, selectableTarget) {
          return (0, iterable_1.toArray)(target.root.index.all().filter((element) => (0, model_4.isSelectable)(element) && element.selected && !(selectableTarget instanceof model_2.SRoutingHandleImpl && element === selectableTarget.parent)));
        }
        handleButton(target, event) {
          if (this.buttonHandlerRegistry !== void 0 && target instanceof model_1.SButtonImpl && target.enabled) {
            const buttonHandler = this.buttonHandlerRegistry.get(target.type);
            if (buttonHandler !== void 0) {
              return buttonHandler.buttonPressed(target);
            }
          }
          return void 0;
        }
        handleSelectTarget(selectableTarget, deselectedElements, event) {
          const result = [];
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs: deselectedElements.map((e2) => e2.id) }));
          result.push(actions_1.BringToFrontAction.create([selectableTarget.id]));
          const routableDeselect = deselectedElements.filter((e2) => e2 instanceof model_3.SRoutableElementImpl).map((e2) => e2.id);
          if (selectableTarget instanceof model_3.SRoutableElementImpl) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [selectableTarget.id], elementsToDeactivate: routableDeselect }));
          } else if (routableDeselect.length > 0) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: routableDeselect }));
          }
          return result;
        }
        handleDeselectTarget(selectableTarget, event) {
          const result = [];
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: [selectableTarget.id] }));
          if (selectableTarget instanceof model_3.SRoutableElementImpl) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: [selectableTarget.id] }));
          }
          return result;
        }
        handleDeselectAll(deselectedElements, event) {
          const result = [];
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: deselectedElements.map((e2) => e2.id) }));
          const routableDeselect = deselectedElements.filter((e2) => e2 instanceof model_3.SRoutableElementImpl).map((e2) => e2.id);
          if (routableDeselect.length > 0) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: routableDeselect }));
          }
          return result;
        }
        mouseMove(target, event) {
          this.hasDragged = this.isMouseDown;
          return [];
        }
        mouseUp(target, event) {
          if (event.button === 0) {
            if (!this.hasDragged) {
              const selectableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_4.isSelectable);
              if (selectableTarget !== void 0) {
                if (this.wasSelected) {
                  return [actions_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs: [] })];
                }
              } else if (target instanceof smodel_1.SModelRootImpl && !(0, scroll_1.findViewportScrollbar)(event) || !(target instanceof smodel_1.SModelRootImpl)) {
                return this.handleDeselectAll(this.collectElementsToDeselect(target, void 0), event);
              }
            }
          }
          this.isMouseDown = false;
          this.hasDragged = false;
          return [];
        }
        decorate(vnode, element) {
          const selectableTarget = (0, smodel_utils_1.findParentByFeature)(element, model_4.isSelectable);
          if (selectableTarget !== void 0) {
            (0, vnode_utils_1.setClass)(vnode, "selected", selectableTarget.selected);
          }
          return vnode;
        }
      };
      exports.SelectMouseListener = SelectMouseListener;
      __decorate([
        (0, inversify_1.inject)(button_handler_1.ButtonHandlerRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", button_handler_1.ButtonHandlerRegistry)
      ], SelectMouseListener.prototype, "buttonHandlerRegistry", void 0);
      var GetSelectionCommand = class GetSelectionCommand extends request_command_1.ModelRequestCommand {
        constructor(action) {
          super();
          this.action = action;
          this.previousSelection = {};
        }
        retrieveResult(context) {
          const selection = context.root.index.all().filter((e2) => (0, model_4.isSelectable)(e2) && e2.selected).map((e2) => e2.id);
          return actions_1.SelectionResult.create((0, iterable_1.toArray)(selection), this.action.requestId);
        }
      };
      exports.GetSelectionCommand = GetSelectionCommand;
      GetSelectionCommand.KIND = actions_1.GetSelectionAction.KIND;
      exports.GetSelectionCommand = GetSelectionCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], GetSelectionCommand);
      var SelectKeyboardListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyA", "ctrlCmd")) {
            return [actions_1.SelectAllAction.create()];
          }
          return [];
        }
      };
      exports.SelectKeyboardListener = SelectKeyboardListener;
    }
  });

  // node_modules/sprotty/lib/features/undo-redo/undo-redo.js
  var require_undo_redo = __commonJS({
    "node_modules/sprotty/lib/features/undo-redo/undo-redo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UndoRedoKeyListener = void 0;
      var actions_1 = require_actions();
      var keyboard_1 = require_keyboard();
      var key_tool_1 = require_key_tool();
      var browser_1 = require_browser();
      var UndoRedoKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd"))
            return [actions_1.UndoAction.create()];
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd", "shift") || !(0, browser_1.isMac)() && (0, keyboard_1.matchesKeystroke)(event, "KeyY", "ctrlCmd"))
            return [actions_1.RedoAction.create()];
          return [];
        }
      };
      exports.UndoRedoKeyListener = UndoRedoKeyListener;
    }
  });

  // node_modules/sprotty/lib/features/update/model-matching.js
  var require_model_matching = __commonJS({
    "node_modules/sprotty/lib/features/update/model-matching.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.applyMatches = exports.ModelMatcher = exports.forEachMatch = void 0;
      var smodel_1 = require_smodel();
      var sprotty_protocol_1 = require_lib();
      function forEachMatch(matchResult, callback) {
        Object.keys(matchResult).forEach((id) => callback(id, matchResult[id]));
      }
      exports.forEachMatch = forEachMatch;
      var ModelMatcher = class {
        match(left, right) {
          const result = {};
          this.matchLeft(left, result);
          this.matchRight(right, result);
          return result;
        }
        matchLeft(element, result, parentId) {
          let match = result[element.id];
          if (match !== void 0) {
            match.left = element;
            match.leftParentId = parentId;
          } else {
            match = {
              left: element,
              leftParentId: parentId
            };
            result[element.id] = match;
          }
          if ((0, smodel_1.isParent)(element)) {
            for (const child of element.children) {
              this.matchLeft(child, result, element.id);
            }
          }
        }
        matchRight(element, result, parentId) {
          let match = result[element.id];
          if (match !== void 0) {
            match.right = element;
            match.rightParentId = parentId;
          } else {
            match = {
              right: element,
              rightParentId: parentId
            };
            result[element.id] = match;
          }
          if ((0, smodel_1.isParent)(element)) {
            for (const child of element.children) {
              this.matchRight(child, result, element.id);
            }
          }
        }
      };
      exports.ModelMatcher = ModelMatcher;
      function applyMatches(root, matches, index) {
        if (root instanceof smodel_1.SModelRootImpl) {
          index = root.index;
        } else if (index === void 0) {
          index = new sprotty_protocol_1.SModelIndex();
          index.add(root);
        }
        for (const match of matches) {
          let newElementInserted = false;
          if (match.left !== void 0 && match.leftParentId !== void 0) {
            const parent = index.getById(match.leftParentId);
            if (parent !== void 0 && parent.children !== void 0) {
              const i2 = parent.children.indexOf(match.left);
              if (i2 >= 0) {
                if (match.right !== void 0 && match.leftParentId === match.rightParentId) {
                  parent.children.splice(i2, 1, match.right);
                  newElementInserted = true;
                } else {
                  parent.children.splice(i2, 1);
                }
              }
              index.remove(match.left);
            }
          }
          if (!newElementInserted && match.right !== void 0 && match.rightParentId !== void 0) {
            const parent = index.getById(match.rightParentId);
            if (parent !== void 0) {
              if (parent.children === void 0)
                parent.children = [];
              parent.children.push(match.right);
            }
          }
        }
      }
      exports.applyMatches = applyMatches;
    }
  });

  // node_modules/sprotty/lib/features/bounds/resize.js
  var require_resize = __commonJS({
    "node_modules/sprotty/lib/features/bounds/resize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResizeAnimation = void 0;
      var animation_1 = require_animation();
      var ResizeAnimation = class extends animation_1.Animation {
        constructor(model, elementResizes, context, reverse = false) {
          super(context);
          this.model = model;
          this.elementResizes = elementResizes;
          this.reverse = reverse;
        }
        tween(t3) {
          this.elementResizes.forEach((elementResize) => {
            const element = elementResize.element;
            const newDimension = this.reverse ? {
              width: (1 - t3) * elementResize.toDimension.width + t3 * elementResize.fromDimension.width,
              height: (1 - t3) * elementResize.toDimension.height + t3 * elementResize.fromDimension.height
            } : {
              width: (1 - t3) * elementResize.fromDimension.width + t3 * elementResize.toDimension.width,
              height: (1 - t3) * elementResize.fromDimension.height + t3 * elementResize.toDimension.height
            };
            element.bounds = {
              x: element.bounds.x,
              y: element.bounds.y,
              width: newDimension.width,
              height: newDimension.height
            };
          });
          return this.model;
        }
      };
      exports.ResizeAnimation = ResizeAnimation;
    }
  });

  // node_modules/sprotty/lib/features/update/update-model.js
  var require_update_model = __commonJS({
    "node_modules/sprotty/lib/features/update/update-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UpdateModelCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var animation_1 = require_animation();
      var command_1 = require_command();
      var fade_1 = require_fade();
      var smodel_1 = require_smodel();
      var move_1 = require_move();
      var model_1 = require_model3();
      var model_2 = require_model8();
      var model_3 = require_model2();
      var viewport_root_1 = require_viewport_root();
      var model_4 = require_model6();
      var model_matching_1 = require_model_matching();
      var resize_1 = require_resize();
      var types_1 = require_types();
      var model_5 = require_model12();
      var routing_1 = require_routing();
      var model_6 = require_model9();
      var smodel_utils_1 = require_smodel_utils();
      var UpdateModelCommand = class UpdateModelCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          let newRoot;
          if (this.action.newRoot !== void 0) {
            newRoot = context.modelFactory.createRoot(this.action.newRoot);
          } else {
            newRoot = context.modelFactory.createRoot(context.root);
            if (this.action.matches !== void 0)
              this.applyMatches(newRoot, this.action.matches, context);
          }
          this.oldRoot = context.root;
          this.newRoot = newRoot;
          return this.performUpdate(this.oldRoot, this.newRoot, context);
        }
        performUpdate(oldRoot, newRoot, context) {
          if ((this.action.animate === void 0 || this.action.animate) && oldRoot.id === newRoot.id) {
            let matchResult;
            if (this.action.matches === void 0) {
              const matcher = new model_matching_1.ModelMatcher();
              matchResult = matcher.match(oldRoot, newRoot);
            } else {
              matchResult = this.convertToMatchResult(this.action.matches, oldRoot, newRoot);
            }
            const animationOrRoot = this.computeAnimation(newRoot, matchResult, context);
            if (animationOrRoot instanceof animation_1.Animation)
              return animationOrRoot.start();
            else
              return animationOrRoot;
          } else {
            if (oldRoot.type === newRoot.type && geometry_1.Dimension.isValid(oldRoot.canvasBounds))
              newRoot.canvasBounds = oldRoot.canvasBounds;
            if ((0, model_5.isViewport)(oldRoot) && (0, model_5.isViewport)(newRoot)) {
              newRoot.zoom = oldRoot.zoom;
              newRoot.scroll = oldRoot.scroll;
            }
            return newRoot;
          }
        }
        applyMatches(root, matches, context) {
          const index = root.index;
          for (const match of matches) {
            if (match.left !== void 0) {
              const element = index.getById(match.left.id);
              if (element instanceof smodel_1.SChildElementImpl)
                element.parent.remove(element);
            }
          }
          for (const match of matches) {
            if (match.right !== void 0) {
              const element = context.modelFactory.createElement(match.right);
              let parent;
              if (match.rightParentId !== void 0)
                parent = index.getById(match.rightParentId);
              if (parent instanceof smodel_1.SParentElementImpl)
                parent.add(element);
              else
                root.add(element);
            }
          }
        }
        convertToMatchResult(matches, leftRoot, rightRoot) {
          const result = {};
          for (const match of matches) {
            const converted = {};
            let id = void 0;
            if (match.left !== void 0) {
              id = match.left.id;
              converted.left = leftRoot.index.getById(id);
              converted.leftParentId = match.leftParentId;
            }
            if (match.right !== void 0) {
              id = match.right.id;
              converted.right = rightRoot.index.getById(id);
              converted.rightParentId = match.rightParentId;
            }
            if (id !== void 0)
              result[id] = converted;
          }
          return result;
        }
        computeAnimation(newRoot, matchResult, context) {
          const animationData = {
            fades: []
          };
          (0, model_matching_1.forEachMatch)(matchResult, (id, match) => {
            if (match.left !== void 0 && match.right !== void 0) {
              this.updateElement(match.left, match.right, animationData);
            } else if (match.right !== void 0) {
              const right = match.right;
              if ((0, model_1.isFadeable)(right)) {
                right.opacity = 0;
                animationData.fades.push({
                  element: right,
                  type: "in"
                });
              }
            } else if (match.left instanceof smodel_1.SChildElementImpl) {
              const left = match.left;
              if ((0, model_1.isFadeable)(left) && match.leftParentId !== void 0) {
                if (!(0, smodel_utils_1.containsSome)(newRoot, left)) {
                  const parent = newRoot.index.getById(match.leftParentId);
                  if (parent instanceof smodel_1.SParentElementImpl) {
                    const leftCopy = context.modelFactory.createElement(left);
                    parent.add(leftCopy);
                    animationData.fades.push({
                      element: leftCopy,
                      type: "out"
                    });
                  }
                }
              }
            }
          });
          const animations = this.createAnimations(animationData, newRoot, context);
          if (animations.length >= 2) {
            return new animation_1.CompoundAnimation(newRoot, context, animations);
          } else if (animations.length === 1) {
            return animations[0];
          } else {
            return newRoot;
          }
        }
        updateElement(left, right, animationData) {
          if ((0, model_2.isLocateable)(left) && (0, model_2.isLocateable)(right)) {
            const leftPos = left.position;
            const rightPos = right.position;
            if (!(0, geometry_1.almostEquals)(leftPos.x, rightPos.x) || !(0, geometry_1.almostEquals)(leftPos.y, rightPos.y)) {
              if (animationData.moves === void 0)
                animationData.moves = [];
              animationData.moves.push({
                element: right,
                fromPosition: leftPos,
                toPosition: rightPos
              });
              right.position = leftPos;
            }
          }
          if ((0, model_3.isSizeable)(left) && (0, model_3.isSizeable)(right)) {
            if (!geometry_1.Dimension.isValid(right.bounds)) {
              right.bounds = {
                x: right.bounds.x,
                y: right.bounds.y,
                width: left.bounds.width,
                height: left.bounds.height
              };
            } else if (!(0, geometry_1.almostEquals)(left.bounds.width, right.bounds.width) || !(0, geometry_1.almostEquals)(left.bounds.height, right.bounds.height)) {
              if (animationData.resizes === void 0)
                animationData.resizes = [];
              animationData.resizes.push({
                element: right,
                fromDimension: {
                  width: left.bounds.width,
                  height: left.bounds.height
                },
                toDimension: {
                  width: right.bounds.width,
                  height: right.bounds.height
                }
              });
            }
          }
          if (left instanceof model_6.SRoutableElementImpl && right instanceof model_6.SRoutableElementImpl && this.edgeRouterRegistry) {
            if (animationData.edgeMementi === void 0)
              animationData.edgeMementi = [];
            animationData.edgeMementi.push({
              edge: right,
              before: this.takeSnapshot(left),
              after: this.takeSnapshot(right)
            });
          }
          if ((0, model_4.isSelectable)(left) && (0, model_4.isSelectable)(right)) {
            right.selected = left.selected;
          }
          if (left instanceof smodel_1.SModelRootImpl && right instanceof smodel_1.SModelRootImpl) {
            right.canvasBounds = left.canvasBounds;
          }
          if (left instanceof viewport_root_1.ViewportRootElementImpl && right instanceof viewport_root_1.ViewportRootElementImpl) {
            right.scroll = left.scroll;
            right.zoom = left.zoom;
          }
        }
        takeSnapshot(edge) {
          const router = this.edgeRouterRegistry.get(edge.routerKind);
          return router.takeSnapshot(edge);
        }
        createAnimations(data, root, context) {
          const animations = [];
          if (data.fades.length > 0) {
            animations.push(new fade_1.FadeAnimation(root, data.fades, context, true));
          }
          if (data.moves !== void 0 && data.moves.length > 0) {
            const movesMap = /* @__PURE__ */ new Map();
            for (const move of data.moves) {
              movesMap.set(move.element.id, move);
            }
            animations.push(new move_1.MoveAnimation(root, movesMap, context, false));
          }
          if (data.resizes !== void 0 && data.resizes.length > 0) {
            const resizesMap = /* @__PURE__ */ new Map();
            for (const resize of data.resizes) {
              resizesMap.set(resize.element.id, resize);
            }
            animations.push(new resize_1.ResizeAnimation(root, resizesMap, context, false));
          }
          if (data.edgeMementi !== void 0 && data.edgeMementi.length > 0) {
            animations.push(new move_1.MorphEdgesAnimation(root, data.edgeMementi, context, false));
          }
          return animations;
        }
        undo(context) {
          return this.performUpdate(this.newRoot, this.oldRoot, context);
        }
        redo(context) {
          return this.performUpdate(this.oldRoot, this.newRoot, context);
        }
      };
      exports.UpdateModelCommand = UpdateModelCommand;
      UpdateModelCommand.KIND = actions_1.UpdateModelAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], UpdateModelCommand.prototype, "edgeRouterRegistry", void 0);
      exports.UpdateModelCommand = UpdateModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], UpdateModelCommand);
    }
  });

  // node_modules/sprotty/lib/features/viewport/viewport.js
  var require_viewport = __commonJS({
    "node_modules/sprotty/lib/features/viewport/viewport.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var SetViewportCommand_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewportAnimation = exports.GetViewportCommand = exports.SetViewportCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var command_1 = require_command();
      var animation_1 = require_animation();
      var model_1 = require_model12();
      var types_1 = require_types();
      var request_command_1 = require_request_command();
      var SetViewportCommand = SetViewportCommand_1 = class SetViewportCommand extends command_1.MergeableCommand {
        constructor(action) {
          super();
          this.action = action;
          this.newViewport = action.newViewport;
        }
        execute(context) {
          const model = context.root;
          const element = model.index.getById(this.action.elementId);
          if (element && (0, model_1.isViewport)(element)) {
            this.element = element;
            this.oldViewport = {
              scroll: this.element.scroll,
              zoom: this.element.zoom
            };
            const { zoomLimits, horizontalScrollLimits, verticalScrollLimits } = this.viewerOptions;
            this.newViewport = (0, model_1.limitViewport)(this.newViewport, model.canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits);
            return this.setViewport(element, this.oldViewport, this.newViewport, context);
          }
          return context.root;
        }
        setViewport(element, oldViewport, newViewport, context) {
          if (element && (0, model_1.isViewport)(element)) {
            if (this.action.animate) {
              return new ViewportAnimation(element, oldViewport, newViewport, context).start();
            } else {
              element.scroll = newViewport.scroll;
              element.zoom = newViewport.zoom;
            }
          }
          return context.root;
        }
        undo(context) {
          return this.setViewport(this.element, this.newViewport, this.oldViewport, context);
        }
        redo(context) {
          return this.setViewport(this.element, this.oldViewport, this.newViewport, context);
        }
        merge(command, context) {
          if (!this.action.animate && command instanceof SetViewportCommand_1 && this.element === command.element) {
            this.newViewport = command.newViewport;
            return true;
          }
          return false;
        }
      };
      exports.SetViewportCommand = SetViewportCommand;
      SetViewportCommand.KIND = actions_1.SetViewportAction.KIND;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], SetViewportCommand.prototype, "viewerOptions", void 0);
      exports.SetViewportCommand = SetViewportCommand = SetViewportCommand_1 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetViewportCommand);
      var GetViewportCommand = class GetViewportCommand extends request_command_1.ModelRequestCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        retrieveResult(context) {
          const elem = context.root;
          let viewport;
          if ((0, model_1.isViewport)(elem)) {
            viewport = { scroll: elem.scroll, zoom: elem.zoom };
          } else {
            viewport = { scroll: geometry_1.Point.ORIGIN, zoom: 1 };
          }
          return actions_1.ViewportResult.create(viewport, elem.canvasBounds, this.action.requestId);
        }
      };
      exports.GetViewportCommand = GetViewportCommand;
      GetViewportCommand.KIND = actions_1.GetViewportAction.KIND;
      exports.GetViewportCommand = GetViewportCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], GetViewportCommand);
      var ViewportAnimation = class extends animation_1.Animation {
        constructor(element, oldViewport, newViewport, context) {
          super(context);
          this.element = element;
          this.oldViewport = oldViewport;
          this.newViewport = newViewport;
          this.context = context;
          this.zoomFactor = Math.log(newViewport.zoom / oldViewport.zoom);
        }
        tween(t3, context) {
          this.element.scroll = {
            x: (1 - t3) * this.oldViewport.scroll.x + t3 * this.newViewport.scroll.x,
            y: (1 - t3) * this.oldViewport.scroll.y + t3 * this.newViewport.scroll.y
          };
          this.element.zoom = this.oldViewport.zoom * Math.exp(t3 * this.zoomFactor);
          return context.root;
        }
      };
      exports.ViewportAnimation = ViewportAnimation;
    }
  });

  // node_modules/sprotty/lib/features/viewport/center-fit.js
  var require_center_fit = __commonJS({
    "node_modules/sprotty/lib/features/viewport/center-fit.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CenterKeyboardListener = exports.FitToScreenCommand = exports.CenterCommand = exports.BoundsAwareViewportCommand = void 0;
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var keyboard_1 = require_keyboard();
      var smodel_1 = require_smodel();
      var command_1 = require_command();
      var key_tool_1 = require_key_tool();
      var model_1 = require_model2();
      var model_2 = require_model6();
      var viewport_1 = require_viewport();
      var model_3 = require_model12();
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var BoundsAwareViewportCommand = class BoundsAwareViewportCommand extends command_1.Command {
        constructor(animate) {
          super();
          this.animate = animate;
        }
        initialize(model) {
          if (!(0, model_3.isViewport)(model)) {
            return;
          }
          this.oldViewport = {
            scroll: model.scroll,
            zoom: model.zoom
          };
          const allBounds = [];
          this.getElementIds().forEach((id) => {
            const element = model.index.getById(id);
            if (element && (0, model_1.isBoundsAware)(element)) {
              allBounds.push(this.boundsInViewport(element, element.bounds, model));
            }
          });
          if (allBounds.length === 0) {
            model.index.all().forEach((element) => {
              if ((0, model_2.isSelectable)(element) && element.selected && (0, model_1.isBoundsAware)(element)) {
                allBounds.push(this.boundsInViewport(element, element.bounds, model));
              }
            });
          }
          if (allBounds.length === 0) {
            model.index.all().forEach((element) => {
              if ((0, model_1.isBoundsAware)(element)) {
                allBounds.push(this.boundsInViewport(element, element.bounds, model));
              }
            });
          }
          if (allBounds.length !== 0) {
            const bounds = allBounds.reduce((b0, b1) => geometry_1.Bounds.combine(b0, b1));
            if (geometry_1.Dimension.isValid(bounds)) {
              const newViewport = this.getNewViewport(bounds, model);
              if (newViewport) {
                const { zoomLimits, horizontalScrollLimits, verticalScrollLimits } = this.viewerOptions;
                this.newViewport = (0, model_3.limitViewport)(newViewport, model.canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits);
              }
            }
          }
        }
        boundsInViewport(element, bounds, viewport) {
          if (element instanceof smodel_1.SChildElementImpl && element.parent !== viewport)
            return this.boundsInViewport(element.parent, element.parent.localToParent(bounds), viewport);
          else
            return bounds;
        }
        execute(context) {
          this.initialize(context.root);
          return this.redo(context);
        }
        undo(context) {
          const model = context.root;
          if ((0, model_3.isViewport)(model) && this.newViewport !== void 0 && !this.equal(this.newViewport, this.oldViewport)) {
            if (this.animate)
              return new viewport_1.ViewportAnimation(model, this.newViewport, this.oldViewport, context).start();
            else {
              model.scroll = this.oldViewport.scroll;
              model.zoom = this.oldViewport.zoom;
            }
          }
          return model;
        }
        redo(context) {
          const model = context.root;
          if ((0, model_3.isViewport)(model) && this.newViewport !== void 0 && !this.equal(this.newViewport, this.oldViewport)) {
            if (this.animate) {
              return new viewport_1.ViewportAnimation(model, this.oldViewport, this.newViewport, context).start();
            } else {
              model.scroll = this.newViewport.scroll;
              model.zoom = this.newViewport.zoom;
            }
          }
          return model;
        }
        equal(vp1, vp2) {
          return (0, geometry_1.almostEquals)(vp1.zoom, vp2.zoom) && (0, geometry_1.almostEquals)(vp1.scroll.x, vp2.scroll.x) && (0, geometry_1.almostEquals)(vp1.scroll.y, vp2.scroll.y);
        }
      };
      exports.BoundsAwareViewportCommand = BoundsAwareViewportCommand;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], BoundsAwareViewportCommand.prototype, "viewerOptions", void 0);
      exports.BoundsAwareViewportCommand = BoundsAwareViewportCommand = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [Boolean])
      ], BoundsAwareViewportCommand);
      var CenterCommand = class CenterCommand extends BoundsAwareViewportCommand {
        constructor(action) {
          super(action.animate);
          this.action = action;
        }
        getElementIds() {
          return this.action.elementIds;
        }
        getNewViewport(bounds, model) {
          if (!geometry_1.Dimension.isValid(model.canvasBounds)) {
            return void 0;
          }
          let zoom = 1;
          if (this.action.retainZoom && (0, model_3.isViewport)(model)) {
            zoom = model.zoom;
          } else if (this.action.zoomScale) {
            zoom = this.action.zoomScale;
          }
          const c3 = geometry_1.Bounds.center(bounds);
          return {
            scroll: {
              x: c3.x - 0.5 * model.canvasBounds.width / zoom,
              y: c3.y - 0.5 * model.canvasBounds.height / zoom
            },
            zoom
          };
        }
      };
      exports.CenterCommand = CenterCommand;
      CenterCommand.KIND = actions_1.CenterAction.KIND;
      exports.CenterCommand = CenterCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], CenterCommand);
      var FitToScreenCommand = class FitToScreenCommand extends BoundsAwareViewportCommand {
        constructor(action) {
          super(action.animate);
          this.action = action;
        }
        getElementIds() {
          return this.action.elementIds;
        }
        getNewViewport(bounds, model) {
          if (!geometry_1.Dimension.isValid(model.canvasBounds)) {
            return void 0;
          }
          const c3 = geometry_1.Bounds.center(bounds);
          const delta = this.action.padding === void 0 ? 0 : 2 * this.action.padding;
          let zoom = Math.min(model.canvasBounds.width / (bounds.width + delta), model.canvasBounds.height / (bounds.height + delta));
          if (this.action.maxZoom !== void 0)
            zoom = Math.min(zoom, this.action.maxZoom);
          if (zoom === Infinity) {
            zoom = 1;
          }
          return {
            scroll: {
              x: c3.x - 0.5 * model.canvasBounds.width / zoom,
              y: c3.y - 0.5 * model.canvasBounds.height / zoom
            },
            zoom
          };
        }
      };
      exports.FitToScreenCommand = FitToScreenCommand;
      FitToScreenCommand.KIND = actions_1.FitToScreenAction.KIND;
      exports.FitToScreenCommand = FitToScreenCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], FitToScreenCommand);
      var CenterKeyboardListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyC", "ctrlCmd", "shift"))
            return [actions_1.CenterAction.create([])];
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyF", "ctrlCmd", "shift"))
            return [actions_1.FitToScreenAction.create([])];
          return [];
        }
      };
      exports.CenterKeyboardListener = CenterKeyboardListener;
    }
  });

  // node_modules/sprotty/lib/features/zorder/zorder.js
  var require_zorder = __commonJS({
    "node_modules/sprotty/lib/features/zorder/zorder.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BringToFrontCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var command_1 = require_command();
      var model_1 = require_model9();
      var BringToFrontCommand = class BringToFrontCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.selected = [];
        }
        execute(context) {
          const model = context.root;
          this.action.elementIDs.forEach((id) => {
            const element = model.index.getById(id);
            if (element instanceof model_1.SRoutableElementImpl) {
              if (element.source)
                this.addToSelection(element.source);
              if (element.target)
                this.addToSelection(element.target);
            }
            if (element instanceof smodel_1.SChildElementImpl) {
              this.addToSelection(element);
            }
            this.includeConnectedEdges(element);
          });
          return this.redo(context);
        }
        includeConnectedEdges(element) {
          if (element instanceof model_1.SConnectableElementImpl) {
            element.incomingEdges.forEach((edge) => this.addToSelection(edge));
            element.outgoingEdges.forEach((edge) => this.addToSelection(edge));
          }
          if (element instanceof smodel_1.SParentElementImpl) {
            for (const child of element.children) {
              this.includeConnectedEdges(child);
            }
          }
        }
        addToSelection(element) {
          this.selected.push({
            element,
            index: element.parent.children.indexOf(element)
          });
        }
        undo(context) {
          for (let i2 = this.selected.length - 1; i2 >= 0; i2--) {
            const selection = this.selected[i2];
            const element = selection.element;
            element.parent.move(element, selection.index);
          }
          return context.root;
        }
        redo(context) {
          for (let i2 = 0; i2 < this.selected.length; i2++) {
            this.bringToFront(this.selected[i2]);
          }
          return context.root;
        }
        bringToFront(selection) {
          const element = selection.element;
          const childrenLength = element.parent.children.length;
          element.parent.move(element, childrenLength - 1);
        }
      };
      exports.BringToFrontCommand = BringToFrontCommand;
      BringToFrontCommand.KIND = actions_1.BringToFrontAction.KIND;
      exports.BringToFrontCommand = BringToFrontCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], BringToFrontCommand);
    }
  });

  // node_modules/sprotty/lib/features/bounds/di.config.js
  var require_di_config4 = __commonJS({
    "node_modules/sprotty/lib/features/bounds/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var bounds_manipulation_1 = require_bounds_manipulation();
      var hidden_bounds_updater_1 = require_hidden_bounds_updater();
      var layout_1 = require_layout();
      var command_registration_1 = require_command_registration();
      var hbox_layout_1 = require_hbox_layout();
      var vbox_layout_1 = require_vbox_layout();
      var stack_layout_1 = require_stack_layout();
      var boundsModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, bounds_manipulation_1.SetBoundsCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, bounds_manipulation_1.RequestBoundsCommand);
        bind(hidden_bounds_updater_1.HiddenBoundsUpdater).toSelf().inSingletonScope();
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(hidden_bounds_updater_1.HiddenBoundsUpdater);
        bind(types_1.TYPES.Layouter).to(layout_1.Layouter).inSingletonScope();
        bind(types_1.TYPES.LayoutRegistry).to(layout_1.LayoutRegistry).inSingletonScope();
        (0, layout_1.configureLayout)({ bind, isBound }, vbox_layout_1.VBoxLayouter.KIND, vbox_layout_1.VBoxLayouter);
        (0, layout_1.configureLayout)({ bind, isBound }, hbox_layout_1.HBoxLayouter.KIND, hbox_layout_1.HBoxLayouter);
        (0, layout_1.configureLayout)({ bind, isBound }, stack_layout_1.StackLayouter.KIND, stack_layout_1.StackLayouter);
      });
      exports.default = boundsModule;
    }
  });

  // node_modules/sprotty/lib/features/button/di.config.js
  var require_di_config5 = __commonJS({
    "node_modules/sprotty/lib/features/button/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var button_handler_1 = require_button_handler();
      var buttonModule = new inversify_1.ContainerModule((bind) => {
        bind(button_handler_1.ButtonHandlerRegistry).toSelf().inSingletonScope();
      });
      exports.default = buttonModule;
    }
  });

  // node_modules/sprotty/lib/features/command-palette/di.config.js
  var require_di_config6 = __commonJS({
    "node_modules/sprotty/lib/features/command-palette/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var action_providers_1 = require_action_providers();
      var command_palette_1 = require_command_palette();
      var commandPaletteModule = new inversify_1.ContainerModule((bind) => {
        bind(command_palette_1.CommandPalette).toSelf().inSingletonScope();
        bind(types_1.TYPES.IUIExtension).toService(command_palette_1.CommandPalette);
        bind(command_palette_1.CommandPaletteKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(command_palette_1.CommandPaletteKeyListener);
        bind(action_providers_1.CommandPaletteActionProviderRegistry).toSelf().inSingletonScope();
        bind(types_1.TYPES.ICommandPaletteActionProviderRegistry).toService(action_providers_1.CommandPaletteActionProviderRegistry);
      });
      exports.default = commandPaletteModule;
    }
  });

  // node_modules/sprotty/lib/features/context-menu/di.config.js
  var require_di_config7 = __commonJS({
    "node_modules/sprotty/lib/features/context-menu/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var menu_providers_1 = require_menu_providers();
      var mouse_listener_1 = require_mouse_listener();
      var types_1 = require_types();
      var contextMenuModule = new inversify_1.ContainerModule((bind) => {
        bind(types_1.TYPES.IContextMenuServiceProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve, reject) => {
              if (ctx.container.isBound(types_1.TYPES.IContextMenuService)) {
                resolve(ctx.container.get(types_1.TYPES.IContextMenuService));
              } else {
                reject();
              }
            });
          };
        });
        bind(mouse_listener_1.ContextMenuMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(mouse_listener_1.ContextMenuMouseListener);
        bind(types_1.TYPES.IContextMenuProviderRegistry).to(menu_providers_1.ContextMenuProviderRegistry);
      });
      exports.default = contextMenuModule;
    }
  });

  // node_modules/sprotty/lib/features/decoration/di.config.js
  var require_di_config8 = __commonJS({
    "node_modules/sprotty/lib/features/decoration/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var view_1 = require_view();
      var inversify_1 = require_cjs4();
      var model_1 = require_model15();
      var views_1 = require_views3();
      var types_1 = require_types();
      var decoration_placer_1 = require_decoration_placer();
      var decorationModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, view_1.configureModelElement)({ bind, isBound }, "marker", model_1.SIssueMarkerImpl, views_1.IssueMarkerView);
        bind(decoration_placer_1.DecorationPlacer).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(decoration_placer_1.DecorationPlacer);
      });
      exports.default = decorationModule;
    }
  });

  // node_modules/sprotty/lib/features/edge-intersection/di.config.js
  var require_di_config9 = __commonJS({
    "node_modules/sprotty/lib/features/edge-intersection/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var intersection_finder_1 = require_intersection_finder();
      var edgeIntersectionModule = new inversify_1.ContainerModule((bind) => {
        bind(intersection_finder_1.IntersectionFinder).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRoutePostprocessor).toService(intersection_finder_1.IntersectionFinder);
      });
      exports.default = edgeIntersectionModule;
    }
  });

  // node_modules/sprotty/lib/features/edge-junction/di.config.js
  var require_di_config10 = __commonJS({
    "node_modules/sprotty/lib/features/edge-junction/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var junction_finder_1 = require_junction_finder();
      var junction_postprocessor_1 = require_junction_postprocessor();
      var edgeJunctionModule = new inversify_1.ContainerModule((bind) => {
        bind(junction_finder_1.JunctionFinder).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRoutePostprocessor).toService(junction_finder_1.JunctionFinder);
        bind(junction_postprocessor_1.JunctionPostProcessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(junction_postprocessor_1.JunctionPostProcessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(junction_postprocessor_1.JunctionPostProcessor);
      });
      exports.default = edgeJunctionModule;
    }
  });

  // node_modules/sprotty/lib/features/expand/di.config.js
  var require_di_config11 = __commonJS({
    "node_modules/sprotty/lib/features/expand/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var button_handler_1 = require_button_handler();
      var expand_1 = require_expand();
      var expandModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, button_handler_1.configureButtonHandler)({ bind, isBound }, expand_1.ExpandButtonHandler.TYPE, expand_1.ExpandButtonHandler);
      });
      exports.default = expandModule;
    }
  });

  // node_modules/sprotty/lib/features/export/di.config.js
  var require_di_config12 = __commonJS({
    "node_modules/sprotty/lib/features/export/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var export_1 = require_export();
      var svg_exporter_1 = require_svg_exporter();
      var command_registration_1 = require_command_registration();
      var exportSvgModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(export_1.ExportSvgKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(export_1.ExportSvgKeyListener);
        bind(export_1.ExportSvgPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(export_1.ExportSvgPostprocessor);
        (0, command_registration_1.configureCommand)({ bind, isBound }, export_1.ExportSvgCommand);
        bind(types_1.TYPES.SvgExporter).to(svg_exporter_1.SvgExporter).inSingletonScope();
      });
      exports.default = exportSvgModule;
    }
  });

  // node_modules/sprotty/lib/features/fade/di.config.js
  var require_di_config13 = __commonJS({
    "node_modules/sprotty/lib/features/fade/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var fade_1 = require_fade();
      var fadeModule = new inversify_1.ContainerModule((bind) => {
        bind(fade_1.ElementFader).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(fade_1.ElementFader);
      });
      exports.default = fadeModule;
    }
  });

  // node_modules/sprotty/lib/features/hover/popup-position-updater.js
  var require_popup_position_updater = __commonJS({
    "node_modules/sprotty/lib/features/hover/popup-position-updater.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PopupPositionUpdater = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var PopupPositionUpdater = class PopupPositionUpdater {
        decorate(vnode, element) {
          return vnode;
        }
        postUpdate() {
          const popupDiv = document.getElementById(this.options.popupDiv);
          if (popupDiv !== null && typeof window !== "undefined") {
            const boundingClientRect = popupDiv.getBoundingClientRect();
            if (window.innerHeight < boundingClientRect.height + boundingClientRect.top) {
              popupDiv.style.top = window.pageYOffset + window.innerHeight - boundingClientRect.height - 5 + "px";
            }
            if (window.innerWidth < boundingClientRect.left + boundingClientRect.width) {
              popupDiv.style.left = window.pageXOffset + window.innerWidth - boundingClientRect.width - 5 + "px";
            }
            if (boundingClientRect.left < 0) {
              popupDiv.style.left = "0px";
            }
            if (boundingClientRect.top < 0) {
              popupDiv.style.top = "0px";
            }
          }
        }
      };
      exports.PopupPositionUpdater = PopupPositionUpdater;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], PopupPositionUpdater.prototype, "options", void 0);
      exports.PopupPositionUpdater = PopupPositionUpdater = __decorate([
        (0, inversify_1.injectable)()
      ], PopupPositionUpdater);
    }
  });

  // node_modules/sprotty/lib/features/hover/di.config.js
  var require_di_config14 = __commonJS({
    "node_modules/sprotty/lib/features/hover/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var hover_1 = require_hover();
      var popup_position_updater_1 = require_popup_position_updater();
      var command_registration_1 = require_command_registration();
      var action_handler_1 = require_action_handler();
      var center_fit_1 = require_center_fit();
      var viewport_1 = require_viewport();
      var move_1 = require_move();
      var hoverModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(popup_position_updater_1.PopupPositionUpdater).toSelf().inSingletonScope();
        bind(types_1.TYPES.PopupVNodePostprocessor).toService(popup_position_updater_1.PopupPositionUpdater);
        bind(hover_1.HoverMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(hover_1.HoverMouseListener);
        bind(hover_1.PopupHoverMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.PopupMouseListener).toService(hover_1.PopupHoverMouseListener);
        bind(hover_1.HoverKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(hover_1.HoverKeyListener);
        bind(types_1.TYPES.HoverState).toConstantValue({
          mouseOverTimer: void 0,
          mouseOutTimer: void 0,
          popupOpen: false,
          previousPopupElement: void 0
        });
        bind(hover_1.ClosePopupActionHandler).toSelf().inSingletonScope();
        const context = { bind, isBound };
        (0, command_registration_1.configureCommand)(context, hover_1.HoverFeedbackCommand);
        (0, command_registration_1.configureCommand)(context, hover_1.SetPopupModelCommand);
        (0, action_handler_1.configureActionHandler)(context, hover_1.SetPopupModelCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, center_fit_1.FitToScreenCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, center_fit_1.CenterCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, viewport_1.SetViewportCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, move_1.MoveCommand.KIND, hover_1.ClosePopupActionHandler);
      });
      exports.default = hoverModule;
    }
  });

  // node_modules/sprotty/lib/features/move/di.config.js
  var require_di_config15 = __commonJS({
    "node_modules/sprotty/lib/features/move/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var move_1 = require_move();
      var command_registration_1 = require_command_registration();
      var moveModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(move_1.MoveMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(move_1.MoveMouseListener);
        (0, command_registration_1.configureCommand)({ bind, isBound }, move_1.MoveCommand);
        bind(move_1.LocationPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(move_1.LocationPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(move_1.LocationPostprocessor);
      });
      exports.default = moveModule;
    }
  });

  // node_modules/sprotty/lib/features/open/di.config.js
  var require_di_config16 = __commonJS({
    "node_modules/sprotty/lib/features/open/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var open_1 = require_open();
      var openModule = new inversify_1.ContainerModule((bind) => {
        bind(open_1.OpenMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(open_1.OpenMouseListener);
      });
      exports.default = openModule;
    }
  });

  // node_modules/sprotty/lib/features/routing/di.config.js
  var require_di_config17 = __commonJS({
    "node_modules/sprotty/lib/features/routing/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var manhattan_edge_router_1 = require_manhattan_edge_router();
      var polyline_edge_router_1 = require_polyline_edge_router();
      var manhattan_anchors_1 = require_manhattan_anchors();
      var polyline_anchors_1 = require_polyline_anchors();
      var anchor_1 = require_anchor();
      var routing_1 = require_routing();
      var bezier_edge_router_1 = require_bezier_edge_router();
      var bezier_anchors_1 = require_bezier_anchors();
      var command_registration_1 = require_command_registration();
      var routingModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(routing_1.EdgeRouterRegistry).toSelf().inSingletonScope();
        bind(anchor_1.AnchorComputerRegistry).toSelf().inSingletonScope();
        bind(manhattan_edge_router_1.ManhattanEdgeRouter).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRouter).toService(manhattan_edge_router_1.ManhattanEdgeRouter);
        bind(manhattan_anchors_1.ManhattanEllipticAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanEllipticAnchor);
        bind(manhattan_anchors_1.ManhattanRectangularAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanRectangularAnchor);
        bind(manhattan_anchors_1.ManhattanDiamondAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanDiamondAnchor);
        bind(polyline_edge_router_1.PolylineEdgeRouter).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRouter).toService(polyline_edge_router_1.PolylineEdgeRouter);
        bind(polyline_anchors_1.EllipseAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(polyline_anchors_1.EllipseAnchor);
        bind(polyline_anchors_1.RectangleAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(polyline_anchors_1.RectangleAnchor);
        bind(polyline_anchors_1.DiamondAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(polyline_anchors_1.DiamondAnchor);
        bind(bezier_edge_router_1.BezierEdgeRouter).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRouter).toService(bezier_edge_router_1.BezierEdgeRouter);
        bind(bezier_anchors_1.BezierEllipseAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierEllipseAnchor);
        bind(bezier_anchors_1.BezierRectangleAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierRectangleAnchor);
        bind(bezier_anchors_1.BezierDiamondAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierDiamondAnchor);
        (0, command_registration_1.configureCommand)({ bind, isBound }, bezier_edge_router_1.AddRemoveBezierSegmentCommand);
      });
      exports.default = routingModule;
    }
  });

  // node_modules/sprotty/lib/features/select/di.config.js
  var require_di_config18 = __commonJS({
    "node_modules/sprotty/lib/features/select/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var select_1 = require_select();
      var command_registration_1 = require_command_registration();
      var selectModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, select_1.SelectCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, select_1.SelectAllCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, select_1.GetSelectionCommand);
        bind(select_1.SelectKeyboardListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(select_1.SelectKeyboardListener);
        bind(select_1.SelectMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(select_1.SelectMouseListener);
      });
      exports.default = selectModule;
    }
  });

  // node_modules/sprotty/lib/features/undo-redo/di.config.js
  var require_di_config19 = __commonJS({
    "node_modules/sprotty/lib/features/undo-redo/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var undo_redo_1 = require_undo_redo();
      var undoRedoModule = new inversify_1.ContainerModule((bind) => {
        bind(undo_redo_1.UndoRedoKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(undo_redo_1.UndoRedoKeyListener);
      });
      exports.default = undoRedoModule;
    }
  });

  // node_modules/sprotty/lib/features/update/di.config.js
  var require_di_config20 = __commonJS({
    "node_modules/sprotty/lib/features/update/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var command_registration_1 = require_command_registration();
      var update_model_1 = require_update_model();
      var updateModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, update_model_1.UpdateModelCommand);
      });
      exports.default = updateModule;
    }
  });

  // node_modules/sprotty/lib/features/viewport/di.config.js
  var require_di_config21 = __commonJS({
    "node_modules/sprotty/lib/features/viewport/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var center_fit_1 = require_center_fit();
      var viewport_1 = require_viewport();
      var scroll_1 = require_scroll();
      var zoom_1 = require_zoom();
      var command_registration_1 = require_command_registration();
      var viewportModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, center_fit_1.CenterCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, center_fit_1.FitToScreenCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, viewport_1.SetViewportCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, viewport_1.GetViewportCommand);
        bind(center_fit_1.CenterKeyboardListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(center_fit_1.CenterKeyboardListener);
        bind(scroll_1.ScrollMouseListener).toSelf().inSingletonScope();
        bind(zoom_1.ZoomMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(scroll_1.ScrollMouseListener);
        bind(types_1.TYPES.MouseListener).toService(zoom_1.ZoomMouseListener);
      });
      exports.default = viewportModule;
    }
  });

  // node_modules/sprotty/lib/features/zorder/di.config.js
  var require_di_config22 = __commonJS({
    "node_modules/sprotty/lib/features/zorder/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var command_registration_1 = require_command_registration();
      var zorder_1 = require_zorder();
      var zorderModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, zorder_1.BringToFrontCommand);
      });
      exports.default = zorderModule;
    }
  });

  // node_modules/sprotty/lib/graph/views.js
  var require_views6 = __commonJS({
    "node_modules/sprotty/lib/graph/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SBezierControlHandleView = exports.SBezierCreateHandleView = exports.SCompartmentView = exports.SLabelView = exports.SRoutingHandleView = exports.BezierCurveEdgeView = exports.PolylineEdgeViewWithGapsOnIntersections = exports.JumpingPolylineEdgeView = exports.PolylineEdgeView = exports.SGraphView = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var model_utils_1 = require_model_utils();
      var vnode_utils_1 = require_vnode_utils();
      var views_1 = require_views();
      var intersection_finder_1 = require_intersection_finder();
      var model_1 = require_model10();
      var model_2 = require_model9();
      var routing_1 = require_routing();
      var views_2 = require_views5();
      var jsx_1 = require_jsx();
      var geometry_2 = require_geometry2();
      var SGraphView = class SGraphView {
        render(model, context) {
          const edgeRouting = this.edgeRouterRegistry.routeAllChildren(model);
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          return (0, jsx_1.svg)(
            "svg",
            { "class-sprotty-graph": true },
            (0, jsx_1.svg)("g", { transform }, context.renderChildren(model, { edgeRouting }))
          );
        }
      };
      exports.SGraphView = SGraphView;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], SGraphView.prototype, "edgeRouterRegistry", void 0);
      exports.SGraphView = SGraphView = __decorate([
        (0, inversify_1.injectable)()
      ], SGraphView);
      var PolylineEdgeView2 = class PolylineEdgeView extends views_2.RoutableView {
        render(edge, context, args) {
          const route = this.edgeRouterRegistry.route(edge, args);
          if (route.length === 0) {
            return this.renderDanglingEdge("Cannot compute route", edge, context);
          }
          if (!this.isVisible(edge, route, context)) {
            if (edge.children.length === 0) {
              return void 0;
            }
            return (0, jsx_1.svg)("g", null, context.renderChildren(edge, { route }));
          }
          return (0, jsx_1.svg)(
            "g",
            { "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback },
            this.renderLine(edge, route, context, args),
            this.renderAdditionals(edge, route, context),
            this.renderJunctionPoints(edge, route, context, args),
            context.renderChildren(edge, { route })
          );
        }
        renderJunctionPoints(edge, route, context, args) {
          const radius = 5;
          const junctionPoints = [];
          for (let i2 = 1; i2 < route.length; i2++) {
            if (route[i2].isJunction) {
              junctionPoints.push((0, jsx_1.svg)("circle", { cx: route[i2].x, cy: route[i2].y, r: radius }));
            }
          }
          if (junctionPoints.length > 0) {
            return (0, jsx_1.svg)("g", { "class-sprotty-junction": true }, junctionPoints);
          }
          return void 0;
        }
        renderLine(edge, segments, context, args) {
          const firstPoint = segments[0];
          let path = `M ${firstPoint.x},${firstPoint.y}`;
          for (let i2 = 1; i2 < segments.length; i2++) {
            const p3 = segments[i2];
            path += ` L ${p3.x},${p3.y}`;
          }
          return (0, jsx_1.svg)("path", { d: path });
        }
        renderAdditionals(edge, segments, context) {
          return [];
        }
        renderDanglingEdge(message, edge, context) {
          return (0, jsx_1.svg)("text", { "class-sprotty-edge-dangling": true, title: message }, "?");
        }
      };
      exports.PolylineEdgeView = PolylineEdgeView2;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], PolylineEdgeView2.prototype, "edgeRouterRegistry", void 0);
      exports.PolylineEdgeView = PolylineEdgeView2 = __decorate([
        (0, inversify_1.injectable)()
      ], PolylineEdgeView2);
      var JumpingPolylineEdgeView = class JumpingPolylineEdgeView extends PolylineEdgeView2 {
        constructor() {
          super(...arguments);
          this.jumpOffsetBefore = 5;
          this.jumpOffsetAfter = 5;
          this.skipOffsetBefore = 3;
          this.skipOffsetAfter = 2;
        }
        renderLine(edge, segments, context, args) {
          let path = "";
          for (let i2 = 0; i2 < segments.length; i2++) {
            const p3 = segments[i2];
            if (i2 === 0) {
              path = `M ${p3.x},${p3.y}`;
            }
            if ((0, intersection_finder_1.isIntersectingRoutedPoint)(p3)) {
              path += this.intersectionPath(edge, segments, p3, args);
            }
            if (i2 !== 0) {
              path += ` L ${p3.x},${p3.y}`;
            }
          }
          return (0, jsx_1.svg)("path", { d: path });
        }
        /**
         * Returns a path that takes the intersections into account by drawing a line jump or a gap for intersections on that path.
         */
        intersectionPath(edge, segments, intersectingPoint, args) {
          if (intersectingPoint.intersections.length < 1) {
            return "";
          }
          const segment = this.getLineSegment(edge, intersectingPoint.intersections[0], args, segments);
          const intersections = this.getIntersectionsSortedBySegmentDirection(segment, intersectingPoint);
          let path = "";
          for (const intersection of intersections) {
            const otherLineSegment = this.getOtherLineSegment(edge, intersection, args);
            if (otherLineSegment === void 0) {
              continue;
            }
            const currentLineSegment = this.getLineSegment(edge, intersection, args, segments);
            const intersectionPoint = intersection.intersectionPoint;
            if (this.shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment)) {
              path += this.createJumpPath(intersectionPoint, currentLineSegment);
            } else if (this.shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment)) {
              path += this.createGapPath(intersectionPoint, currentLineSegment);
            }
          }
          return path;
        }
        /**
         * Returns the intersections sorted by the direction of the `lineSegment`.
         *
         * The coordinate system goes from left to right and top to bottom.
         * Thus, x increases to the right and y increases downwards.
         *
         * We need to draw the intersections in the order of the direction of the line segment.
         * To draw a line pointing north, we need to order intersections by Y in a descending order.
         * To draw a line pointing south, we need to order intersections by Y in an ascending order.
         */
        getIntersectionsSortedBySegmentDirection(lineSegment, intersectingPoint) {
          switch (lineSegment.direction) {
            case "north":
            case "north-east":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_X_THEN_DESCENDING_Y);
            case "south":
            case "south-east":
            case "east":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_X_THEN_Y);
            case "south-west":
            case "west":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_DESCENDING_X_THEN_Y);
            case "north-west":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_DESCENDING_X_THEN_DESCENDING_Y);
          }
        }
        /**
         * Whether or not to draw a line jump on an intersection for the `currentLineSegment`.
         * This should usually be inverse of `shouldDrawLineGapOnIntersection()`.
         */
        shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment) {
          return Math.abs(currentLineSegment.slopeOrMax) < Math.abs(otherLineSegment.slopeOrMax);
        }
        /**
         * Whether or not to draw a line gap on an intersection for the `currentLineSegment`.
         * This should usually be inverse of `shouldDrawLineJumpOnIntersection()`.
         */
        shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment) {
          return !this.shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment);
        }
        getLineSegment(edge, intersection, args, segments) {
          const route = segments ? segments : this.edgeRouterRegistry.route(edge, args);
          const index = intersection.routable1 === edge.id ? intersection.segmentIndex1 : intersection.segmentIndex2;
          return new geometry_2.PointToPointLine(route[index], route[index + 1]);
        }
        getOtherLineSegment(currentEdge, intersection, args) {
          const otherEdgeId = intersection.routable1 === currentEdge.id ? intersection.routable2 : intersection.routable1;
          const otherEdge = currentEdge.index.getById(otherEdgeId);
          if (!(otherEdge instanceof model_2.SRoutableElementImpl)) {
            return void 0;
          }
          return this.getLineSegment(otherEdge, intersection, args);
        }
        createJumpPath(intersectionPoint, lineSegment) {
          const anchorBefore = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p1, this.jumpOffsetBefore);
          const anchorAfter = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p2, this.jumpOffsetAfter);
          const rotation = lineSegment.p1.x < lineSegment.p2.x ? 1 : 0;
          return ` L ${anchorBefore.x},${anchorBefore.y} A 1,1 0,0 ${rotation} ${anchorAfter.x},${anchorAfter.y}`;
        }
        createGapPath(intersectionPoint, lineSegment) {
          let offsetBefore;
          let offsetAfter;
          if (intersectionPoint.y < lineSegment.p1.y) {
            offsetBefore = -this.skipOffsetBefore;
            offsetAfter = this.jumpOffsetAfter + this.skipOffsetAfter;
          } else {
            offsetBefore = this.jumpOffsetBefore + this.skipOffsetAfter;
            offsetAfter = -this.skipOffsetBefore;
          }
          const anchorBefore = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p1, offsetBefore);
          const anchorAfter = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p2, offsetAfter);
          return ` L ${anchorBefore.x},${anchorBefore.y} M ${anchorAfter.x},${anchorAfter.y}`;
        }
      };
      exports.JumpingPolylineEdgeView = JumpingPolylineEdgeView;
      exports.JumpingPolylineEdgeView = JumpingPolylineEdgeView = __decorate([
        (0, inversify_1.injectable)()
      ], JumpingPolylineEdgeView);
      var PolylineEdgeViewWithGapsOnIntersections = class PolylineEdgeViewWithGapsOnIntersections extends JumpingPolylineEdgeView {
        constructor() {
          super(...arguments);
          this.skipOffsetBefore = 3;
          this.skipOffsetAfter = 3;
        }
        shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment) {
          return false;
        }
        shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment) {
          return Math.abs(currentLineSegment.slopeOrMax) >= Math.abs(otherLineSegment.slopeOrMax);
        }
        createGapPath(intersectionPoint, lineSegment) {
          const anchorBefore = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p1, this.skipOffsetBefore);
          const anchorAfter = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p2, this.skipOffsetAfter);
          return ` L ${anchorBefore.x},${anchorBefore.y} M ${anchorAfter.x},${anchorAfter.y}`;
        }
      };
      exports.PolylineEdgeViewWithGapsOnIntersections = PolylineEdgeViewWithGapsOnIntersections;
      exports.PolylineEdgeViewWithGapsOnIntersections = PolylineEdgeViewWithGapsOnIntersections = __decorate([
        (0, inversify_1.injectable)()
      ], PolylineEdgeViewWithGapsOnIntersections);
      var BezierCurveEdgeView = class BezierCurveEdgeView extends views_2.RoutableView {
        render(edge, context, args) {
          const route = this.edgeRouterRegistry.route(edge, args);
          if (route.length === 0) {
            return this.renderDanglingEdge("Cannot compute route", edge, context);
          }
          if (!this.isVisible(edge, route, context)) {
            if (edge.children.length === 0) {
              return void 0;
            }
            return (0, jsx_1.svg)("g", null, context.renderChildren(edge, { route }));
          }
          return (0, jsx_1.svg)(
            "g",
            { "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback },
            this.renderLine(edge, route, context, args),
            this.renderAdditionals(edge, route, context),
            context.renderChildren(edge, { route })
          );
        }
        renderLine(edge, segments, context, args) {
          let path = "";
          if (segments.length >= 4) {
            path += this.buildMainSegment(segments);
            const pointsLeft = segments.length - 4;
            if (pointsLeft > 0 && pointsLeft % 3 === 0) {
              for (let i2 = 4; i2 < segments.length; i2 += 3) {
                path += this.addSpline(segments, i2);
              }
            }
          }
          return (0, jsx_1.svg)("path", { d: path });
        }
        buildMainSegment(segments) {
          const s3 = segments[0];
          const h1 = segments[1];
          const h22 = segments[2];
          const t3 = segments[3];
          return `M${s3.x},${s3.y} C${h1.x},${h1.y} ${h22.x},${h22.y} ${t3.x},${t3.y}`;
        }
        addSpline(segments, index) {
          const c3 = segments[index + 1];
          const p3 = segments[index + 2];
          return ` S${c3.x},${c3.y} ${p3.x},${p3.y}`;
        }
        renderAdditionals(edge, segments, context) {
          return [];
        }
        renderDanglingEdge(message, edge, context) {
          return (0, jsx_1.svg)("text", { "class-sprotty-edge-dangling": true, title: message }, "?");
        }
      };
      exports.BezierCurveEdgeView = BezierCurveEdgeView;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], BezierCurveEdgeView.prototype, "edgeRouterRegistry", void 0);
      exports.BezierCurveEdgeView = BezierCurveEdgeView = __decorate([
        (0, inversify_1.injectable)()
      ], BezierCurveEdgeView);
      var SRoutingHandleView2 = class SRoutingHandleView {
        constructor() {
          this.minimalPointDistance = 10;
        }
        render(handle, context, args) {
          if (args && args.route) {
            if (handle.parent instanceof model_2.SRoutableElementImpl) {
              const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
              const theRoute = args.route === void 0 ? this.edgeRouterRegistry.route(handle.parent, args) : args.route;
              const position = router.getHandlePosition(handle.parent, theRoute, handle);
              if (position !== void 0) {
                const node = (0, jsx_1.svg)("circle", { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y, r: this.getRadius() });
                (0, vnode_utils_1.setAttr)(node, "data-kind", handle.kind);
                return node;
              }
            }
          }
          return (0, jsx_1.svg)("g", null);
        }
        getRadius() {
          return 7;
        }
      };
      exports.SRoutingHandleView = SRoutingHandleView2;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], SRoutingHandleView2.prototype, "edgeRouterRegistry", void 0);
      exports.SRoutingHandleView = SRoutingHandleView2 = __decorate([
        (0, inversify_1.injectable)()
      ], SRoutingHandleView2);
      var SLabelView = class SLabelView extends views_1.ShapeView {
        render(label, context) {
          if (!(0, model_1.isEdgeLayoutable)(label) && !this.isVisible(label, context)) {
            return void 0;
          }
          const vnode = (0, jsx_1.svg)("text", { "class-sprotty-label": true }, label.text);
          const subType = (0, model_utils_1.getSubType)(label);
          if (subType) {
            (0, vnode_utils_1.setAttr)(vnode, "class", subType);
          }
          return vnode;
        }
      };
      exports.SLabelView = SLabelView;
      exports.SLabelView = SLabelView = __decorate([
        (0, inversify_1.injectable)()
      ], SLabelView);
      var SCompartmentView = class SCompartmentView {
        render(compartment, context, args) {
          const translate = `translate(${compartment.bounds.x}, ${compartment.bounds.y})`;
          const vnode = (0, jsx_1.svg)("g", { transform: translate, "class-sprotty-comp": "{true}" }, context.renderChildren(compartment));
          const subType = (0, model_utils_1.getSubType)(compartment);
          if (subType)
            (0, vnode_utils_1.setAttr)(vnode, "class", subType);
          return vnode;
        }
      };
      exports.SCompartmentView = SCompartmentView;
      exports.SCompartmentView = SCompartmentView = __decorate([
        (0, inversify_1.injectable)()
      ], SCompartmentView);
      var SBezierCreateHandleView = class SBezierCreateHandleView extends SRoutingHandleView2 {
        render(handle, context, args) {
          if (args) {
            const theRoute = args.route;
            if (theRoute && handle.parent instanceof model_2.SRoutableElementImpl) {
              const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
              const position = router.getHandlePosition(handle.parent, theRoute, handle);
              if (position !== void 0) {
                const translation = "translate(" + position.x + ", " + position.y + ")";
                const textOffsetX = -5.5;
                const textOffsetY = 5.5;
                const text = handle.kind === "bezier-add" ? "+" : "-";
                const node = (0, jsx_1.svg)(
                  "g",
                  { transform: translation, "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback },
                  (0, jsx_1.svg)("circle", { r: this.getRadius() }),
                  (0, jsx_1.svg)("text", { x: textOffsetX, y: textOffsetY, "attrs-text-align": "middle", "style-font-family": "monospace", "style-pointer-events": "none", "style-fill": "white" }, text)
                );
                (0, vnode_utils_1.setAttr)(node, "data-kind", handle.kind);
                return node;
              }
            }
          }
          return (0, jsx_1.svg)("g", null);
        }
      };
      exports.SBezierCreateHandleView = SBezierCreateHandleView;
      exports.SBezierCreateHandleView = SBezierCreateHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], SBezierCreateHandleView);
      var SBezierControlHandleView = class SBezierControlHandleView extends SRoutingHandleView2 {
        render(handle, context, args) {
          if (args) {
            const theRoute = args.route;
            if (theRoute && handle.parent instanceof model_2.SRoutableElementImpl) {
              const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
              const position = router.getHandlePosition(handle.parent, theRoute, handle);
              if (position !== void 0) {
                let pathEndPos;
                for (let i2 = 0; i2 < theRoute.length; i2++) {
                  const elem = theRoute[i2];
                  if (elem.kind === position.kind && elem.pointIndex === position.pointIndex) {
                    if (handle.kind === "bezier-control-before") {
                      pathEndPos = theRoute[i2 + 1];
                    } else {
                      pathEndPos = theRoute[i2 - 1];
                    }
                    break;
                  }
                }
                let node;
                if (pathEndPos) {
                  const coords = `M ${position.x}, ${position.y} L ${pathEndPos.x}, ${pathEndPos.y}`;
                  node = (0, jsx_1.svg)(
                    "g",
                    { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback },
                    (0, jsx_1.svg)("path", { d: coords, stroke: "grey", "style-stroke-width": "2px" }),
                    (0, jsx_1.svg)("circle", { cx: position.x, cy: position.y, r: this.getRadius() })
                  );
                } else {
                  node = (0, jsx_1.svg)("circle", { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y, r: this.getRadius() });
                }
                (0, vnode_utils_1.setAttr)(node, "data-kind", handle.kind);
                return node;
              }
            }
          }
          return (0, jsx_1.svg)("g", null);
        }
      };
      exports.SBezierControlHandleView = SBezierControlHandleView;
      exports.SBezierControlHandleView = SBezierControlHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], SBezierControlHandleView);
    }
  });

  // node_modules/sprotty/lib/model-source/di.config.js
  var require_di_config23 = __commonJS({
    "node_modules/sprotty/lib/model-source/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var command_registration_1 = require_command_registration();
      var types_1 = require_types();
      var commit_model_1 = require_commit_model();
      var model_source_1 = require_model_source();
      var modelSourceModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(types_1.TYPES.ModelSourceProvider).toProvider((context) => {
          return () => {
            return new Promise((resolve) => {
              resolve(context.container.get(types_1.TYPES.ModelSource));
            });
          };
        });
        (0, command_registration_1.configureCommand)({ bind, isBound }, commit_model_1.CommitModelCommand);
        bind(types_1.TYPES.IActionHandlerInitializer).toService(types_1.TYPES.ModelSource);
        bind(model_source_1.ComputedBoundsApplicator).toSelf().inSingletonScope();
      });
      exports.default = modelSourceModule;
    }
  });

  // node_modules/sprotty/lib/lib/modules.js
  var require_modules = __commonJS({
    "node_modules/sprotty/lib/lib/modules.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.loadDefaultModules = void 0;
      var di_config_1 = __importDefault(require_di_config());
      var di_config_2 = __importDefault(require_di_config23());
      var di_config_3 = __importDefault(require_di_config4());
      var di_config_4 = __importDefault(require_di_config5());
      var di_config_5 = __importDefault(require_di_config6());
      var di_config_6 = __importDefault(require_di_config7());
      var di_config_7 = __importDefault(require_di_config8());
      var di_config_8 = __importDefault(require_di_config2());
      var di_config_9 = require_di_config3();
      var di_config_10 = __importDefault(require_di_config11());
      var di_config_11 = __importDefault(require_di_config12());
      var di_config_12 = __importDefault(require_di_config13());
      var di_config_13 = __importDefault(require_di_config14());
      var di_config_14 = __importDefault(require_di_config15());
      var di_config_15 = __importDefault(require_di_config16());
      var di_config_16 = __importDefault(require_di_config17());
      var di_config_17 = __importDefault(require_di_config18());
      var di_config_18 = __importDefault(require_di_config19());
      var di_config_19 = __importDefault(require_di_config20());
      var di_config_20 = __importDefault(require_di_config21());
      var di_config_21 = __importDefault(require_di_config22());
      function loadDefaultModules(container, options) {
        const modules = [
          di_config_1.default,
          di_config_2.default,
          di_config_3.default,
          di_config_4.default,
          di_config_5.default,
          di_config_6.default,
          di_config_7.default,
          di_config_9.edgeEditModule,
          di_config_8.default,
          di_config_10.default,
          di_config_11.default,
          di_config_12.default,
          di_config_13.default,
          di_config_9.labelEditModule,
          di_config_9.labelEditUiModule,
          di_config_14.default,
          di_config_15.default,
          di_config_16.default,
          di_config_17.default,
          di_config_18.default,
          di_config_19.default,
          di_config_20.default,
          di_config_21.default
        ];
        if (options && options.exclude) {
          for (const mod of options.exclude) {
            const index = modules.indexOf(mod);
            if (index >= 0)
              modules.splice(index, 1);
          }
        }
        container.load(...modules);
      }
      exports.loadDefaultModules = loadDefaultModules;
    }
  });

  // node_modules/sprotty/lib/lib/virtualize.js
  var require_virtualize = __commonJS({
    "node_modules/sprotty/lib/lib/virtualize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var snabbdom_1 = require_snabbdom_cjs();
      function buildVNodeData(attrs) {
        const data = {};
        const addData = (memo, name) => {
          if (name !== "style" && name !== "class") {
            const val = unescapeEntities(attrs[name]);
            memo ? memo[name] = val : memo = { [name]: val };
          }
          return memo;
        };
        const _attrs = Object.keys(attrs).reduce(addData, null);
        if (_attrs) {
          data.attrs = _attrs;
        }
        const style = parseStyle(attrs);
        if (style) {
          data.style = style;
        }
        const classes = parseClass(attrs);
        if (classes) {
          data.class = classes;
        }
        return data;
      }
      function parseStyle(attrs) {
        const addStyle = (memo, styleProp) => {
          const res = styleProp.split(":");
          const name = transformName(res[0].trim());
          if (name) {
            const val = res[1].replace("!important", "").trim();
            memo ? memo[name] = val : memo = { [name]: val };
          }
          return memo;
        };
        try {
          return attrs.style.split(";").reduce(addStyle, null);
        } catch (e2) {
          return null;
        }
      }
      function parseClass(attrs) {
        const addClass = (memo, className) => {
          className = className.trim();
          if (className) {
            memo ? memo[className] = true : memo = { [className]: true };
          }
          return memo;
        };
        try {
          return attrs.class.split(" ").reduce(addClass, null);
        } catch (e2) {
          return null;
        }
      }
      function transformName(name) {
        name = name.replace(/-(\w)/g, function _replace($1, $2) {
          return $2.toUpperCase();
        });
        const firstChar = name.charAt(0).toLowerCase();
        return `${firstChar}${name.substring(1)}`;
      }
      var entityRegex = new RegExp("&[a-z0-9#]+;", "gi");
      var el = null;
      function unescapeEntities(text) {
        if (!el) {
          el = document.createElement("div");
        }
        return text.replace(entityRegex, (entity) => {
          if (el === null)
            return "";
          el.innerHTML = entity;
          return el.textContent === null ? "" : el.textContent;
        });
      }
      function recurse(doc, func) {
        let node = doc;
        let parent = null;
        const stack = [];
        const setChild = (n) => {
          const child = n.firstChild;
          if (child !== null) {
            parent = n;
          }
          node = child;
        };
        func(node, parent);
        setChild(node);
        while (true) {
          while (node) {
            stack.push(node);
            func(node, parent);
            setChild(node);
          }
          const _node = stack.pop();
          node = _node ? _node : null;
          if (!stack.length)
            break;
          parent = stack[stack.length - 1];
          if (node) {
            const sibling = node.nextSibling;
            if (sibling == null) {
              parent = stack[stack.length - 1];
            }
            node = sibling;
          }
        }
      }
      var vdom = null;
      var vnodeMap = /* @__PURE__ */ new Map();
      var delimited = false;
      function toVNode(node, parent) {
        let current;
        if (parent !== null) {
          current = vnodeMap.get(parent);
        }
        switch (node === null || node === void 0 ? void 0 : node.nodeType) {
          // element
          case 1: {
            if (current === void 0)
              return;
            current.children = current.children ? current.children : [];
            const children = current.children;
            const attributes = node.attributes;
            const attrs = {};
            for (let i2 = 0; i2 < attributes.length; i2++) {
              const attr = attributes.item(i2);
              if (attr) {
                attrs[attr.name] = attr.value;
              }
            }
            const vn = (0, snabbdom_1.h)(node.nodeName, buildVNodeData(attrs));
            children.push(vn);
            vnodeMap.set(node, vn);
            break;
          }
          // text
          case 3: {
            const text = node.textContent;
            if (text !== null && current !== void 0) {
              current.children = current.children ? current.children : [];
              const children = current.children;
              const lastData = children.length > 0 ? children[children.length - 1] : null;
              if (!delimited && typeof lastData !== "string" && lastData !== null && lastData.sel === void 0) {
                lastData.text = lastData.text + text;
              } else {
                children.push((0, snabbdom_1.vnode)(void 0, void 0, void 0, text, void 0));
              }
              delimited = false;
            }
            break;
          }
          case 8: {
            delimited = true;
            break;
          }
          // document
          case 9: {
            vdom = (0, snabbdom_1.vnode)(void 0, void 0, [], void 0, void 0);
            vnodeMap.set(node, vdom);
            break;
          }
          default:
            break;
        }
      }
      function stripVNode(vnodes) {
        const children = vnodes === null || vnodes === void 0 ? void 0 : vnodes.children;
        if (typeof children === "undefined")
          return null;
        if (children.length === 1 && typeof children[0] !== "string")
          return children[0];
        return null;
      }
      function virtualizeString(html) {
        var _a4, _b2;
        const parser = new window.DOMParser();
        if (parser === void 0 || html === void 0 || html === "")
          return null;
        const doc = parser.parseFromString(html, "application/xml");
        if (((_a4 = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _a4 === void 0 ? void 0 : _a4.nodeName) === "parsererror") {
          const error = `${(_b2 = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _b2 === void 0 ? void 0 : _b2.textContent}`;
          return (0, snabbdom_1.h)("parsererror", [error]);
        }
        delimited = false;
        vdom = null;
        recurse(doc, toVNode);
        if (vdom === null)
          return null;
        return stripVNode(vdom);
      }
      exports.default = virtualizeString;
    }
  });

  // node_modules/sprotty/lib/lib/model.js
  var require_model18 = __commonJS({
    "node_modules/sprotty/lib/lib/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ForeignObjectElement = exports.ForeignObjectElementImpl = exports.ShapedPreRenderedElement = exports.ShapedPreRenderedElementImpl = exports.PreRenderedElement = exports.PreRenderedElementImpl = exports.HtmlRoot = exports.HtmlRootImpl = exports.RectangularPort = exports.CircularPort = exports.DiamondNode = exports.RectangularNode = exports.CircularNode = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var model_2 = require_model8();
      var model_3 = require_model6();
      var sgraph_1 = require_sgraph();
      var anchor_1 = require_anchor();
      var CircularNode = class extends sgraph_1.SNodeImpl {
        get anchorKind() {
          return anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
      };
      exports.CircularNode = CircularNode;
      var RectangularNode = class extends sgraph_1.SNodeImpl {
        get anchorKind() {
          return anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
      };
      exports.RectangularNode = RectangularNode;
      var DiamondNode = class extends sgraph_1.SNodeImpl {
        get anchorKind() {
          return anchor_1.DIAMOND_ANCHOR_KIND;
        }
      };
      exports.DiamondNode = DiamondNode;
      var CircularPort = class extends sgraph_1.SPortImpl {
        get anchorKind() {
          return anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
      };
      exports.CircularPort = CircularPort;
      var RectangularPort = class extends sgraph_1.SPortImpl {
        get anchorKind() {
          return anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
      };
      exports.RectangularPort = RectangularPort;
      var HtmlRootImpl = class extends smodel_1.SModelRootImpl {
        constructor() {
          super(...arguments);
          this.classes = [];
        }
      };
      exports.HtmlRootImpl = HtmlRootImpl;
      exports.HtmlRoot = HtmlRootImpl;
      var PreRenderedElementImpl = class extends smodel_1.SChildElementImpl {
      };
      exports.PreRenderedElementImpl = PreRenderedElementImpl;
      exports.PreRenderedElement = PreRenderedElementImpl;
      var ShapedPreRenderedElementImpl = class extends PreRenderedElementImpl {
        constructor() {
          super(...arguments);
          this.position = geometry_1.Point.ORIGIN;
          this.size = geometry_1.Dimension.EMPTY;
          this.selected = false;
          this.alignment = geometry_1.Point.ORIGIN;
        }
        get bounds() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
          };
        }
        set bounds(newBounds) {
          this.position = {
            x: newBounds.x,
            y: newBounds.y
          };
          this.size = {
            width: newBounds.width,
            height: newBounds.height
          };
        }
      };
      exports.ShapedPreRenderedElementImpl = ShapedPreRenderedElementImpl;
      ShapedPreRenderedElementImpl.DEFAULT_FEATURES = [model_2.moveFeature, model_1.boundsFeature, model_3.selectFeature, model_1.alignFeature];
      exports.ShapedPreRenderedElement = ShapedPreRenderedElementImpl;
      var ForeignObjectElementImpl = class extends ShapedPreRenderedElementImpl {
        get bounds() {
          if (geometry_1.Dimension.isValid(this.size)) {
            return {
              x: this.position.x,
              y: this.position.y,
              width: this.size.width,
              height: this.size.height
            };
          } else if ((0, model_1.isBoundsAware)(this.parent)) {
            return {
              x: this.position.x,
              y: this.position.y,
              width: this.parent.bounds.width,
              height: this.parent.bounds.height
            };
          }
          return geometry_1.Bounds.EMPTY;
        }
      };
      exports.ForeignObjectElementImpl = ForeignObjectElementImpl;
      exports.ForeignObjectElement = ForeignObjectElementImpl;
    }
  });

  // node_modules/sprotty/lib/lib/generic-views.js
  var require_generic_views = __commonJS({
    "node_modules/sprotty/lib/lib/generic-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ForeignObjectView = exports.PreRenderedView = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_cjs4();
      var virtualize_1 = __importDefault(require_virtualize());
      var vnode_utils_1 = require_vnode_utils();
      var views_1 = require_views();
      var model_1 = require_model18();
      var PreRenderedView = class PreRenderedView extends views_1.ShapeView {
        render(model, context) {
          if (model instanceof model_1.ShapedPreRenderedElementImpl && !this.isVisible(model, context)) {
            return void 0;
          }
          const node = (0, virtualize_1.default)(model.code);
          if (node === null)
            return void 0;
          this.correctNamespace(node);
          return node;
        }
        correctNamespace(node) {
          if (node.sel === "svg" || node.sel === "g")
            (0, vnode_utils_1.setNamespace)(node, "http://www.w3.org/2000/svg");
        }
      };
      exports.PreRenderedView = PreRenderedView;
      exports.PreRenderedView = PreRenderedView = __decorate([
        (0, inversify_1.injectable)()
      ], PreRenderedView);
      var ForeignObjectView = class ForeignObjectView {
        render(model, context) {
          const foreignObjectContents = (0, virtualize_1.default)(model.code);
          if (foreignObjectContents === null)
            return void 0;
          const node = (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("foreignObject", { requiredFeatures: "http://www.w3.org/TR/SVG11/feature#Extensibility", height: model.bounds.height, width: model.bounds.width, x: 0, y: 0 }, foreignObjectContents),
            context.renderChildren(model)
          );
          (0, vnode_utils_1.setAttr)(node, "class", model.type);
          (0, vnode_utils_1.setNamespace)(foreignObjectContents, model.namespace);
          return node;
        }
      };
      exports.ForeignObjectView = ForeignObjectView;
      exports.ForeignObjectView = ForeignObjectView = __decorate([
        (0, inversify_1.injectable)()
      ], ForeignObjectView);
    }
  });

  // node_modules/sprotty/lib/lib/html-views.js
  var require_html_views = __commonJS({
    "node_modules/sprotty/lib/lib/html-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HtmlRootView = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_cjs4();
      var vnode_utils_1 = require_vnode_utils();
      var HtmlRootView = class HtmlRootView {
        render(model, context) {
          const root = (0, jsx_1.html)("div", null, context.renderChildren(model));
          for (const c3 of model.classes) {
            (0, vnode_utils_1.setClass)(root, c3, true);
          }
          return root;
        }
      };
      exports.HtmlRootView = HtmlRootView;
      exports.HtmlRootView = HtmlRootView = __decorate([
        (0, inversify_1.injectable)()
      ], HtmlRootView);
    }
  });

  // node_modules/file-saver/dist/FileSaver.min.js
  var require_FileSaver_min = __commonJS({
    "node_modules/file-saver/dist/FileSaver.min.js"(exports, module) {
      (function(a3, b3) {
        if ("function" == typeof define && define.amd) define([], b3);
        else if ("undefined" != typeof exports) b3();
        else {
          b3(), a3.FileSaver = { exports: {} }.exports;
        }
      })(exports, function() {
        "use strict";
        function b3(a4, b4) {
          return "undefined" == typeof b4 ? b4 = { autoBom: false } : "object" != typeof b4 && (console.warn("Deprecated: Expected third argument to be a object"), b4 = { autoBom: !b4 }), b4.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a4.type) ? new Blob(["\uFEFF", a4], { type: a4.type }) : a4;
        }
        function c3(a4, b4, c4) {
          var d4 = new XMLHttpRequest();
          d4.open("GET", a4), d4.responseType = "blob", d4.onload = function() {
            g3(d4.response, b4, c4);
          }, d4.onerror = function() {
            console.error("could not download file");
          }, d4.send();
        }
        function d3(a4) {
          var b4 = new XMLHttpRequest();
          b4.open("HEAD", a4, false);
          try {
            b4.send();
          } catch (a5) {
          }
          return 200 <= b4.status && 299 >= b4.status;
        }
        function e2(a4) {
          try {
            a4.dispatchEvent(new MouseEvent("click"));
          } catch (c4) {
            var b4 = document.createEvent("MouseEvents");
            b4.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a4.dispatchEvent(b4);
          }
        }
        var f3 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a3 = f3.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g3 = f3.saveAs || ("object" != typeof window || window !== f3 ? function() {
        } : "download" in HTMLAnchorElement.prototype && !a3 ? function(b4, g4, h3) {
          var i2 = f3.URL || f3.webkitURL, j3 = document.createElement("a");
          g4 = g4 || b4.name || "download", j3.download = g4, j3.rel = "noopener", "string" == typeof b4 ? (j3.href = b4, j3.origin === location.origin ? e2(j3) : d3(j3.href) ? c3(b4, g4, h3) : e2(j3, j3.target = "_blank")) : (j3.href = i2.createObjectURL(b4), setTimeout(function() {
            i2.revokeObjectURL(j3.href);
          }, 4e4), setTimeout(function() {
            e2(j3);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function(f4, g4, h3) {
          if (g4 = g4 || f4.name || "download", "string" != typeof f4) navigator.msSaveOrOpenBlob(b3(f4, h3), g4);
          else if (d3(f4)) c3(f4, g4, h3);
          else {
            var i2 = document.createElement("a");
            i2.href = f4, i2.target = "_blank", setTimeout(function() {
              e2(i2);
            });
          }
        } : function(b4, d4, e3, g4) {
          if (g4 = g4 || open("", "_blank"), g4 && (g4.document.title = g4.document.body.innerText = "downloading..."), "string" == typeof b4) return c3(b4, d4, e3);
          var h3 = "application/octet-stream" === b4.type, i2 = /constructor/i.test(f3.HTMLElement) || f3.safari, j3 = /CriOS\/[\d]+/.test(navigator.userAgent);
          if ((j3 || h3 && i2 || a3) && "undefined" != typeof FileReader) {
            var k3 = new FileReader();
            k3.onloadend = function() {
              var a4 = k3.result;
              a4 = j3 ? a4 : a4.replace(/^data:[^;]*;/, "data:attachment/file;"), g4 ? g4.location.href = a4 : location = a4, g4 = null;
            }, k3.readAsDataURL(b4);
          } else {
            var l3 = f3.URL || f3.webkitURL, m3 = l3.createObjectURL(b4);
            g4 ? g4.location = m3 : location.href = m3, g4 = null, setTimeout(function() {
              l3.revokeObjectURL(m3);
            }, 4e4);
          }
        });
        f3.saveAs = g3.saveAs = g3, "undefined" != typeof module && (module.exports = g3);
      });
    }
  });

  // node_modules/sprotty/lib/model-source/diagram-server.js
  var require_diagram_server2 = __commonJS({
    "node_modules/sprotty/lib/model-source/diagram-server.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramServerProxy = exports.ServerStatusAction = void 0;
      var file_saver_1 = require_FileSaver_min();
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var set_model_1 = require_set_model();
      var types_1 = require_types();
      var bounds_manipulation_1 = require_bounds_manipulation();
      var update_model_1 = require_update_model();
      var model_source_1 = require_model_source();
      var ServerStatusAction = class _ServerStatusAction {
        constructor() {
          this.kind = _ServerStatusAction.KIND;
        }
      };
      exports.ServerStatusAction = ServerStatusAction;
      ServerStatusAction.KIND = "serverStatus";
      var receivedFromServerProperty = "__receivedFromServer";
      var DiagramServerProxy = class DiagramServerProxy extends model_source_1.ModelSource {
        constructor() {
          super(...arguments);
          this.currentRoot = {
            type: "NONE",
            id: "ROOT"
          };
        }
        get model() {
          return this.currentRoot;
        }
        initialize(registry) {
          super.initialize(registry);
          registry.register(actions_1.ComputedBoundsAction.KIND, this);
          registry.register(bounds_manipulation_1.RequestBoundsCommand.KIND, this);
          registry.register(actions_1.RequestPopupModelAction.KIND, this);
          registry.register(actions_1.CollapseExpandAction.KIND, this);
          registry.register(actions_1.CollapseExpandAllAction.KIND, this);
          registry.register(actions_1.OpenAction.KIND, this);
          registry.register(ServerStatusAction.KIND, this);
          if (!this.clientId) {
            this.clientId = this.viewerOptions.baseDiv;
          }
        }
        handle(action) {
          const forwardToServer = this.handleLocally(action);
          if (forwardToServer) {
            this.forwardToServer(action);
          }
        }
        forwardToServer(action) {
          const message = {
            clientId: this.clientId,
            action
          };
          this.logger.log(this, "sending", message);
          this.sendMessage(message);
        }
        /**
         * Called when a message is received from the remote diagram server.
         */
        messageReceived(data) {
          const object = typeof data === "string" ? JSON.parse(data) : data;
          if ((0, actions_1.isActionMessage)(object) && object.action) {
            if (!object.clientId || object.clientId === this.clientId) {
              object.action[receivedFromServerProperty] = true;
              this.logger.log(this, "receiving", object);
              this.actionDispatcher.dispatch(object.action).then(() => {
                this.storeNewModel(object.action);
              });
            }
          } else {
            this.logger.error(this, "received data is not an action message", object);
          }
        }
        /**
         * Check whether the given action should be handled locally. Returns true if the action should
         * still be sent to the server, and false if it's only handled locally.
         */
        handleLocally(action) {
          this.storeNewModel(action);
          switch (action.kind) {
            case actions_1.ComputedBoundsAction.KIND:
              return this.handleComputedBounds(action);
            case actions_1.RequestModelAction.KIND:
              return this.handleRequestModel(action);
            case bounds_manipulation_1.RequestBoundsCommand.KIND:
              return false;
            case actions_1.ExportSvgAction.KIND:
              return this.handleExportSvgAction(action);
            case ServerStatusAction.KIND:
              return this.handleServerStateAction(action);
          }
          return !action[receivedFromServerProperty];
        }
        /**
         * Put the new model contained in the given action into the model storage, if there is any.
         */
        storeNewModel(action) {
          if (action.kind === set_model_1.SetModelCommand.KIND || action.kind === update_model_1.UpdateModelCommand.KIND || action.kind === bounds_manipulation_1.RequestBoundsCommand.KIND) {
            const newRoot = action.newRoot;
            if (newRoot) {
              this.currentRoot = newRoot;
              if (action.kind === set_model_1.SetModelCommand.KIND || action.kind === update_model_1.UpdateModelCommand.KIND) {
                this.lastSubmittedModelType = newRoot.type;
              }
            }
          }
        }
        handleRequestModel(action) {
          const newOptions = Object.assign({ needsClientLayout: this.viewerOptions.needsClientLayout, needsServerLayout: this.viewerOptions.needsServerLayout }, action.options);
          const newAction = Object.assign(Object.assign({}, action), { options: newOptions });
          this.forwardToServer(newAction);
          return false;
        }
        /**
         * If the server requires to compute a layout, the computed bounds are forwarded. Otherwise they
         * are applied to the current model locally and a model update is triggered.
         */
        handleComputedBounds(action) {
          if (this.viewerOptions.needsServerLayout) {
            return true;
          } else {
            const root = this.currentRoot;
            this.computedBoundsApplicator.apply(root, action);
            if (root.type === this.lastSubmittedModelType) {
              this.actionDispatcher.dispatch(actions_1.UpdateModelAction.create(root));
            } else {
              this.actionDispatcher.dispatch(actions_1.SetModelAction.create(root));
            }
            this.lastSubmittedModelType = root.type;
            return false;
          }
        }
        handleExportSvgAction(action) {
          const blob = new Blob([action.svg], { type: "text/plain;charset=utf-8" });
          (0, file_saver_1.saveAs)(blob, "diagram.svg");
          return false;
        }
        handleServerStateAction(action) {
          return false;
        }
        commitModel(newRoot) {
          const previousRoot = this.currentRoot;
          this.currentRoot = newRoot;
          return previousRoot;
        }
      };
      exports.DiagramServerProxy = DiagramServerProxy;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], DiagramServerProxy.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(model_source_1.ComputedBoundsApplicator),
        __metadata("design:type", model_source_1.ComputedBoundsApplicator)
      ], DiagramServerProxy.prototype, "computedBoundsApplicator", void 0);
      exports.DiagramServerProxy = DiagramServerProxy = __decorate([
        (0, inversify_1.injectable)()
      ], DiagramServerProxy);
    }
  });

  // node_modules/sprotty/lib/model-source/local-model-source.js
  var require_local_model_source = __commonJS({
    "node_modules/sprotty/lib/model-source/local-model-source.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocalModelSource = void 0;
      var file_saver_1 = require_FileSaver_min();
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var sprotty_protocol_1 = require_lib();
      var model_utils_1 = require_model_utils();
      var types_1 = require_types();
      var smodel_factory_1 = require_smodel_factory();
      var model_matching_1 = require_model_matching();
      var model_source_1 = require_model_source();
      var LocalModelSource = class LocalModelSource extends model_source_1.ModelSource {
        constructor() {
          super(...arguments);
          this.currentRoot = smodel_factory_1.EMPTY_ROOT;
        }
        get model() {
          return this.currentRoot;
        }
        set model(root) {
          this.setModel(root);
        }
        initialize(registry) {
          super.initialize(registry);
          registry.register(actions_1.ComputedBoundsAction.KIND, this);
          registry.register(actions_1.RequestPopupModelAction.KIND, this);
        }
        /**
         * Set the model without incremental update.
         */
        setModel(newRoot) {
          this.currentRoot = newRoot;
          return this.submitModel(newRoot, false);
        }
        commitModel(newRoot) {
          const previousRoot = this.currentRoot;
          this.currentRoot = newRoot;
          return previousRoot;
        }
        /**
         * Apply an incremental update to the model with an animation showing the transition to
         * the new state. If `newRoot` is undefined, the current root is submitted; in that case
         * it is assumed that it has been modified before.
         */
        updateModel(newRoot) {
          if (newRoot === void 0) {
            return this.submitModel(this.currentRoot, true);
          } else {
            this.currentRoot = newRoot;
            return this.submitModel(newRoot, true);
          }
        }
        /**
         * Get the current selection from the model.
         */
        async getSelection() {
          const res = await this.actionDispatcher.request(sprotty_protocol_1.GetSelectionAction.create());
          const result = [];
          this.gatherSelectedElements(this.currentRoot, new Set(res.selectedElementsIDs), result);
          return result;
        }
        gatherSelectedElements(element, selected, result) {
          if (selected.has(element.id)) {
            result.push(element);
          }
          if (element.children) {
            for (const child of element.children) {
              this.gatherSelectedElements(child, selected, result);
            }
          }
        }
        /**
         * Get the current viewport from the model.
         */
        async getViewport() {
          const res = await this.actionDispatcher.request(sprotty_protocol_1.GetViewportAction.create());
          return {
            scroll: res.viewport.scroll,
            zoom: res.viewport.zoom,
            canvasBounds: res.canvasBounds
          };
        }
        /**
         * If client layout is active, run a `RequestBoundsAction` and wait for the resulting
         * `ComputedBoundsAction`, otherwise call `doSubmitModel()` directly.
         */
        async submitModel(newRoot, update, cause) {
          if (this.viewerOptions.needsClientLayout) {
            const computedBounds = await this.actionDispatcher.request(actions_1.RequestBoundsAction.create(newRoot));
            const index = this.computedBoundsApplicator.apply(this.currentRoot, computedBounds);
            await this.doSubmitModel(newRoot, update, cause, index);
          } else {
            await this.doSubmitModel(newRoot, update, cause);
          }
        }
        /**
         * Submit the given model with an `UpdateModelAction` or a `SetModelAction` depending on the
         * `update` argument. If available, the model layout engine is invoked first.
         */
        async doSubmitModel(newRoot, update, cause, index) {
          if (this.layoutEngine !== void 0) {
            try {
              const layoutResult = this.layoutEngine.layout(newRoot, index);
              if (layoutResult instanceof Promise)
                newRoot = await layoutResult;
              else if (layoutResult !== void 0)
                newRoot = layoutResult;
            } catch (error) {
              this.logger.error(this, error.toString(), error.stack);
            }
          }
          const lastSubmittedModelType = this.lastSubmittedModelType;
          this.lastSubmittedModelType = newRoot.type;
          if (cause && cause.kind === actions_1.RequestModelAction.KIND && cause.requestId) {
            const request = cause;
            await this.actionDispatcher.dispatch(actions_1.SetModelAction.create(newRoot, request.requestId));
          } else if (update && newRoot.type === lastSubmittedModelType) {
            const input = Array.isArray(update) ? update : newRoot;
            await this.actionDispatcher.dispatch(actions_1.UpdateModelAction.create(input, { animate: true, cause }));
          } else {
            await this.actionDispatcher.dispatch(actions_1.SetModelAction.create(newRoot));
          }
        }
        /**
         * Modify the current model with an array of matches.
         */
        applyMatches(matches) {
          const root = this.currentRoot;
          (0, model_matching_1.applyMatches)(root, matches);
          return this.submitModel(root, matches);
        }
        /**
         * Modify the current model by adding new elements.
         */
        addElements(elements) {
          const matches = [];
          for (const e2 of elements) {
            const anye = e2;
            if (typeof anye.element === "object" && typeof anye.parentId === "string") {
              matches.push({
                right: anye.element,
                rightParentId: anye.parentId
              });
            } else if (typeof anye.id === "string") {
              matches.push({
                right: anye,
                rightParentId: this.currentRoot.id
              });
            }
          }
          return this.applyMatches(matches);
        }
        /**
         * Modify the current model by removing elements.
         */
        removeElements(elements) {
          const matches = [];
          const index = new model_utils_1.SModelIndex();
          index.add(this.currentRoot);
          for (const e2 of elements) {
            const anye = e2;
            if (anye.elementId !== void 0 && anye.parentId !== void 0) {
              const element = index.getById(anye.elementId);
              if (element !== void 0) {
                matches.push({
                  left: element,
                  leftParentId: anye.parentId
                });
              }
            } else {
              const element = index.getById(anye);
              if (element !== void 0) {
                matches.push({
                  left: element,
                  leftParentId: this.currentRoot.id
                });
              }
            }
          }
          return this.applyMatches(matches);
        }
        // ----- Methods for handling incoming actions ----------------------------
        handle(action) {
          switch (action.kind) {
            case actions_1.RequestModelAction.KIND:
              this.handleRequestModel(action);
              break;
            case actions_1.ComputedBoundsAction.KIND:
              this.computedBoundsApplicator.apply(this.currentRoot, action);
              break;
            case actions_1.RequestPopupModelAction.KIND:
              this.handleRequestPopupModel(action);
              break;
            case actions_1.ExportSvgAction.KIND:
              this.handleExportSvgAction(action);
              break;
          }
        }
        handleRequestModel(action) {
          this.submitModel(this.currentRoot, false, action);
        }
        handleRequestPopupModel(action) {
          if (this.popupModelProvider !== void 0) {
            const element = (0, model_utils_1.findElement)(this.currentRoot, action.elementId);
            const popupRoot = this.popupModelProvider.getPopupModel(action, element);
            if (popupRoot !== void 0) {
              popupRoot.canvasBounds = action.bounds;
              this.actionDispatcher.dispatch(actions_1.SetPopupModelAction.create(popupRoot, action.requestId));
            }
          }
        }
        handleExportSvgAction(action) {
          const blob = new Blob([action.svg], { type: "text/plain;charset=utf-8" });
          (0, file_saver_1.saveAs)(blob, "diagram.svg");
        }
      };
      exports.LocalModelSource = LocalModelSource;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], LocalModelSource.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(model_source_1.ComputedBoundsApplicator),
        __metadata("design:type", model_source_1.ComputedBoundsApplicator)
      ], LocalModelSource.prototype, "computedBoundsApplicator", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IPopupModelProvider),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], LocalModelSource.prototype, "popupModelProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IModelLayoutEngine),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], LocalModelSource.prototype, "layoutEngine", void 0);
      exports.LocalModelSource = LocalModelSource = __decorate([
        (0, inversify_1.injectable)()
      ], LocalModelSource);
    }
  });

  // node_modules/sprotty/lib/model-source/logging.js
  var require_logging2 = __commonJS({
    "node_modules/sprotty/lib/model-source/logging.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ForwardingLogger = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var logging_1 = require_logging();
      var types_1 = require_types();
      var ForwardingLogger = class ForwardingLogger {
        error(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.error)
            this.forward(thisArg, message, logging_1.LogLevel.error, params);
        }
        warn(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.warn)
            this.forward(thisArg, message, logging_1.LogLevel.warn, params);
        }
        info(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.info)
            this.forward(thisArg, message, logging_1.LogLevel.info, params);
        }
        log(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.log) {
            try {
              const caller = typeof thisArg === "object" ? thisArg.constructor.name : String(thisArg);
              console.log.apply(thisArg, [caller + ": " + message, ...params]);
            } catch (error) {
            }
          }
        }
        forward(thisArg, message, logLevel, params) {
          const date = /* @__PURE__ */ new Date();
          const action = actions_1.LoggingAction.create({
            message,
            severity: logging_1.LogLevel[logLevel],
            time: date.toLocaleTimeString(),
            caller: typeof thisArg === "object" ? thisArg.constructor.name : String(thisArg),
            params: params.map((p3) => JSON.stringify(p3))
          });
          this.modelSourceProvider().then((modelSource) => {
            try {
              modelSource.handle(action);
            } catch (error) {
              try {
                console.log.apply(thisArg, [message, action, error]);
              } catch (e2) {
              }
            }
          });
        }
      };
      exports.ForwardingLogger = ForwardingLogger;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ModelSourceProvider),
        __metadata("design:type", Function)
      ], ForwardingLogger.prototype, "modelSourceProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.LogLevel),
        __metadata("design:type", Number)
      ], ForwardingLogger.prototype, "logLevel", void 0);
      exports.ForwardingLogger = ForwardingLogger = __decorate([
        (0, inversify_1.injectable)()
      ], ForwardingLogger);
    }
  });

  // node_modules/sprotty/lib/model-source/websocket.js
  var require_websocket = __commonJS({
    "node_modules/sprotty/lib/model-source/websocket.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WebSocketDiagramServerProxy = void 0;
      var inversify_1 = require_cjs4();
      var diagram_server_1 = require_diagram_server2();
      var WebSocketDiagramServerProxy = class WebSocketDiagramServerProxy extends diagram_server_1.DiagramServerProxy {
        listen(webSocket) {
          webSocket.addEventListener("message", (event) => {
            this.messageReceived(event.data);
          });
          webSocket.addEventListener("error", (event) => {
            this.logger.error(this, "error event received", event);
          });
          this.webSocket = webSocket;
        }
        disconnect() {
          if (this.webSocket) {
            this.webSocket.close();
            this.webSocket = void 0;
          }
        }
        sendMessage(message) {
          if (this.webSocket) {
            this.webSocket.send(JSON.stringify(message));
          } else {
            throw new Error("WebSocket is not connected");
          }
        }
      };
      exports.WebSocketDiagramServerProxy = WebSocketDiagramServerProxy;
      exports.WebSocketDiagramServerProxy = WebSocketDiagramServerProxy = __decorate([
        (0, inversify_1.injectable)()
      ], WebSocketDiagramServerProxy);
    }
  });

  // node_modules/sprotty/lib/utils/color.js
  var require_color = __commonJS({
    "node_modules/sprotty/lib/utils/color.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ColorMap = exports.toSVG = exports.rgb = void 0;
      function rgb(red, green, blue) {
        return {
          red,
          green,
          blue
        };
      }
      exports.rgb = rgb;
      function toSVG(c3) {
        return "rgb(" + c3.red + "," + c3.green + "," + c3.blue + ")";
      }
      exports.toSVG = toSVG;
      var ColorMap = class {
        constructor(stops) {
          this.stops = stops;
        }
        getColor(t3) {
          t3 = Math.max(0, Math.min(0.99999999, t3));
          const i2 = Math.floor(t3 * this.stops.length);
          return this.stops[i2];
        }
      };
      exports.ColorMap = ColorMap;
    }
  });

  // node_modules/sprotty/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/sprotty/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.modelSourceModule = exports.zorderModule = exports.viewportModule = exports.updateModule = exports.undoRedoModule = exports.selectModule = exports.routingModule = exports.openModule = exports.moveModule = exports.hoverModule = exports.fadeModule = exports.exportModule = exports.expandModule = exports.edgeLayoutModule = exports.edgeJunctionModule = exports.edgeIntersectionModule = exports.decorationModule = exports.contextMenuModule = exports.commandPaletteModule = exports.buttonModule = exports.boundsModule = exports.defaultModule = void 0;
      __exportStar(require_action(), exports);
      __exportStar(require_action_dispatcher(), exports);
      __exportStar(require_action_handler(), exports);
      __exportStar(require_diagram_locker(), exports);
      __exportStar(require_animation_frame_syncer(), exports);
      __exportStar(require_animation(), exports);
      __exportStar(require_easing(), exports);
      __exportStar(require_command(), exports);
      __exportStar(require_command_registration(), exports);
      __exportStar(require_command_stack_options(), exports);
      __exportStar(require_command_stack(), exports);
      __exportStar(require_initialize_canvas(), exports);
      __exportStar(require_set_model(), exports);
      __exportStar(require_smodel_factory(), exports);
      __exportStar(require_smodel_utils(), exports);
      __exportStar(require_smodel(), exports);
      __exportStar(require_ui_extension_registry(), exports);
      __exportStar(require_ui_extension(), exports);
      __exportStar(require_key_tool(), exports);
      __exportStar(require_mouse_tool(), exports);
      __exportStar(require_thunk_view(), exports);
      __exportStar(require_view(), exports);
      __exportStar(require_viewer_cache(), exports);
      __exportStar(require_viewer_options(), exports);
      __exportStar(require_viewer(), exports);
      __exportStar(require_vnode_postprocessor(), exports);
      __exportStar(require_vnode_utils(), exports);
      __exportStar(require_types(), exports);
      var di_config_1 = __importDefault(require_di_config());
      exports.defaultModule = di_config_1.default;
      __exportStar(require_bounds_manipulation(), exports);
      __exportStar(require_hidden_bounds_updater(), exports);
      __exportStar(require_layout(), exports);
      __exportStar(require_model2(), exports);
      __exportStar(require_vbox_layout(), exports);
      __exportStar(require_hbox_layout(), exports);
      __exportStar(require_stack_layout(), exports);
      __exportStar(require_views(), exports);
      __exportStar(require_button_handler(), exports);
      __exportStar(require_model4(), exports);
      __exportStar(require_action_providers(), exports);
      __exportStar(require_command_palette(), exports);
      __exportStar(require_context_menu_service(), exports);
      __exportStar(require_menu_providers(), exports);
      __exportStar(require_mouse_listener(), exports);
      __exportStar(require_di_config2(), exports);
      __exportStar(require_edge_layout(), exports);
      __exportStar(require_model10(), exports);
      __exportStar(require_create(), exports);
      __exportStar(require_create_on_drag(), exports);
      __exportStar(require_di_config3(), exports);
      __exportStar(require_delete(), exports);
      __exportStar(require_edit_label(), exports);
      __exportStar(require_edit_label_ui(), exports);
      __exportStar(require_edit_routing(), exports);
      __exportStar(require_model11(), exports);
      __exportStar(require_reconnect(), exports);
      __exportStar(require_expand(), exports);
      __exportStar(require_model14(), exports);
      __exportStar(require_views2(), exports);
      __exportStar(require_export(), exports);
      __exportStar(require_model13(), exports);
      __exportStar(require_svg_exporter(), exports);
      __exportStar(require_svg_export_postprocessor(), exports);
      __exportStar(require_fade(), exports);
      __exportStar(require_model3(), exports);
      __exportStar(require_hover(), exports);
      __exportStar(require_model7(), exports);
      __exportStar(require_model15(), exports);
      __exportStar(require_views3(), exports);
      __exportStar(require_decoration_placer(), exports);
      __exportStar(require_intersection_finder(), exports);
      __exportStar(require_sweepline(), exports);
      __exportStar(require_junction_finder(), exports);
      __exportStar(require_junction_postprocessor(), exports);
      __exportStar(require_model8(), exports);
      __exportStar(require_move(), exports);
      __exportStar(require_snap(), exports);
      __exportStar(require_model5(), exports);
      __exportStar(require_open(), exports);
      __exportStar(require_model16(), exports);
      __exportStar(require_model17(), exports);
      __exportStar(require_views4(), exports);
      __exportStar(require_anchor(), exports);
      __exportStar(require_abstract_edge_router(), exports);
      __exportStar(require_bezier_anchors(), exports);
      __exportStar(require_bezier_edge_router(), exports);
      __exportStar(require_manhattan_anchors(), exports);
      __exportStar(require_manhattan_edge_router(), exports);
      __exportStar(require_model9(), exports);
      __exportStar(require_polyline_anchors(), exports);
      __exportStar(require_polyline_edge_router(), exports);
      __exportStar(require_routing(), exports);
      __exportStar(require_views5(), exports);
      __exportStar(require_model6(), exports);
      __exportStar(require_select(), exports);
      __exportStar(require_undo_redo(), exports);
      __exportStar(require_model_matching(), exports);
      __exportStar(require_update_model(), exports);
      __exportStar(require_center_fit(), exports);
      __exportStar(require_model12(), exports);
      __exportStar(require_scroll(), exports);
      __exportStar(require_viewport_root(), exports);
      __exportStar(require_viewport(), exports);
      __exportStar(require_zoom(), exports);
      __exportStar(require_zorder(), exports);
      var di_config_2 = __importDefault(require_di_config4());
      exports.boundsModule = di_config_2.default;
      var di_config_3 = __importDefault(require_di_config5());
      exports.buttonModule = di_config_3.default;
      var di_config_4 = __importDefault(require_di_config6());
      exports.commandPaletteModule = di_config_4.default;
      var di_config_5 = __importDefault(require_di_config7());
      exports.contextMenuModule = di_config_5.default;
      var di_config_6 = __importDefault(require_di_config8());
      exports.decorationModule = di_config_6.default;
      var di_config_7 = __importDefault(require_di_config9());
      exports.edgeIntersectionModule = di_config_7.default;
      var di_config_8 = __importDefault(require_di_config10());
      exports.edgeJunctionModule = di_config_8.default;
      var di_config_9 = __importDefault(require_di_config2());
      exports.edgeLayoutModule = di_config_9.default;
      var di_config_10 = __importDefault(require_di_config11());
      exports.expandModule = di_config_10.default;
      var di_config_11 = __importDefault(require_di_config12());
      exports.exportModule = di_config_11.default;
      var di_config_12 = __importDefault(require_di_config13());
      exports.fadeModule = di_config_12.default;
      var di_config_13 = __importDefault(require_di_config14());
      exports.hoverModule = di_config_13.default;
      var di_config_14 = __importDefault(require_di_config15());
      exports.moveModule = di_config_14.default;
      var di_config_15 = __importDefault(require_di_config16());
      exports.openModule = di_config_15.default;
      var di_config_16 = __importDefault(require_di_config17());
      exports.routingModule = di_config_16.default;
      var di_config_17 = __importDefault(require_di_config18());
      exports.selectModule = di_config_17.default;
      var di_config_18 = __importDefault(require_di_config19());
      exports.undoRedoModule = di_config_18.default;
      var di_config_19 = __importDefault(require_di_config20());
      exports.updateModule = di_config_19.default;
      var di_config_20 = __importDefault(require_di_config21());
      exports.viewportModule = di_config_20.default;
      var di_config_21 = __importDefault(require_di_config22());
      exports.zorderModule = di_config_21.default;
      __exportStar(require_sgraph(), exports);
      __exportStar(require_views6(), exports);
      __exportStar(require_modules(), exports);
      __exportStar(require_generic_views(), exports);
      __exportStar(require_html_views(), exports);
      __exportStar(require_jsx(), exports);
      __exportStar(require_model18(), exports);
      __exportStar(require_svg_views(), exports);
      __exportStar(require_commit_model(), exports);
      __exportStar(require_diagram_server2(), exports);
      __exportStar(require_local_model_source(), exports);
      __exportStar(require_logging2(), exports);
      __exportStar(require_model_source(), exports);
      __exportStar(require_websocket(), exports);
      var di_config_22 = __importDefault(require_di_config23());
      exports.modelSourceModule = di_config_22.default;
      __exportStar(require_browser(), exports);
      __exportStar(require_codicon(), exports);
      __exportStar(require_color(), exports);
      __exportStar(require_geometry2(), exports);
      __exportStar(require_inversify(), exports);
      __exportStar(require_logging(), exports);
      __exportStar(require_registry(), exports);
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/api-override.js
  var require_api_override = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/api-override.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MouseListener = exports.KeyListener = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib2();
      var KeyListener = class KeyListener extends sprotty_1.KeyListener {
        keyDown(element, event) {
          return [];
        }
        keyUp(element, event) {
          return [];
        }
      };
      exports.KeyListener = KeyListener;
      exports.KeyListener = KeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], KeyListener);
      var MouseListener = class MouseListener extends sprotty_1.MouseListener {
        mouseOver(target, event) {
          return [];
        }
        mouseOut(target, event) {
          return [];
        }
        mouseEnter(target, event) {
          return [];
        }
        mouseLeave(target, event) {
          return [];
        }
        mouseDown(target, event) {
          return [];
        }
        mouseMove(target, event) {
          return [];
        }
        mouseUp(target, event) {
          return [];
        }
        wheel(target, event) {
          return [];
        }
        doubleClick(target, event) {
          return [];
        }
        contextMenu(target, event) {
          return [];
        }
        dragOver(target, event) {
          return [];
        }
        drop(target, event) {
          return [];
        }
        decorate(vnode, element) {
          return vnode;
        }
      };
      exports.MouseListener = MouseListener;
      exports.MouseListener = MouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], MouseListener);
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js
  var require_array_util = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/array-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.arrayOf = exports.partition = exports.isArrayMatching = exports.isStringArray = exports.isArrayOfPrimitive = exports.isArrayOfClass = exports.isArrayOfType = exports.distinctAdd = exports.asArray = exports.flatPush = exports.remove = exports.pluck = exports.last = exports.first = void 0;
      function first(array, n) {
        if (n) {
          return array.filter((_3, index) => index < n);
        }
        return array[0];
      }
      exports.first = first;
      function last(array, n) {
        if (n) {
          return array.filter((_3, index) => array.length - index <= n);
        }
        return array[array.length - 1];
      }
      exports.last = last;
      function pluck(array, key) {
        return array.map((element) => element[key]);
      }
      exports.pluck = pluck;
      function remove(array, ...values) {
        values.forEach((value) => {
          const index = array.indexOf(value);
          if (index >= 0) {
            array.splice(index, 1);
          }
        });
      }
      exports.remove = remove;
      function flatPush(array, toPush) {
        toPush.forEach((value) => Array.isArray(value) ? array.push(...value) : array.push(value));
      }
      exports.flatPush = flatPush;
      function asArray(maybe) {
        if (Array.isArray(maybe)) {
          return maybe;
        }
        return [maybe];
      }
      exports.asArray = asArray;
      function distinctAdd(array, ...values) {
        values.forEach((value) => {
          if (!array.includes(value)) {
            array.push(value);
          }
        });
      }
      exports.distinctAdd = distinctAdd;
      function isArrayOfType(object, typeGuard, supportEmpty = false) {
        return isArrayMatching(object, (element) => typeGuard(element), supportEmpty);
      }
      exports.isArrayOfType = isArrayOfType;
      function isArrayOfClass(object, constructor, supportEmpty = false) {
        return isArrayMatching(object, (element) => element instanceof constructor, supportEmpty);
      }
      exports.isArrayOfClass = isArrayOfClass;
      function isArrayOfPrimitive(object, primitiveType, supportEmpty = false) {
        return isArrayMatching(object, (element) => typeof element === primitiveType, supportEmpty);
      }
      exports.isArrayOfPrimitive = isArrayOfPrimitive;
      function isStringArray(object, supportEmpty = false) {
        return isArrayOfPrimitive(object, "string", supportEmpty);
      }
      exports.isStringArray = isStringArray;
      function isArrayMatching(object, predicate, supportEmpty = false) {
        return Array.isArray(object) && object.every(predicate) && (supportEmpty || object.length > 0);
      }
      exports.isArrayMatching = isArrayMatching;
      function partition(source, matchGuard) {
        const match = [];
        const rest = [];
        source.forEach((element) => {
          if (matchGuard(element)) {
            match.push(element);
          } else {
            rest.push(element);
          }
        });
        return { match, rest };
      }
      exports.partition = partition;
      function arrayOf(...values) {
        return values.filter((element) => element !== void 0);
      }
      exports.arrayOf = arrayOf;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js
  var require_type_util = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/type-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hasArrayProp = exports.hasFunctionProp = exports.hasObjectProp = exports.hasNumberProp = exports.hasBooleanProp = exports.hasStringProp = exports.MaybeActions = exports.call = exports.toTypeGuard = exports.typeGuardOr = exports.typeGuard = exports.AnyObject = void 0;
      var array_util_1 = require_array_util();
      var AnyObject;
      (function(AnyObject2) {
        function is(object) {
          return object !== null && typeof object === "object";
        }
        AnyObject2.is = is;
      })(AnyObject || (exports.AnyObject = AnyObject = {}));
      function typeGuard(one, other) {
        return (element) => one(element) && other(element);
      }
      exports.typeGuard = typeGuard;
      function typeGuardOr(one, other) {
        return (element) => one(element) || other(element);
      }
      exports.typeGuardOr = typeGuardOr;
      function toTypeGuard(constructor) {
        return (element) => element instanceof constructor;
      }
      exports.toTypeGuard = toTypeGuard;
      function call(maybeFun, ...args) {
        return typeof maybeFun === "function" ? maybeFun(...args) : maybeFun;
      }
      exports.call = call;
      var MaybeActions;
      (function(MaybeActions2) {
        function asArray(actions) {
          const cleanup = actions ? call(actions) : [];
          return cleanup ? (0, array_util_1.asArray)(cleanup) : [];
        }
        MaybeActions2.asArray = asArray;
      })(MaybeActions || (exports.MaybeActions = MaybeActions = {}));
      function hasStringProp(object, propertyKey, optional = false) {
        const property = object[propertyKey];
        return property !== void 0 ? typeof property === "string" : optional;
      }
      exports.hasStringProp = hasStringProp;
      function hasBooleanProp(object, propertyKey, optional = false) {
        const property = object[propertyKey];
        return property !== void 0 ? typeof property === "boolean" : optional;
      }
      exports.hasBooleanProp = hasBooleanProp;
      function hasNumberProp(object, propertyKey, optional = false) {
        const property = object[propertyKey];
        return property !== void 0 ? typeof property === "number" : optional;
      }
      exports.hasNumberProp = hasNumberProp;
      function hasObjectProp(object, propertyKey, optional = false) {
        const property = object[propertyKey];
        return property !== void 0 ? AnyObject.is(property) : optional;
      }
      exports.hasObjectProp = hasObjectProp;
      function hasFunctionProp(object, propertyKey, optional = false) {
        const property = object[propertyKey];
        return property !== void 0 ? typeof property === "function" : optional;
      }
      exports.hasFunctionProp = hasFunctionProp;
      function hasArrayProp(object, propertyKey, optional = false) {
        const property = object[propertyKey];
        return property !== void 0 ? Array.isArray(property) : optional;
      }
      exports.hasArrayProp = hasArrayProp;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/di/feature-module.js
  var require_feature_module = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/di/feature-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeatureModule = void 0;
      var inversify_1 = require_cjs4();
      var array_util_1 = require_array_util();
      var FeatureModule = class _FeatureModule extends inversify_1.ContainerModule {
        constructor(registry, options = {}) {
          var _a4;
          super((bind, unbind, isBound, ...rest) => {
            if (this.configure(bind, isBound)) {
              registry(bind, unbind, isBound, ...rest);
              this.debugLog(`Loading of feature module with id '${this.featureId.toString()}' completed`);
            }
          });
          this.featureId = (_a4 = options.featureId) !== null && _a4 !== void 0 ? _a4 : this.createFeatureId();
          this.requires = options.requires;
        }
        createFeatureId() {
          return Symbol(this.id);
        }
        /**
         * Configures the feature module i.e. checks if the requirements are met.
         * If this is the case the {@link FeatureModule.featureId} will be bound and the module will be loaded
         * @param bind container bind function
         * @param isBound container isBound function
         * @returns `true` if all requirements are met and the module is loaded. `false` otherwise
         */
        configure(bind, isBound) {
          this.debugLog(`Trying to load feature module with id '${this.featureId.toString()}'`);
          if (this.isLoaded({ isBound })) {
            const message = `Could not load feature module. Another module with id '${this.featureId.toString()}' is already loaded`;
            this.debugLog(message);
            throw new Error(message);
          }
          if (this.checkRequirements(isBound)) {
            this.debugLog(`Requirements are met, continue loading of feature module with id '${this.featureId.toString()}'`);
            bind(this.featureId).toConstantValue(this.featureId);
            return true;
          }
          return false;
        }
        debugLog(message, ...optionalParams) {
          if (_FeatureModule.DEBUG_LOG_ENABLED) {
            console.log(message, ...optionalParams);
          }
        }
        /**
         * Checks if all required {@link FeatureModule}s are already loaded/bound in the container.
         * @param isBound The `isBound` property of the module callback. Used to check the required modules.
         * @returns `true` if all requirements are met, `false` otherwise
         */
        checkRequirements(isBound) {
          var _a4;
          const requires = (0, array_util_1.asArray)((_a4 = this.requires) !== null && _a4 !== void 0 ? _a4 : []);
          if (requires.length === 0) {
            return true;
          }
          const missing = requires.filter((module2) => !module2.isLoaded({ isBound }));
          if (missing.length > 0) {
            this.debugLog(
              // eslint-disable-next-line max-len
              `Could not load feature module. Required modules are not loaded. Feature ids: ${missing.map((m3) => m3.featureId.toString()).join(", ")}`
            );
            return false;
          }
          return true;
        }
        isLoaded(context) {
          return context.isBound(this.featureId);
        }
      };
      exports.FeatureModule = FeatureModule;
      FeatureModule.DEBUG_LOG_ENABLED = false;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/di/container-configuration.js
  var require_container_configuration = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/di/container-configuration.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.resolveContainerConfiguration = exports.initializeContainer = void 0;
      var array_util_1 = require_array_util();
      var type_util_1 = require_type_util();
      var feature_module_1 = require_feature_module();
      function initializeContainer(container, ...containerConfigurations) {
        const modules = resolveContainerConfiguration(...containerConfigurations);
        container.load(...modules);
        return container;
      }
      exports.initializeContainer = initializeContainer;
      function resolveContainerConfiguration(...containerConfigurations) {
        const modules = [];
        containerConfigurations.forEach((config) => {
          if (isContainerModule(config)) {
            (0, array_util_1.distinctAdd)(modules, config);
          } else {
            if (config.remove) {
              (0, array_util_1.remove)(modules, ...(0, array_util_1.asArray)(config.remove));
            }
            if (config.add) {
              (0, array_util_1.distinctAdd)(modules, ...(0, array_util_1.asArray)(config.add));
            }
            if (config.replace) {
              (0, array_util_1.asArray)(config.replace).forEach((replace) => {
                const existingIndex = modules.findIndex((m3) => m3 instanceof feature_module_1.FeatureModule && m3.featureId === replace.featureId);
                if (existingIndex >= 0) {
                  modules[existingIndex] = replace;
                } else {
                  console.warn(`Could not find module to replace with feature id ${replace.featureId.toString()}.Adding replacement module to the end of the resolved configurations.`);
                  (0, array_util_1.distinctAdd)(modules, replace);
                }
              });
            }
          }
        });
        const featureIds = /* @__PURE__ */ new Set();
        const duplicates = [];
        modules.forEach((module2) => {
          if (module2 instanceof feature_module_1.FeatureModule) {
            if (featureIds.has(module2.featureId)) {
              duplicates.push(module2);
            } else {
              featureIds.add(module2.featureId);
            }
          }
        });
        if (duplicates.length > 0) {
          const culprits = duplicates.map((m3) => m3.featureId.toString()).join(", ");
          throw new Error(`Could not resolve container configuration. Non-unique feature ids found in container configuration: ${culprits}`);
        }
        return modules;
      }
      exports.resolveContainerConfiguration = resolveContainerConfiguration;
      function isContainerModule(config) {
        return (0, type_util_1.hasNumberProp)(config, "id") && (0, type_util_1.hasFunctionProp)(config, "registry");
      }
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/di/inversify-util.js
  var require_inversify_util = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/di/inversify-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindAsService = exports.lazyBind = exports.bindOrRebind = void 0;
      function bindOrRebind(context, serviceIdentifier) {
        if (context.isBound(serviceIdentifier)) {
          return context.rebind(serviceIdentifier);
        }
        return context.bind(serviceIdentifier);
      }
      exports.bindOrRebind = bindOrRebind;
      function lazyBind(context, serviceIdentifier) {
        if (context.isBound(serviceIdentifier)) {
          return void 0;
        }
        return context.bind(serviceIdentifier);
      }
      exports.lazyBind = lazyBind;
      function bindAsService(context, serviceIdentifier, targetService) {
        const bind = typeof context === "object" ? context.bind.bind(context) : context;
        bind(targetService).toSelf().inSingletonScope();
        bind(serviceIdentifier).toService(targetService);
      }
      exports.bindAsService = bindAsService;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/di/lazy-injector.js
  var require_lazy_injector = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/di/lazy-injector.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindLazyInjector = exports.DefaultLazyInjector = exports.LazyInjector = void 0;
      var inversify_1 = require_cjs4();
      exports.LazyInjector = Symbol("LazyInjector");
      var DefaultLazyInjector = class {
        constructor(container) {
          this.container = container;
          this.cache = /* @__PURE__ */ new Map();
        }
        get(serviceIdentifier) {
          const service = this.getOptional(serviceIdentifier);
          if (service === void 0) {
            throw new Error("No matching bindings found for serviceIdentifier:" + (0, inversify_1.getServiceIdentifierAsString)(serviceIdentifier));
          }
          return service;
        }
        getOptional(serviceIdentifier) {
          if (this.cache.has(serviceIdentifier)) {
            return this.cache.get(serviceIdentifier);
          }
          const service = this.container.isBound(serviceIdentifier) ? this.container.get(serviceIdentifier) : void 0;
          this.cache.set(serviceIdentifier, service);
          return service;
        }
        getAll(serviceIdentifier) {
          if (this.cache.has(serviceIdentifier)) {
            return this.cache.get(serviceIdentifier);
          }
          const services = this.container.isBound(serviceIdentifier) ? this.container.getAll(serviceIdentifier) : [];
          this.cache.set(serviceIdentifier, services);
          return services;
        }
      };
      exports.DefaultLazyInjector = DefaultLazyInjector;
      function bindLazyInjector(context) {
        const bind = typeof context === "object" ? context.bind.bind(context) : context;
        bind(exports.LazyInjector).toDynamicValue((ctx) => new DefaultLazyInjector(ctx.container));
      }
      exports.bindLazyInjector = bindLazyInjector;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports.stringArray = stringArray;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
      var is = require_is();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
      var ResponseError = class _ResponseError extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, _ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports.ResponseError = ResponseError;
      var ParameterStructures = class _ParameterStructures {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports.NotificationType9 = NotificationType9;
      var Message;
      (function(Message2) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message2.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message2.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message2.isResponse = isResponse;
      })(Message || (exports.Message = Message = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
      "use strict";
      var _a4;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch || (exports.Touch = Touch = {}));
      var LinkedMap = class {
        constructor() {
          this[_a4] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a4 = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports.LinkedMap = LinkedMap;
      var LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports.LRUCache = LRUCache;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Disposable = void 0;
      var Disposable;
      (function(Disposable2) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable2.create = create;
      })(Disposable || (exports.Disposable = Disposable = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports.default = RAL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Emitter = exports.Event = void 0;
      var ral_1 = require_ral();
      var Event2;
      (function(Event3) {
        const _disposable = { dispose() {
        } };
        Event3.None = function() {
          return _disposable;
        };
      })(Event2 || (exports.Event = Event2 = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i2 = 0, len = this._callbacks.length; i2 < len; i2++) {
            if (this._callbacks[i2] === callback) {
              if (this._contexts[i2] === context) {
                this._callbacks.splice(i2, 1);
                this._contexts.splice(i2, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i2 = 0, len = callbacks.length; i2 < len; i2++) {
            try {
              ret.push(callbacks[i2].apply(contexts[i2], args));
            } catch (e2) {
              (0, ral_1.default)().console.error(e2);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter = class _Emitter {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = _Emitter._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports.Emitter = Emitter;
      Emitter._noop = function() {
      };
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CancellationTokenSource = exports.CancellationToken = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var events_1 = require_events();
      var CancellationToken;
      (function(CancellationToken2) {
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken2.is = is;
      })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
      var shortcutEvent = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
      exports.CancellationTokenSource = CancellationTokenSource;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
  var require_sharedArrayCancellation = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
      var cancellation_1 = require_cancellation();
      var CancellationState;
      (function(CancellationState2) {
        CancellationState2.Continue = 0;
        CancellationState2.Cancelled = 1;
      })(CancellationState || (CancellationState = {}));
      var SharedArraySenderStrategy = class {
        constructor() {
          this.buffers = /* @__PURE__ */ new Map();
        }
        enableCancellation(request) {
          if (request.id === null) {
            return;
          }
          const buffer = new SharedArrayBuffer(4);
          const data = new Int32Array(buffer, 0, 1);
          data[0] = CancellationState.Continue;
          this.buffers.set(request.id, buffer);
          request.$cancellationData = buffer;
        }
        async sendCancellation(_conn, id) {
          const buffer = this.buffers.get(id);
          if (buffer === void 0) {
            return;
          }
          const data = new Int32Array(buffer, 0, 1);
          Atomics.store(data, 0, CancellationState.Cancelled);
        }
        cleanup(id) {
          this.buffers.delete(id);
        }
        dispose() {
          this.buffers.clear();
        }
      };
      exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
      var SharedArrayBufferCancellationToken = class {
        constructor(buffer) {
          this.data = new Int32Array(buffer, 0, 1);
        }
        get isCancellationRequested() {
          return Atomics.load(this.data, 0) === CancellationState.Cancelled;
        }
        get onCancellationRequested() {
          throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
        }
      };
      var SharedArrayBufferCancellationTokenSource = class {
        constructor(buffer) {
          this.token = new SharedArrayBufferCancellationToken(buffer);
        }
        cancel() {
        }
        dispose() {
        }
      };
      var SharedArrayReceiverStrategy = class {
        constructor() {
          this.kind = "request";
        }
        createCancellationTokenSource(request) {
          const buffer = request.$cancellationData;
          if (buffer === void 0) {
            return new cancellation_1.CancellationTokenSource();
          }
          return new SharedArrayBufferCancellationTokenSource(buffer);
        }
      };
      exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Semaphore = void 0;
      var ral_1 = require_ral();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports.Semaphore = Semaphore;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var events_1 = require_events();
      var semaphore_1 = require_semaphore();
      var MessageReader;
      (function(MessageReader2) {
        function is(value) {
          let candidate = value;
          return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
        }
        MessageReader2.is = is;
      })(MessageReader || (exports.MessageReader = MessageReader = {}));
      var AbstractMessageReader = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageReader = AbstractMessageReader;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.readSemaphore = new semaphore_1.Semaphore(1);
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          try {
            this.buffer.append(data);
            while (true) {
              if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders(true);
                if (!headers) {
                  return;
                }
                const contentLength = headers.get("content-length");
                if (!contentLength) {
                  this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                  return;
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                  this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                  return;
                }
                this.nextMessageLength = length;
              }
              const body = this.buffer.tryReadBody(this.nextMessageLength);
              if (body === void 0) {
                this.setPartialMessageTimer();
                return;
              }
              this.clearPartialMessageTimer();
              this.nextMessageLength = -1;
              this.readSemaphore.lock(async () => {
                const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                this.callback(message);
              }).catch((error) => {
                this.fireError(error);
              });
            }
          } catch (error) {
            this.fireError(error);
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var semaphore_1 = require_semaphore();
      var events_1 = require_events();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter;
      (function(MessageWriter2) {
        function is(value) {
          let candidate = value;
          return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
        }
        MessageWriter2.is = is;
      })(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
      var AbstractMessageWriter = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports.AbstractMessageWriter = AbstractMessageWriter;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders(lowerCaseKeys = false) {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
              const value = chunk[offset];
              switch (value) {
                case CR:
                  switch (state) {
                    case 0:
                      state = 1;
                      break;
                    case 2:
                      state = 3;
                      break;
                    default:
                      state = 0;
                  }
                  break;
                case LF:
                  switch (state) {
                    case 1:
                      state = 2;
                      break;
                    case 3:
                      state = 4;
                      offset++;
                      break row;
                    default:
                      state = 0;
                  }
                  break;
                default:
                  state = 0;
              }
              offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i2 = 0; i2 < headers.length - 2; i2++) {
            const header = headers[i2];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error(`Message header must separate key and value using ':'
${header}`);
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var messages_1 = require_messages();
      var linkedMap_1 = require_linkedMap();
      var events_1 = require_events();
      var cancellation_1 = require_cancellation();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace || (exports.Trace = Trace = {}));
      var TraceValues;
      (function(TraceValues2) {
        TraceValues2.Off = "off";
        TraceValues2.Messages = "messages";
        TraceValues2.Compact = "compact";
        TraceValues2.Verbose = "verbose";
      })(TraceValues || (exports.TraceValues = TraceValues = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString;
      })(Trace || (exports.Trace = Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
      var ConnectionError = class _ConnectionError extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, _ConnectionError.prototype);
        }
      };
      exports.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
      var IdCancellationReceiverStrategy;
      (function(IdCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
        }
        IdCancellationReceiverStrategy2.is = is;
      })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
      var RequestCancellationReceiverStrategy;
      (function(RequestCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
        }
        RequestCancellationReceiverStrategy2.is = is;
      })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_3) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_3) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
      var MessageStrategy;
      (function(MessageStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is.func(candidate.handleMessage);
        }
        MessageStrategy2.is = is;
      })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection(messageReader, messageWriter, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader.onClose(closeHandler);
        messageReader.onError(readErrorHandler);
        messageWriter.onClose(closeHandler);
        messageWriter.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer || messageQueue.size === 0) {
            return;
          }
          timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = void 0;
            processMessageQueue();
          });
        }
        function handleMessage(message) {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
              messageStrategy.handleMessage(message, handleMessage);
            } else {
              handleMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i2 = 0; i2 < params.length && i2 < numberOfParams; i2++) {
                result.push(undefinedToNull(params[i2]));
              }
              if (params.length < numberOfParams) {
                for (let i2 = params.length; i2 < numberOfParams; i2++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
              method = type;
              const first = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch((error) => {
              logger.error(`Sending notification failed.`);
              throw error;
            });
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is.string(type)) {
              method = type;
              const first = args[0];
              const last = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last)) {
                paramEnd = paramEnd - 1;
                token = last;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p3 = cancellationStrategy.sender.sendCancellation(connection, id);
                if (p3 === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p3.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === "function") {
              cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject) => {
              const resolveWithCleanup = (r3) => {
                resolve(r3);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r3) => {
                reject(r3);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              try {
                await messageWriter.write(requestMessage);
                responsePromises.set(id, responsePromise);
              } catch (error) {
                logger.error(`Sending request failed.`);
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
                throw error;
              }
            });
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is.func(messageWriter.dispose)) {
              messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
              messageReader.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection;
      }
      exports.createMessageConnection = createMessageConnection;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
      exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
      var messages_1 = require_messages();
      Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap();
      Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable();
      Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events();
      Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation();
      Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var sharedArrayCancellation_1 = require_sharedArrayCancellation();
      Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArraySenderStrategy;
      } });
      Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
      } });
      var messageReader_1 = require_messageReader();
      Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter();
      Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var messageBuffer_1 = require_messageBuffer();
      Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
        return messageBuffer_1.AbstractMessageBuffer;
      } });
      var connection_1 = require_connection();
      Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
        return connection_1.TraceValues;
      } });
      Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
        return connection_1.MessageStrategy;
      } });
      var ral_1 = require_ral();
      exports.RAL = ral_1.default;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var api_1 = require_api();
      var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return _MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          api_1.RAL.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports.default = RIL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/main.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
      var ril_1 = require_ril();
      ril_1.default.install();
      var api_1 = require_api();
      __exportStar(require_api(), exports);
      var BrowserMessageReader = class extends api_1.AbstractMessageReader {
        constructor(port) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          port.addEventListener("error", (event) => this.fireError(event));
          port.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports.BrowserMessageReader = BrowserMessageReader;
      var BrowserMessageWriter = class extends api_1.AbstractMessageWriter {
        constructor(port) {
          super();
          this.port = port;
          this.errorCount = 0;
          port.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.port.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports.BrowserMessageWriter = BrowserMessageWriter;
      function createMessageConnection(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports.createMessageConnection = createMessageConnection;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/event.js
  var require_event = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/event.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Emitter = exports.Event = void 0;
      var jsonrpc = require_main();
      var Event2;
      (function(Event3) {
        function once(event, listener, thisArgs, disposables) {
          const toDispose = event((e2) => {
            listener(e2);
            toDispose.dispose();
          }, thisArgs, disposables);
          return toDispose;
        }
        Event3.once = once;
        function waitUntil(event, predicate) {
          return new Promise((resolve) => {
            const toDispose = event((e2) => {
              if (!predicate || predicate(e2)) {
                resolve(e2);
                toDispose.dispose();
              }
            });
          });
        }
        Event3.waitUntil = waitUntil;
      })(Event2 || (exports.Event = Event2 = {}));
      var Emitter = class extends jsonrpc.Emitter {
        constructor(options = {}) {
          super(options);
        }
        /**
         * The even that is managed by this emitter.
         * Intended for the public to allow to subscribe to the emitter`s events.
         */
        get event() {
          return super.event;
        }
        /**
         * Fires and event and notifies all registered listeners
         */
        fire(event) {
          super.fire(event);
        }
      };
      exports.Emitter = Emitter;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/max.js
  var require_max = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/max.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _default = exports.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
    }
  });

  // node_modules/uuid/dist/commonjs-browser/nil.js
  var require_nil = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/nil.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _default = exports.default = "00000000-0000-0000-0000-000000000000";
    }
  });

  // node_modules/uuid/dist/commonjs-browser/regex.js
  var require_regex = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/regex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _default = exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/validate.js
  var require_validate = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _regex = _interopRequireDefault(require_regex());
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      function validate(uuid) {
        return typeof uuid === "string" && _regex.default.test(uuid);
      }
      var _default = exports.default = validate;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/parse.js
  var require_parse = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/parse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _validate = _interopRequireDefault(require_validate());
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      function parse(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }
        var v3;
        var arr = new Uint8Array(16);
        arr[0] = (v3 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
        arr[1] = v3 >>> 16 & 255;
        arr[2] = v3 >>> 8 & 255;
        arr[3] = v3 & 255;
        arr[4] = (v3 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
        arr[5] = v3 & 255;
        arr[6] = (v3 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
        arr[7] = v3 & 255;
        arr[8] = (v3 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
        arr[9] = v3 & 255;
        arr[10] = (v3 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
        arr[11] = v3 / 4294967296 & 255;
        arr[12] = v3 >>> 24 & 255;
        arr[13] = v3 >>> 16 & 255;
        arr[14] = v3 >>> 8 & 255;
        arr[15] = v3 & 255;
        return arr;
      }
      var _default = exports.default = parse;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/stringify.js
  var require_stringify = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/stringify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      exports.unsafeStringify = unsafeStringify;
      var _validate = _interopRequireDefault(require_validate());
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var byteToHex = [];
      for (i2 = 0; i2 < 256; ++i2) {
        byteToHex.push((i2 + 256).toString(16).slice(1));
      }
      var i2;
      function unsafeStringify(arr, offset = 0) {
        return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
      }
      function stringify(arr, offset = 0) {
        var uuid = unsafeStringify(arr, offset);
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Stringified UUID is invalid");
        }
        return uuid;
      }
      var _default = exports.default = stringify;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/rng.js
  var require_rng = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/rng.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = rng;
      var getRandomValues;
      var rnds8 = new Uint8Array(16);
      function rng() {
        if (!getRandomValues) {
          getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
          if (!getRandomValues) {
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
          }
        }
        return getRandomValues(rnds8);
      }
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v1.js
  var require_v1 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v1.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _rng = _interopRequireDefault(require_rng());
      var _stringify = require_stringify();
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var _nodeId;
      var _clockseq;
      var _lastMSecs = 0;
      var _lastNSecs = 0;
      function v1(options, buf, offset) {
        var i2 = buf && offset || 0;
        var b3 = buf || new Array(16);
        options = options || {};
        var node = options.node;
        var clockseq = options.clockseq;
        if (!options._v6) {
          if (!node) {
            node = _nodeId;
          }
          if (clockseq == null) {
            clockseq = _clockseq;
          }
        }
        if (node == null || clockseq == null) {
          var seedBytes = options.random || (options.rng || _rng.default)();
          if (node == null) {
            node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
            if (!_nodeId && !options._v6) {
              node[0] |= 1;
              _nodeId = node;
            }
          }
          if (clockseq == null) {
            clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
            if (_clockseq === void 0 && !options._v6) {
              _clockseq = clockseq;
            }
          }
        }
        var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
        var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
        var dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt2 < 0 && options.clockseq === void 0) {
          clockseq = clockseq + 1 & 16383;
        }
        if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
          nsecs = 0;
        }
        if (nsecs >= 1e4) {
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 122192928e5;
        var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
        b3[i2++] = tl >>> 24 & 255;
        b3[i2++] = tl >>> 16 & 255;
        b3[i2++] = tl >>> 8 & 255;
        b3[i2++] = tl & 255;
        var tmh = msecs / 4294967296 * 1e4 & 268435455;
        b3[i2++] = tmh >>> 8 & 255;
        b3[i2++] = tmh & 255;
        b3[i2++] = tmh >>> 24 & 15 | 16;
        b3[i2++] = tmh >>> 16 & 255;
        b3[i2++] = clockseq >>> 8 | 128;
        b3[i2++] = clockseq & 255;
        for (var n = 0; n < 6; ++n) {
          b3[i2 + n] = node[n];
        }
        return buf || (0, _stringify.unsafeStringify)(b3);
      }
      var _default = exports.default = v1;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v1ToV6.js
  var require_v1ToV6 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v1ToV6.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = v1ToV6;
      var _parse = _interopRequireDefault(require_parse());
      var _stringify = require_stringify();
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      function v1ToV6(uuid) {
        var v1Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
        var v6Bytes = _v1ToV6(v1Bytes);
        return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v6Bytes) : v6Bytes;
      }
      function _v1ToV6(v1Bytes, randomize = false) {
        return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
      }
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v35.js
  var require_v35 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v35.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.URL = exports.DNS = void 0;
      exports.default = v35;
      var _stringify = require_stringify();
      var _parse = _interopRequireDefault(require_parse());
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      function stringToBytes(str) {
        str = unescape(encodeURIComponent(str));
        var bytes = [];
        for (var i2 = 0; i2 < str.length; ++i2) {
          bytes.push(str.charCodeAt(i2));
        }
        return bytes;
      }
      var DNS = exports.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      var URL = exports.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
      function v35(name, version, hashfunc) {
        function generateUUID(value, namespace, buf, offset) {
          var _namespace;
          if (typeof value === "string") {
            value = stringToBytes(value);
          }
          if (typeof namespace === "string") {
            namespace = (0, _parse.default)(namespace);
          }
          if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
          }
          var bytes = new Uint8Array(16 + value.length);
          bytes.set(namespace);
          bytes.set(value, namespace.length);
          bytes = hashfunc(bytes);
          bytes[6] = bytes[6] & 15 | version;
          bytes[8] = bytes[8] & 63 | 128;
          if (buf) {
            offset = offset || 0;
            for (var i2 = 0; i2 < 16; ++i2) {
              buf[offset + i2] = bytes[i2];
            }
            return buf;
          }
          return (0, _stringify.unsafeStringify)(bytes);
        }
        try {
          generateUUID.name = name;
        } catch (err) {
        }
        generateUUID.DNS = DNS;
        generateUUID.URL = URL;
        return generateUUID;
      }
    }
  });

  // node_modules/uuid/dist/commonjs-browser/md5.js
  var require_md5 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/md5.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      function md5(bytes) {
        if (typeof bytes === "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = new Uint8Array(msg.length);
          for (var i2 = 0; i2 < msg.length; ++i2) {
            bytes[i2] = msg.charCodeAt(i2);
          }
        }
        return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
      }
      function md5ToHexEncodedArray(input) {
        var output = [];
        var length32 = input.length * 32;
        var hexTab = "0123456789abcdef";
        for (var i2 = 0; i2 < length32; i2 += 8) {
          var x3 = input[i2 >> 5] >>> i2 % 32 & 255;
          var hex = parseInt(hexTab.charAt(x3 >>> 4 & 15) + hexTab.charAt(x3 & 15), 16);
          output.push(hex);
        }
        return output;
      }
      function getOutputLength(inputLength8) {
        return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
      }
      function wordsToMd5(x3, len) {
        x3[len >> 5] |= 128 << len % 32;
        x3[getOutputLength(len) - 1] = len;
        var a3 = 1732584193;
        var b3 = -271733879;
        var c3 = -1732584194;
        var d3 = 271733878;
        for (var i2 = 0; i2 < x3.length; i2 += 16) {
          var olda = a3;
          var oldb = b3;
          var oldc = c3;
          var oldd = d3;
          a3 = md5ff(a3, b3, c3, d3, x3[i2], 7, -680876936);
          d3 = md5ff(d3, a3, b3, c3, x3[i2 + 1], 12, -389564586);
          c3 = md5ff(c3, d3, a3, b3, x3[i2 + 2], 17, 606105819);
          b3 = md5ff(b3, c3, d3, a3, x3[i2 + 3], 22, -1044525330);
          a3 = md5ff(a3, b3, c3, d3, x3[i2 + 4], 7, -176418897);
          d3 = md5ff(d3, a3, b3, c3, x3[i2 + 5], 12, 1200080426);
          c3 = md5ff(c3, d3, a3, b3, x3[i2 + 6], 17, -1473231341);
          b3 = md5ff(b3, c3, d3, a3, x3[i2 + 7], 22, -45705983);
          a3 = md5ff(a3, b3, c3, d3, x3[i2 + 8], 7, 1770035416);
          d3 = md5ff(d3, a3, b3, c3, x3[i2 + 9], 12, -1958414417);
          c3 = md5ff(c3, d3, a3, b3, x3[i2 + 10], 17, -42063);
          b3 = md5ff(b3, c3, d3, a3, x3[i2 + 11], 22, -1990404162);
          a3 = md5ff(a3, b3, c3, d3, x3[i2 + 12], 7, 1804603682);
          d3 = md5ff(d3, a3, b3, c3, x3[i2 + 13], 12, -40341101);
          c3 = md5ff(c3, d3, a3, b3, x3[i2 + 14], 17, -1502002290);
          b3 = md5ff(b3, c3, d3, a3, x3[i2 + 15], 22, 1236535329);
          a3 = md5gg(a3, b3, c3, d3, x3[i2 + 1], 5, -165796510);
          d3 = md5gg(d3, a3, b3, c3, x3[i2 + 6], 9, -1069501632);
          c3 = md5gg(c3, d3, a3, b3, x3[i2 + 11], 14, 643717713);
          b3 = md5gg(b3, c3, d3, a3, x3[i2], 20, -373897302);
          a3 = md5gg(a3, b3, c3, d3, x3[i2 + 5], 5, -701558691);
          d3 = md5gg(d3, a3, b3, c3, x3[i2 + 10], 9, 38016083);
          c3 = md5gg(c3, d3, a3, b3, x3[i2 + 15], 14, -660478335);
          b3 = md5gg(b3, c3, d3, a3, x3[i2 + 4], 20, -405537848);
          a3 = md5gg(a3, b3, c3, d3, x3[i2 + 9], 5, 568446438);
          d3 = md5gg(d3, a3, b3, c3, x3[i2 + 14], 9, -1019803690);
          c3 = md5gg(c3, d3, a3, b3, x3[i2 + 3], 14, -187363961);
          b3 = md5gg(b3, c3, d3, a3, x3[i2 + 8], 20, 1163531501);
          a3 = md5gg(a3, b3, c3, d3, x3[i2 + 13], 5, -1444681467);
          d3 = md5gg(d3, a3, b3, c3, x3[i2 + 2], 9, -51403784);
          c3 = md5gg(c3, d3, a3, b3, x3[i2 + 7], 14, 1735328473);
          b3 = md5gg(b3, c3, d3, a3, x3[i2 + 12], 20, -1926607734);
          a3 = md5hh(a3, b3, c3, d3, x3[i2 + 5], 4, -378558);
          d3 = md5hh(d3, a3, b3, c3, x3[i2 + 8], 11, -2022574463);
          c3 = md5hh(c3, d3, a3, b3, x3[i2 + 11], 16, 1839030562);
          b3 = md5hh(b3, c3, d3, a3, x3[i2 + 14], 23, -35309556);
          a3 = md5hh(a3, b3, c3, d3, x3[i2 + 1], 4, -1530992060);
          d3 = md5hh(d3, a3, b3, c3, x3[i2 + 4], 11, 1272893353);
          c3 = md5hh(c3, d3, a3, b3, x3[i2 + 7], 16, -155497632);
          b3 = md5hh(b3, c3, d3, a3, x3[i2 + 10], 23, -1094730640);
          a3 = md5hh(a3, b3, c3, d3, x3[i2 + 13], 4, 681279174);
          d3 = md5hh(d3, a3, b3, c3, x3[i2], 11, -358537222);
          c3 = md5hh(c3, d3, a3, b3, x3[i2 + 3], 16, -722521979);
          b3 = md5hh(b3, c3, d3, a3, x3[i2 + 6], 23, 76029189);
          a3 = md5hh(a3, b3, c3, d3, x3[i2 + 9], 4, -640364487);
          d3 = md5hh(d3, a3, b3, c3, x3[i2 + 12], 11, -421815835);
          c3 = md5hh(c3, d3, a3, b3, x3[i2 + 15], 16, 530742520);
          b3 = md5hh(b3, c3, d3, a3, x3[i2 + 2], 23, -995338651);
          a3 = md5ii(a3, b3, c3, d3, x3[i2], 6, -198630844);
          d3 = md5ii(d3, a3, b3, c3, x3[i2 + 7], 10, 1126891415);
          c3 = md5ii(c3, d3, a3, b3, x3[i2 + 14], 15, -1416354905);
          b3 = md5ii(b3, c3, d3, a3, x3[i2 + 5], 21, -57434055);
          a3 = md5ii(a3, b3, c3, d3, x3[i2 + 12], 6, 1700485571);
          d3 = md5ii(d3, a3, b3, c3, x3[i2 + 3], 10, -1894986606);
          c3 = md5ii(c3, d3, a3, b3, x3[i2 + 10], 15, -1051523);
          b3 = md5ii(b3, c3, d3, a3, x3[i2 + 1], 21, -2054922799);
          a3 = md5ii(a3, b3, c3, d3, x3[i2 + 8], 6, 1873313359);
          d3 = md5ii(d3, a3, b3, c3, x3[i2 + 15], 10, -30611744);
          c3 = md5ii(c3, d3, a3, b3, x3[i2 + 6], 15, -1560198380);
          b3 = md5ii(b3, c3, d3, a3, x3[i2 + 13], 21, 1309151649);
          a3 = md5ii(a3, b3, c3, d3, x3[i2 + 4], 6, -145523070);
          d3 = md5ii(d3, a3, b3, c3, x3[i2 + 11], 10, -1120210379);
          c3 = md5ii(c3, d3, a3, b3, x3[i2 + 2], 15, 718787259);
          b3 = md5ii(b3, c3, d3, a3, x3[i2 + 9], 21, -343485551);
          a3 = safeAdd(a3, olda);
          b3 = safeAdd(b3, oldb);
          c3 = safeAdd(c3, oldc);
          d3 = safeAdd(d3, oldd);
        }
        return [a3, b3, c3, d3];
      }
      function bytesToWords(input) {
        if (input.length === 0) {
          return [];
        }
        var length8 = input.length * 8;
        var output = new Uint32Array(getOutputLength(length8));
        for (var i2 = 0; i2 < length8; i2 += 8) {
          output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
        }
        return output;
      }
      function safeAdd(x3, y3) {
        var lsw = (x3 & 65535) + (y3 & 65535);
        var msw = (x3 >> 16) + (y3 >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      }
      function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      function md5cmn(q2, a3, b3, x3, s3, t3) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a3, q2), safeAdd(x3, t3)), s3), b3);
      }
      function md5ff(a3, b3, c3, d3, x3, s3, t3) {
        return md5cmn(b3 & c3 | ~b3 & d3, a3, b3, x3, s3, t3);
      }
      function md5gg(a3, b3, c3, d3, x3, s3, t3) {
        return md5cmn(b3 & d3 | c3 & ~d3, a3, b3, x3, s3, t3);
      }
      function md5hh(a3, b3, c3, d3, x3, s3, t3) {
        return md5cmn(b3 ^ c3 ^ d3, a3, b3, x3, s3, t3);
      }
      function md5ii(a3, b3, c3, d3, x3, s3, t3) {
        return md5cmn(c3 ^ (b3 | ~d3), a3, b3, x3, s3, t3);
      }
      var _default = exports.default = md5;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v3.js
  var require_v3 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v3.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _v = _interopRequireDefault(require_v35());
      var _md = _interopRequireDefault(require_md5());
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var v3 = (0, _v.default)("v3", 48, _md.default);
      var _default = exports.default = v3;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/native.js
  var require_native = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/native.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
      var _default = exports.default = {
        randomUUID
      };
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v4.js
  var require_v4 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v4.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _native = _interopRequireDefault(require_native());
      var _rng = _interopRequireDefault(require_rng());
      var _stringify = require_stringify();
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      function v4(options, buf, offset) {
        if (_native.default.randomUUID && !buf && !options) {
          return _native.default.randomUUID();
        }
        options = options || {};
        var rnds = options.random || (options.rng || _rng.default)();
        rnds[6] = rnds[6] & 15 | 64;
        rnds[8] = rnds[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (var i2 = 0; i2 < 16; ++i2) {
            buf[offset + i2] = rnds[i2];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(rnds);
      }
      var _default = exports.default = v4;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/sha1.js
  var require_sha1 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/sha1.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      function f3(s3, x3, y3, z2) {
        switch (s3) {
          case 0:
            return x3 & y3 ^ ~x3 & z2;
          case 1:
            return x3 ^ y3 ^ z2;
          case 2:
            return x3 & y3 ^ x3 & z2 ^ y3 & z2;
          case 3:
            return x3 ^ y3 ^ z2;
        }
      }
      function ROTL(x3, n) {
        return x3 << n | x3 >>> 32 - n;
      }
      function sha1(bytes) {
        var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
        var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        if (typeof bytes === "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = [];
          for (var i2 = 0; i2 < msg.length; ++i2) {
            bytes.push(msg.charCodeAt(i2));
          }
        } else if (!Array.isArray(bytes)) {
          bytes = Array.prototype.slice.call(bytes);
        }
        bytes.push(128);
        var l3 = bytes.length / 4 + 2;
        var N3 = Math.ceil(l3 / 16);
        var M3 = new Array(N3);
        for (var _i2 = 0; _i2 < N3; ++_i2) {
          var arr = new Uint32Array(16);
          for (var j3 = 0; j3 < 16; ++j3) {
            arr[j3] = bytes[_i2 * 64 + j3 * 4] << 24 | bytes[_i2 * 64 + j3 * 4 + 1] << 16 | bytes[_i2 * 64 + j3 * 4 + 2] << 8 | bytes[_i2 * 64 + j3 * 4 + 3];
          }
          M3[_i2] = arr;
        }
        M3[N3 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
        M3[N3 - 1][14] = Math.floor(M3[N3 - 1][14]);
        M3[N3 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
        for (var _i22 = 0; _i22 < N3; ++_i22) {
          var W2 = new Uint32Array(80);
          for (var t3 = 0; t3 < 16; ++t3) {
            W2[t3] = M3[_i22][t3];
          }
          for (var _t3 = 16; _t3 < 80; ++_t3) {
            W2[_t3] = ROTL(W2[_t3 - 3] ^ W2[_t3 - 8] ^ W2[_t3 - 14] ^ W2[_t3 - 16], 1);
          }
          var a3 = H2[0];
          var b3 = H2[1];
          var c3 = H2[2];
          var d3 = H2[3];
          var e2 = H2[4];
          for (var _t22 = 0; _t22 < 80; ++_t22) {
            var s3 = Math.floor(_t22 / 20);
            var T3 = ROTL(a3, 5) + f3(s3, b3, c3, d3) + e2 + K2[s3] + W2[_t22] >>> 0;
            e2 = d3;
            d3 = c3;
            c3 = ROTL(b3, 30) >>> 0;
            b3 = a3;
            a3 = T3;
          }
          H2[0] = H2[0] + a3 >>> 0;
          H2[1] = H2[1] + b3 >>> 0;
          H2[2] = H2[2] + c3 >>> 0;
          H2[3] = H2[3] + d3 >>> 0;
          H2[4] = H2[4] + e2 >>> 0;
        }
        return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
      }
      var _default = exports.default = sha1;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v5.js
  var require_v5 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v5.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _v = _interopRequireDefault(require_v35());
      var _sha = _interopRequireDefault(require_sha1());
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var v5 = (0, _v.default)("v5", 80, _sha.default);
      var _default = exports.default = v5;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v6.js
  var require_v6 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v6.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = v6;
      var _stringify = require_stringify();
      var _v = _interopRequireDefault(require_v1());
      var _v1ToV = _interopRequireDefault(require_v1ToV6());
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      function ownKeys(e2, r3) {
        var t3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var o3 = Object.getOwnPropertySymbols(e2);
          r3 && (o3 = o3.filter(function(r4) {
            return Object.getOwnPropertyDescriptor(e2, r4).enumerable;
          })), t3.push.apply(t3, o3);
        }
        return t3;
      }
      function _objectSpread(e2) {
        for (var r3 = 1; r3 < arguments.length; r3++) {
          var t3 = null != arguments[r3] ? arguments[r3] : {};
          r3 % 2 ? ownKeys(Object(t3), true).forEach(function(r4) {
            _defineProperty(e2, r4, t3[r4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3)) : ownKeys(Object(t3)).forEach(function(r4) {
            Object.defineProperty(e2, r4, Object.getOwnPropertyDescriptor(t3, r4));
          });
        }
        return e2;
      }
      function _defineProperty(e2, r3, t3) {
        return (r3 = _toPropertyKey(r3)) in e2 ? Object.defineProperty(e2, r3, { value: t3, enumerable: true, configurable: true, writable: true }) : e2[r3] = t3, e2;
      }
      function _toPropertyKey(t3) {
        var i2 = _toPrimitive(t3, "string");
        return "symbol" == typeof i2 ? i2 : i2 + "";
      }
      function _toPrimitive(t3, r3) {
        if ("object" != typeof t3 || !t3) return t3;
        var e2 = t3[Symbol.toPrimitive];
        if (void 0 !== e2) {
          var i2 = e2.call(t3, r3 || "default");
          if ("object" != typeof i2) return i2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r3 ? String : Number)(t3);
      }
      function v6(options = {}, buf, offset = 0) {
        var bytes = (0, _v.default)(_objectSpread(_objectSpread({}, options), {}, {
          _v6: true
        }), new Uint8Array(16));
        bytes = (0, _v1ToV.default)(bytes);
        if (buf) {
          for (var i2 = 0; i2 < 16; i2++) {
            buf[offset + i2] = bytes[i2];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v6ToV1.js
  var require_v6ToV1 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v6ToV1.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = v6ToV1;
      var _parse = _interopRequireDefault(require_parse());
      var _stringify = require_stringify();
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      function v6ToV1(uuid) {
        var v6Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
        var v1Bytes = _v6ToV1(v6Bytes);
        return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v1Bytes) : v1Bytes;
      }
      function _v6ToV1(v6Bytes) {
        return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
      }
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v7.js
  var require_v7 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v7.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _rng = _interopRequireDefault(require_rng());
      var _stringify = require_stringify();
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var _seqLow = null;
      var _seqHigh = null;
      var _msecs = 0;
      function v7(options, buf, offset) {
        options = options || {};
        var i2 = buf && offset || 0;
        var b3 = buf || new Uint8Array(16);
        var rnds = options.random || (options.rng || _rng.default)();
        var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
        var seq = options.seq !== void 0 ? options.seq : null;
        var seqHigh = _seqHigh;
        var seqLow = _seqLow;
        if (msecs > _msecs && options.msecs === void 0) {
          _msecs = msecs;
          if (seq !== null) {
            seqHigh = null;
            seqLow = null;
          }
        }
        if (seq !== null) {
          if (seq > 2147483647) {
            seq = 2147483647;
          }
          seqHigh = seq >>> 19 & 4095;
          seqLow = seq & 524287;
        }
        if (seqHigh === null || seqLow === null) {
          seqHigh = rnds[6] & 127;
          seqHigh = seqHigh << 8 | rnds[7];
          seqLow = rnds[8] & 63;
          seqLow = seqLow << 8 | rnds[9];
          seqLow = seqLow << 5 | rnds[10] >>> 3;
        }
        if (msecs + 1e4 > _msecs && seq === null) {
          if (++seqLow > 524287) {
            seqLow = 0;
            if (++seqHigh > 4095) {
              seqHigh = 0;
              _msecs++;
            }
          }
        } else {
          _msecs = msecs;
        }
        _seqHigh = seqHigh;
        _seqLow = seqLow;
        b3[i2++] = _msecs / 1099511627776 & 255;
        b3[i2++] = _msecs / 4294967296 & 255;
        b3[i2++] = _msecs / 16777216 & 255;
        b3[i2++] = _msecs / 65536 & 255;
        b3[i2++] = _msecs / 256 & 255;
        b3[i2++] = _msecs & 255;
        b3[i2++] = seqHigh >>> 4 & 15 | 112;
        b3[i2++] = seqHigh & 255;
        b3[i2++] = seqLow >>> 13 & 63 | 128;
        b3[i2++] = seqLow >>> 5 & 255;
        b3[i2++] = seqLow << 3 & 255 | rnds[10] & 7;
        b3[i2++] = rnds[11];
        b3[i2++] = rnds[12];
        b3[i2++] = rnds[13];
        b3[i2++] = rnds[14];
        b3[i2++] = rnds[15];
        return buf || (0, _stringify.unsafeStringify)(b3);
      }
      var _default = exports.default = v7;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/version.js
  var require_version = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/version.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _validate = _interopRequireDefault(require_validate());
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      function version(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }
        return parseInt(uuid.slice(14, 15), 16);
      }
      var _default = exports.default = version;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/index.js
  var require_commonjs_browser = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "MAX", {
        enumerable: true,
        get: function get() {
          return _max.default;
        }
      });
      Object.defineProperty(exports, "NIL", {
        enumerable: true,
        get: function get() {
          return _nil.default;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function get() {
          return _parse.default;
        }
      });
      Object.defineProperty(exports, "stringify", {
        enumerable: true,
        get: function get() {
          return _stringify.default;
        }
      });
      Object.defineProperty(exports, "v1", {
        enumerable: true,
        get: function get() {
          return _v.default;
        }
      });
      Object.defineProperty(exports, "v1ToV6", {
        enumerable: true,
        get: function get() {
          return _v1ToV.default;
        }
      });
      Object.defineProperty(exports, "v3", {
        enumerable: true,
        get: function get() {
          return _v2.default;
        }
      });
      Object.defineProperty(exports, "v4", {
        enumerable: true,
        get: function get() {
          return _v3.default;
        }
      });
      Object.defineProperty(exports, "v5", {
        enumerable: true,
        get: function get() {
          return _v4.default;
        }
      });
      Object.defineProperty(exports, "v6", {
        enumerable: true,
        get: function get() {
          return _v5.default;
        }
      });
      Object.defineProperty(exports, "v6ToV1", {
        enumerable: true,
        get: function get() {
          return _v6ToV.default;
        }
      });
      Object.defineProperty(exports, "v7", {
        enumerable: true,
        get: function get() {
          return _v6.default;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function get() {
          return _validate.default;
        }
      });
      Object.defineProperty(exports, "version", {
        enumerable: true,
        get: function get() {
          return _version.default;
        }
      });
      var _max = _interopRequireDefault(require_max());
      var _nil = _interopRequireDefault(require_nil());
      var _parse = _interopRequireDefault(require_parse());
      var _stringify = _interopRequireDefault(require_stringify());
      var _v = _interopRequireDefault(require_v1());
      var _v1ToV = _interopRequireDefault(require_v1ToV6());
      var _v2 = _interopRequireDefault(require_v3());
      var _v3 = _interopRequireDefault(require_v4());
      var _v4 = _interopRequireDefault(require_v5());
      var _v5 = _interopRequireDefault(require_v6());
      var _v6ToV = _interopRequireDefault(require_v6ToV1());
      var _v6 = _interopRequireDefault(require_v7());
      var _validate = _interopRequireDefault(require_validate());
      var _version = _interopRequireDefault(require_version());
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js
  var require_glsp_client = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPClient = exports.ClientState = exports.ApplicationIdProvider = void 0;
      var uuid = require_commonjs_browser();
      var type_util_1 = require_type_util();
      var ApplicationIdProvider = class _ApplicationIdProvider {
        static get() {
          if (!_ApplicationIdProvider._applicationId) {
            _ApplicationIdProvider._applicationId = uuid.v4();
          }
          return _ApplicationIdProvider._applicationId;
        }
      };
      exports.ApplicationIdProvider = ApplicationIdProvider;
      var ClientState;
      (function(ClientState2) {
        ClientState2[ClientState2["Initial"] = 0] = "Initial";
        ClientState2[ClientState2["Starting"] = 1] = "Starting";
        ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
        ClientState2[ClientState2["Running"] = 3] = "Running";
        ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
        ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
        ClientState2[ClientState2["ServerError"] = 6] = "ServerError";
      })(ClientState || (exports.ClientState = ClientState = {}));
      var GLSPClient;
      (function(GLSPClient2) {
        function isOptions(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "id");
        }
        GLSPClient2.isOptions = isOptions;
        GLSPClient2.protocolVersion = "1.0.0";
      })(GLSPClient || (exports.GLSPClient = GLSPClient = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-client.js
  var require_glsp_jsonrpc_client = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JsonrpcGLSPClient = void 0;
      var vscode_jsonrpc_1 = require_main();
      var glsp_client_1 = require_glsp_client();
      var JsonrpcGLSPClient;
      (function(JsonrpcGLSPClient2) {
        function isOptions(object) {
          return glsp_client_1.GLSPClient.isOptions(object) && "connectionProvider" in object;
        }
        JsonrpcGLSPClient2.isOptions = isOptions;
        JsonrpcGLSPClient2.ActionMessageNotification = new vscode_jsonrpc_1.NotificationType("process");
        JsonrpcGLSPClient2.InitializeRequest = new vscode_jsonrpc_1.RequestType("initialize");
        JsonrpcGLSPClient2.InitializeClientSessionRequest = new vscode_jsonrpc_1.RequestType("initializeClientSession");
        JsonrpcGLSPClient2.DisposeClientSessionRequest = new vscode_jsonrpc_1.RequestType("disposeClientSession");
        JsonrpcGLSPClient2.ShutdownNotification = new vscode_jsonrpc_1.NotificationType0("shutdown");
        JsonrpcGLSPClient2.ClientNotReadyMsg = "JsonrpcGLSPClient is not ready yet";
        function error(message, ...optionalParams) {
          console.error(`[JsonrpcGLSPClient] ${message}`, optionalParams);
        }
        JsonrpcGLSPClient2.error = error;
      })(JsonrpcGLSPClient || (exports.JsonrpcGLSPClient = JsonrpcGLSPClient = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/base-jsonrpc-glsp-client.js
  var require_base_jsonrpc_glsp_client = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/base-jsonrpc-glsp-client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JsonrpcClientProxy = exports.BaseJsonrpcGLSPClient = void 0;
      var sprotty_protocol_1 = require_lib();
      var event_1 = require_event();
      var glsp_client_1 = require_glsp_client();
      var glsp_jsonrpc_client_1 = require_glsp_jsonrpc_client();
      var BaseJsonrpcGLSPClient = class {
        get onServerInitialized() {
          return this.onServerInitializedEmitter.event;
        }
        get onActionMessageNotification() {
          return this.onActionMessageNotificationEmitter.event;
        }
        get onCurrentStateChanged() {
          return this.onCurrentStateChangedEmitter.event;
        }
        set state(state) {
          if (this._state !== state) {
            this._state = state;
            this.onCurrentStateChangedEmitter.fire(state);
          }
        }
        get state() {
          return this._state;
        }
        get initializeResult() {
          return this._initializeResult;
        }
        constructor(options) {
          this.onServerInitializedEmitter = new event_1.Emitter();
          this.onActionMessageNotificationEmitter = new event_1.Emitter();
          this.onCurrentStateChangedEmitter = new event_1.Emitter();
          this.connectionProvider = options.connectionProvider;
          this.state = glsp_client_1.ClientState.Initial;
        }
        async start() {
          if (this.state === glsp_client_1.ClientState.Running || this.state === glsp_client_1.ClientState.StartFailed) {
            return;
          } else if (this.state === glsp_client_1.ClientState.Starting) {
            await event_1.Event.waitUntil(this.onCurrentStateChanged, (state) => state === glsp_client_1.ClientState.Running || state === glsp_client_1.ClientState.StartFailed);
            return;
          }
          try {
            this.state = glsp_client_1.ClientState.Starting;
            const connection = await this.resolveConnection();
            connection.listen();
            this.resolvedConnection = connection;
            this.state = glsp_client_1.ClientState.Running;
          } catch (error) {
            glsp_jsonrpc_client_1.JsonrpcGLSPClient.error("Failed to start connection to server", error);
            this.state = glsp_client_1.ClientState.StartFailed;
          }
        }
        async initializeServer(params) {
          if (this.initializeResult) {
            return this.initializeResult;
          } else if (this.pendingServerInitialize) {
            return this.pendingServerInitialize;
          }
          const initializeDeferred = new sprotty_protocol_1.Deferred();
          try {
            this.pendingServerInitialize = initializeDeferred.promise;
            this._initializeResult = await this.checkedConnection.sendRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeRequest, params);
            this.onServerInitializedEmitter.fire(this._initializeResult);
            initializeDeferred.resolve(this._initializeResult);
            this.pendingServerInitialize = void 0;
          } catch (error) {
            initializeDeferred.reject(error);
            this._initializeResult = void 0;
            this.pendingServerInitialize = void 0;
          }
          return initializeDeferred.promise;
        }
        initializeClientSession(params) {
          return this.checkedConnection.sendRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeClientSessionRequest, params);
        }
        disposeClientSession(params) {
          return this.checkedConnection.sendRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.DisposeClientSessionRequest, params);
        }
        onActionMessage(handler, clientId) {
          return this.onActionMessageNotification((msg) => {
            if (!clientId || msg.clientId === clientId) {
              handler(msg);
            }
          });
        }
        sendActionMessage(message) {
          this.checkedConnection.sendNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, message);
        }
        shutdownServer() {
          this.checkedConnection.sendNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ShutdownNotification);
        }
        stop() {
          if (!this.connectionPromise) {
            this.state = glsp_client_1.ClientState.Stopped;
            return Promise.resolve();
          }
          if (this.state === glsp_client_1.ClientState.Stopping && this.onStop) {
            return this.onStop;
          }
          this.state = glsp_client_1.ClientState.Stopping;
          return this.onStop = this.resolveConnection().then((connection) => {
            connection.dispose();
            this.state = glsp_client_1.ClientState.Stopped;
            this.onStop = void 0;
            this.onActionMessageNotificationEmitter.dispose();
            this.onCurrentStateChangedEmitter.dispose();
            this.connectionPromise = void 0;
            this.resolvedConnection = void 0;
          });
        }
        get checkedConnection() {
          if (!this.isConnectionActive()) {
            throw new Error(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ClientNotReadyMsg);
          }
          return this.resolvedConnection;
        }
        resolveConnection() {
          if (!this.connectionPromise) {
            this.connectionPromise = this.doCreateConnection();
          }
          return this.connectionPromise;
        }
        async doCreateConnection() {
          const connection = typeof this.connectionProvider === "function" ? await this.connectionProvider() : this.connectionProvider;
          connection.onError((data) => this.handleConnectionError(data[0], data[1], data[2]));
          connection.onClose(() => this.handleConnectionClosed());
          connection.onNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, (msg) => this.onActionMessageNotificationEmitter.fire(msg));
          return connection;
        }
        handleConnectionError(error, message, count) {
          glsp_jsonrpc_client_1.JsonrpcGLSPClient.error("Connection to server is erroring. Shutting down server.", error);
          this.stop();
          this.state = glsp_client_1.ClientState.ServerError;
        }
        handleConnectionClosed() {
          if (this.state === glsp_client_1.ClientState.Stopping || this.state === glsp_client_1.ClientState.Stopped) {
            return;
          }
          try {
            if (this.resolvedConnection) {
              this.resolvedConnection.dispose();
              this.connectionPromise = void 0;
              this.resolvedConnection = void 0;
            }
          } catch (error) {
          }
          glsp_jsonrpc_client_1.JsonrpcGLSPClient.error("Connection to server got closed. Server will not be restarted.");
          this.state = glsp_client_1.ClientState.ServerError;
        }
        isConnectionActive() {
          return this.state === glsp_client_1.ClientState.Running && !!this.resolvedConnection;
        }
        get currentState() {
          return this.state;
        }
      };
      exports.BaseJsonrpcGLSPClient = BaseJsonrpcGLSPClient;
      var JsonrpcClientProxy = class {
        initialize(clientConnection, enableLogging = false) {
          this.clientConnection = clientConnection;
          this.enableLogging = enableLogging;
        }
        process(message) {
          var _a4;
          if (this.enableLogging) {
            console.log(`Send action '${message.action.kind}' to client '${message.clientId}'`);
          }
          (_a4 = this.clientConnection) === null || _a4 === void 0 ? void 0 : _a4.sendNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, message);
        }
      };
      exports.JsonrpcClientProxy = JsonrpcClientProxy;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/di/re-decorate.js
  var require_re_decorate = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/di/re-decorate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var base_jsonrpc_glsp_client_1 = require_base_jsonrpc_glsp_client();
      (0, inversify_1.decorate)((0, inversify_1.injectable)(), base_jsonrpc_glsp_client_1.JsonrpcClientProxy);
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/di/index.js
  var require_di = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/di/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_container_configuration(), exports);
      __exportStar(require_feature_module(), exports);
      __exportStar(require_inversify_util(), exports);
      __exportStar(require_lazy_injector(), exports);
      __exportStar(require_re_decorate(), exports);
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/feature-modules.js
  var require_feature_modules = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/feature-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sprottyDefaultModule = exports.edgeJunctionModule = exports.zorderModule = exports.updateModule = exports.openModule = exports.moveModule = exports.modelSourceModule = exports.fadeModule = exports.expandModule = exports.edgeLayoutModule = exports.edgeIntersectionModule = exports.edgeEditModule = exports.buttonModule = void 0;
      var di_1 = require_di();
      var di_config_1 = require_di_config();
      exports.sprottyDefaultModule = di_config_1.default;
      var di_config_2 = require_di_config5();
      var di_config_3 = require_di_config9();
      var di_config_4 = require_di_config10();
      var di_config_5 = require_di_config2();
      var di_config_6 = require_di_config3();
      var di_config_7 = require_di_config11();
      var di_config_8 = require_di_config13();
      var di_config_9 = require_di_config15();
      var di_config_10 = require_di_config16();
      var di_config_11 = require_di_config20();
      var di_config_12 = require_di_config22();
      var di_config_13 = require_di_config23();
      exports.buttonModule = new di_1.FeatureModule(di_config_2.default.registry, { featureId: Symbol("button") });
      exports.edgeEditModule = new di_1.FeatureModule(di_config_6.edgeEditModule.registry, { featureId: Symbol("edgeEdit") });
      exports.edgeIntersectionModule = new di_1.FeatureModule(di_config_3.default.registry, { featureId: Symbol("edgeIntersection") });
      exports.edgeLayoutModule = new di_1.FeatureModule(di_config_5.default.registry, { featureId: Symbol("edgeLayout") });
      exports.expandModule = new di_1.FeatureModule(di_config_7.default.registry, { featureId: Symbol("expand") });
      exports.fadeModule = new di_1.FeatureModule(di_config_8.default.registry, { featureId: Symbol("fade") });
      exports.modelSourceModule = new di_1.FeatureModule(di_config_13.default.registry, { featureId: Symbol("modelSource") });
      exports.moveModule = new di_1.FeatureModule(di_config_9.default.registry, { featureId: Symbol("move") });
      exports.openModule = new di_1.FeatureModule(di_config_10.default.registry, { featureId: Symbol("open") });
      exports.updateModule = new di_1.FeatureModule(di_config_11.default.registry, { featureId: Symbol("update") });
      exports.zorderModule = new di_1.FeatureModule(di_config_12.default.registry, { featureId: Symbol("zorder") });
      exports.edgeJunctionModule = new di_1.FeatureModule(di_config_4.default.registry, { featureId: Symbol("edgeJunction") });
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js
  var require_base_protocol = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/base-protocol.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompoundOperation = exports.Operation = exports.RejectAction = exports.ResponseAction = exports.RequestAction = exports.ActionMessage = exports.Action = void 0;
      var sprotty = require_actions();
      var type_util_1 = require_type_util();
      var Action3;
      (function(Action4) {
        function is(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "kind");
        }
        Action4.is = is;
        function hasKind(object, kind) {
          return Action4.is(object) && object.kind === kind;
        }
        Action4.hasKind = hasKind;
      })(Action3 || (exports.Action = Action3 = {}));
      var ActionMessage;
      (function(ActionMessage2) {
        function is(object, typeguard) {
          const actionGuard = typeguard !== null && typeguard !== void 0 ? typeguard : Action3.is;
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "clientId") && "action" in object && actionGuard(object.action);
        }
        ActionMessage2.is = is;
      })(ActionMessage || (exports.ActionMessage = ActionMessage = {}));
      var RequestAction;
      (function(RequestAction2) {
        function is(object) {
          return Action3.is(object) && (0, type_util_1.hasStringProp)(object, "requestId");
        }
        RequestAction2.is = is;
        function hasKind(object, kind) {
          return RequestAction2.is(object) && object.kind === kind;
        }
        RequestAction2.hasKind = hasKind;
        function generateRequestId() {
          return sprotty.generateRequestId();
        }
        RequestAction2.generateRequestId = generateRequestId;
      })(RequestAction || (exports.RequestAction = RequestAction = {}));
      var ResponseAction;
      (function(ResponseAction2) {
        function is(object) {
          return Action3.is(object) && (0, type_util_1.hasStringProp)(object, "responseId");
        }
        ResponseAction2.is = is;
        function hasValidResponseId(object) {
          return ResponseAction2.is(object) && object.responseId !== "";
        }
        ResponseAction2.hasValidResponseId = hasValidResponseId;
      })(ResponseAction || (exports.ResponseAction = ResponseAction = {}));
      var RejectAction;
      (function(RejectAction2) {
        RejectAction2.KIND = "rejectRequest";
        function is(object) {
          return Action3.hasKind(object, RejectAction2.KIND) && (0, type_util_1.hasStringProp)(object, "message");
        }
        RejectAction2.is = is;
        function create(message, options = {}) {
          return {
            kind: RejectAction2.KIND,
            responseId: "",
            message,
            ...options
          };
        }
        RejectAction2.create = create;
      })(RejectAction || (exports.RejectAction = RejectAction = {}));
      var Operation;
      (function(Operation2) {
        function is(object) {
          return Action3.is(object) && "isOperation" in object && object.isOperation === true;
        }
        Operation2.is = is;
        function hasKind(object, kind) {
          return Operation2.is(object) && object.kind === kind;
        }
        Operation2.hasKind = hasKind;
      })(Operation || (exports.Operation = Operation = {}));
      var CompoundOperation;
      (function(CompoundOperation2) {
        CompoundOperation2.KIND = "compound";
        function is(object) {
          return Operation.hasKind(object, CompoundOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "operationList");
        }
        CompoundOperation2.is = is;
        function create(operationList, options = {}) {
          return {
            kind: CompoundOperation2.KIND,
            isOperation: true,
            operationList,
            ...options
          };
        }
        CompoundOperation2.create = create;
      })(CompoundOperation || (exports.CompoundOperation = CompoundOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/client-notification.js
  var require_client_notification = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/client-notification.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EndProgressAction = exports.UpdateProgressAction = exports.StartProgressAction = exports.MessageAction = exports.StatusAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var StatusAction;
      (function(StatusAction2) {
        StatusAction2.KIND = "status";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, StatusAction2.KIND) && (0, type_util_1.hasStringProp)(object, "severity") && (0, type_util_1.hasStringProp)(object, "message");
        }
        StatusAction2.is = is;
        function create(message, options = {}) {
          return {
            kind: StatusAction2.KIND,
            severity: "INFO",
            message,
            ...options
          };
        }
        StatusAction2.create = create;
      })(StatusAction || (exports.StatusAction = StatusAction = {}));
      var MessageAction;
      (function(MessageAction2) {
        MessageAction2.KIND = "message";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, MessageAction2.KIND) && (0, type_util_1.hasStringProp)(object, "message") && (0, type_util_1.hasStringProp)(object, "severity");
        }
        MessageAction2.is = is;
        function create(message, options = {}) {
          return {
            kind: MessageAction2.KIND,
            message,
            severity: "INFO",
            ...options
          };
        }
        MessageAction2.create = create;
      })(MessageAction || (exports.MessageAction = MessageAction = {}));
      var StartProgressAction;
      (function(StartProgressAction2) {
        StartProgressAction2.KIND = "startProgress";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, StartProgressAction2.KIND) && (0, type_util_1.hasStringProp)(object, "progressId") && (0, type_util_1.hasStringProp)(object, "title");
        }
        StartProgressAction2.is = is;
        function create(options) {
          return {
            kind: StartProgressAction2.KIND,
            ...options
          };
        }
        StartProgressAction2.create = create;
      })(StartProgressAction || (exports.StartProgressAction = StartProgressAction = {}));
      var UpdateProgressAction;
      (function(UpdateProgressAction2) {
        UpdateProgressAction2.KIND = "updateProgress";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, UpdateProgressAction2.KIND) && (0, type_util_1.hasStringProp)(object, "progressId");
        }
        UpdateProgressAction2.is = is;
        function create(progressId, options = {}) {
          return {
            kind: UpdateProgressAction2.KIND,
            progressId,
            ...options
          };
        }
        UpdateProgressAction2.create = create;
      })(UpdateProgressAction || (exports.UpdateProgressAction = UpdateProgressAction = {}));
      var EndProgressAction;
      (function(EndProgressAction2) {
        EndProgressAction2.KIND = "endProgress";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, EndProgressAction2.KIND) && (0, type_util_1.hasStringProp)(object, "progressId");
        }
        EndProgressAction2.is = is;
        function create(progressId, message) {
          return {
            kind: EndProgressAction2.KIND,
            progressId,
            message
          };
        }
        EndProgressAction2.create = create;
      })(EndProgressAction || (exports.EndProgressAction = EndProgressAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/clipboard.js
  var require_clipboard = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/clipboard.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PasteOperation = exports.CutOperation = exports.SetClipboardDataAction = exports.RequestClipboardDataAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestClipboardDataAction;
      (function(RequestClipboardDataAction2) {
        RequestClipboardDataAction2.KIND = "requestClipboardData";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestClipboardDataAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        RequestClipboardDataAction2.is = is;
        function create(editorContext, options = {}) {
          return {
            kind: RequestClipboardDataAction2.KIND,
            requestId: "",
            editorContext,
            ...options
          };
        }
        RequestClipboardDataAction2.create = create;
      })(RequestClipboardDataAction || (exports.RequestClipboardDataAction = RequestClipboardDataAction = {}));
      var SetClipboardDataAction;
      (function(SetClipboardDataAction2) {
        SetClipboardDataAction2.KIND = "setClipboardData";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetClipboardDataAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "clipboardData");
        }
        SetClipboardDataAction2.is = is;
        function create(clipboardData, options = {}) {
          return {
            kind: SetClipboardDataAction2.KIND,
            responseId: "",
            clipboardData,
            ...options
          };
        }
        SetClipboardDataAction2.create = create;
      })(SetClipboardDataAction || (exports.SetClipboardDataAction = SetClipboardDataAction = {}));
      var CutOperation;
      (function(CutOperation2) {
        CutOperation2.KIND = "cut";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, CutOperation2.KIND) && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        CutOperation2.is = is;
        function create(editorContext, options = {}) {
          return {
            kind: CutOperation2.KIND,
            isOperation: true,
            editorContext,
            ...options
          };
        }
        CutOperation2.create = create;
      })(CutOperation || (exports.CutOperation = CutOperation = {}));
      var PasteOperation;
      (function(PasteOperation2) {
        PasteOperation2.KIND = "paste";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, PasteOperation2.KIND) && (0, type_util_1.hasObjectProp)(object, "clipboardData") && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        PasteOperation2.is = is;
        function create(options) {
          return {
            kind: PasteOperation2.KIND,
            isOperation: true,
            ...options
          };
        }
        PasteOperation2.create = create;
      })(PasteOperation || (exports.PasteOperation = PasteOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/contexts.js
  var require_contexts = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/contexts.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetContextActions = exports.RequestContextActions = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestContextActions;
      (function(RequestContextActions2) {
        RequestContextActions2.KIND = "requestContextActions";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestContextActions2.KIND) && (0, type_util_1.hasStringProp)(object, "contextId") && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        RequestContextActions2.is = is;
        function create(options) {
          return {
            kind: RequestContextActions2.KIND,
            requestId: "",
            ...options
          };
        }
        RequestContextActions2.create = create;
      })(RequestContextActions || (exports.RequestContextActions = RequestContextActions = {}));
      var SetContextActions;
      (function(SetContextActions2) {
        SetContextActions2.KIND = "setContextActions";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetContextActions2.KIND) && (0, type_util_1.hasArrayProp)(object, "actions");
        }
        SetContextActions2.is = is;
        function create(actions, options = {}) {
          return {
            kind: SetContextActions2.KIND,
            responseId: "",
            actions,
            ...options
          };
        }
        SetContextActions2.create = create;
      })(SetContextActions || (exports.SetContextActions = SetContextActions = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/edge-modification.js
  var require_edge_modification = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/edge-modification.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ChangeRoutingPointsOperation = exports.ReconnectEdgeOperation = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var ReconnectEdgeOperation;
      (function(ReconnectEdgeOperation2) {
        ReconnectEdgeOperation2.KIND = "reconnectEdge";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ReconnectEdgeOperation2.KIND) && (0, type_util_1.hasStringProp)(object, "edgeElementId") && (0, type_util_1.hasStringProp)(object, "sourceElementId") && (0, type_util_1.hasStringProp)(object, "targetElementId");
        }
        ReconnectEdgeOperation2.is = is;
        function create(options) {
          return {
            kind: ReconnectEdgeOperation2.KIND,
            isOperation: true,
            ...options
          };
        }
        ReconnectEdgeOperation2.create = create;
      })(ReconnectEdgeOperation || (exports.ReconnectEdgeOperation = ReconnectEdgeOperation = {}));
      var ChangeRoutingPointsOperation;
      (function(ChangeRoutingPointsOperation2) {
        ChangeRoutingPointsOperation2.KIND = "changeRoutingPoints";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ChangeRoutingPointsOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "newRoutingPoints");
        }
        ChangeRoutingPointsOperation2.is = is;
        function create(newRoutingPoints, options = {}) {
          return {
            kind: ChangeRoutingPointsOperation2.KIND,
            isOperation: true,
            newRoutingPoints,
            ...options
          };
        }
        ChangeRoutingPointsOperation2.create = create;
      })(ChangeRoutingPointsOperation || (exports.ChangeRoutingPointsOperation = ChangeRoutingPointsOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-creation.js
  var require_element_creation = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-creation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteElementOperation = exports.CreateEdgeOperation = exports.CreateNodeOperation = exports.CreateOperation = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var CreateOperation;
      (function(CreateOperation2) {
        function is(object) {
          return base_protocol_1.Operation.is(object) && (0, type_util_1.hasStringProp)(object, "elementTypeId");
        }
        CreateOperation2.is = is;
        function hasKind(object, kind) {
          return CreateOperation2.is(object) && object.kind === kind;
        }
        CreateOperation2.hasKind = hasKind;
      })(CreateOperation || (exports.CreateOperation = CreateOperation = {}));
      var CreateNodeOperation;
      (function(CreateNodeOperation2) {
        CreateNodeOperation2.KIND = "createNode";
        function is(object) {
          return CreateOperation.hasKind(object, CreateNodeOperation2.KIND);
        }
        CreateNodeOperation2.is = is;
        function create(elementTypeId, options = {}) {
          return {
            kind: CreateNodeOperation2.KIND,
            isOperation: true,
            elementTypeId,
            ...options
          };
        }
        CreateNodeOperation2.create = create;
      })(CreateNodeOperation || (exports.CreateNodeOperation = CreateNodeOperation = {}));
      var CreateEdgeOperation;
      (function(CreateEdgeOperation2) {
        CreateEdgeOperation2.KIND = "createEdge";
        function is(object) {
          return CreateOperation.hasKind(object, CreateEdgeOperation2.KIND) && (0, type_util_1.hasStringProp)(object, "sourceElementId") && (0, type_util_1.hasStringProp)(object, "targetElementId");
        }
        CreateEdgeOperation2.is = is;
        function create(options) {
          return {
            kind: CreateEdgeOperation2.KIND,
            isOperation: true,
            ...options
          };
        }
        CreateEdgeOperation2.create = create;
      })(CreateEdgeOperation || (exports.CreateEdgeOperation = CreateEdgeOperation = {}));
      var DeleteElementOperation;
      (function(DeleteElementOperation2) {
        DeleteElementOperation2.KIND = "deleteElement";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, DeleteElementOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementIds");
        }
        DeleteElementOperation2.is = is;
        function create(elementIds, options = {}) {
          return {
            kind: DeleteElementOperation2.KIND,
            isOperation: true,
            elementIds,
            ...options
          };
        }
        DeleteElementOperation2.create = create;
      })(DeleteElementOperation || (exports.DeleteElementOperation = DeleteElementOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-hover.js
  var require_element_hover = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-hover.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetPopupModelAction = exports.RequestPopupModelAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestPopupModelAction;
      (function(RequestPopupModelAction2) {
        RequestPopupModelAction2.KIND = "requestPopupModel";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestPopupModelAction2.KIND) && (0, type_util_1.hasStringProp)(object, "elementId") && (0, type_util_1.hasObjectProp)(object, "bounds");
        }
        RequestPopupModelAction2.is = is;
        function create(options) {
          return {
            kind: RequestPopupModelAction2.KIND,
            requestId: "",
            ...options
          };
        }
        RequestPopupModelAction2.create = create;
      })(RequestPopupModelAction || (exports.RequestPopupModelAction = RequestPopupModelAction = {}));
      var SetPopupModelAction;
      (function(SetPopupModelAction2) {
        SetPopupModelAction2.KIND = "setPopupModel";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetPopupModelAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "newRoot");
        }
        SetPopupModelAction2.is = is;
        function create(newRoot, options = {}) {
          return {
            kind: SetPopupModelAction2.KIND,
            responseId: "",
            newRoot,
            ...options
          };
        }
        SetPopupModelAction2.create = create;
      })(SetPopupModelAction || (exports.SetPopupModelAction = SetPopupModelAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-navigation.js
  var require_element_navigation = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-navigation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NavigateToExternalTargetAction = exports.SetResolvedNavigationTargetAction = exports.ResolveNavigationTargetAction = exports.NavigateToTargetAction = exports.SetNavigationTargetsAction = exports.RequestNavigationTargetsAction = exports.NavigationTarget = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var NavigationTarget;
      (function(NavigationTarget2) {
        function is(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "uri");
        }
        NavigationTarget2.is = is;
        NavigationTarget2.ELEMENT_IDS = "elementIds";
        NavigationTarget2.ELEMENT_IDS_SEPARATOR = "&";
        NavigationTarget2.TEXT_LINE = "line";
        NavigationTarget2.TEXT_COLUMN = "column";
        function hasArguments(target) {
          return target.args !== void 0 && Object.keys(target.args).length > 0;
        }
        NavigationTarget2.hasArguments = hasArguments;
        function addArgument(target, key, value) {
          if (!target.args) {
            target.args = {};
          }
          target.args[key] = value;
        }
        NavigationTarget2.addArgument = addArgument;
        function getElementIds(target) {
          var _a4;
          if (!((_a4 = target === null || target === void 0 ? void 0 : target.args) === null || _a4 === void 0 ? void 0 : _a4[NavigationTarget2.ELEMENT_IDS])) {
            return [];
          }
          const elementIdsValue = target.args[NavigationTarget2.ELEMENT_IDS].toString();
          return elementIdsValue.split(NavigationTarget2.ELEMENT_IDS_SEPARATOR);
        }
        NavigationTarget2.getElementIds = getElementIds;
        function setElementIds(target, ...elementIds) {
          if (target.args === void 0) {
            target.args = {};
          }
          return target.args[NavigationTarget2.ELEMENT_IDS] = elementIds.join(NavigationTarget2.ELEMENT_IDS_SEPARATOR);
        }
        NavigationTarget2.setElementIds = setElementIds;
        function setTextPosition(target, position) {
          if (position) {
            if (target.args === void 0) {
              target.args = {};
            }
            target.args[NavigationTarget2.TEXT_LINE] = position.line;
            target.args[NavigationTarget2.TEXT_COLUMN] = position.character;
          }
        }
        NavigationTarget2.setTextPosition = setTextPosition;
        function getTextPosition(target) {
          if (!target.args || !target.args[NavigationTarget2.TEXT_LINE] || !target.args[NavigationTarget2.TEXT_COLUMN]) {
            return void 0;
          }
          return {
            line: Number(target.args[NavigationTarget2.TEXT_LINE]),
            character: Number(target.args[NavigationTarget2.TEXT_COLUMN])
          };
        }
        NavigationTarget2.getTextPosition = getTextPosition;
      })(NavigationTarget || (exports.NavigationTarget = NavigationTarget = {}));
      var RequestNavigationTargetsAction;
      (function(RequestNavigationTargetsAction2) {
        RequestNavigationTargetsAction2.KIND = "requestNavigationTargets";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestNavigationTargetsAction2.KIND) && (0, type_util_1.hasStringProp)(object, "targetTypeId") && (0, type_util_1.hasObjectProp)(object, "editorContext");
        }
        RequestNavigationTargetsAction2.is = is;
        function create(options) {
          return {
            kind: RequestNavigationTargetsAction2.KIND,
            requestId: "",
            ...options
          };
        }
        RequestNavigationTargetsAction2.create = create;
      })(RequestNavigationTargetsAction || (exports.RequestNavigationTargetsAction = RequestNavigationTargetsAction = {}));
      var SetNavigationTargetsAction;
      (function(SetNavigationTargetsAction2) {
        SetNavigationTargetsAction2.KIND = "setNavigationTargets";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetNavigationTargetsAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "targets");
        }
        SetNavigationTargetsAction2.is = is;
        function create(targets, options = {}) {
          return {
            kind: SetNavigationTargetsAction2.KIND,
            responseId: "",
            targets,
            ...options
          };
        }
        SetNavigationTargetsAction2.create = create;
      })(SetNavigationTargetsAction || (exports.SetNavigationTargetsAction = SetNavigationTargetsAction = {}));
      var NavigateToTargetAction;
      (function(NavigateToTargetAction2) {
        NavigateToTargetAction2.KIND = "navigateToTarget";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, NavigateToTargetAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "target");
        }
        NavigateToTargetAction2.is = is;
        function create(target) {
          return {
            kind: NavigateToTargetAction2.KIND,
            target
          };
        }
        NavigateToTargetAction2.create = create;
      })(NavigateToTargetAction || (exports.NavigateToTargetAction = NavigateToTargetAction = {}));
      var ResolveNavigationTargetAction;
      (function(ResolveNavigationTargetAction2) {
        ResolveNavigationTargetAction2.KIND = "resolveNavigationTarget";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, ResolveNavigationTargetAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "navigationTarget");
        }
        ResolveNavigationTargetAction2.is = is;
        function create(navigationTarget, options = {}) {
          return {
            kind: ResolveNavigationTargetAction2.KIND,
            requestId: "",
            navigationTarget,
            ...options
          };
        }
        ResolveNavigationTargetAction2.create = create;
      })(ResolveNavigationTargetAction || (exports.ResolveNavigationTargetAction = ResolveNavigationTargetAction = {}));
      var SetResolvedNavigationTargetAction;
      (function(SetResolvedNavigationTargetAction2) {
        SetResolvedNavigationTargetAction2.KIND = "setResolvedNavigationTarget";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetResolvedNavigationTargetAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementIds");
        }
        SetResolvedNavigationTargetAction2.is = is;
        function create(elementIds, options = {}) {
          return {
            kind: SetResolvedNavigationTargetAction2.KIND,
            responseId: "",
            elementIds,
            ...options
          };
        }
        SetResolvedNavigationTargetAction2.create = create;
      })(SetResolvedNavigationTargetAction || (exports.SetResolvedNavigationTargetAction = SetResolvedNavigationTargetAction = {}));
      var NavigateToExternalTargetAction;
      (function(NavigateToExternalTargetAction2) {
        NavigateToExternalTargetAction2.KIND = "navigateToExternalTarget";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, NavigateToExternalTargetAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "target");
        }
        NavigateToExternalTargetAction2.is = is;
        function create(target) {
          return {
            kind: NavigateToExternalTargetAction2.KIND,
            target
          };
        }
        NavigateToExternalTargetAction2.create = create;
      })(NavigateToExternalTargetAction || (exports.NavigateToExternalTargetAction = NavigateToExternalTargetAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-selection.js
  var require_element_selection = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-selection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectAllAction = exports.SelectAction = void 0;
      var array_util_1 = require_array_util();
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var SelectAction;
      (function(SelectAction2) {
        SelectAction2.KIND = "elementSelected";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SelectAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "selectedElementsIDs") && (0, type_util_1.hasArrayProp)(object, "deselectedElementsIDs");
        }
        SelectAction2.is = is;
        function create(options = {}) {
          var _a4, _b2;
          const deselectedElementsIDs = (_a4 = options.deselectedElementsIDs) !== null && _a4 !== void 0 ? _a4 : [];
          return {
            kind: SelectAction2.KIND,
            selectedElementsIDs: (_b2 = options.selectedElementsIDs) !== null && _b2 !== void 0 ? _b2 : [],
            deselectedElementsIDs: (0, array_util_1.isStringArray)(deselectedElementsIDs, true) ? deselectedElementsIDs : [],
            deselectAll: typeof deselectedElementsIDs === "boolean" ? deselectedElementsIDs : false
          };
        }
        SelectAction2.create = create;
        function addSelection(selectedElementsIDs) {
          return create({ selectedElementsIDs });
        }
        SelectAction2.addSelection = addSelection;
        function removeSelection(deselectedElementsIDs) {
          return create({ deselectedElementsIDs });
        }
        SelectAction2.removeSelection = removeSelection;
        function setSelection(selectedElementsIDs) {
          return create({ selectedElementsIDs, deselectedElementsIDs: true });
        }
        SelectAction2.setSelection = setSelection;
      })(SelectAction || (exports.SelectAction = SelectAction = {}));
      var SelectAllAction;
      (function(SelectAllAction2) {
        SelectAllAction2.KIND = "allSelected";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SelectAllAction2.KIND) && (0, type_util_1.hasBooleanProp)(object, "select");
        }
        SelectAllAction2.is = is;
        function create(select = true) {
          return {
            kind: SelectAllAction2.KIND,
            select
          };
        }
        SelectAllAction2.create = create;
      })(SelectAllAction || (exports.SelectAllAction = SelectAllAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-text-editing.js
  var require_element_text_editing = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-text-editing.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValidationStatus = exports.ApplyLabelEditOperation = exports.SetEditValidationResultAction = exports.RequestEditValidationAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestEditValidationAction;
      (function(RequestEditValidationAction2) {
        RequestEditValidationAction2.KIND = "requestEditValidation";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestEditValidationAction2.KIND) && (0, type_util_1.hasStringProp)(object, "contextId") && (0, type_util_1.hasStringProp)(object, "modelElementId") && (0, type_util_1.hasStringProp)(object, "text");
        }
        RequestEditValidationAction2.is = is;
        function create(options) {
          return {
            kind: RequestEditValidationAction2.KIND,
            requestId: "",
            ...options
          };
        }
        RequestEditValidationAction2.create = create;
      })(RequestEditValidationAction || (exports.RequestEditValidationAction = RequestEditValidationAction = {}));
      var SetEditValidationResultAction;
      (function(SetEditValidationResultAction2) {
        SetEditValidationResultAction2.KIND = "setEditValidationResult";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetEditValidationResultAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "status");
        }
        SetEditValidationResultAction2.is = is;
        function create(status, options = {}) {
          return {
            kind: SetEditValidationResultAction2.KIND,
            responseId: "",
            status,
            ...options
          };
        }
        SetEditValidationResultAction2.create = create;
      })(SetEditValidationResultAction || (exports.SetEditValidationResultAction = SetEditValidationResultAction = {}));
      var ApplyLabelEditOperation;
      (function(ApplyLabelEditOperation2) {
        ApplyLabelEditOperation2.KIND = "applyLabelEdit";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ApplyLabelEditOperation2.KIND) && (0, type_util_1.hasStringProp)(object, "labelId") && (0, type_util_1.hasStringProp)(object, "text");
        }
        ApplyLabelEditOperation2.is = is;
        function create(options) {
          return {
            kind: ApplyLabelEditOperation2.KIND,
            isOperation: true,
            ...options
          };
        }
        ApplyLabelEditOperation2.create = create;
      })(ApplyLabelEditOperation || (exports.ApplyLabelEditOperation = ApplyLabelEditOperation = {}));
      var ValidationStatus;
      (function(ValidationStatus2) {
        let Severity;
        (function(Severity2) {
          Severity2[Severity2["FATAL"] = 0] = "FATAL";
          Severity2[Severity2["ERROR"] = 1] = "ERROR";
          Severity2[Severity2["WARNING"] = 2] = "WARNING";
          Severity2[Severity2["INFO"] = 3] = "INFO";
          Severity2[Severity2["OK"] = 4] = "OK";
          Severity2[Severity2["NONE"] = 5] = "NONE";
        })(Severity = ValidationStatus2.Severity || (ValidationStatus2.Severity = {}));
        ValidationStatus2.NONE = {
          severity: Severity.NONE,
          message: "",
          error: { code: -1, message: "", data: {} }
        };
        function isOk(validationStatus) {
          return validationStatus.severity === Severity.OK || validationStatus.severity === Severity.INFO || validationStatus.severity === Severity.NONE;
        }
        ValidationStatus2.isOk = isOk;
        function isWarning(validationStatus) {
          return validationStatus.severity === Severity.WARNING;
        }
        ValidationStatus2.isWarning = isWarning;
        function isError(validationStatus) {
          return validationStatus.severity === Severity.ERROR || validationStatus.severity === Severity.FATAL;
        }
        ValidationStatus2.isError = isError;
      })(ValidationStatus || (exports.ValidationStatus = ValidationStatus = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-type-hints.js
  var require_element_type_hints = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-type-hints.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CheckEdgeResultAction = exports.RequestCheckEdgeAction = exports.SetTypeHintsAction = exports.RequestTypeHintsAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestTypeHintsAction;
      (function(RequestTypeHintsAction2) {
        RequestTypeHintsAction2.KIND = "requestTypeHints";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestTypeHintsAction2.KIND);
        }
        RequestTypeHintsAction2.is = is;
        function create(options = {}) {
          return {
            kind: RequestTypeHintsAction2.KIND,
            requestId: "",
            ...options
          };
        }
        RequestTypeHintsAction2.create = create;
      })(RequestTypeHintsAction || (exports.RequestTypeHintsAction = RequestTypeHintsAction = {}));
      var SetTypeHintsAction;
      (function(SetTypeHintsAction2) {
        SetTypeHintsAction2.KIND = "setTypeHints";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetTypeHintsAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "shapeHints") && (0, type_util_1.hasArrayProp)(object, "edgeHints");
        }
        SetTypeHintsAction2.is = is;
        function create(options) {
          return {
            kind: SetTypeHintsAction2.KIND,
            responseId: "",
            ...options
          };
        }
        SetTypeHintsAction2.create = create;
      })(SetTypeHintsAction || (exports.SetTypeHintsAction = SetTypeHintsAction = {}));
      var RequestCheckEdgeAction;
      (function(RequestCheckEdgeAction2) {
        RequestCheckEdgeAction2.KIND = "requestCheckEdge";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, RequestCheckEdgeAction2.KIND) && (0, type_util_1.hasStringProp)(object, "edgeType") && (0, type_util_1.hasStringProp)(object, "sourceElementId") && (0, type_util_1.hasStringProp)(object, "targetElementId", true);
        }
        RequestCheckEdgeAction2.is = is;
        function create(options) {
          var _a4;
          return {
            kind: RequestCheckEdgeAction2.KIND,
            edgeType: options.edgeType,
            sourceElementId: getElementTypeId(options.sourceElement),
            targetElementId: options.targetElement ? getElementTypeId(options.targetElement) : void 0,
            requestId: (_a4 = options.requestId) !== null && _a4 !== void 0 ? _a4 : ""
          };
        }
        RequestCheckEdgeAction2.create = create;
      })(RequestCheckEdgeAction || (exports.RequestCheckEdgeAction = RequestCheckEdgeAction = {}));
      function getElementTypeId(element) {
        if (typeof element === "string") {
          return element;
        }
        return element.id;
      }
      var CheckEdgeResultAction;
      (function(CheckEdgeResultAction2) {
        CheckEdgeResultAction2.KIND = "checkEdgeTargetResult";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, CheckEdgeResultAction2.KIND) && (0, type_util_1.hasBooleanProp)(object, "isValid") && (0, type_util_1.hasStringProp)(object, "edgeType") && (0, type_util_1.hasStringProp)(object, "sourceElementId") && (0, type_util_1.hasStringProp)(object, "targetElementId", true);
        }
        CheckEdgeResultAction2.is = is;
        function create(options) {
          return {
            kind: CheckEdgeResultAction2.KIND,
            responseId: "",
            ...options
          };
        }
        CheckEdgeResultAction2.create = create;
      })(CheckEdgeResultAction || (exports.CheckEdgeResultAction = CheckEdgeResultAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-validation.js
  var require_element_validation = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/element-validation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteMarkersAction = exports.SetMarkersAction = exports.RequestMarkersAction = exports.MarkersReason = exports.MarkerKind = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var MarkerKind;
      (function(MarkerKind2) {
        MarkerKind2.INFO = "info";
        MarkerKind2.WARNING = "warning";
        MarkerKind2.ERROR = "error";
      })(MarkerKind || (exports.MarkerKind = MarkerKind = {}));
      var MarkersReason;
      (function(MarkersReason2) {
        MarkersReason2.BATCH = "batch";
        MarkersReason2.LIVE = "live";
      })(MarkersReason || (exports.MarkersReason = MarkersReason = {}));
      var RequestMarkersAction;
      (function(RequestMarkersAction2) {
        RequestMarkersAction2.KIND = "requestMarkers";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestMarkersAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementsIDs");
        }
        RequestMarkersAction2.is = is;
        function create(elementsIDs, options = {}) {
          return {
            kind: RequestMarkersAction2.KIND,
            requestId: "",
            elementsIDs,
            reason: MarkersReason.BATCH,
            ...options
          };
        }
        RequestMarkersAction2.create = create;
      })(RequestMarkersAction || (exports.RequestMarkersAction = RequestMarkersAction = {}));
      var SetMarkersAction;
      (function(SetMarkersAction2) {
        SetMarkersAction2.KIND = "setMarkers";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetMarkersAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "markers");
        }
        SetMarkersAction2.is = is;
        function create(markers, options = {}) {
          return {
            kind: SetMarkersAction2.KIND,
            responseId: "",
            markers,
            reason: MarkersReason.BATCH,
            ...options
          };
        }
        SetMarkersAction2.create = create;
      })(SetMarkersAction || (exports.SetMarkersAction = SetMarkersAction = {}));
      var DeleteMarkersAction;
      (function(DeleteMarkersAction2) {
        DeleteMarkersAction2.KIND = "deleteMarkers";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, DeleteMarkersAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "markers");
        }
        DeleteMarkersAction2.is = is;
        function create(markers) {
          return {
            kind: DeleteMarkersAction2.KIND,
            markers
          };
        }
        DeleteMarkersAction2.create = create;
      })(DeleteMarkersAction || (exports.DeleteMarkersAction = DeleteMarkersAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-data.js
  var require_model_data = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-data.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SourceModelChangedAction = exports.UpdateModelAction = exports.SetModelAction = exports.RequestModelAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestModelAction2;
      (function(RequestModelAction3) {
        RequestModelAction3.KIND = "requestModel";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestModelAction3.KIND);
        }
        RequestModelAction3.is = is;
        function create(options = {}) {
          return {
            kind: RequestModelAction3.KIND,
            requestId: "",
            ...options
          };
        }
        RequestModelAction3.create = create;
      })(RequestModelAction2 || (exports.RequestModelAction = RequestModelAction2 = {}));
      var SetModelAction3;
      (function(SetModelAction4) {
        SetModelAction4.KIND = "setModel";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetModelAction4.KIND) && (0, type_util_1.hasObjectProp)(object, "newRoot");
        }
        SetModelAction4.is = is;
        function create(newRoot, options = {}) {
          return {
            kind: SetModelAction4.KIND,
            responseId: "",
            newRoot,
            ...options
          };
        }
        SetModelAction4.create = create;
      })(SetModelAction3 || (exports.SetModelAction = SetModelAction3 = {}));
      var UpdateModelAction3;
      (function(UpdateModelAction4) {
        UpdateModelAction4.KIND = "updateModel";
        function is(action) {
          return base_protocol_1.Action.hasKind(action, UpdateModelAction4.KIND) && (0, type_util_1.hasObjectProp)(action, "newRoot");
        }
        UpdateModelAction4.is = is;
        function create(newRoot, options = {}) {
          return {
            kind: UpdateModelAction4.KIND,
            newRoot,
            animate: true,
            ...options
          };
        }
        UpdateModelAction4.create = create;
      })(UpdateModelAction3 || (exports.UpdateModelAction = UpdateModelAction3 = {}));
      var SourceModelChangedAction;
      (function(SourceModelChangedAction2) {
        SourceModelChangedAction2.KIND = "sourceModelChanged";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SourceModelChangedAction2.KIND) && (0, type_util_1.hasStringProp)(object, "sourceModelName");
        }
        SourceModelChangedAction2.is = is;
        function create(sourceModelName) {
          return {
            kind: SourceModelChangedAction2.KIND,
            sourceModelName
          };
        }
        SourceModelChangedAction2.create = create;
      })(SourceModelChangedAction || (exports.SourceModelChangedAction = SourceModelChangedAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-edit-mode.js
  var require_model_edit_mode = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-edit-mode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EditMode = exports.SetEditModeAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var SetEditModeAction;
      (function(SetEditModeAction2) {
        SetEditModeAction2.KIND = "setEditMode";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetEditModeAction2.KIND) && (0, type_util_1.hasStringProp)(object, "editMode");
        }
        SetEditModeAction2.is = is;
        function create(editMode) {
          return {
            kind: SetEditModeAction2.KIND,
            editMode
          };
        }
        SetEditModeAction2.create = create;
      })(SetEditModeAction || (exports.SetEditModeAction = SetEditModeAction = {}));
      var EditMode;
      (function(EditMode2) {
        EditMode2.READONLY = "readonly";
        EditMode2.EDITABLE = "editable";
      })(EditMode || (exports.EditMode = EditMode = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-layout.js
  var require_model_layout = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-layout.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LayoutOperation = exports.ComputedBoundsAction = exports.RequestBoundsAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var RequestBoundsAction;
      (function(RequestBoundsAction2) {
        RequestBoundsAction2.KIND = "requestBounds";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestBoundsAction2.KIND) && (0, type_util_1.hasObjectProp)(object, "newRoot");
        }
        RequestBoundsAction2.is = is;
        function create(newRoot, options = {}) {
          return {
            kind: RequestBoundsAction2.KIND,
            requestId: "",
            newRoot,
            ...options
          };
        }
        RequestBoundsAction2.create = create;
      })(RequestBoundsAction || (exports.RequestBoundsAction = RequestBoundsAction = {}));
      var ComputedBoundsAction;
      (function(ComputedBoundsAction2) {
        ComputedBoundsAction2.KIND = "computedBounds";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, ComputedBoundsAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "bounds");
        }
        ComputedBoundsAction2.is = is;
        function create(bounds, options = {}) {
          return {
            kind: ComputedBoundsAction2.KIND,
            responseId: "",
            bounds,
            ...options
          };
        }
        ComputedBoundsAction2.create = create;
      })(ComputedBoundsAction || (exports.ComputedBoundsAction = ComputedBoundsAction = {}));
      var LayoutOperation;
      (function(LayoutOperation2) {
        LayoutOperation2.KIND = "layout";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, LayoutOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementIds");
        }
        LayoutOperation2.is = is;
        function create(elementIds, options = {}) {
          return {
            kind: LayoutOperation2.KIND,
            isOperation: true,
            elementIds,
            ...options
          };
        }
        LayoutOperation2.create = create;
      })(LayoutOperation || (exports.LayoutOperation = LayoutOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-saving.js
  var require_model_saving = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/model-saving.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExportSvgAction = exports.RequestExportSvgAction = exports.SetDirtyStateAction = exports.SaveModelAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var SaveModelAction;
      (function(SaveModelAction2) {
        SaveModelAction2.KIND = "saveModel";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SaveModelAction2.KIND);
        }
        SaveModelAction2.is = is;
        function create(options = {}) {
          return {
            kind: SaveModelAction2.KIND,
            ...options
          };
        }
        SaveModelAction2.create = create;
      })(SaveModelAction || (exports.SaveModelAction = SaveModelAction = {}));
      var SetDirtyStateAction;
      (function(SetDirtyStateAction2) {
        SetDirtyStateAction2.KIND = "setDirtyState";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, SetDirtyStateAction2.KIND) && (0, type_util_1.hasBooleanProp)(object, "isDirty");
        }
        SetDirtyStateAction2.is = is;
        function create(isDirty, options = {}) {
          return {
            kind: SetDirtyStateAction2.KIND,
            isDirty,
            ...options
          };
        }
        SetDirtyStateAction2.create = create;
      })(SetDirtyStateAction || (exports.SetDirtyStateAction = SetDirtyStateAction = {}));
      var RequestExportSvgAction;
      (function(RequestExportSvgAction2) {
        RequestExportSvgAction2.KIND = "requestExportSvg";
        function is(object) {
          return base_protocol_1.RequestAction.hasKind(object, RequestExportSvgAction2.KIND);
        }
        RequestExportSvgAction2.is = is;
        function create(options = {}) {
          return {
            kind: RequestExportSvgAction2.KIND,
            requestId: "",
            ...options
          };
        }
        RequestExportSvgAction2.create = create;
      })(RequestExportSvgAction || (exports.RequestExportSvgAction = RequestExportSvgAction = {}));
      var ExportSvgAction;
      (function(ExportSvgAction2) {
        ExportSvgAction2.KIND = "exportSvg";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, ExportSvgAction2.KIND) && (0, type_util_1.hasStringProp)(object, "svg");
        }
        ExportSvgAction2.is = is;
        function create(svg, options = {}) {
          return {
            kind: ExportSvgAction2.KIND,
            svg,
            responseId: "",
            ...options
          };
        }
        ExportSvgAction2.create = create;
      })(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/node-modification.js
  var require_node_modification = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/node-modification.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ChangeContainerOperation = exports.ChangeBoundsOperation = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var ChangeBoundsOperation;
      (function(ChangeBoundsOperation2) {
        ChangeBoundsOperation2.KIND = "changeBounds";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ChangeBoundsOperation2.KIND) && (0, type_util_1.hasArrayProp)(object, "newBounds");
        }
        ChangeBoundsOperation2.is = is;
        function create(newBounds) {
          return {
            kind: ChangeBoundsOperation2.KIND,
            isOperation: true,
            newBounds
          };
        }
        ChangeBoundsOperation2.create = create;
      })(ChangeBoundsOperation || (exports.ChangeBoundsOperation = ChangeBoundsOperation = {}));
      var ChangeContainerOperation;
      (function(ChangeContainerOperation2) {
        ChangeContainerOperation2.KIND = "changeContainer";
        function is(object) {
          return base_protocol_1.Operation.hasKind(object, ChangeContainerOperation2.KIND) && (0, type_util_1.hasStringProp)(object, "elementId") && (0, type_util_1.hasStringProp)(object, "targetContainerId");
        }
        ChangeContainerOperation2.is = is;
        function create(options) {
          return {
            kind: ChangeContainerOperation2.KIND,
            isOperation: true,
            ...options
          };
        }
        ChangeContainerOperation2.create = create;
      })(ChangeContainerOperation || (exports.ChangeContainerOperation = ChangeContainerOperation = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/tool-palette.js
  var require_tool_palette = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/tool-palette.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TriggerEdgeCreationAction = exports.TriggerNodeCreationAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var TriggerNodeCreationAction;
      (function(TriggerNodeCreationAction2) {
        TriggerNodeCreationAction2.KIND = "triggerNodeCreation";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, TriggerNodeCreationAction2.KIND) && (0, type_util_1.hasStringProp)(object, "elementTypeId");
        }
        TriggerNodeCreationAction2.is = is;
        function create(elementTypeId, options) {
          return {
            kind: TriggerNodeCreationAction2.KIND,
            elementTypeId,
            ...options
          };
        }
        TriggerNodeCreationAction2.create = create;
      })(TriggerNodeCreationAction || (exports.TriggerNodeCreationAction = TriggerNodeCreationAction = {}));
      var TriggerEdgeCreationAction;
      (function(TriggerEdgeCreationAction2) {
        TriggerEdgeCreationAction2.KIND = "triggerEdgeCreation";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, TriggerEdgeCreationAction2.KIND) && (0, type_util_1.hasStringProp)(object, "elementTypeId");
        }
        TriggerEdgeCreationAction2.is = is;
        function create(elementTypeId, options = {}) {
          return {
            kind: TriggerEdgeCreationAction2.KIND,
            elementTypeId,
            ...options
          };
        }
        TriggerEdgeCreationAction2.create = create;
      })(TriggerEdgeCreationAction || (exports.TriggerEdgeCreationAction = TriggerEdgeCreationAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/types.js
  var require_types2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MenuItem = exports.PaletteItem = exports.LabeledAction = exports.EditorContext = void 0;
      var type_util_1 = require_type_util();
      var tool_palette_1 = require_tool_palette();
      var EditorContext;
      (function(EditorContext2) {
        function is(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasArrayProp)(object, "selectedElementIds");
        }
        EditorContext2.is = is;
      })(EditorContext || (exports.EditorContext = EditorContext = {}));
      var LabeledAction;
      (function(LabeledAction2) {
        function is(object) {
          return type_util_1.AnyObject.is(object) && (0, type_util_1.hasStringProp)(object, "label") && (0, type_util_1.hasArrayProp)(object, "actions");
        }
        LabeledAction2.is = is;
        function toActionArray(input) {
          if (Array.isArray(input)) {
            return input;
          } else if (LabeledAction2.is(input)) {
            return input.actions;
          }
          return [input];
        }
        LabeledAction2.toActionArray = toActionArray;
      })(LabeledAction || (exports.LabeledAction = LabeledAction = {}));
      var PaletteItem;
      (function(PaletteItem2) {
        function is(object) {
          return LabeledAction.is(object) && (0, type_util_1.hasStringProp)(object, "id") && (0, type_util_1.hasStringProp)(object, "sortString");
        }
        PaletteItem2.is = is;
        function getTriggerAction(item) {
          if (item) {
            const initialActions = item.actions.filter((a3) => isTriggerElementCreationAction(a3)).map((action) => action);
            return initialActions.length > 0 ? initialActions[0] : void 0;
          }
          return void 0;
        }
        PaletteItem2.getTriggerAction = getTriggerAction;
        function isTriggerElementCreationAction(object) {
          return tool_palette_1.TriggerNodeCreationAction.is(object) || tool_palette_1.TriggerEdgeCreationAction.is(object);
        }
        PaletteItem2.isTriggerElementCreationAction = isTriggerElementCreationAction;
      })(PaletteItem || (exports.PaletteItem = PaletteItem = {}));
      var MenuItem;
      (function(MenuItem2) {
        function is(object) {
          return LabeledAction.is(object) && (0, type_util_1.hasStringProp)(object, "id");
        }
        MenuItem2.is = is;
      })(MenuItem || (exports.MenuItem = MenuItem = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/undo-redo.js
  var require_undo_redo2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/undo-redo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RedoAction = exports.UndoAction = void 0;
      var base_protocol_1 = require_base_protocol();
      var UndoAction;
      (function(UndoAction2) {
        UndoAction2.KIND = "glspUndo";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, UndoAction2.KIND);
        }
        UndoAction2.is = is;
        function create() {
          return {
            kind: UndoAction2.KIND
          };
        }
        UndoAction2.create = create;
      })(UndoAction || (exports.UndoAction = UndoAction = {}));
      var RedoAction;
      (function(RedoAction2) {
        RedoAction2.KIND = "glspRedo";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, RedoAction2.KIND);
        }
        RedoAction2.is = is;
        function create() {
          return {
            kind: RedoAction2.KIND
          };
        }
        RedoAction2.create = create;
      })(RedoAction || (exports.RedoAction = RedoAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/action-protocol/viewport.js
  var require_viewport2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/action-protocol/viewport.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MoveViewportAction = exports.FitToScreenAction = exports.CenterAction = void 0;
      var type_util_1 = require_type_util();
      var base_protocol_1 = require_base_protocol();
      var CenterAction;
      (function(CenterAction2) {
        CenterAction2.KIND = "center";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, CenterAction2.KIND) && (0, type_util_1.hasBooleanProp)(object, "animate") && (0, type_util_1.hasBooleanProp)(object, "retainZoom");
        }
        CenterAction2.is = is;
        function create(elementIds, options = {}) {
          return {
            kind: CenterAction2.KIND,
            animate: true,
            retainZoom: false,
            elementIds,
            ...options
          };
        }
        CenterAction2.create = create;
      })(CenterAction || (exports.CenterAction = CenterAction = {}));
      var FitToScreenAction;
      (function(FitToScreenAction2) {
        FitToScreenAction2.KIND = "fit";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, FitToScreenAction2.KIND) && (0, type_util_1.hasArrayProp)(object, "elementIds") && (0, type_util_1.hasBooleanProp)(object, "animate");
        }
        FitToScreenAction2.is = is;
        function create(elementIds, options = {}) {
          return {
            kind: FitToScreenAction2.KIND,
            animate: true,
            elementIds,
            ...options
          };
        }
        FitToScreenAction2.create = create;
      })(FitToScreenAction || (exports.FitToScreenAction = FitToScreenAction = {}));
      var MoveViewportAction;
      (function(MoveViewportAction2) {
        MoveViewportAction2.KIND = "moveViewport";
        function is(object) {
          return base_protocol_1.Action.hasKind(object, MoveViewportAction2.KIND);
        }
        MoveViewportAction2.is = is;
        function create(options) {
          return { kind: MoveViewportAction2.KIND, ...options };
        }
        MoveViewportAction2.create = create;
      })(MoveViewportAction || (exports.MoveViewportAction = MoveViewportAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/base-glsp-client.js
  var require_base_glsp_client = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/base-glsp-client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseGLSPClient = exports.GLOBAL_HANDLER_ID = void 0;
      var sprotty_protocol_1 = require_lib();
      var vscode_jsonrpc_1 = require_main();
      var array_util_1 = require_array_util();
      var event_1 = require_event();
      var glsp_client_1 = require_glsp_client();
      exports.GLOBAL_HANDLER_ID = "*";
      var BaseGLSPClient = class {
        get onServerInitialized() {
          return this.onServerInitializedEmitter.event;
        }
        get onCurrentStateChanged() {
          return this.onCurrentStateChangedEmitter.event;
        }
        set state(state) {
          if (this._state !== state) {
            this._state = state;
            this.onCurrentStateChangedEmitter.fire(state);
          }
        }
        get state() {
          return this._state;
        }
        get checkedServer() {
          this.checkState();
          if (!this._server) {
            throw new Error(`No server is configured for GLSPClient with id '${this.id}'`);
          }
          return this._server;
        }
        get initializeResult() {
          return this._initializeResult;
        }
        constructor(options) {
          this.options = options;
          this.serverDeferred = new sprotty_protocol_1.Deferred();
          this.onStartDeferred = new sprotty_protocol_1.Deferred();
          this.onStopDeferred = new sprotty_protocol_1.Deferred();
          this.startupTimeout = 1500;
          this.actionMessageHandlers = /* @__PURE__ */ new Map([[exports.GLOBAL_HANDLER_ID, []]]);
          this.onServerInitializedEmitter = new event_1.Emitter();
          this.onCurrentStateChangedEmitter = new event_1.Emitter();
          this.state = glsp_client_1.ClientState.Initial;
          this.proxy = this.createProxy();
        }
        createProxy() {
          return {
            process: (message) => {
              var _a4;
              const handlers = (_a4 = this.actionMessageHandlers.get(message.clientId)) !== null && _a4 !== void 0 ? _a4 : this.actionMessageHandlers.get(exports.GLOBAL_HANDLER_ID);
              if (!handlers) {
                console.warn("No ActionMessageHandler is configured- Cannot process server message", message);
                return;
              }
              handlers.forEach((handler) => handler(message));
            }
          };
        }
        configureServer(server) {
          if (this.state === glsp_client_1.ClientState.Running) {
            throw new Error("Could not configure new server. The GLSPClient is already running");
          }
          this.serverDeferred.resolve(server);
        }
        start() {
          if (this.state === glsp_client_1.ClientState.Running || this.state === glsp_client_1.ClientState.Starting) {
            return this.onStartDeferred.promise;
          }
          this.state = glsp_client_1.ClientState.Starting;
          const timeOut = new Promise((_3, reject) => setTimeout(() => {
            reject(new Error("Could not start client. No server is configured"));
          }, this.startupTimeout));
          Promise.race([this.serverDeferred.promise, timeOut]).then((server) => {
            this._server = server;
            this.state = glsp_client_1.ClientState.Running;
            this.onStartDeferred.resolve();
          }).catch((error) => {
            this.state = glsp_client_1.ClientState.StartFailed;
            this.onStartDeferred.reject(error);
          });
          return this.onStartDeferred.promise;
        }
        async initializeServer(params) {
          if (this.initializeResult) {
            return this.initializeResult;
          } else if (this.pendingServerInitialize) {
            return this.pendingServerInitialize;
          }
          const initializeDeferred = new sprotty_protocol_1.Deferred();
          try {
            this.pendingServerInitialize = initializeDeferred.promise;
            this._initializeResult = await this.checkedServer.initialize(params);
            this.onServerInitializedEmitter.fire(this._initializeResult);
            initializeDeferred.resolve(this._initializeResult);
            this.pendingServerInitialize = void 0;
          } catch (error) {
            initializeDeferred.reject(error);
            this._initializeResult = void 0;
            this.pendingServerInitialize = void 0;
          }
          return initializeDeferred.promise;
        }
        initializeClientSession(params) {
          return this.checkedServer.initializeClientSession(params);
        }
        disposeClientSession(params) {
          return this.checkedServer.disposeClientSession(params);
        }
        shutdownServer() {
          this.checkedServer.shutdown();
        }
        async stop() {
          if (this.state === glsp_client_1.ClientState.Stopped || this.state === glsp_client_1.ClientState.Stopping) {
            return this.onStop();
          }
          this.state = glsp_client_1.ClientState.Stopping;
          try {
            if (this._server) {
              this._server.shutdown();
            }
          } finally {
            this.state = glsp_client_1.ClientState.Stopped;
            this.onStopDeferred.resolve();
          }
        }
        sendActionMessage(message) {
          this.checkedServer.process(message);
        }
        onActionMessage(handler, clientId) {
          if (!clientId) {
            (0, array_util_1.distinctAdd)(this.actionMessageHandlers.get(exports.GLOBAL_HANDLER_ID), handler);
            return vscode_jsonrpc_1.Disposable.create(() => (0, array_util_1.remove)(this.actionMessageHandlers.get(exports.GLOBAL_HANDLER_ID), handler));
          }
          if (!this.actionMessageHandlers.has(clientId)) {
            this.actionMessageHandlers.set(clientId, [handler]);
          } else {
            (0, array_util_1.distinctAdd)(this.actionMessageHandlers.get(clientId), handler);
          }
          return vscode_jsonrpc_1.Disposable.create(() => (0, array_util_1.remove)(this.actionMessageHandlers.get(clientId), handler));
        }
        get currentState() {
          return this.state;
        }
        onStart() {
          return this.onStartDeferred.promise;
        }
        onStop() {
          return this.onStopDeferred.promise;
        }
        get id() {
          return this.options.id;
        }
        checkState() {
          if (this.state !== glsp_client_1.ClientState.Running) {
            throw new Error(`Client with id '${this.id}' is not in 'Running' state`);
          }
        }
        setStartupTimeout(ms) {
          this.startupTimeout = ms;
        }
      };
      exports.BaseGLSPClient = BaseGLSPClient;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-server.js
  var require_glsp_server = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/glsp-server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPClientProxy = exports.GLSPServerListener = exports.GLSPServer = void 0;
      exports.GLSPServer = Symbol("GLSPServer");
      exports.GLSPServerListener = Symbol("GLSPServerListener");
      exports.GLSPClientProxy = Symbol("GLSPClientProxy");
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-server.js
  var require_glsp_jsonrpc_server = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/glsp-jsonrpc-server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureClientConnection = void 0;
      var glsp_jsonrpc_client_1 = require_glsp_jsonrpc_client();
      function configureClientConnection(clientConnection, glspServer) {
        clientConnection.onRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeRequest.method, (params) => glspServer.initialize(params));
        clientConnection.onRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.InitializeClientSessionRequest, (params) => glspServer.initializeClientSession(params));
        clientConnection.onRequest(glsp_jsonrpc_client_1.JsonrpcGLSPClient.DisposeClientSessionRequest, (params) => glspServer.disposeClientSession(params));
        clientConnection.onNotification(glsp_jsonrpc_client_1.JsonrpcGLSPClient.ActionMessageNotification, (message) => glspServer.process(message));
        clientConnection.listen();
      }
      exports.configureClientConnection = configureClientConnection;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/websocket-connection.js
  var require_websocket_connection = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/websocket-connection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.listen = exports.createWebSocketConnection = exports.WebSocketMessageWriter = exports.WebSocketMessageReader = exports.wrap = void 0;
      var vscode_jsonrpc_1 = require_main();
      function wrap(socket) {
        return {
          send: (content) => socket.send(content),
          onMessage: (cb) => socket.onmessage = (event) => cb(event.data),
          onClose: (cb) => socket.onclose = (event) => cb(event.code, event.reason),
          onError: (cb) => socket.onerror = (event) => {
            if ("error" in event) {
              cb(event.error);
            }
          },
          dispose: () => socket.close()
        };
      }
      exports.wrap = wrap;
      var WebSocketMessageReader = class extends vscode_jsonrpc_1.AbstractMessageReader {
        constructor(socket) {
          super();
          this.socket = socket;
          this.state = "initial";
          this.eventQueue = [];
          this.socket.onMessage((message) => this.handleMessage(message));
          this.socket.onError((error) => this.fireError(error));
          this.socket.onClose(() => this.fireClose());
        }
        listen(callback) {
          if (this.state === "initial") {
            this.state = "listening";
            this.callback = callback;
            this.eventQueue.forEach((event) => {
              if (event.message) {
                this.handleMessage(event.message);
              } else if (event.error) {
                this.fireError(event.error);
              } else {
                this.fireClose();
              }
            });
            this.eventQueue = [];
          }
          return vscode_jsonrpc_1.Disposable.create(() => {
            this.callback = void 0;
            this.eventQueue = [];
          });
        }
        handleMessage(message) {
          if (this.state === "initial") {
            this.eventQueue.push({ message });
          } else if (this.state === "listening") {
            const data = JSON.parse(message);
            this.callback(data);
          }
        }
        fireError(error) {
          if (this.state === "initial") {
            this.eventQueue.push({ error });
          } else if (this.state === "listening") {
            super.fireError(error);
          }
        }
        fireClose() {
          if (this.state === "initial") {
            this.eventQueue.push({});
          } else if (this.state === "listening") {
            super.fireClose();
          }
          this.state = "closed";
        }
      };
      exports.WebSocketMessageReader = WebSocketMessageReader;
      var WebSocketMessageWriter = class extends vscode_jsonrpc_1.AbstractMessageWriter {
        constructor(socket) {
          super();
          this.socket = socket;
          this.errorCount = 0;
        }
        end() {
        }
        async write(msg) {
          try {
            const content = JSON.stringify(msg);
            this.socket.send(content);
          } catch (e2) {
            this.errorCount++;
            this.fireError(e2, msg, this.errorCount);
          }
        }
      };
      exports.WebSocketMessageWriter = WebSocketMessageWriter;
      function createWebSocketConnection(socket, logger) {
        const reader = new WebSocketMessageReader(socket);
        const writer = new WebSocketMessageWriter(socket);
        return (0, vscode_jsonrpc_1.createMessageConnection)(reader, writer, logger);
      }
      exports.createWebSocketConnection = createWebSocketConnection;
      function listen(webSocket, onConnection, logger) {
        return new Promise((resolve) => {
          webSocket.onopen = () => {
            const socket = wrap(webSocket);
            const connection = createWebSocketConnection(socket, logger);
            onConnection === null || onConnection === void 0 ? void 0 : onConnection(connection);
            resolve(connection);
          };
        });
      }
      exports.listen = listen;
    }
  });

  // node_modules/vscode-jsonrpc/browser.js
  var require_browser2 = __commonJS({
    "node_modules/vscode-jsonrpc/browser.js"(exports, module) {
      "use strict";
      module.exports = require_main();
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/worker-connection-provider.js
  var require_worker_connection_provider = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/worker-connection-provider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPWebWorkerProvider = void 0;
      var browser_1 = require_browser2();
      var GLSPWebWorkerProvider = class {
        constructor(url) {
          this.url = url;
        }
        createWebWorker(url) {
          return new Worker(url);
        }
        listen(handler) {
          var _a4, _b2;
          this.worker = this.createWebWorker(this.url);
          const wwConnection = (0, browser_1.createMessageConnection)(new browser_1.BrowserMessageReader(this.worker), new browser_1.BrowserMessageWriter(this.worker));
          (_a4 = handler.logger) === null || _a4 === void 0 ? void 0 : _a4.warn("GLSPWebWorkerProvider Initializing!");
          (_b2 = handler.onConnection) === null || _b2 === void 0 ? void 0 : _b2.call(handler, wwConnection);
          return wwConnection;
        }
      };
      exports.GLSPWebWorkerProvider = GLSPWebWorkerProvider;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/ws-connection-provider.js
  var require_ws_connection_provider = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/jsonrpc/ws-connection-provider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPWebSocketProvider = exports.GLSPConnectionHandler = void 0;
      var websocket_connection_1 = require_websocket_connection();
      exports.GLSPConnectionHandler = Symbol("GLSPConnectionHandler");
      var GLSPWebSocketProvider = class {
        constructor(url, options) {
          this.url = url;
          this.reconnectAttempts = 0;
          this.options = {
            // default values
            reconnecting: true,
            reconnectAttempts: Infinity,
            reconnectDelay: 1e3
          };
          this.options = Object.assign(this.options, options);
        }
        createWebSocket(url) {
          return new WebSocket(url);
        }
        listen(handler, isReconnecting = false) {
          this.webSocket = this.createWebSocket(this.url);
          this.webSocket.onerror = () => {
            var _a4;
            (_a4 = handler.logger) === null || _a4 === void 0 ? void 0 : _a4.error("GLSPWebSocketProvider Connection to server errored. Please make sure that the server is running!");
            clearInterval(this.reconnectTimer);
            this.webSocket.close();
          };
          return new Promise((resolve) => {
            this.webSocket.onopen = () => {
              var _a4, _b2, _c, _d;
              clearInterval(this.reconnectTimer);
              const wrappedSocket = (0, websocket_connection_1.wrap)(this.webSocket);
              const wsConnection = (0, websocket_connection_1.createWebSocketConnection)(wrappedSocket, handler.logger);
              this.webSocket.onclose = () => {
                var _a5, _b3;
                const { reconnecting, reconnectAttempts, reconnectDelay } = this.options;
                if (reconnecting) {
                  if (this.reconnectAttempts >= reconnectAttempts) {
                    (_a5 = handler.logger) === null || _a5 === void 0 ? void 0 : _a5.error(`GLSPWebSocketProvider WebSocket reconnect failed - maximum number reconnect attempts (${reconnectAttempts}) was exceeded!`);
                  } else {
                    this.reconnectTimer = setInterval(() => {
                      var _a6;
                      (_a6 = handler.logger) === null || _a6 === void 0 ? void 0 : _a6.warn("GLSPWebSocketProvider reconnecting...");
                      this.listen(handler, true);
                      this.reconnectAttempts++;
                    }, reconnectDelay);
                  }
                } else {
                  (_b3 = handler.logger) === null || _b3 === void 0 ? void 0 : _b3.error("GLSPWebSocketProvider WebSocket will not reconnect - closing the connection now!");
                }
              };
              if (isReconnecting) {
                (_a4 = handler.logger) === null || _a4 === void 0 ? void 0 : _a4.warn("GLSPWebSocketProvider Reconnecting!");
                (_b2 = handler.onReconnect) === null || _b2 === void 0 ? void 0 : _b2.call(handler, wsConnection);
              } else {
                (_c = handler.logger) === null || _c === void 0 ? void 0 : _c.warn("GLSPWebSocketProvider Initializing!");
                (_d = handler.onConnection) === null || _d === void 0 ? void 0 : _d.call(handler, wsConnection);
              }
              resolve(wsConnection);
            };
          });
        }
      };
      exports.GLSPWebSocketProvider = GLSPWebSocketProvider;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/types.js
  var require_types3 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/client-server-protocol/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/model/default-types.js
  var require_default_types = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/model/default-types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultTypes = void 0;
      var DefaultTypes2;
      (function(DefaultTypes3) {
        DefaultTypes3.HTML = "html";
        DefaultTypes3.FOREIGN_OBJECT = "foreign-object";
        DefaultTypes3.PRE_RENDERED = "pre-rendered";
        DefaultTypes3.SHAPE_PRE_RENDERED = "shape-pre-rendered";
        DefaultTypes3.SVG = "svg";
        DefaultTypes3.GRAPH = "graph";
        DefaultTypes3.NODE = "node";
        DefaultTypes3.COMPARTMENT = "comp";
        DefaultTypes3.COMPARTMENT_HEADER = "comp:header";
        DefaultTypes3.EDGE = "edge";
        DefaultTypes3.PORT = "port";
        DefaultTypes3.ROUTING_POINT = "routing-point";
        DefaultTypes3.VOLATILE_ROUTING_POINT = `volatile-${DefaultTypes3.ROUTING_POINT}`;
        DefaultTypes3.LABEL = "label";
        DefaultTypes3.BUTTON = "button";
        DefaultTypes3.BUTTON_EXPAND = "button:expand";
        DefaultTypes3.ISSUE_MARKER = "marker";
        DefaultTypes3.NODE_CIRCLE = "node:circle";
        DefaultTypes3.NODE_RECTANGLE = "node:rectangle";
        DefaultTypes3.NODE_DIAMOND = "node:diamond";
      })(DefaultTypes2 || (exports.DefaultTypes = DefaultTypes2 = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/model/model-schema.js
  var require_model_schema = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/model/model-schema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isGModelElementSchema = void 0;
      var type_util_1 = require_type_util();
      function isGModelElementSchema(object) {
        return typeof object === "object" && (0, type_util_1.hasStringProp)(object, "type") && (0, type_util_1.hasStringProp)(object, "id");
      }
      exports.isGModelElementSchema = isGModelElementSchema;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/re-exports.js
  var require_re_exports = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/re-exports.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSubType = exports.getBasicType = exports.findElement = exports.cloneModel = exports.applyBounds = exports.isZoomable = exports.isScrollable = void 0;
      var model_1 = require_model();
      Object.defineProperty(exports, "isScrollable", { enumerable: true, get: function() {
        return model_1.isScrollable;
      } });
      Object.defineProperty(exports, "isZoomable", { enumerable: true, get: function() {
        return model_1.isZoomable;
      } });
      __exportStar(require_async2(), exports);
      __exportStar(require_geometry(), exports);
      __exportStar(require_json(), exports);
      var model_utils_1 = require_model_utils();
      Object.defineProperty(exports, "applyBounds", { enumerable: true, get: function() {
        return model_utils_1.applyBounds;
      } });
      Object.defineProperty(exports, "cloneModel", { enumerable: true, get: function() {
        return model_utils_1.cloneModel;
      } });
      Object.defineProperty(exports, "findElement", { enumerable: true, get: function() {
        return model_utils_1.findElement;
      } });
      Object.defineProperty(exports, "getBasicType", { enumerable: true, get: function() {
        return model_utils_1.getBasicType;
      } });
      Object.defineProperty(exports, "getSubType", { enumerable: true, get: function() {
        return model_utils_1.getSubType;
      } });
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/sprotty-actions.js
  var require_sprotty_actions = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/sprotty-actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewportResult = exports.SetViewportAction = exports.SetBoundsAction = exports.SelectionResult = exports.OpenAction = exports.MoveAction = exports.HoverFeedbackAction = exports.GetViewportAction = exports.GetSelectionAction = exports.CollapseExpandAllAction = exports.CollapseExpandAction = exports.BringToFrontAction = void 0;
      var actions_1 = require_actions();
      Object.defineProperty(exports, "BringToFrontAction", { enumerable: true, get: function() {
        return actions_1.BringToFrontAction;
      } });
      Object.defineProperty(exports, "CollapseExpandAction", { enumerable: true, get: function() {
        return actions_1.CollapseExpandAction;
      } });
      Object.defineProperty(exports, "CollapseExpandAllAction", { enumerable: true, get: function() {
        return actions_1.CollapseExpandAllAction;
      } });
      Object.defineProperty(exports, "GetSelectionAction", { enumerable: true, get: function() {
        return actions_1.GetSelectionAction;
      } });
      Object.defineProperty(exports, "GetViewportAction", { enumerable: true, get: function() {
        return actions_1.GetViewportAction;
      } });
      Object.defineProperty(exports, "HoverFeedbackAction", { enumerable: true, get: function() {
        return actions_1.HoverFeedbackAction;
      } });
      Object.defineProperty(exports, "MoveAction", { enumerable: true, get: function() {
        return actions_1.MoveAction;
      } });
      Object.defineProperty(exports, "OpenAction", { enumerable: true, get: function() {
        return actions_1.OpenAction;
      } });
      Object.defineProperty(exports, "SelectionResult", { enumerable: true, get: function() {
        return actions_1.SelectionResult;
      } });
      Object.defineProperty(exports, "SetBoundsAction", { enumerable: true, get: function() {
        return actions_1.SetBoundsAction;
      } });
      Object.defineProperty(exports, "SetViewportAction", { enumerable: true, get: function() {
        return actions_1.SetViewportAction;
      } });
      Object.defineProperty(exports, "ViewportResult", { enumerable: true, get: function() {
        return actions_1.ViewportResult;
      } });
      var base_protocol_1 = require_base_protocol();
      var type_util_1 = require_type_util();
      actions_1.CollapseExpandAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.CollapseExpandAction.KIND) && (0, type_util_1.hasArrayProp)(object, "expandIds") && (0, type_util_1.hasArrayProp)(object, "collapseIds");
      actions_1.CollapseExpandAllAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.CollapseExpandAllAction.KIND) && (0, type_util_1.hasBooleanProp)(object, "expand");
      actions_1.GetSelectionAction.is = (object) => base_protocol_1.RequestAction.hasKind(object, actions_1.GetSelectionAction.KIND);
      actions_1.GetViewportAction.is = (object) => base_protocol_1.RequestAction.hasKind(object, actions_1.GetViewportAction.KIND);
      actions_1.HoverFeedbackAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.HoverFeedbackAction.KIND) && (0, type_util_1.hasStringProp)(object, "mouseoverElement") && (0, type_util_1.hasBooleanProp)(object, "mouseIsOver");
      actions_1.MoveAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.MoveAction.KIND) && (0, type_util_1.hasArrayProp)(object, "moves") && (0, type_util_1.hasBooleanProp)(object, "animate") && (0, type_util_1.hasBooleanProp)(object, "finished");
      actions_1.OpenAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.OpenAction.KIND) && (0, type_util_1.hasStringProp)(object, "elementId");
      actions_1.SelectionResult.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.SelectionResult.KIND) && (0, type_util_1.hasArrayProp)(object, "selectedElementsIDs");
      actions_1.SetBoundsAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.SetBoundsAction.KIND) && (0, type_util_1.hasObjectProp)(object, "bounds");
      actions_1.SetViewportAction.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.SetViewportAction.KIND) && (0, type_util_1.hasStringProp)(object, "elementId") && (0, type_util_1.hasObjectProp)(object, "newViewport") && (0, type_util_1.hasBooleanProp)(object, "animate");
      actions_1.ViewportResult.is = (object) => base_protocol_1.Action.hasKind(object, actions_1.ViewportResult.KIND) && (0, type_util_1.hasObjectProp)(object, "viewport") && (0, type_util_1.hasObjectProp)(object, "canvasBounds");
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/math-util.js
  var require_math_util = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/math-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.equalUpTo = void 0;
      function equalUpTo(one, other, epsilon = Number.EPSILON) {
        return Math.abs(one - other) <= epsilon;
      }
      exports.equalUpTo = equalUpTo;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-dimension.js
  var require_sprotty_geometry_dimension = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-dimension.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Dimension = void 0;
      var geometry_1 = require_geometry();
      Object.defineProperty(exports, "Dimension", { enumerable: true, get: function() {
        return geometry_1.Dimension;
      } });
      var math_util_1 = require_math_util();
      var type_util_1 = require_type_util();
      geometry_1.Dimension.ZERO = Object.freeze({
        width: 0,
        height: 0
      });
      geometry_1.Dimension.is = (dimension) => type_util_1.AnyObject.is(dimension) && (0, type_util_1.hasNumberProp)(dimension, "width") && (0, type_util_1.hasNumberProp)(dimension, "height");
      geometry_1.Dimension.center = (d3) => ({ x: d3.width * 0.5, y: d3.height * 0.5 });
      geometry_1.Dimension.add = (d3, a3) => ({ width: d3.width + a3.width, height: d3.height + a3.height });
      geometry_1.Dimension.subtract = (d3, a3) => ({ width: d3.width - a3.width, height: d3.height - a3.height });
      geometry_1.Dimension.multiplyMeasure = (d3, m3) => ({ width: d3.width * m3, height: d3.height * m3 });
      geometry_1.Dimension.divideMeasure = (d3, m3) => ({ width: d3.width / m3, height: d3.height / m3 });
      geometry_1.Dimension.map = (dimension, callbackfn) => ({
        ...dimension,
        width: callbackfn(dimension.width, "width"),
        height: callbackfn(dimension.height, "height")
      });
      geometry_1.Dimension.equals = (left, right, eps) => (0, math_util_1.equalUpTo)(left.width, right.width, eps) && (0, math_util_1.equalUpTo)(left.height, right.height, eps);
      geometry_1.Dimension.fromPoint = (point) => ({ width: point.x, height: point.y });
      geometry_1.Dimension.area = (dimension) => dimension.width * dimension.height;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/geometry-util.js
  var require_geometry_util = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/geometry-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Direction = void 0;
      exports.Direction = {
        Left: "left",
        Right: "right",
        Up: "up",
        Down: "down"
      };
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/geometry-vector.js
  var require_geometry_vector = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/geometry-vector.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Vector = void 0;
      var geometry_util_1 = require_geometry_util();
      var type_util_1 = require_type_util();
      var Vector;
      (function(Vector2) {
        Vector2.ZERO = Object.freeze({
          x: 0,
          y: 0
        });
        function abs(vector) {
          return { x: Math.abs(vector.x), y: Math.abs(vector.y) };
        }
        Vector2.abs = abs;
        function add(vector, addend) {
          return { x: vector.x + addend.x, y: vector.y + addend.y };
        }
        Vector2.add = add;
        function equals(left, right) {
          return left.x === right.x && left.y === right.y;
        }
        Vector2.equals = equals;
        function isValid(vector) {
          return vector !== void 0 && !isNaN(vector.x) && !isNaN(vector.y);
        }
        Vector2.isValid = isValid;
        function magnitude(point) {
          return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        }
        Vector2.magnitude = magnitude;
        function map(vector, callbackfn) {
          return {
            ...vector,
            x: callbackfn(vector.x, "x"),
            y: callbackfn(vector.y, "y")
          };
        }
        Vector2.map = map;
        function normalize(vector) {
          const mag = magnitude(vector);
          if (mag === 0 || mag === 1) {
            return Vector2.ZERO;
          }
          return {
            x: vector.x / mag,
            y: vector.y / mag
          };
        }
        Vector2.normalize = normalize;
        function isZero(vector) {
          return Vector2.equals(vector, Vector2.ZERO);
        }
        Vector2.isZero = isZero;
        function is(vector) {
          return type_util_1.AnyObject.is(vector) && (0, type_util_1.hasNumberProp)(vector, "x") && (0, type_util_1.hasNumberProp)(vector, "y");
        }
        Vector2.is = is;
        function divide(vector, scalar) {
          return Vector2.map(vector, (coordinate) => coordinate / scalar);
        }
        Vector2.divide = divide;
        function multiply(vector, scalar) {
          return Vector2.map(vector, (coordinate) => coordinate * scalar);
        }
        Vector2.multiply = multiply;
        function subtract(vector, subtrahend) {
          return { x: vector.x - subtrahend.x, y: vector.y - subtrahend.y };
        }
        Vector2.subtract = subtract;
        function reverse(vector) {
          return { x: -vector.x, y: -vector.y };
        }
        Vector2.reverse = reverse;
        function direction(vector) {
          const directions = [];
          if (vector.x < 0) {
            directions.push(geometry_util_1.Direction.Left);
          } else if (vector.x > 0) {
            directions.push(geometry_util_1.Direction.Right);
          }
          if (vector.y < 0) {
            directions.push(geometry_util_1.Direction.Up);
          } else if (vector.y > 0) {
            directions.push(geometry_util_1.Direction.Down);
          }
          return directions;
        }
        Vector2.direction = direction;
        function min(...vectors) {
          return {
            x: Math.min(...vectors.map((vector) => vector.x)),
            y: Math.min(...vectors.map((vector) => vector.y))
          };
        }
        Vector2.min = min;
        function max(...vectors) {
          return {
            x: Math.max(...vectors.map((vector) => vector.x)),
            y: Math.max(...vectors.map((vector) => vector.y))
          };
        }
        Vector2.max = max;
        function avg(...vectors) {
          if (vectors.length === 0) {
            return Vector2.ZERO;
          }
          return {
            x: vectors.reduce((prev, cur) => prev + cur.x, 0) / vectors.length,
            y: vectors.reduce((prev, cur) => prev + cur.y, 0) / vectors.length
          };
        }
        Vector2.avg = avg;
      })(Vector || (exports.Vector = Vector = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-point.js
  var require_sprotty_geometry_point = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-point.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Point = void 0;
      var geometry_1 = require_geometry();
      Object.defineProperty(exports, "Point", { enumerable: true, get: function() {
        return geometry_1.Point;
      } });
      var geometry_vector_1 = require_geometry_vector();
      var math_util_1 = require_math_util();
      var type_util_1 = require_type_util();
      geometry_1.Point.is = (point) => type_util_1.AnyObject.is(point) && (0, type_util_1.hasNumberProp)(point, "x") && (0, type_util_1.hasNumberProp)(point, "y");
      geometry_1.Point.isOrigin = (point) => geometry_1.Point.equals(point, geometry_1.Point.ORIGIN);
      geometry_1.Point.isValid = (point) => point !== void 0 && !isNaN(point.x) && !isNaN(point.y);
      geometry_1.Point.abs = (point) => geometry_1.Point.map(point, Math.abs);
      geometry_1.Point.divideScalar = (point, scalar) => geometry_1.Point.map(point, (coordinate) => coordinate / scalar);
      geometry_1.Point.multiplyScalar = (point, scalar) => geometry_1.Point.map(point, (coordinate) => coordinate * scalar);
      geometry_1.Point.map = (point, callbackfn) => ({
        ...point,
        x: callbackfn(point.x, "x"),
        y: callbackfn(point.y, "y")
      });
      geometry_1.Point.snapToGrid = (point, grid, gridOrigin) => {
        if (gridOrigin) {
          const relative = geometry_1.Point.subtract(point, gridOrigin);
          const snapped = geometry_1.Point.snapToGrid(relative, grid);
          return geometry_1.Point.add(gridOrigin, snapped);
        } else {
          return { x: Math.round(point.x / grid.x) * grid.x, y: Math.round(point.y / grid.y) * grid.y };
        }
      };
      geometry_1.Point.vector = (from, to) => geometry_1.Point.subtract(to, from);
      geometry_1.Point.move = (from, to) => {
        const vector = geometry_1.Point.vector(from, to);
        const direction = geometry_vector_1.Vector.direction(vector);
        return { from, to, vector, direction };
      };
      geometry_1.Point.moveTowards = (from, vector) => {
        const to = geometry_1.Point.add(from, vector);
        const dir = geometry_vector_1.Vector.direction(vector);
        return { from, to, vector, direction: dir };
      };
      geometry_1.Point.equals = (one, other, eps) => (0, math_util_1.equalUpTo)(one.x, other.x, eps) && (0, math_util_1.equalUpTo)(one.y, other.y, eps);
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-bounds.js
  var require_sprotty_geometry_bounds = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/sprotty-geometry-bounds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Bounds = void 0;
      var geometry_1 = require_geometry();
      Object.defineProperty(exports, "Bounds", { enumerable: true, get: function() {
        return geometry_1.Bounds;
      } });
      var sprotty_geometry_dimension_1 = require_sprotty_geometry_dimension();
      var sprotty_geometry_point_1 = require_sprotty_geometry_point();
      var type_util_1 = require_type_util();
      geometry_1.Bounds.ZERO = Object.freeze({
        x: 0,
        y: 0,
        width: 0,
        height: 0
      });
      geometry_1.Bounds.is = (bounds) => type_util_1.AnyObject.is(bounds) && (0, type_util_1.hasNumberProp)(bounds, "x") && (0, type_util_1.hasNumberProp)(bounds, "y") && (0, type_util_1.hasNumberProp)(bounds, "width") && (0, type_util_1.hasNumberProp)(bounds, "height");
      geometry_1.Bounds.isValid = (bounds) => bounds !== void 0 && sprotty_geometry_dimension_1.Dimension.isValid(bounds) && sprotty_geometry_point_1.Point.isValid(bounds);
      geometry_1.Bounds.encompasses = (outer, inner) => geometry_1.Bounds.includes(outer, geometry_1.Bounds.topLeft(inner)) && geometry_1.Bounds.includes(outer, geometry_1.Bounds.bottomRight(inner));
      geometry_1.Bounds.overlap = (one, other, touch) => {
        const oneTopLeft = geometry_1.Bounds.topLeft(one);
        const oneBottomRight = geometry_1.Bounds.bottomRight(one);
        const otherTopLeft = geometry_1.Bounds.topLeft(other);
        const otherBottomRight = geometry_1.Bounds.bottomRight(other);
        return touch ? oneTopLeft.x <= otherBottomRight.x && otherTopLeft.x <= oneBottomRight.x && oneBottomRight.y >= otherTopLeft.y && otherBottomRight.y >= oneTopLeft.y : oneTopLeft.x < otherBottomRight.x && otherTopLeft.x < oneBottomRight.x && oneBottomRight.y > otherTopLeft.y && otherBottomRight.y > oneTopLeft.y;
      };
      geometry_1.Bounds.equals = (left, right, eps) => sprotty_geometry_point_1.Point.equals(left, right, eps) && sprotty_geometry_dimension_1.Dimension.equals(left, right, eps);
      geometry_1.Bounds.left = (bounds) => bounds.x;
      geometry_1.Bounds.centerX = (bounds) => bounds.x + (bounds.width >= 0 ? bounds.width * 0.5 : 0);
      geometry_1.Bounds.right = (bounds) => bounds.x + bounds.width;
      geometry_1.Bounds.top = (bounds) => bounds.y;
      geometry_1.Bounds.middle = (bounds) => bounds.y + (bounds.height >= 0 ? bounds.height * 0.5 : 0);
      geometry_1.Bounds.centerY = geometry_1.Bounds.middle;
      geometry_1.Bounds.bottom = (bounds) => bounds.y + bounds.height;
      geometry_1.Bounds.topLeft = (bounds) => ({ x: geometry_1.Bounds.left(bounds), y: geometry_1.Bounds.top(bounds) });
      geometry_1.Bounds.topCenter = (bounds) => ({ x: geometry_1.Bounds.centerX(bounds), y: geometry_1.Bounds.top(bounds) });
      geometry_1.Bounds.topRight = (bounds) => ({ x: geometry_1.Bounds.right(bounds), y: geometry_1.Bounds.top(bounds) });
      geometry_1.Bounds.middleLeft = (bounds) => ({ x: geometry_1.Bounds.left(bounds), y: geometry_1.Bounds.middle(bounds) });
      geometry_1.Bounds.middleCenter = (bounds) => ({ x: geometry_1.Bounds.centerX(bounds), y: geometry_1.Bounds.middle(bounds) });
      geometry_1.Bounds.middleRight = (bounds) => ({ x: geometry_1.Bounds.right(bounds), y: geometry_1.Bounds.middle(bounds) });
      geometry_1.Bounds.bottomLeft = (bounds) => ({ x: geometry_1.Bounds.left(bounds), y: geometry_1.Bounds.bottom(bounds) });
      geometry_1.Bounds.bottomCenter = (bounds) => ({ x: geometry_1.Bounds.centerX(bounds), y: geometry_1.Bounds.bottom(bounds) });
      geometry_1.Bounds.bottomRight = (bounds) => ({ x: geometry_1.Bounds.right(bounds), y: geometry_1.Bounds.bottom(bounds) });
      geometry_1.Bounds.isAbove = (leftBounds, rightBounds) => geometry_1.Bounds.top(leftBounds) <= geometry_1.Bounds.top(rightBounds);
      geometry_1.Bounds.isBelow = (leftBounds, rightBounds) => geometry_1.Bounds.top(leftBounds) >= geometry_1.Bounds.top(rightBounds);
      geometry_1.Bounds.isBefore = (leftBounds, rightBounds) => geometry_1.Bounds.left(leftBounds) < geometry_1.Bounds.left(rightBounds);
      geometry_1.Bounds.isAfter = (leftBounds, rightBounds) => geometry_1.Bounds.left(leftBounds) >= geometry_1.Bounds.left(rightBounds);
      geometry_1.Bounds.sortBy = (rankFunc, ...bounds) => bounds.sort((left, right) => rankFunc(left) - rankFunc(right));
      geometry_1.Bounds.from = (topLeft, bottomRight) => ({
        ...topLeft,
        width: bottomRight.x - topLeft.x,
        height: bottomRight.y - topLeft.y
      });
      geometry_1.Bounds.position = geometry_1.Bounds.topLeft;
      geometry_1.Bounds.dimension = (bounds) => ({ width: bounds.width, height: bounds.height });
      geometry_1.Bounds.move = geometry_1.Bounds.translate;
      geometry_1.Bounds.resize = (bounds, delta) => ({
        ...bounds,
        width: bounds.width + delta.width,
        height: bounds.height + delta.height
      });
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/disposable.js
  var require_disposable2 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/disposable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DisposableCollection = exports.Disposable = void 0;
      var array_util_1 = require_array_util();
      var type_util_1 = require_type_util();
      var Disposable;
      (function(Disposable2) {
        function is(value) {
          return type_util_1.AnyObject.is(value) && (0, type_util_1.hasFunctionProp)(value, "dispose");
        }
        Disposable2.is = is;
        function empty() {
          return { dispose: () => {
          } };
        }
        Disposable2.empty = empty;
        function create(cb) {
          return { dispose: cb };
        }
        Disposable2.create = create;
        function dispose(value) {
          if (is(value)) {
            value.dispose();
          }
        }
        Disposable2.dispose = dispose;
      })(Disposable || (exports.Disposable = Disposable = {}));
      var DisposableCollection = class {
        constructor(...toDispose) {
          this.disposables = [];
          toDispose.forEach((d3) => this.push(d3));
          this.errorHandler = (err) => console.error(err);
        }
        dispose() {
          var _a4, _b2;
          if (this.disposed) {
            return;
          }
          try {
            while (!this.disposed) {
              (_a4 = this.disposables.pop()) === null || _a4 === void 0 ? void 0 : _a4.dispose();
            }
          } catch (err) {
            (_b2 = this.errorHandler) === null || _b2 === void 0 ? void 0 : _b2.call(this, err);
          }
        }
        get disposed() {
          return this.disposables.length === 0;
        }
        push(...disposables) {
          const toAdd = (0, array_util_1.isArrayOfType)(disposables, Disposable.is) ? disposables : disposables.map(Disposable.create);
          this.disposables.push(...toAdd);
          return Disposable.create(() => (0, array_util_1.remove)(this.disposables, ...toAdd));
        }
        get isDisposed() {
          return this.disposed;
        }
        /**
         * Removes all disposables in this collection WITHOUT triggering their disposal behavior.
         */
        clear() {
          this.disposables.length = 0;
        }
      };
      exports.DisposableCollection = DisposableCollection;
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/utils/geometry-movement.js
  var require_geometry_movement = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/utils/geometry-movement.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Movement = void 0;
      var sprotty_geometry_point_1 = require_sprotty_geometry_point();
      var geometry_vector_1 = require_geometry_vector();
      var type_util_1 = require_type_util();
      var Movement;
      (function(Movement2) {
        Movement2.ZERO = Object.freeze({
          from: sprotty_geometry_point_1.Point.ORIGIN,
          to: sprotty_geometry_point_1.Point.ORIGIN,
          vector: geometry_vector_1.Vector.ZERO,
          direction: []
        });
        function is(obj) {
          return type_util_1.AnyObject.is(obj) && (0, type_util_1.hasObjectProp)(obj, "from") && sprotty_geometry_point_1.Point.is(obj.from) && (0, type_util_1.hasObjectProp)(obj, "to") && sprotty_geometry_point_1.Point.is(obj.to) && (0, type_util_1.hasObjectProp)(obj, "vector") && geometry_vector_1.Vector.is(obj.to) && (0, type_util_1.hasObjectProp)(obj, "direction");
        }
        Movement2.is = is;
        function isStationary(movement) {
          return geometry_vector_1.Vector.isZero(movement.vector);
        }
        Movement2.isStationary = isStationary;
        function isZero(movement) {
          return Movement2.equals(movement, Movement2.ZERO);
        }
        Movement2.isZero = isZero;
        function equals(left, right) {
          return sprotty_geometry_point_1.Point.equals(left.from, right.from) && sprotty_geometry_point_1.Point.equals(left.to, right.to) && geometry_vector_1.Vector.equals(left.vector, right.vector);
        }
        Movement2.equals = equals;
      })(Movement || (exports.Movement = Movement = {}));
    }
  });

  // node_modules/@eclipse-glsp/protocol/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/@eclipse-glsp/protocol/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_base_protocol(), exports);
      __exportStar(require_client_notification(), exports);
      __exportStar(require_clipboard(), exports);
      __exportStar(require_contexts(), exports);
      __exportStar(require_edge_modification(), exports);
      __exportStar(require_element_creation(), exports);
      __exportStar(require_element_hover(), exports);
      __exportStar(require_element_navigation(), exports);
      __exportStar(require_element_selection(), exports);
      __exportStar(require_element_text_editing(), exports);
      __exportStar(require_element_type_hints(), exports);
      __exportStar(require_element_validation(), exports);
      __exportStar(require_model_data(), exports);
      __exportStar(require_model_edit_mode(), exports);
      __exportStar(require_model_layout(), exports);
      __exportStar(require_model_saving(), exports);
      __exportStar(require_node_modification(), exports);
      __exportStar(require_tool_palette(), exports);
      __exportStar(require_types2(), exports);
      __exportStar(require_undo_redo2(), exports);
      __exportStar(require_viewport2(), exports);
      __exportStar(require_base_glsp_client(), exports);
      __exportStar(require_glsp_client(), exports);
      __exportStar(require_glsp_server(), exports);
      __exportStar(require_base_jsonrpc_glsp_client(), exports);
      __exportStar(require_glsp_jsonrpc_client(), exports);
      __exportStar(require_glsp_jsonrpc_server(), exports);
      __exportStar(require_websocket_connection(), exports);
      __exportStar(require_worker_connection_provider(), exports);
      __exportStar(require_ws_connection_provider(), exports);
      __exportStar(require_types3(), exports);
      __exportStar(require_default_types(), exports);
      __exportStar(require_model_schema(), exports);
      __exportStar(require_re_exports(), exports);
      __exportStar(require_sprotty_actions(), exports);
      __exportStar(require_sprotty_geometry_bounds(), exports);
      __exportStar(require_sprotty_geometry_dimension(), exports);
      __exportStar(require_sprotty_geometry_point(), exports);
      __exportStar(require_array_util(), exports);
      __exportStar(require_disposable2(), exports);
      __exportStar(require_event(), exports);
      __exportStar(require_geometry_movement(), exports);
      __exportStar(require_geometry_util(), exports);
      __exportStar(require_geometry_vector(), exports);
      __exportStar(require_math_util(), exports);
      __exportStar(require_type_util(), exports);
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/re-exports.js
  var require_re_exports2 = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/re-exports.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SvgExporter = exports.ExportSvgPostprocessor = exports.ExportSvgKeyListener = exports.ExportSvgCommand = exports.isExpandable = exports.expandFeature = exports.isEdgeLayoutable = exports.edgeLayoutFeature = exports.checkEdgePlacement = exports.DEFAULT_EDGE_PLACEMENT = exports.DeleteContextMenuItemProvider = exports.ContextMenuProviderRegistry = exports.RevealNamedElementActionProvider = exports.CommandPaletteActionProviderRegistry = exports.GButton = exports.configureButtonHandler = exports.ButtonHandlerRegistry = exports.layoutableChildFeature = exports.layoutContainerFeature = exports.isSizeable = exports.isLayoutableChild = exports.isLayoutContainer = exports.isBoundsAware = exports.isAlignable = exports.getAbsoluteClientBounds = exports.getAbsoluteBounds = exports.findChildrenAtPosition = exports.boundsFeature = exports.alignFeature = exports.GShapeElement = exports.FocusFixPostprocessor = exports.PopupMouseTool = exports.MouseTool = exports.MousePositionTracker = exports.KeyTool = exports.createFeatureSet = exports.SModelRegistry = exports.GModelFactory = exports.EMPTY_ROOT = exports.isParent = exports.createRandomId = exports.ModelIndexImpl = exports.GParentElement = exports.GModelRoot = exports.GModelElement = exports.GChildElement = exports.onAction = exports.configureActionHandler = exports.ActionHandlerRegistry = exports.ActionDispatcher = void 0;
      exports.JumpingPolylineEdgeView = exports.SRoutingHandleView = exports.GLabelView = exports.GCompartmentView = exports.GBezierCreateHandleView = exports.GBezierControlHandleView = exports.BezierCurveEdgeView = exports.SGraphImpl = exports.SEdgeImpl = exports.GPort = exports.GNode = exports.GLabel = exports.GGraphIndex = exports.GCompartment = exports.GViewportRootElement = exports.SprottySelectCommand = exports.SprottySelectAllCommand = exports.SelectMouseListener = exports.SelectKeyboardListener = exports.GetSelectionCommand = exports.selectFeature = exports.isSelected = exports.isSelectable = exports.isConnectable = exports.getRouteBounds = exports.getAbsoluteRouteBounds = exports.edgeInProgressTargetHandleID = exports.edgeInProgressID = exports.connectableFeature = exports.GRoutingHandle = exports.GRoutableElement = exports.GDanglingAnchor = exports.GConnectableElement = exports.isProjectable = exports.getProjections = exports.getProjectedBounds = exports.getModelBounds = exports.moveFeature = exports.isMoveable = exports.isLocateable = exports.isDecoration = exports.decorationFeature = exports.SIssueMarkerImpl = exports.GDecoration = exports.popupFeature = exports.isHoverable = exports.hoverFeedbackFeature = exports.hasPopupFeature = exports.isFadeable = exports.fadeFeature = void 0;
      exports.SvgViewportView = exports.RectangularNodeView = exports.EmptyGroupView = exports.RectangularPort = exports.RectangularNode = exports.GShapedPreRenderedElement = exports.GPreRenderedElement = exports.GHtmlRoot = exports.GForeignObjectElement = exports.DiamondNode = exports.CircularPort = exports.CircularNode = exports.SGraphView = exports.PolylineEdgeViewWithGapsOnIntersections = exports.PolylineEdgeView = void 0;
      __exportStar(require_lib3(), exports);
      __exportStar(require_di(), exports);
      var action_dispatcher_1 = require_action_dispatcher();
      Object.defineProperty(exports, "ActionDispatcher", { enumerable: true, get: function() {
        return action_dispatcher_1.ActionDispatcher;
      } });
      var action_handler_1 = require_action_handler();
      Object.defineProperty(exports, "ActionHandlerRegistry", { enumerable: true, get: function() {
        return action_handler_1.ActionHandlerRegistry;
      } });
      Object.defineProperty(exports, "configureActionHandler", { enumerable: true, get: function() {
        return action_handler_1.configureActionHandler;
      } });
      Object.defineProperty(exports, "onAction", { enumerable: true, get: function() {
        return action_handler_1.onAction;
      } });
      __exportStar(require_diagram_locker(), exports);
      __exportStar(require_animation(), exports);
      __exportStar(require_animation_frame_syncer(), exports);
      __exportStar(require_easing(), exports);
      __exportStar(require_command(), exports);
      __exportStar(require_command_registration(), exports);
      __exportStar(require_command_stack(), exports);
      __exportStar(require_command_stack_options(), exports);
      __exportStar(require_initialize_canvas(), exports);
      __exportStar(require_set_model(), exports);
      var smodel_1 = require_smodel();
      Object.defineProperty(exports, "GChildElement", { enumerable: true, get: function() {
        return smodel_1.SChildElementImpl;
      } });
      Object.defineProperty(exports, "GModelElement", { enumerable: true, get: function() {
        return smodel_1.SModelElementImpl;
      } });
      Object.defineProperty(exports, "GModelRoot", { enumerable: true, get: function() {
        return smodel_1.SModelRootImpl;
      } });
      Object.defineProperty(exports, "GParentElement", { enumerable: true, get: function() {
        return smodel_1.SParentElementImpl;
      } });
      Object.defineProperty(exports, "ModelIndexImpl", { enumerable: true, get: function() {
        return smodel_1.ModelIndexImpl;
      } });
      Object.defineProperty(exports, "createRandomId", { enumerable: true, get: function() {
        return smodel_1.createRandomId;
      } });
      Object.defineProperty(exports, "isParent", { enumerable: true, get: function() {
        return smodel_1.isParent;
      } });
      var smodel_factory_1 = require_smodel_factory();
      Object.defineProperty(exports, "EMPTY_ROOT", { enumerable: true, get: function() {
        return smodel_factory_1.EMPTY_ROOT;
      } });
      Object.defineProperty(exports, "GModelFactory", { enumerable: true, get: function() {
        return smodel_factory_1.SModelFactory;
      } });
      Object.defineProperty(exports, "SModelRegistry", { enumerable: true, get: function() {
        return smodel_factory_1.SModelRegistry;
      } });
      Object.defineProperty(exports, "createFeatureSet", { enumerable: true, get: function() {
        return smodel_factory_1.createFeatureSet;
      } });
      __exportStar(require_smodel_utils(), exports);
      __exportStar(require_ui_extension(), exports);
      __exportStar(require_ui_extension_registry(), exports);
      __exportStar(require_dom_helper(), exports);
      var key_tool_1 = require_key_tool();
      Object.defineProperty(exports, "KeyTool", { enumerable: true, get: function() {
        return key_tool_1.KeyTool;
      } });
      var mouse_tool_1 = require_mouse_tool();
      Object.defineProperty(exports, "MousePositionTracker", { enumerable: true, get: function() {
        return mouse_tool_1.MousePositionTracker;
      } });
      Object.defineProperty(exports, "MouseTool", { enumerable: true, get: function() {
        return mouse_tool_1.MouseTool;
      } });
      Object.defineProperty(exports, "PopupMouseTool", { enumerable: true, get: function() {
        return mouse_tool_1.PopupMouseTool;
      } });
      __exportStar(require_thunk_view(), exports);
      __exportStar(require_view(), exports);
      __exportStar(require_viewer(), exports);
      __exportStar(require_viewer_cache(), exports);
      __exportStar(require_viewer_options(), exports);
      var vnode_postprocessor_1 = require_vnode_postprocessor();
      Object.defineProperty(exports, "FocusFixPostprocessor", { enumerable: true, get: function() {
        return vnode_postprocessor_1.FocusFixPostprocessor;
      } });
      __exportStar(require_vnode_utils(), exports);
      __exportStar(require_abstract_layout(), exports);
      __exportStar(require_bounds_manipulation(), exports);
      __exportStar(require_hbox_layout(), exports);
      __exportStar(require_hidden_bounds_updater(), exports);
      __exportStar(require_layout(), exports);
      var model_1 = require_model2();
      Object.defineProperty(exports, "GShapeElement", { enumerable: true, get: function() {
        return model_1.SShapeElementImpl;
      } });
      Object.defineProperty(exports, "alignFeature", { enumerable: true, get: function() {
        return model_1.alignFeature;
      } });
      Object.defineProperty(exports, "boundsFeature", { enumerable: true, get: function() {
        return model_1.boundsFeature;
      } });
      Object.defineProperty(exports, "findChildrenAtPosition", { enumerable: true, get: function() {
        return model_1.findChildrenAtPosition;
      } });
      Object.defineProperty(exports, "getAbsoluteBounds", { enumerable: true, get: function() {
        return model_1.getAbsoluteBounds;
      } });
      Object.defineProperty(exports, "getAbsoluteClientBounds", { enumerable: true, get: function() {
        return model_1.getAbsoluteClientBounds;
      } });
      Object.defineProperty(exports, "isAlignable", { enumerable: true, get: function() {
        return model_1.isAlignable;
      } });
      Object.defineProperty(exports, "isBoundsAware", { enumerable: true, get: function() {
        return model_1.isBoundsAware;
      } });
      Object.defineProperty(exports, "isLayoutContainer", { enumerable: true, get: function() {
        return model_1.isLayoutContainer;
      } });
      Object.defineProperty(exports, "isLayoutableChild", { enumerable: true, get: function() {
        return model_1.isLayoutableChild;
      } });
      Object.defineProperty(exports, "isSizeable", { enumerable: true, get: function() {
        return model_1.isSizeable;
      } });
      Object.defineProperty(exports, "layoutContainerFeature", { enumerable: true, get: function() {
        return model_1.layoutContainerFeature;
      } });
      Object.defineProperty(exports, "layoutableChildFeature", { enumerable: true, get: function() {
        return model_1.layoutableChildFeature;
      } });
      __exportStar(require_vbox_layout(), exports);
      __exportStar(require_views(), exports);
      var button_handler_1 = require_button_handler();
      Object.defineProperty(exports, "ButtonHandlerRegistry", { enumerable: true, get: function() {
        return button_handler_1.ButtonHandlerRegistry;
      } });
      Object.defineProperty(exports, "configureButtonHandler", { enumerable: true, get: function() {
        return button_handler_1.configureButtonHandler;
      } });
      var model_2 = require_model4();
      Object.defineProperty(exports, "GButton", { enumerable: true, get: function() {
        return model_2.SButtonImpl;
      } });
      var action_providers_1 = require_action_providers();
      Object.defineProperty(exports, "CommandPaletteActionProviderRegistry", { enumerable: true, get: function() {
        return action_providers_1.CommandPaletteActionProviderRegistry;
      } });
      Object.defineProperty(exports, "RevealNamedElementActionProvider", { enumerable: true, get: function() {
        return action_providers_1.RevealNamedElementActionProvider;
      } });
      __exportStar(require_command_palette(), exports);
      var menu_providers_1 = require_menu_providers();
      Object.defineProperty(exports, "ContextMenuProviderRegistry", { enumerable: true, get: function() {
        return menu_providers_1.ContextMenuProviderRegistry;
      } });
      Object.defineProperty(exports, "DeleteContextMenuItemProvider", { enumerable: true, get: function() {
        return menu_providers_1.DeleteContextMenuItemProvider;
      } });
      __exportStar(require_mouse_listener(), exports);
      __exportStar(require_di_config2(), exports);
      __exportStar(require_edge_layout(), exports);
      var model_3 = require_model10();
      Object.defineProperty(exports, "DEFAULT_EDGE_PLACEMENT", { enumerable: true, get: function() {
        return model_3.DEFAULT_EDGE_PLACEMENT;
      } });
      Object.defineProperty(exports, "checkEdgePlacement", { enumerable: true, get: function() {
        return model_3.checkEdgePlacement;
      } });
      Object.defineProperty(exports, "edgeLayoutFeature", { enumerable: true, get: function() {
        return model_3.edgeLayoutFeature;
      } });
      Object.defineProperty(exports, "isEdgeLayoutable", { enumerable: true, get: function() {
        return model_3.isEdgeLayoutable;
      } });
      __exportStar(require_delete(), exports);
      __exportStar(require_edit_label(), exports);
      __exportStar(require_edit_label_ui(), exports);
      __exportStar(require_edit_routing(), exports);
      __exportStar(require_model11(), exports);
      __exportStar(require_expand(), exports);
      var model_4 = require_model14();
      Object.defineProperty(exports, "expandFeature", { enumerable: true, get: function() {
        return model_4.expandFeature;
      } });
      Object.defineProperty(exports, "isExpandable", { enumerable: true, get: function() {
        return model_4.isExpandable;
      } });
      __exportStar(require_views2(), exports);
      var export_1 = require_export();
      Object.defineProperty(exports, "ExportSvgCommand", { enumerable: true, get: function() {
        return export_1.ExportSvgCommand;
      } });
      Object.defineProperty(exports, "ExportSvgKeyListener", { enumerable: true, get: function() {
        return export_1.ExportSvgKeyListener;
      } });
      Object.defineProperty(exports, "ExportSvgPostprocessor", { enumerable: true, get: function() {
        return export_1.ExportSvgPostprocessor;
      } });
      __exportStar(require_model13(), exports);
      var svg_exporter_1 = require_svg_exporter();
      Object.defineProperty(exports, "SvgExporter", { enumerable: true, get: function() {
        return svg_exporter_1.SvgExporter;
      } });
      __exportStar(require_fade(), exports);
      var model_5 = require_model3();
      Object.defineProperty(exports, "fadeFeature", { enumerable: true, get: function() {
        return model_5.fadeFeature;
      } });
      Object.defineProperty(exports, "isFadeable", { enumerable: true, get: function() {
        return model_5.isFadeable;
      } });
      __exportStar(require_hover(), exports);
      var model_6 = require_model7();
      Object.defineProperty(exports, "hasPopupFeature", { enumerable: true, get: function() {
        return model_6.hasPopupFeature;
      } });
      Object.defineProperty(exports, "hoverFeedbackFeature", { enumerable: true, get: function() {
        return model_6.hoverFeedbackFeature;
      } });
      Object.defineProperty(exports, "isHoverable", { enumerable: true, get: function() {
        return model_6.isHoverable;
      } });
      Object.defineProperty(exports, "popupFeature", { enumerable: true, get: function() {
        return model_6.popupFeature;
      } });
      __exportStar(require_popup_position_updater(), exports);
      __exportStar(require_decoration_placer(), exports);
      var model_7 = require_model15();
      Object.defineProperty(exports, "GDecoration", { enumerable: true, get: function() {
        return model_7.SDecoration;
      } });
      Object.defineProperty(exports, "SIssueMarkerImpl", { enumerable: true, get: function() {
        return model_7.SIssueMarkerImpl;
      } });
      Object.defineProperty(exports, "decorationFeature", { enumerable: true, get: function() {
        return model_7.decorationFeature;
      } });
      Object.defineProperty(exports, "isDecoration", { enumerable: true, get: function() {
        return model_7.isDecoration;
      } });
      __exportStar(require_views3(), exports);
      __exportStar(require_intersection_finder(), exports);
      __exportStar(require_sweepline(), exports);
      __exportStar(require_junction_finder(), exports);
      var model_8 = require_model8();
      Object.defineProperty(exports, "isLocateable", { enumerable: true, get: function() {
        return model_8.isLocateable;
      } });
      Object.defineProperty(exports, "isMoveable", { enumerable: true, get: function() {
        return model_8.isMoveable;
      } });
      Object.defineProperty(exports, "moveFeature", { enumerable: true, get: function() {
        return model_8.moveFeature;
      } });
      __exportStar(require_move(), exports);
      __exportStar(require_snap(), exports);
      __exportStar(require_model5(), exports);
      __exportStar(require_model16(), exports);
      __exportStar(require_open(), exports);
      var model_9 = require_model17();
      Object.defineProperty(exports, "getModelBounds", { enumerable: true, get: function() {
        return model_9.getModelBounds;
      } });
      Object.defineProperty(exports, "getProjectedBounds", { enumerable: true, get: function() {
        return model_9.getProjectedBounds;
      } });
      Object.defineProperty(exports, "getProjections", { enumerable: true, get: function() {
        return model_9.getProjections;
      } });
      Object.defineProperty(exports, "isProjectable", { enumerable: true, get: function() {
        return model_9.isProjectable;
      } });
      __exportStar(require_views4(), exports);
      __exportStar(require_abstract_edge_router(), exports);
      __exportStar(require_anchor(), exports);
      __exportStar(require_bezier_anchors(), exports);
      __exportStar(require_bezier_edge_router(), exports);
      __exportStar(require_manhattan_anchors(), exports);
      __exportStar(require_manhattan_edge_router(), exports);
      var model_10 = require_model9();
      Object.defineProperty(exports, "GConnectableElement", { enumerable: true, get: function() {
        return model_10.SConnectableElementImpl;
      } });
      Object.defineProperty(exports, "GDanglingAnchor", { enumerable: true, get: function() {
        return model_10.SDanglingAnchorImpl;
      } });
      Object.defineProperty(exports, "GRoutableElement", { enumerable: true, get: function() {
        return model_10.SRoutableElementImpl;
      } });
      Object.defineProperty(exports, "GRoutingHandle", { enumerable: true, get: function() {
        return model_10.SRoutingHandleImpl;
      } });
      Object.defineProperty(exports, "connectableFeature", { enumerable: true, get: function() {
        return model_10.connectableFeature;
      } });
      Object.defineProperty(exports, "edgeInProgressID", { enumerable: true, get: function() {
        return model_10.edgeInProgressID;
      } });
      Object.defineProperty(exports, "edgeInProgressTargetHandleID", { enumerable: true, get: function() {
        return model_10.edgeInProgressTargetHandleID;
      } });
      Object.defineProperty(exports, "getAbsoluteRouteBounds", { enumerable: true, get: function() {
        return model_10.getAbsoluteRouteBounds;
      } });
      Object.defineProperty(exports, "getRouteBounds", { enumerable: true, get: function() {
        return model_10.getRouteBounds;
      } });
      Object.defineProperty(exports, "isConnectable", { enumerable: true, get: function() {
        return model_10.isConnectable;
      } });
      __exportStar(require_polyline_anchors(), exports);
      __exportStar(require_polyline_edge_router(), exports);
      __exportStar(require_routing(), exports);
      __exportStar(require_views5(), exports);
      var model_11 = require_model6();
      Object.defineProperty(exports, "isSelectable", { enumerable: true, get: function() {
        return model_11.isSelectable;
      } });
      Object.defineProperty(exports, "isSelected", { enumerable: true, get: function() {
        return model_11.isSelected;
      } });
      Object.defineProperty(exports, "selectFeature", { enumerable: true, get: function() {
        return model_11.selectFeature;
      } });
      var select_1 = require_select();
      Object.defineProperty(exports, "GetSelectionCommand", { enumerable: true, get: function() {
        return select_1.GetSelectionCommand;
      } });
      Object.defineProperty(exports, "SelectKeyboardListener", { enumerable: true, get: function() {
        return select_1.SelectKeyboardListener;
      } });
      Object.defineProperty(exports, "SelectMouseListener", { enumerable: true, get: function() {
        return select_1.SelectMouseListener;
      } });
      Object.defineProperty(exports, "SprottySelectAllCommand", { enumerable: true, get: function() {
        return select_1.SelectAllCommand;
      } });
      Object.defineProperty(exports, "SprottySelectCommand", { enumerable: true, get: function() {
        return select_1.SelectCommand;
      } });
      __exportStar(require_model_matching(), exports);
      __exportStar(require_update_model(), exports);
      __exportStar(require_center_fit(), exports);
      __exportStar(require_model12(), exports);
      __exportStar(require_scroll(), exports);
      __exportStar(require_viewport(), exports);
      var viewport_root_1 = require_viewport_root();
      Object.defineProperty(exports, "GViewportRootElement", { enumerable: true, get: function() {
        return viewport_root_1.ViewportRootElementImpl;
      } });
      __exportStar(require_zoom(), exports);
      __exportStar(require_zorder(), exports);
      var sgraph_1 = require_sgraph();
      Object.defineProperty(exports, "GCompartment", { enumerable: true, get: function() {
        return sgraph_1.SCompartmentImpl;
      } });
      Object.defineProperty(exports, "GGraphIndex", { enumerable: true, get: function() {
        return sgraph_1.SGraphIndex;
      } });
      Object.defineProperty(exports, "GLabel", { enumerable: true, get: function() {
        return sgraph_1.SLabelImpl;
      } });
      Object.defineProperty(exports, "GNode", { enumerable: true, get: function() {
        return sgraph_1.SNodeImpl;
      } });
      Object.defineProperty(exports, "GPort", { enumerable: true, get: function() {
        return sgraph_1.SPortImpl;
      } });
      Object.defineProperty(exports, "SEdgeImpl", { enumerable: true, get: function() {
        return sgraph_1.SEdgeImpl;
      } });
      Object.defineProperty(exports, "SGraphImpl", { enumerable: true, get: function() {
        return sgraph_1.SGraphImpl;
      } });
      var views_1 = require_views6();
      Object.defineProperty(exports, "BezierCurveEdgeView", { enumerable: true, get: function() {
        return views_1.BezierCurveEdgeView;
      } });
      Object.defineProperty(exports, "GBezierControlHandleView", { enumerable: true, get: function() {
        return views_1.SBezierControlHandleView;
      } });
      Object.defineProperty(exports, "GBezierCreateHandleView", { enumerable: true, get: function() {
        return views_1.SBezierCreateHandleView;
      } });
      Object.defineProperty(exports, "GCompartmentView", { enumerable: true, get: function() {
        return views_1.SCompartmentView;
      } });
      Object.defineProperty(exports, "GLabelView", { enumerable: true, get: function() {
        return views_1.SLabelView;
      } });
      Object.defineProperty(exports, "SRoutingHandleView", { enumerable: true, get: function() {
        return views_1.SRoutingHandleView;
      } });
      Object.defineProperty(exports, "JumpingPolylineEdgeView", { enumerable: true, get: function() {
        return views_1.JumpingPolylineEdgeView;
      } });
      Object.defineProperty(exports, "PolylineEdgeView", { enumerable: true, get: function() {
        return views_1.PolylineEdgeView;
      } });
      Object.defineProperty(exports, "PolylineEdgeViewWithGapsOnIntersections", { enumerable: true, get: function() {
        return views_1.PolylineEdgeViewWithGapsOnIntersections;
      } });
      Object.defineProperty(exports, "SGraphView", { enumerable: true, get: function() {
        return views_1.SGraphView;
      } });
      __exportStar(require_generic_views(), exports);
      __exportStar(require_html_views(), exports);
      __exportStar(require_jsx(), exports);
      var model_12 = require_model18();
      Object.defineProperty(exports, "CircularNode", { enumerable: true, get: function() {
        return model_12.CircularNode;
      } });
      Object.defineProperty(exports, "CircularPort", { enumerable: true, get: function() {
        return model_12.CircularPort;
      } });
      Object.defineProperty(exports, "DiamondNode", { enumerable: true, get: function() {
        return model_12.DiamondNode;
      } });
      Object.defineProperty(exports, "GForeignObjectElement", { enumerable: true, get: function() {
        return model_12.ForeignObjectElementImpl;
      } });
      Object.defineProperty(exports, "GHtmlRoot", { enumerable: true, get: function() {
        return model_12.HtmlRootImpl;
      } });
      Object.defineProperty(exports, "GPreRenderedElement", { enumerable: true, get: function() {
        return model_12.PreRenderedElementImpl;
      } });
      Object.defineProperty(exports, "GShapedPreRenderedElement", { enumerable: true, get: function() {
        return model_12.ShapedPreRenderedElementImpl;
      } });
      Object.defineProperty(exports, "RectangularNode", { enumerable: true, get: function() {
        return model_12.RectangularNode;
      } });
      Object.defineProperty(exports, "RectangularPort", { enumerable: true, get: function() {
        return model_12.RectangularPort;
      } });
      __exportStar(require_modules(), exports);
      var svg_views_1 = require_svg_views();
      Object.defineProperty(exports, "EmptyGroupView", { enumerable: true, get: function() {
        return svg_views_1.EmptyGroupView;
      } });
      Object.defineProperty(exports, "RectangularNodeView", { enumerable: true, get: function() {
        return svg_views_1.RectangularNodeView;
      } });
      Object.defineProperty(exports, "SvgViewportView", { enumerable: true, get: function() {
        return svg_views_1.SvgViewportView;
      } });
      __exportStar(require_commit_model(), exports);
      __exportStar(require_logging2(), exports);
      __exportStar(require_model_source(), exports);
      __exportStar(require_browser(), exports);
      __exportStar(require_codicon(), exports);
      __exportStar(require_color(), exports);
      __exportStar(require_geometry2(), exports);
      __exportStar(require_inversify(), exports);
      __exportStar(require_iterable(), exports);
      __exportStar(require_keyboard(), exports);
      __exportStar(require_logging(), exports);
      __exportStar(require_registry(), exports);
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/svg-views-override.js
  var require_svg_views_override = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/svg-views-override.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.applyHiddenBoundingRect = exports.hiddenBoundingRect = exports.CircularNodeView = exports.DiamondNodeView = void 0;
      var protocol_1 = require_lib3();
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib2();
      var DiamondNodeView = class DiamondNodeView extends sprotty_1.DiamondNodeView {
        render(node, context, args) {
          return applyHiddenBoundingRect(node, context, super.render(node, context, args));
        }
      };
      exports.DiamondNodeView = DiamondNodeView;
      exports.DiamondNodeView = DiamondNodeView = __decorate([
        (0, inversify_1.injectable)()
      ], DiamondNodeView);
      var CircularNodeView2 = class CircularNodeView extends sprotty_1.CircularNodeView {
        render(node, context, args) {
          return applyHiddenBoundingRect(node, context, super.render(node, context, args));
        }
      };
      exports.CircularNodeView = CircularNodeView2;
      exports.CircularNodeView = CircularNodeView2 = __decorate([
        (0, inversify_1.injectable)()
      ], CircularNodeView2);
      function hiddenBoundingRect(withBounds, context) {
        return !context || context.targetKind === "hidden" ? (0, sprotty_1.svg)("rect", { attrs: { [sprotty_1.ATTR_BBOX_ELEMENT]: true }, ...protocol_1.Bounds.dimension(withBounds.bounds), style: { fill: "transparent" } }) : void 0;
      }
      exports.hiddenBoundingRect = hiddenBoundingRect;
      function applyHiddenBoundingRect(withBounds, context, view) {
        var _a4;
        if (view && context.targetKind === "hidden") {
          const parent = view.sel === "g" ? view : (0, sprotty_1.svg)("g", null, view);
          (_a4 = parent.children) === null || _a4 === void 0 ? void 0 : _a4.unshift(hiddenBoundingRect(withBounds));
          return parent;
        }
        return view;
      }
      exports.applyHiddenBoundingRect = applyHiddenBoundingRect;
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/types.js
  var require_types4 = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TYPES = void 0;
      var sprotty_1 = require_lib2();
      var IGModelRootListener = Symbol("IGModelRootListener");
      exports.TYPES = {
        ...sprotty_1.TYPES,
        // GLSP extends certain sprotty base classes and replaces constructor injection with lazy injection to avoid circular dependencies
        // To pass inversify base class checks an empty array has to be injected.
        // This is the purpose of this service identifier. Typically adopters should not have to  use this identifier.
        EmptyArray: Symbol("EmptyArray"),
        /** @deprecated Using async providers for container service retrieval is discouraged. Use the `LazyInjector` instead */
        ActionHandlerRegistryProvider: sprotty_1.TYPES.ActionHandlerRegistryProvider,
        IAsyncClipboardService: Symbol("IAsyncClipboardService"),
        /** @deprecated Async provider is no longer necessary. Either directly inject or use `LazyInjector`*/
        IEditorContextServiceProvider: Symbol("IEditorContextProvider"),
        IFeedbackActionDispatcher: Symbol("IFeedbackActionDispatcher"),
        IToolFactory: Symbol("Factory<Tool>"),
        ITypeHintProvider: Symbol("ITypeHintProvider"),
        IMovementRestrictor: Symbol("IMovementRestrictor"),
        IMovementOptions: Symbol("IMovementOptions"),
        ISelectionListener: Symbol("ISelectionListener"),
        /** @deprecated Use {@link TYPES.IGModelRootListener} instead */
        ISModelRootListener: IGModelRootListener,
        IGModelRootListener,
        IContextMenuProvider: Symbol("IContextMenuProvider"),
        ICopyPasteHandler: Symbol("ICopyPasteHandler"),
        ITool: Symbol("ITool"),
        IDefaultTool: Symbol("IDefaultTool"),
        IEditModeListener: Symbol("IEditModeListener"),
        IMarqueeBehavior: Symbol("IMarqueeBehavior"),
        IHelperLineManager: Symbol("IHelperLineManager"),
        IHelperLineOptions: Symbol("IHelperLineOptions"),
        IElementNavigator: Symbol("IElementNavigator"),
        ILocalElementNavigator: Symbol("ILocalElementNavigator"),
        IDiagramOptions: Symbol("IDiagramOptions"),
        IDiagramStartup: Symbol("IDiagramStartup"),
        IToolManager: Symbol("IToolManager"),
        IContainerManager: Symbol("IContainerManager"),
        IChangeBoundsManager: Symbol("IChangeBoundsManager"),
        IGridManager: Symbol("IGridManager"),
        IDebugManager: Symbol("IDebugManager"),
        Grid: Symbol("Grid"),
        ZoomFactors: Symbol("ZoomFactors"),
        /**
         * Experimental shortcut manager.
         * The API is not stable yet.
         */
        IShortcutManager: Symbol("IShortcutManager")
      };
    }
  });

  // node_modules/@eclipse-glsp/sprotty/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/@eclipse-glsp/sprotty/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_api_override(), exports);
      __exportStar(require_feature_modules(), exports);
      __exportStar(require_re_exports2(), exports);
      __exportStar(require_svg_views_override(), exports);
      __exportStar(require_types4(), exports);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/action-handler-registry.js
  var require_action_handler_registry = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/action-handler-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPActionHandlerRegistry = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var GLSPActionHandlerRegistry = class GLSPActionHandlerRegistry extends sprotty_1.ActionHandlerRegistry {
        constructor(registrations, initializers) {
          super(registrations, initializers);
          this.initialized = false;
        }
        /**
         * Retrieve a set of all action kinds for which (at least) one
         * handler is registered
         * @returns the set of handled action kinds
         */
        getHandledActionKinds() {
          return Array.from(this.elements.keys());
        }
        initialize() {
          if (this.initialized) {
            return;
          }
          this.lazyInjector.getAll(sprotty_1.TYPES.ActionHandlerRegistration).forEach((registration) => this.register(registration.actionKind, registration.factory()));
          this.lazyInjector.getAll(sprotty_1.TYPES.IActionHandlerInitializer).forEach((initializer) => this.initializeActionHandler(initializer));
        }
      };
      exports.GLSPActionHandlerRegistry = GLSPActionHandlerRegistry;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.LazyInjector),
        __metadata("design:type", Object)
      ], GLSPActionHandlerRegistry.prototype, "lazyInjector", void 0);
      exports.GLSPActionHandlerRegistry = GLSPActionHandlerRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.EmptyArray)),
        __param(1, (0, inversify_1.inject)(sprotty_1.TYPES.EmptyArray)),
        __metadata("design:paramtypes", [Array, Array])
      ], GLSPActionHandlerRegistry);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/model/glsp-model-source.js
  var require_glsp_model_source = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/model/glsp-model-source.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPModelSource = exports.OptionalAction = exports.ServerAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ServerAction;
      (function(ServerAction2) {
        function is(object) {
          return sprotty_1.Action.is(object) && "__receivedFromServer" in object && object.__receivedFromServer === true;
        }
        ServerAction2.is = is;
        function mark(action) {
          action.__receivedFromServer = true;
        }
        ServerAction2.mark = mark;
      })(ServerAction || (exports.ServerAction = ServerAction = {}));
      var OptionalAction;
      (function(OptionalAction2) {
        function is(object) {
          return sprotty_1.Action.is(object) && "__skipErrorIfNoHandler" in object && object.__skipErrorIfNoHandler === true;
        }
        OptionalAction2.is = is;
        function mark(action) {
          action.__skipErrorIfNoHandler = true;
          return action;
        }
        OptionalAction2.mark = mark;
      })(OptionalAction || (exports.OptionalAction = OptionalAction = {}));
      var GLSPModelSource = class GLSPModelSource extends sprotty_1.ModelSource {
        constructor() {
          super(...arguments);
          this.toDispose = new sprotty_1.DisposableCollection();
        }
        get diagramType() {
          return this.options.diagramType;
        }
        get sourceUri() {
          return this.options.sourceUri;
        }
        /**
         * Configure forwarding of server-handled actions to the given {@link GLSPClient} and
         * handling of action received from the `GLSPClient` (i.e. server). It is expected that the
         * given GLSP client has already been initialized.
         * @param glspClient The GLSP  to use.
         * @throws An error if the given `GLSPClient` has not been initialized yet or if the set of server handled
         *         action kinds could not be derived from the initialize result
         */
        configure(glspClient) {
          this.glspClient = glspClient;
          if (!glspClient.initializeResult) {
            throw new Error("Could not configure model source. The GLSP client is not initialized yet!");
          }
          const initializeParams = this.createInitializeClientSessionParameters(glspClient.initializeResult);
          this.configureServeActions(glspClient.initializeResult);
          this.toDispose.push(glspClient.onActionMessage((message) => this.messageReceived(message), this.clientId), sprotty_1.Disposable.create(() => glspClient.disposeClientSession(this.createDisposeClientSessionParameters())));
          return glspClient.initializeClientSession(initializeParams);
        }
        createInitializeClientSessionParameters(_initializeResult) {
          const clientActionKinds = this.registry.getHandledActionKinds();
          return {
            clientSessionId: this.clientId,
            clientActionKinds,
            diagramType: this.diagramType
          };
        }
        createDisposeClientSessionParameters() {
          return {
            clientSessionId: this.clientId
          };
        }
        configureServeActions(initializeResult) {
          const serverActions = initializeResult.serverActions[this.diagramType];
          if ((serverActions === null || serverActions === void 0 ? void 0 : serverActions.length) === 0) {
            throw new Error(`No server-handled actions could be derived from the initialize result for diagramType: ${this.diagramType}!`);
          }
          serverActions.forEach((action) => this.registry.register(action, this));
        }
        messageReceived(message) {
          if (this.clientId !== message.clientId) {
            return;
          }
          const action = message.action;
          ServerAction.mark(action);
          this.logger.log(this, "receiving", action);
          this.actionDispatcher.dispatch(action);
        }
        initialize(registry) {
          var _a4;
          if (!this.clientId) {
            this.clientId = (_a4 = this.options.clientId) !== null && _a4 !== void 0 ? _a4 : this.viewerOptions.baseDiv;
          }
          this.registry = registry;
        }
        handle(action) {
          if (this.shouldForwardToServer(action)) {
            this.forwardToServer(action);
          }
        }
        forwardToServer(action) {
          const message = {
            clientId: this.clientId,
            action
          };
          this.logger.log(this, "sending", message);
          if (this.glspClient) {
            this.glspClient.sendActionMessage(message);
          } else {
            throw new Error("GLSPClient is not connected");
          }
        }
        shouldForwardToServer(action) {
          return !ServerAction.is(action);
        }
        commitModel(newRoot) {
          this._currentRoot = newRoot;
          return newRoot;
        }
        get model() {
          return this._currentRoot;
        }
        dispose() {
          this.toDispose.dispose();
        }
      };
      exports.GLSPModelSource = GLSPModelSource;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], GLSPModelSource.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], GLSPModelSource.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], GLSPModelSource.prototype, "dispose", null);
      exports.GLSPModelSource = GLSPModelSource = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPModelSource);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/model/model-initialization-constraint.js
  var require_model_initialization_constraint = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/model/model-initialization-constraint.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultModelInitializationConstraint = exports.ModelInitializationConstraint = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var ModelInitializationConstraint = class ModelInitializationConstraint {
        constructor() {
          this.completion = new sprotty_1.Deferred();
          this._isCompleted = false;
          this.onInitializedEmitter = new sprotty_1.Emitter();
        }
        get isCompleted() {
          return this._isCompleted;
        }
        onInitialized(listener) {
          if (!listener) {
            return this.completion.promise;
          }
          if (this.isCompleted) {
            listener();
            return sprotty_1.Disposable.empty();
          }
          return this.onInitializedEmitter.event(listener);
        }
        setCompleted() {
          if (!this.isCompleted) {
            this._isCompleted = true;
            this.completion.resolve();
            this.onInitializedEmitter.fire();
            this.onInitializedEmitter.dispose();
          }
        }
        notifyDispatched(action) {
          if (this.isCompleted) {
            return;
          }
          if (this.isInitializedAfter(action)) {
            this.setCompleted();
          }
        }
      };
      exports.ModelInitializationConstraint = ModelInitializationConstraint;
      exports.ModelInitializationConstraint = ModelInitializationConstraint = __decorate([
        (0, inversify_1.injectable)()
      ], ModelInitializationConstraint);
      var DefaultModelInitializationConstraint = class DefaultModelInitializationConstraint extends ModelInitializationConstraint {
        constructor() {
          super(...arguments);
          this.seenNonEmptyModelAction = false;
        }
        isInitializedAfter(action) {
          if (this.isNonEmptyModelAction(action)) {
            this.seenNonEmptyModelAction = true;
          } else if (this.seenNonEmptyModelAction && action.kind === sprotty_1.InitializeCanvasBoundsAction.KIND) {
            return true;
          }
          return false;
        }
        isNonEmptyModelAction(action) {
          if (sprotty_1.SetModelAction.is(action) || sprotty_1.UpdateModelAction.is(action)) {
            return action.newRoot.type !== "NONE";
          }
          return false;
        }
      };
      exports.DefaultModelInitializationConstraint = DefaultModelInitializationConstraint;
      exports.DefaultModelInitializationConstraint = DefaultModelInitializationConstraint = __decorate([
        (0, inversify_1.injectable)()
      ], DefaultModelInitializationConstraint);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/action-dispatcher.js
  var require_action_dispatcher2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/action-dispatcher.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPActionDispatcher = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var action_handler_registry_1 = require_action_handler_registry();
      var glsp_model_source_1 = require_glsp_model_source();
      var model_initialization_constraint_1 = require_model_initialization_constraint();
      var GLSPActionDispatcher = class GLSPActionDispatcher extends sprotty_1.ActionDispatcher {
        constructor() {
          super(...arguments);
          this.timeouts = /* @__PURE__ */ new Map();
          this.initializedConstraint = false;
          this.postUpdateQueue = [];
          this.initializeDeferred = new sprotty_1.Deferred();
        }
        initialize() {
          if (!this.initialized) {
            this.initialized = this.initializeDeferred.promise;
            this.doInitialize();
          }
          return this.initialized;
        }
        async doInitialize() {
          try {
            if (this.actionHandlerRegistry instanceof action_handler_registry_1.GLSPActionHandlerRegistry) {
              this.actionHandlerRegistry.initialize();
            }
            this.handleAction(sprotty_1.SetModelAction.create(sprotty_1.EMPTY_ROOT)).catch(() => {
            });
            this.startModelInitialization();
            this.initializeDeferred.resolve();
          } catch (error) {
            this.initializeDeferred.reject(error);
          }
        }
        startModelInitialization() {
          if (!this.initializedConstraint) {
            this.logger.log(this, "Starting model initialization mode");
            this.initializationConstraint.onInitialized(() => this.logger.log(this, "Model initialization completed"));
            this.initializedConstraint = true;
          }
        }
        onceModelInitialized() {
          return this.initializationConstraint.onInitialized();
        }
        hasHandler(action) {
          return this.actionHandlerRegistry.get(action.kind).length > 0;
        }
        /**
         * Processes all given actions, by dispatching them to the corresponding handlers, after the model initialization is completed.
         *
         * @param actions The actions that should be dispatched after the model initialization
         */
        dispatchOnceModelInitialized(...actions) {
          this.initializationConstraint.onInitialized(() => this.dispatchAll(actions));
        }
        /**
         * Processes all given actions, by dispatching them to the corresponding handlers, after the next model update.
         * The given actions are queued until the next model update cycle has been completed i.e.
         * the `EditorContextService.onModelRootChanged` event is triggered.
         *
         * @param actions The actions that should be dispatched after the next model update
         */
        dispatchAfterNextUpdate(...actions) {
          this.postUpdateQueue.push(...actions);
        }
        modelRootChanged(_root) {
          if (this.postUpdateQueue.length === 0) {
            return;
          }
          const toDispatch = [...this.postUpdateQueue];
          this.postUpdateQueue = [];
          this.dispatchAll(toDispatch);
        }
        async dispatch(action) {
          const result = await super.dispatch(action);
          this.initializationConstraint.notifyDispatched(action);
          return result;
        }
        handleAction(action) {
          if (sprotty_1.ResponseAction.hasValidResponseId(action)) {
            const timeout = this.timeouts.get(action.responseId);
            if (timeout !== void 0) {
              clearTimeout(timeout);
              this.timeouts.delete(action.responseId);
            }
            const deferred = this.requests.get(action.responseId);
            if (deferred === void 0) {
              action.responseId = "";
            }
          }
          if (!this.hasHandler(action) && glsp_model_source_1.OptionalAction.is(action)) {
            return Promise.resolve();
          }
          return super.handleAction(action);
        }
        request(action) {
          if (!action.requestId && action.requestId === "") {
            action.requestId = sprotty_1.RequestAction.generateRequestId();
          }
          return super.request(action);
        }
        /**
         * Dispatch a request and waits for a response until the timeout given in `timeoutMs` has
         * been reached. The returned promise is resolved when a response with matching identifier
         * is dispatched or when the timeout has been reached. That response is _not_ passed to the
         * registered action handlers. Instead, it is the responsibility of the caller of this method
         * to handle the response properly. For example, it can be sent to the registered handlers by
         * passing it again to the `dispatch` method.
         * If `rejectOnTimeout` is set to false (default) the returned promise will be resolved with
         * no value, otherwise it will be rejected.
         */
        requestUntil(action, timeoutMs = 2e3, rejectOnTimeout = false) {
          if (!action.requestId && action.requestId === "") {
            action.requestId = sprotty_1.RequestAction.generateRequestId();
          }
          const requestId = action.requestId;
          const timeout = setTimeout(() => {
            const deferred = this.requests.get(requestId);
            if (deferred !== void 0) {
              clearTimeout(timeout);
              this.requests.delete(requestId);
              const notification = "Request " + requestId + " (" + action + ") time out after " + timeoutMs + "ms.";
              if (rejectOnTimeout) {
                deferred.reject(notification);
              } else {
                this.logger.info(this, notification);
                deferred.resolve();
              }
            }
          }, timeoutMs);
          this.timeouts.set(requestId, timeout);
          return super.request(action);
        }
      };
      exports.GLSPActionDispatcher = GLSPActionDispatcher;
      __decorate([
        (0, inversify_1.inject)(model_initialization_constraint_1.ModelInitializationConstraint),
        __metadata("design:type", model_initialization_constraint_1.ModelInitializationConstraint)
      ], GLSPActionDispatcher.prototype, "initializationConstraint", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.ActionHandlerRegistry),
        __metadata("design:type", sprotty_1.ActionHandlerRegistry)
      ], GLSPActionDispatcher.prototype, "actionHandlerRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ActionHandlerRegistryProvider),
        __metadata("design:type", Function)
      ], GLSPActionDispatcher.prototype, "actionHandlerRegistryProvider", void 0);
      exports.GLSPActionDispatcher = GLSPActionDispatcher = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPActionDispatcher);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/args-feature.js
  var require_args_feature = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/args-feature.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ensureArgs = exports.hasArgs = exports.isArgsAware = exports.argsFeature = void 0;
      exports.argsFeature = Symbol("argsFeature");
      function isArgsAware(element) {
        return element !== void 0 && element.hasFeature(exports.argsFeature);
      }
      exports.isArgsAware = isArgsAware;
      function hasArgs(element) {
        return element !== void 0 && isArgsAware(element) && element.args !== void 0;
      }
      exports.hasArgs = hasArgs;
      function ensureArgs(element) {
        if (!isArgsAware(element)) {
          return false;
        }
        if (element.args === void 0) {
          element.args = {};
        }
        return true;
      }
      exports.ensureArgs = ensureArgs;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/auto-complete/auto-complete-actions.js
  var require_auto_complete_actions = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/auto-complete/auto-complete-actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AutoCompleteValue = void 0;
      var sprotty_1 = require_lib4();
      var AutoCompleteValue;
      (function(AutoCompleteValue2) {
        function is(object) {
          return sprotty_1.LabeledAction.is(object) && (0, sprotty_1.hasStringProp)(object, "text");
        }
        AutoCompleteValue2.is = is;
      })(AutoCompleteValue || (exports.AutoCompleteValue = AutoCompleteValue = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/auto-complete/validation-decorator.js
  var require_validation_decorator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/auto-complete/validation-decorator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValidationDecorator = exports.IValidationDecorator = void 0;
      var sprotty_1 = require_lib4();
      var IValidationDecorator;
      (function(IValidationDecorator2) {
        IValidationDecorator2.NO_DECORATION = {
          // eslint-disable-next-line @typescript-eslint/no-empty-function
          decorateValidationResult(_status) {
          },
          isValidatedOk() {
            return false;
          },
          // eslint-disable-next-line @typescript-eslint/no-empty-function
          invalidate() {
          },
          // eslint-disable-next-line @typescript-eslint/no-empty-function
          dispose() {
          }
        };
      })(IValidationDecorator || (exports.IValidationDecorator = IValidationDecorator = {}));
      var ValidationDecorator = class {
        constructor(containerElement) {
          this.containerElement = containerElement;
          this.warningClasses = ["warning"];
          this.warningIconClasses = (0, sprotty_1.codiconCSSString)("warning");
          this.errorClasses = ["error"];
          this.errorIconClasses = (0, sprotty_1.codiconCSSString)("error");
          this.isValidated = false;
          this.hasValidationError = false;
        }
        decorateValidationResult(status) {
          if (sprotty_1.ValidationStatus.isError(status)) {
            this.hasValidationError = true;
            this.decorateError(status.message ? status.message : "Error");
          } else if (sprotty_1.ValidationStatus.isWarning(status)) {
            this.hasValidationError = false;
            this.decorateWarning(status.message ? status.message : "Warning");
          } else {
            this.hasValidationError = false;
            this.dispose();
          }
          this.isValidated = true;
        }
        decorateError(message) {
          this.switchCssClasses(this.containerElement, this.errorClasses);
          const div = this.createDecorationDiv();
          this.switchCssClasses(div, this.errorClasses);
          div.innerHTML = `<span class="${this.errorIconClasses}"></span> ${message}`;
          this.adjustPosition();
        }
        decorateWarning(message) {
          this.switchCssClasses(this.containerElement, this.warningClasses);
          const div = this.createDecorationDiv();
          this.switchCssClasses(div, this.warningClasses);
          div.innerHTML = `<span class="${this.warningIconClasses}"></span> ${message}`;
          this.adjustPosition();
        }
        switchCssClasses(element, cssClasses) {
          element.classList.remove(...this.errorClasses, ...this.warningClasses);
          element.classList.add(...cssClasses);
        }
        createDecorationDiv() {
          if (!this.decorationDiv) {
            this.containerElement.classList.add("validation");
            this.decorationDiv = document.createElement("div");
            this.decorationDiv.style.width = `${this.decorationContainerWidth()}px`;
            this.decorationDiv.classList.add("validation-decorator");
            this.containerElement.appendChild(this.decorationDiv);
          }
          return this.decorationDiv;
        }
        decorationContainerWidth() {
          return this.containerElement.clientWidth - 5;
        }
        adjustPosition() {
          if (this.decorationDiv) {
            const height = this.decorationDiv.clientHeight + 2;
            this.decorationDiv.style.top = `-${height}px`;
          }
        }
        isValidatedOk() {
          return this.isValidated && !this.hasValidationError;
        }
        invalidate() {
          this.isValidated = false;
        }
        dispose() {
          this.hasValidationError = false;
          this.isValidated = false;
          if (this.decorationDiv && this.containerElement && this.containerElement.contains(this.decorationDiv)) {
            this.containerElement.removeChild(this.decorationDiv);
            this.switchCssClasses(this.containerElement, []);
            this.decorationDiv = void 0;
          }
        }
      };
      exports.ValidationDecorator = ValidationDecorator;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/auto-complete/auto-complete-widget.js
  var require_auto_complete_widget = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/auto-complete/auto-complete-widget.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toActionArray = exports.AutoCompleteWidget = void 0;
      var sprotty_1 = require_lib4();
      var auto_complete_actions_1 = require_auto_complete_actions();
      var validation_decorator_1 = require_validation_decorator();
      var configureAutocomplete = require_autocomplete();
      var AutoCompleteWidget = class {
        constructor(autoSuggestionSettings, suggestionProvider, suggestionSubmitHandler, notifyClose = () => {
        }, logger, options) {
          this.autoSuggestionSettings = autoSuggestionSettings;
          this.suggestionProvider = suggestionProvider;
          this.suggestionSubmitHandler = suggestionSubmitHandler;
          this.notifyClose = notifyClose;
          this.logger = logger;
          this.options = options;
          this.loadingIndicatorClasses = (0, sprotty_1.codiconCSSClasses)("loading", false, true, ["loading"]);
          this.validationDecorator = validation_decorator_1.IValidationDecorator.NO_DECORATION;
        }
        configureValidation(inputValidator, validationDecorator = validation_decorator_1.IValidationDecorator.NO_DECORATION) {
          this.inputValidator = inputValidator;
          this.validationDecorator = validationDecorator;
        }
        configureTextSubmitHandler(textSubmitHandler) {
          this.textSubmitHandler = textSubmitHandler;
        }
        initialize(containerElement) {
          this.containerElement = containerElement;
          this.inputElement = this.createInputElement();
          this.containerElement.appendChild(this.inputElement);
          this.containerElement.style.position = "absolute";
        }
        createInputElement() {
          const inputElement = document.createElement("input");
          inputElement.style.position = "absolute";
          inputElement.spellcheck = false;
          inputElement.autocapitalize = "false";
          inputElement.autocomplete = "off";
          inputElement.style.width = "100%";
          inputElement.addEventListener("keydown", (event) => this.handleKeyDown(event));
          inputElement.addEventListener("blur", () => {
            if (this.containerElement.style.visibility !== "hidden") {
              window.setTimeout(() => this.notifyClose("blur"), 200);
            }
          });
          return inputElement;
        }
        handleKeyDown(event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            this.notifyClose("escape");
            return;
          }
          if ((0, sprotty_1.matchesKeystroke)(event, "Enter") && !this.isInputElementChanged() && this.isSuggestionAvailable()) {
            return;
          }
          if (this.isInputElementChanged()) {
            this.invalidateValidationResultAndContextActions();
          }
          if (!(0, sprotty_1.matchesKeystroke)(event, "Enter") || this.isSuggestionAvailable()) {
            return;
          }
          if (!this.validationDecorator.isValidatedOk()) {
            event.stopImmediatePropagation();
            return;
          }
          if (this.textSubmitHandler) {
            this.executeFromTextOnlyInput();
            this.notifyClose("submission");
          }
        }
        isInputElementChanged() {
          return this.inputElement.value !== this.previousContent;
        }
        invalidateValidationResultAndContextActions() {
          this.contextActions = void 0;
          this.validationDecorator.invalidate();
        }
        open(root, ...contextElementIds) {
          this.contextActions = void 0;
          this.autoCompleteResult = configureAutocomplete(this.autocompleteSettings(root));
          this.previousContent = this.inputElement.value;
          this.inputElement.setSelectionRange(0, this.inputElement.value.length);
          this.inputElement.focus();
        }
        autocompleteSettings(root) {
          return {
            input: this.inputElement,
            emptyMsg: this.autoSuggestionSettings.noSuggestionsMessage,
            className: this.autoSuggestionSettings.suggestionsClass,
            showOnFocus: this.autoSuggestionSettings.showOnFocus,
            debounceWaitMs: this.autoSuggestionSettings.debounceWaitMs,
            minLength: -1,
            fetch: (text, update) => this.updateSuggestions(update, text, root),
            onSelect: (item) => this.onSelect(item),
            render: (item, currentValue) => this.renderSuggestions(item, currentValue),
            customize: (input, inputRect, container, maxHeight) => {
              var _a4;
              this.customizeInputElement(input, inputRect, container, maxHeight);
              const selectedSuggestionChanged = (_a4 = this.options) === null || _a4 === void 0 ? void 0 : _a4.selectedSuggestionChanged;
              if (selectedSuggestionChanged) {
                this.observer = new MutationObserver((mutations) => this.handleContainerMutations(mutations, selectedSuggestionChanged));
                this.observer.observe(container, { childList: true, attributes: true, subtree: true });
              }
            }
          };
        }
        customizeInputElement(input, inputRect, container, maxHeight) {
          container.style.position = "fixed";
          if (this.containerElement) {
            this.containerElement.appendChild(container);
          }
          this.container = container;
        }
        handleContainerMutations(mutations, selectionChanged) {
          var _a4;
          const selectedElement = this.container.querySelector(".selected");
          if (selectedElement !== null && selectedElement !== void 0) {
            const index = Array.from(this.container.children).indexOf(selectedElement);
            selectionChanged((_a4 = this.contextActions) === null || _a4 === void 0 ? void 0 : _a4[index]);
          } else {
            selectionChanged(void 0);
          }
        }
        updateSuggestions(update, text, root, ...contextElementIds) {
          this.onLoading();
          this.doUpdateSuggestions(text, root).then((actions) => {
            var _a4, _b2;
            this.contextActions = this.filterActions(text, actions);
            update(this.contextActions);
            (_b2 = (_a4 = this.options) === null || _a4 === void 0 ? void 0 : _a4.visibleSuggestionsChanged) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, this.contextActions);
            this.onLoaded("success");
          }).catch((reason) => {
            if (this.logger) {
              this.logger.error(this, "Failed to obtain suggestions", reason);
            }
            this.onLoaded("error");
          });
        }
        onLoading() {
          if (this.loadingIndicator && this.containerElement.contains(this.loadingIndicator)) {
            return;
          }
          this.loadingIndicator = document.createElement("span");
          this.loadingIndicator.classList.add(...this.loadingIndicatorClasses);
          this.containerElement.appendChild(this.loadingIndicator);
        }
        doUpdateSuggestions(text, root, ...contextElementIds) {
          return this.suggestionProvider.provideSuggestions(text);
        }
        onLoaded(_success) {
          if (this.containerElement.contains(this.loadingIndicator)) {
            this.containerElement.removeChild(this.loadingIndicator);
          }
          this.validationDecorator.invalidate();
          this.validateInputIfNoContextActions();
          this.previousContent = this.inputElement.value;
        }
        renderSuggestions(item, value) {
          const itemElement = document.createElement("div");
          const wordMatcher = this.escapeForRegExp(value).split(" ").join("|");
          const regex = new RegExp(wordMatcher, "gi");
          if (item.icon) {
            this.renderIcon(itemElement, item.icon);
          }
          itemElement.innerHTML += item.label.replace(regex, (match) => "<em>" + match + "</em>").replace(/ /g, "&nbsp;");
          return itemElement;
        }
        escapeForRegExp(value) {
          return value.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
        }
        renderIcon(itemElement, icon) {
          itemElement.innerHTML += `<span class="icon ${icon}"></span>`;
        }
        filterActions(filterText, actions) {
          return (0, sprotty_1.toArray)(actions.filter((action) => {
            const label = action.label.toLowerCase();
            const searchWords = filterText.split(" ");
            return searchWords.every((word) => label.indexOf(word.toLowerCase()) !== -1);
          }));
        }
        onSelect(item) {
          if (auto_complete_actions_1.AutoCompleteValue.is(item)) {
            this.inputElement.value = item.text;
            window.setTimeout(() => this.inputElement.dispatchEvent(new Event("input")));
          } else {
            this.executeFromSuggestion(item);
            this.notifyClose("submission");
          }
        }
        validateInputIfNoContextActions() {
          if (this.isNoOrExactlyOneMatchingContextAction()) {
            this.validateInput();
          } else {
            this.validationDecorator.dispose();
          }
        }
        isNoOrExactlyOneMatchingContextAction() {
          return !this.isSuggestionAvailable() || this.contextActions && this.contextActions.length === 1 && this.inputElement.value.endsWith(this.contextActions[0].label);
        }
        isSuggestionAvailable() {
          return this.contextActions && this.contextActions.length > 0;
        }
        validateInput() {
          if (this.inputValidator) {
            this.inputValidator.validate(this.inputElement.value).then((result) => this.validationDecorator.decorateValidationResult(result)).catch((error) => this.handleErrorDuringValidation(error));
          }
        }
        handleErrorDuringValidation(error) {
          if (this.logger) {
            this.logger.error(this, "Failed to validate input", error);
          }
          this.validationDecorator.dispose();
        }
        executeFromSuggestion(input) {
          this.suggestionSubmitHandler.executeFromSuggestion(input);
        }
        executeFromTextOnlyInput() {
          if (this.textSubmitHandler) {
            this.textSubmitHandler.executeFromTextOnlyInput(this.inputElement.value);
          }
        }
        get inputField() {
          return this.inputElement;
        }
        dispose() {
          this.validationDecorator.dispose();
          if (this.autoCompleteResult) {
            this.autoCompleteResult.destroy();
          }
        }
      };
      exports.AutoCompleteWidget = AutoCompleteWidget;
      function toActionArray(input) {
        if (sprotty_1.LabeledAction.is(input)) {
          return input.actions;
        } else if (sprotty_1.Action.is(input)) {
          return [input];
        }
        return [];
      }
      exports.toActionArray = toActionArray;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/auto-complete/autocomplete-suggestion-providers.js
  var require_autocomplete_suggestion_providers = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/auto-complete/autocomplete-suggestion-providers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@eclipse-glsp/client/css/autocomplete-palette.css
  var require_autocomplete_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/css/autocomplete-palette.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/ui-extension/ui-extension.js
  var require_ui_extension2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/ui-extension/ui-extension.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPAbstractUIExtension = exports.CSS_HIDDEN_EXTENSION_CLASS = exports.CSS_UI_EXTENSION_CLASS = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      exports.CSS_UI_EXTENSION_CLASS = "ui-extension";
      exports.CSS_HIDDEN_EXTENSION_CLASS = "hidden";
      var GLSPAbstractUIExtension = class GLSPAbstractUIExtension extends sprotty_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.toDisposeOnHide = new sprotty_1.DisposableCollection();
        }
        get diagramContainerId() {
          return this.options.baseDiv;
        }
        get parentContainerSelector() {
          return "#" + this.diagramContainerId;
        }
        get containerSelector() {
          return "#" + this.id();
        }
        get initialized() {
          return !!this.containerElement;
        }
        initialize() {
          if (this.initialized) {
            return true;
          }
          try {
            this.containerElement = this.getOrCreateContainer();
            this.initializeContainer(this.containerElement);
            this.initializeContents(this.containerElement);
          } catch (error) {
            const msg = error instanceof Error ? error.message : `Could not retrieve container element for UI extension ${this.id}`;
            this.logger.error(this, msg);
            return false;
          }
          return true;
        }
        getOrCreateContainer() {
          if (this.containerElement) {
            return this.containerElement;
          }
          const existingContainer = this.getContainer();
          if (existingContainer) {
            return existingContainer;
          }
          const parent = this.getParentContainer();
          if (!(parent === null || parent === void 0 ? void 0 : parent.isConnected)) {
            throw new Error(`Could not obtain attached parent for initializing UI extension ${this.id}`);
          }
          const container = this.createContainer(parent);
          this.insertContainerIntoParent(container, parent);
          return container;
        }
        getContainer() {
          return document.querySelector(this.containerSelector);
        }
        createContainer(parent) {
          const container = document.createElement("div");
          container.id = parent.id + "_" + this.id();
          return container;
        }
        initializeContainer(container) {
          container.classList.add(exports.CSS_UI_EXTENSION_CLASS, this.containerClass());
        }
        getParentContainer() {
          return document.querySelector(this.parentContainerSelector);
        }
        insertContainerIntoParent(container, parent) {
          parent.insertBefore(container, parent.firstChild);
        }
        setContainerVisible(visible) {
          var _a4, _b2;
          if (visible) {
            (_a4 = this.containerElement) === null || _a4 === void 0 ? void 0 : _a4.classList.remove(exports.CSS_HIDDEN_EXTENSION_CLASS);
          } else {
            (_b2 = this.containerElement) === null || _b2 === void 0 ? void 0 : _b2.classList.add(exports.CSS_HIDDEN_EXTENSION_CLASS);
          }
        }
        isContainerVisible() {
          var _a4;
          return !((_a4 = this.containerElement) === null || _a4 === void 0 ? void 0 : _a4.classList.contains(exports.CSS_HIDDEN_EXTENSION_CLASS));
        }
        toggleContainerVisible() {
          this.setContainerVisible(!this.isContainerVisible());
        }
        hide() {
          super.hide();
          this.toDisposeOnHide.dispose();
        }
      };
      exports.GLSPAbstractUIExtension = GLSPAbstractUIExtension;
      exports.GLSPAbstractUIExtension = GLSPAbstractUIExtension = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPAbstractUIExtension);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/messages.json
  var require_messages2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/messages.json"(exports, module) {
      module.exports = {
        navigation: {
          default_navigation_mode_activated: "Navigation On: Use arrow keys to select preceding (\u2190) or succeding (\u2192) elements. Use the up (\u2191) and down (\u2193) arrows to navigate paths. Press 'N' to exit.",
          default_navigation_mode_deactivated: "Navigation Off: Press 'N' for default navigation, 'ALT+N' for position based navigation.",
          local_navigation_mode_activated: "Position based Nav On: Navigate nearest elements using arrow keys: (\u2191) for above, (\u2193) for below, (\u2190) for previous, (\u2192) for next element. Press 'ALT+N' to exit.",
          local_navigation_mode_deactivated: "Position based Nav Off: Press 'N' for default navigation, 'ALT+N' for position based navigation.",
          shortcut_local_mode: "Activate local navigation mode",
          shortcut_global_mode: "Activate global navigation mode"
        },
        focus: {
          focus_not_set: "Focus not set",
          focus_on: "Currently focused: ",
          focus_off: "Currently no element is focused.",
          focus_within: "Within",
          shortcut_focus_palette: "Focus on tool palette",
          shortcut_focus_graph: "Focus on graph"
        },
        resize: {
          resize_mode_activated: "Resize On: Use plus(+) and minus(-) to resize, 'CTRL'+'0' for default size. Press 'ESC' to exit.",
          resize_mode_deactivated: "Resize Off: Press 'ALT'+'A' for resize mode.",
          shortcut_activate: "Activate resize mode for selected element",
          shortcut_deactivate: "Deactivate resize handler",
          shortcut_increase: "Increase size of element",
          shortcut_decrease: "Decrease size of element",
          shortcut_reset: "Set element size to default"
        },
        move: {
          shortcut_move: "Move element"
        },
        grid: {
          zoom_in_grid: "Select a digit from 1-9 to zoom in on the respective box.",
          shortcut_zoom_in: "Zoom in via grid"
        },
        search: {
          shortcut_activate: "Activate search for elements",
          placeholder: "Search for elements...",
          label: "Search Field"
        },
        tool_palette: {
          label: "Tool Palette",
          delete_button: "Enable deletion tool",
          marquee_button: "Enable marquee tool",
          marquee_message: "Currently marquee tool is only usable with mouse.",
          search_placeholder: "Search...",
          search_button: "Filter palette entries",
          selection_button: "Enable selection tool",
          validate_button: "Validate model",
          reset_viewport_button: "Reset Viewport",
          toggle_grid_button: "Toggle Grid",
          debug_mode_button: "Debug Mode",
          minimize: "Minimize palette",
          maximize: "Maximize palette",
          no_items: "No results found."
        },
        viewport: {
          shortcut_move_viewport: "Move viewport",
          shortcut_zoom_viewport: "Zoom viewport",
          shortcut_zoom_element: "Zoom element"
        },
        shortcut: {
          title: "Keyboard Shortcuts",
          header_command: "Command",
          header_shortcut: "Keybinding",
          menu_title: "Shortcut Menu",
          group_move: "Move",
          group_graph: "Graph",
          group_resize: "Resize",
          group_focus: "Focus",
          group_zoom: "Zoom",
          group_navigation: "Navigation",
          group_grid: "Grid",
          group_search: "Search",
          group_tool_palette: "Tool Palette",
          group_viewport: "Viewport"
        },
        diagram: {
          label: "Diagram"
        },
        autocomplete: {
          no_suggestions: "No suggestions available"
        }
      };
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/messages.js
  var require_messages3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.repeatOnMessagesUpdated = exports.updateMessages = exports.onMessagesUpdated = exports.messages = void 0;
      var sprotty_1 = require_lib4();
      var rawMessages = require_messages2();
      var deepUpdate = (target, updates) => {
        for (const key in updates) {
          if (!Object.prototype.hasOwnProperty.call(updates, key) || key === "__proto__" || key === "constructor") {
            continue;
          }
          if (updates[key] && typeof updates[key] === "object" && !Array.isArray(updates[key])) {
            if (!target[key]) {
              target[key] = {};
            }
            deepUpdate(target[key], updates[key]);
          } else {
            target[key] = updates[key];
          }
        }
      };
      exports.messages = rawMessages;
      var messagesUpdatedEmitter = new sprotty_1.Emitter();
      exports.onMessagesUpdated = messagesUpdatedEmitter.event;
      var updateMessages = (updates) => {
        deepUpdate(exports.messages, updates);
        messagesUpdatedEmitter.fire(exports.messages);
      };
      exports.updateMessages = updateMessages;
      function repeatOnMessagesUpdated(listener, options = { initial: true }) {
        let cleanup = options.initial ? listener(exports.messages) : {};
        const updateListener = (0, exports.onMessagesUpdated)(() => {
          sprotty_1.Disposable.dispose(cleanup);
          cleanup = listener();
        });
        return sprotty_1.Disposable.create(() => {
          sprotty_1.Disposable.dispose(cleanup);
          updateListener.dispose();
        });
      }
      exports.repeatOnMessagesUpdated = repeatOnMessagesUpdated;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/auto-complete/base-autocomplete-palette.js
  var require_base_autocomplete_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/auto-complete/base-autocomplete-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseAutocompletePalette = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      require_autocomplete_palette();
      var ui_extension_1 = require_ui_extension2();
      var auto_complete_widget_1 = require_auto_complete_widget();
      var messages_1 = require_messages3();
      var BaseAutocompletePalette = class extends ui_extension_1.GLSPAbstractUIExtension {
        constructor() {
          super(...arguments);
          this.autoSuggestionSettings = {
            noSuggestionsMessage: messages_1.messages.autocomplete.no_suggestions,
            suggestionsClass: "command-palette-suggestions",
            debounceWaitMs: 50,
            showOnFocus: true
          };
        }
        containerClass() {
          return "autocomplete-palette";
        }
        show(root, ...contextElementIds) {
          super.show(root, ...contextElementIds);
          this.root = root;
          this.autocompleteWidget.open(root);
        }
        hide() {
          var _a4;
          (_a4 = this.autocompleteWidget) === null || _a4 === void 0 ? void 0 : _a4.dispose();
          this.root = void 0;
          super.hide();
        }
        initializeContents(containerElement) {
          containerElement.classList.add("command-palette");
          this.autocompleteWidget = new auto_complete_widget_1.AutoCompleteWidget(this.autoSuggestionSettings, { provideSuggestions: (input) => this.retrieveSuggestions(this.root, input) }, { executeFromSuggestion: (input) => this.executeSuggestion(input) }, (reason) => this.autocompleteHide(reason), this.logger, {
            visibleSuggestionsChanged: (suggestions) => this.visibleSuggestionsChanged(this.root, suggestions),
            selectedSuggestionChanged: (suggestion) => this.selectedSuggestionChanged(this.root, suggestion)
          });
          this.autocompleteWidget.initialize(containerElement);
        }
        async visibleSuggestionsChanged(root, labeledActions) {
          return;
        }
        async selectedSuggestionChanged(root, labeledAction) {
          return;
        }
        autocompleteHide(reason) {
          this.hide();
        }
        executeSuggestion(input) {
          this.actionDispatcher.dispatchAll((0, auto_complete_widget_1.toActionArray)(input));
        }
      };
      exports.BaseAutocompletePalette = BaseAutocompletePalette;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], BaseAutocompletePalette.prototype, "actionDispatcher", void 0);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/focus/focus-state-change-action.js
  var require_focus_state_change_action = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/focus/focus-state-change-action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusStateChangedAction = void 0;
      var sprotty_1 = require_lib4();
      var FocusStateChangedAction;
      (function(FocusStateChangedAction2) {
        FocusStateChangedAction2.KIND = "focusStateChanged";
        function is(object) {
          return sprotty_1.Action.hasKind(object, FocusStateChangedAction2.KIND) && (0, sprotty_1.hasBooleanProp)(object, "hasFocus");
        }
        FocusStateChangedAction2.is = is;
        function create(hasFocus = true) {
          return {
            kind: FocusStateChangedAction2.KIND,
            hasFocus
          };
        }
        FocusStateChangedAction2.create = create;
      })(FocusStateChangedAction || (exports.FocusStateChangedAction = FocusStateChangedAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/focus/focus-tracker.js
  var require_focus_tracker = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/focus/focus-tracker.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusTracker = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var FocusTracker = class FocusTracker {
        constructor() {
          this.inActiveCssClass = "inactive";
          this._hasFocus = true;
          this.onFocusChangedEmitter = new sprotty_1.Emitter();
        }
        /**
         * Event that is fired when the focus state of the diagram changes i.e. after a {@link FocusStateChangedAction} has been handled.
         */
        get onFocusChanged() {
          return this.onFocusChangedEmitter.event;
        }
        get hasFocus() {
          return this._hasFocus;
        }
        get focusElement() {
          return this._focusElement;
        }
        get diagramElement() {
          return this._diagramElement;
        }
        handle(action) {
          if (!focus_state_change_action_1.FocusStateChangedAction.is(action)) {
            return;
          }
          this._hasFocus = action.hasFocus;
          this._focusElement = document.activeElement;
          this._diagramElement = document.getElementById(this.options.baseDiv);
          if (!this._diagramElement) {
            return;
          }
          if (this.hasFocus) {
            if (this._diagramElement.classList.contains(this.inActiveCssClass)) {
              this._diagramElement.classList.remove(this.inActiveCssClass);
            }
          } else {
            this._diagramElement.classList.add(this.inActiveCssClass);
          }
          this.onFocusChangedEmitter.fire({ hasFocus: this.hasFocus, focusElement: this.focusElement, diagramElement: this.diagramElement });
        }
      };
      exports.FocusTracker = FocusTracker;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], FocusTracker.prototype, "options", void 0);
      exports.FocusTracker = FocusTracker = __decorate([
        (0, inversify_1.injectable)()
      ], FocusTracker);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/gmodel-util.js
  var require_gmodel_util = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/gmodel-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.removeDescendants = exports.isNotDescendantOfAnyElement = exports.getDescendantIds = exports.isVisibleOnCanvas = exports.calculateDeltaBetweenPoints = exports.findTopLevelElementByFeature = exports.getElementTypeId = exports.calcRoute = exports.calcElementAndRoute = exports.calcElementAndRoutingPoints = exports.ROUTE_KINDS = exports.ROUTING_POINT_KINDS = exports.ALL_ROUTING_POINTS = exports.toElementAndRoutingPoints = exports.toElementAndBounds = exports.isSelectableAndBoundsAware = exports.isRoutingHandle = exports.isRoutable = exports.isNonRoutableBoundsAware = exports.isNonRoutableSelectedBoundsAware = exports.isNonRoutableMovableBoundsAware = exports.isNonRoutableSelectedMovableBoundsAware = exports.toggleCssClass = exports.removeCssClassOfElements = exports.addCssClassToElements = exports.removeCssClasses = exports.addCssClasses = exports.isNotUndefined = exports.hasSelectedElements = exports.getSelectedElementCount = exports.getElements = exports.getMatchingElements = exports.forEachElement = exports.filter = void 0;
      var sprotty_1 = require_lib4();
      function filter(index, predicate) {
        return index.all().filter(predicate);
      }
      exports.filter = filter;
      function forEachElement(index, predicate, runnable) {
        filter(index, predicate).forEach(runnable);
      }
      exports.forEachElement = forEachElement;
      function getMatchingElements(index, predicate) {
        return Array.from(filter(index, predicate));
      }
      exports.getMatchingElements = getMatchingElements;
      function getElements(index, elementsIDs, guard) {
        const filterFn = (element) => {
          if (element !== void 0) {
            return guard ? guard(element) : true;
          }
          return false;
        };
        return elementsIDs.map((id) => index.getById(id)).filter(filterFn);
      }
      exports.getElements = getElements;
      function getSelectedElementCount(index) {
        let selected = 0;
        forEachElement(index, sprotty_1.isSelected, (element) => selected++);
        return selected;
      }
      exports.getSelectedElementCount = getSelectedElementCount;
      function hasSelectedElements(index) {
        return getSelectedElementCount(index) > 0;
      }
      exports.hasSelectedElements = hasSelectedElements;
      function isNotUndefined(element) {
        return element !== void 0;
      }
      exports.isNotUndefined = isNotUndefined;
      function addCssClasses(element, ...cssClasses) {
        var _a4;
        const classes = Array.isArray(cssClasses[0]) ? cssClasses[0] : cssClasses;
        const elementCssClasses = (_a4 = element.cssClasses) !== null && _a4 !== void 0 ? _a4 : [];
        (0, sprotty_1.distinctAdd)(elementCssClasses, ...classes);
        element.cssClasses = elementCssClasses;
      }
      exports.addCssClasses = addCssClasses;
      function removeCssClasses(element, ...cssClasses) {
        if (!element.cssClasses || element.cssClasses.length === 0) {
          return;
        }
        const classes = Array.isArray(cssClasses[0]) ? cssClasses[0] : cssClasses;
        (0, sprotty_1.remove)(element.cssClasses, ...classes);
      }
      exports.removeCssClasses = removeCssClasses;
      function addCssClassToElements(elements, ...cssClasses) {
        for (const element of elements) {
          addCssClasses(element, cssClasses);
        }
      }
      exports.addCssClassToElements = addCssClassToElements;
      function removeCssClassOfElements(elements, ...cssClasses) {
        for (const element of elements) {
          removeCssClasses(element, cssClasses);
        }
      }
      exports.removeCssClassOfElements = removeCssClassOfElements;
      function toggleCssClass(element, cssClass, toggle) {
        return toggle ? addCssClasses(element, cssClass) : removeCssClasses(element, cssClass);
      }
      exports.toggleCssClass = toggleCssClass;
      function isNonRoutableSelectedMovableBoundsAware(element) {
        return isNonRoutableSelectedBoundsAware(element) && (0, sprotty_1.isMoveable)(element);
      }
      exports.isNonRoutableSelectedMovableBoundsAware = isNonRoutableSelectedMovableBoundsAware;
      function isNonRoutableMovableBoundsAware(element) {
        return isNonRoutableBoundsAware(element) && (0, sprotty_1.isMoveable)(element);
      }
      exports.isNonRoutableMovableBoundsAware = isNonRoutableMovableBoundsAware;
      function isNonRoutableSelectedBoundsAware(element) {
        return isNonRoutableBoundsAware(element) && (0, sprotty_1.isSelected)(element);
      }
      exports.isNonRoutableSelectedBoundsAware = isNonRoutableSelectedBoundsAware;
      function isNonRoutableBoundsAware(element) {
        return (0, sprotty_1.isBoundsAware)(element) && !isRoutable(element);
      }
      exports.isNonRoutableBoundsAware = isNonRoutableBoundsAware;
      function isRoutable(element) {
        return element instanceof sprotty_1.GRoutableElement && element.routingPoints !== void 0;
      }
      exports.isRoutable = isRoutable;
      function isRoutingHandle(element) {
        return element !== void 0 && element instanceof sprotty_1.GRoutingHandle;
      }
      exports.isRoutingHandle = isRoutingHandle;
      function isSelectableAndBoundsAware(element) {
        return (0, sprotty_1.isSelectable)(element) && (0, sprotty_1.isBoundsAware)(element);
      }
      exports.isSelectableAndBoundsAware = isSelectableAndBoundsAware;
      function toElementAndBounds(element) {
        return {
          elementId: element.id,
          newPosition: {
            x: element.bounds.x,
            y: element.bounds.y
          },
          newSize: {
            width: element.bounds.width,
            height: element.bounds.height
          }
        };
      }
      exports.toElementAndBounds = toElementAndBounds;
      function toElementAndRoutingPoints(element) {
        return {
          elementId: element.id,
          newRoutingPoints: element.routingPoints
        };
      }
      exports.toElementAndRoutingPoints = toElementAndRoutingPoints;
      exports.ALL_ROUTING_POINTS = void 0;
      exports.ROUTING_POINT_KINDS = ["linear", "bezier-junction"];
      exports.ROUTE_KINDS = [...exports.ROUTING_POINT_KINDS, "source", "target"];
      function calcElementAndRoutingPoints(element, routerRegistry) {
        const newRoutingPoints = routerRegistry ? calcRoute(element, routerRegistry, exports.ROUTING_POINT_KINDS) : element.routingPoints;
        return { elementId: element.id, newRoutingPoints };
      }
      exports.calcElementAndRoutingPoints = calcElementAndRoutingPoints;
      function calcElementAndRoute(element, routerRegistry) {
        var _a4, _b2;
        let route = routerRegistry ? calcRoute(element, routerRegistry, exports.ROUTE_KINDS) : void 0;
        if (!route) {
          route = [...element.routingPoints];
          route.splice(0, 0, ((_a4 = element.source) === null || _a4 === void 0 ? void 0 : _a4.position) || sprotty_1.Point.ORIGIN);
          route.push(((_b2 = element.target) === null || _b2 === void 0 ? void 0 : _b2.position) || sprotty_1.Point.ORIGIN);
        }
        return { elementId: element.id, newRoutingPoints: route };
      }
      exports.calcElementAndRoute = calcElementAndRoute;
      function calcRoute(element, routerRegistry, pointKinds = exports.ALL_ROUTING_POINTS, tolerance = Number.EPSILON) {
        const route = routerRegistry.get(element.routerKind).route(element);
        const calculatedRoute = [];
        for (const point of route) {
          if (pointKinds && !pointKinds.includes(point.kind)) {
            continue;
          }
          if (exports.ROUTING_POINT_KINDS.includes(point.kind) && calculatedRoute.find((calculatedPoint) => sprotty_1.Point.maxDistance(point, calculatedPoint) < tolerance)) {
            continue;
          }
          calculatedRoute.push(point);
        }
        return calculatedRoute;
      }
      exports.calcRoute = calcRoute;
      function getElementTypeId(input) {
        if (typeof input === "string") {
          return input;
        } else {
          return input.type;
        }
      }
      exports.getElementTypeId = getElementTypeId;
      function findTopLevelElementByFeature(element, predicate, skip = (_t3) => false) {
        let match;
        let current = element;
        while (current !== void 0) {
          if (!skip(current) && predicate(current)) {
            match = current;
          }
          if (current instanceof sprotty_1.GChildElement) {
            current = current.parent;
          } else {
            current = void 0;
          }
        }
        return match;
      }
      exports.findTopLevelElementByFeature = findTopLevelElementByFeature;
      function calculateDeltaBetweenPoints(target, source, element) {
        const delta = sprotty_1.Point.subtract(target, source);
        const zoom = (0, sprotty_1.getZoom)(element);
        const adaptedDelta = sprotty_1.Point.divideScalar(delta, zoom);
        return adaptedDelta;
      }
      exports.calculateDeltaBetweenPoints = calculateDeltaBetweenPoints;
      function isVisibleOnCanvas(model) {
        const modelBounds = (0, sprotty_1.getAbsoluteBounds)(model);
        const canvasBounds = model.root.canvasBounds;
        return modelBounds.x <= canvasBounds.width && modelBounds.x + modelBounds.width >= 0 && modelBounds.y <= canvasBounds.height && modelBounds.y + modelBounds.height >= 0;
      }
      exports.isVisibleOnCanvas = isVisibleOnCanvas;
      function getDescendantIds(element, skip) {
        if (!element || (skip === null || skip === void 0 ? void 0 : skip(element))) {
          return [];
        }
        const parent = element;
        const ids = [parent.id];
        if (parent instanceof sprotty_1.GParentElement) {
          ids.push(...parent.children.flatMap((child) => getDescendantIds(child, skip)));
        }
        return ids;
      }
      exports.getDescendantIds = getDescendantIds;
      function isNotDescendantOfAnyElement(elements) {
        const elementsSet = new Set(elements);
        return (element) => {
          let parent = element;
          while (parent instanceof sprotty_1.GChildElement) {
            parent = parent.parent;
            if (elementsSet.has(parent)) {
              return false;
            }
          }
          return true;
        };
      }
      exports.isNotDescendantOfAnyElement = isNotDescendantOfAnyElement;
      function removeDescendants(elements) {
        return elements.filter(isNotDescendantOfAnyElement(elements));
      }
      exports.removeDescendants = removeDescendants;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/selection-service.js
  var require_selection_service = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/selection-service.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectFeedbackAction = exports.SelectAllCommand = exports.SelectCommand = exports.SelectionService = exports.ISelectionListener = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var gmodel_util_1 = require_gmodel_util();
      var ISelectionListener;
      (function(ISelectionListener2) {
        function is(object) {
          return sprotty_1.AnyObject.is(object) && (0, sprotty_1.hasFunctionProp)(object, "selectionChanged");
        }
        ISelectionListener2.is = is;
      })(ISelectionListener || (exports.ISelectionListener = ISelectionListener = {}));
      var SelectionService = class SelectionService {
        constructor() {
          this.selectedElementIDs = /* @__PURE__ */ new Set();
          this.toDispose = new sprotty_1.DisposableCollection();
          this.onSelectionChangedEmitter = new sprotty_1.Emitter();
        }
        initialize() {
          this.toDispose.push(this.onSelectionChangedEmitter);
        }
        preLoadDiagram() {
          this.lazyInjector.getAll(sprotty_1.TYPES.ISelectionListener).forEach((listener) => this.addListener(listener));
        }
        dispose() {
          this.toDispose.dispose();
        }
        get onSelectionChanged() {
          return this.onSelectionChangedEmitter.event;
        }
        addListener(listener) {
          return this.onSelectionChanged((change) => listener.selectionChanged(change.root, change.selectedElements, change.deselectedElements));
        }
        modelRootChanged(root) {
          this.updateSelection(root, [], []);
        }
        updateSelection(newRoot, select, deselect) {
          if (newRoot === void 0 && select.length === 0 && deselect.length === 0) {
            return;
          }
          const prevRoot = this.root;
          const prevSelectedElementIDs = new Set(this.selectedElementIDs);
          this.root = newRoot;
          const toSelect = [...select].filter((selectId) => deselect.indexOf(selectId) === -1);
          const toDeselect = [...deselect].filter((deselectId) => select.indexOf(deselectId) === -1 && this.selectedElementIDs.has(deselectId));
          toDeselect.forEach((toDeselectId) => this.selectedElementIDs.delete(toDeselectId));
          toSelect.forEach((toSelectId) => this.selectedElementIDs.add(toSelectId));
          const deselectedElementIDs = new Set(toDeselect);
          for (const id of this.selectedElementIDs) {
            const element = newRoot.index.getById(id);
            if (element === void 0) {
              this.selectedElementIDs.delete(id);
              if (prevRoot === null || prevRoot === void 0 ? void 0 : prevRoot.index.getById(id)) {
                deselectedElementIDs.add(id);
              }
            }
          }
          const selectionChanged = prevSelectedElementIDs.size !== this.selectedElementIDs.size || ![...prevSelectedElementIDs].every((value) => this.selectedElementIDs.has(value));
          if (selectionChanged) {
            this.dispatchFeedback([
              SelectFeedbackAction.create({
                selectedElementsIDs: [...this.selectedElementIDs],
                deselectedElementsIDs: [...deselectedElementIDs]
              })
            ]);
            this.notifyListeners(this.root, this.selectedElementIDs, deselectedElementIDs);
          }
        }
        dispatchFeedback(actions) {
          this.feedbackDispatcher.registerFeedback(this, actions);
        }
        notifyListeners(root, selectedElementIDs, deselectedElementIDs) {
          this.onSelectionChangedEmitter.fire({
            root,
            selectedElements: Array.from(selectedElementIDs),
            deselectedElements: Array.from(deselectedElementIDs)
          });
        }
        getModelRoot() {
          return this.root;
        }
        getSelectedElements() {
          return !this.root ? [] : (0, gmodel_util_1.getElements)(this.root.index, Array.from(this.selectedElementIDs), sprotty_1.isSelectable);
        }
        /**
         * QUERY METHODS
         */
        getSelectedElementIDs() {
          return [...this.selectedElementIDs];
        }
        hasSelectedElements() {
          return this.selectedElementIDs.size > 0;
        }
        isSingleSelection() {
          return this.selectedElementIDs.size === 1;
        }
        isMultiSelection() {
          return this.selectedElementIDs.size > 1;
        }
      };
      exports.SelectionService = SelectionService;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], SelectionService.prototype, "feedbackDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.LazyInjector),
        __metadata("design:type", Object)
      ], SelectionService.prototype, "lazyInjector", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], SelectionService.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], SelectionService.prototype, "initialize", null);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], SelectionService.prototype, "dispose", null);
      exports.SelectionService = SelectionService = __decorate([
        (0, inversify_1.injectable)()
      ], SelectionService);
      var SelectCommand = class SelectCommand extends sprotty_1.Command {
        constructor(action, selectionService) {
          super();
          this.action = action;
          this.selectionService = selectionService;
          this.selected = [];
          this.deselected = [];
        }
        execute(context) {
          const model = context.root;
          const selectionGuard = (element) => element instanceof sprotty_1.GChildElement && (0, sprotty_1.isSelectable)(element);
          const selectedElements = (0, gmodel_util_1.getElements)(model.index, this.action.selectedElementsIDs, selectionGuard);
          const deselectedElements = this.action.deselectAll ? this.selectionService.getSelectedElements() : (0, gmodel_util_1.getElements)(model.index, this.action.deselectedElementsIDs, selectionGuard);
          this.selectionService.updateSelection(model, (0, sprotty_1.pluck)(selectedElements, "id"), (0, sprotty_1.pluck)(deselectedElements, "id"));
          return model;
        }
        // Basically no-op since client-side undo is not supported in GLSP.
        undo(context) {
          return context.root;
        }
        // Basically no-op since client-side redo is not supported in GLSP.
        redo(context) {
          return context.root;
        }
      };
      exports.SelectCommand = SelectCommand;
      SelectCommand.KIND = sprotty_1.SprottySelectCommand.KIND;
      exports.SelectCommand = SelectCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __param(1, (0, inversify_1.inject)(SelectionService)),
        __metadata("design:paramtypes", [Object, SelectionService])
      ], SelectCommand);
      var SelectAllCommand = class SelectAllCommand extends sprotty_1.Command {
        constructor(action, selectionService) {
          super();
          this.action = action;
          this.selectionService = selectionService;
          this.previousSelection = /* @__PURE__ */ new Map();
        }
        execute(context) {
          const model = context.root;
          const selectionGuard = (element) => element instanceof sprotty_1.GChildElement && (0, sprotty_1.isSelectable)(element);
          const selectables = (0, gmodel_util_1.getMatchingElements)(model.index, selectionGuard);
          const selectableIds = (0, sprotty_1.pluck)(selectables, "id");
          if (this.action.select) {
            this.selectionService.updateSelection(model, selectableIds, []);
          } else {
            this.selectionService.updateSelection(model, [], selectableIds);
          }
          return model;
        }
        // Basically no-op since client-side undo is not supported in GLSP.
        undo(context) {
          return context.root;
        }
        // Basically no-op since client-side redo is not supported in GLSP.
        redo(context) {
          return context.root;
        }
      };
      exports.SelectAllCommand = SelectAllCommand;
      SelectAllCommand.KIND = sprotty_1.SprottySelectAllCommand.KIND;
      exports.SelectAllCommand = SelectAllCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __param(1, (0, inversify_1.inject)(SelectionService)),
        __metadata("design:paramtypes", [Object, SelectionService])
      ], SelectAllCommand);
      var SelectFeedbackAction;
      (function(SelectFeedbackAction2) {
        SelectFeedbackAction2.KIND = "selectFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, SelectFeedbackAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "selectedElementsIDs") && (0, sprotty_1.hasArrayProp)(object, "deselectedElementsIDs");
        }
        SelectFeedbackAction2.is = is;
        function create(options) {
          return { ...sprotty_1.SelectAction.create(options), kind: SelectFeedbackAction2.KIND };
        }
        SelectFeedbackAction2.create = create;
        function addSelection(selectedElementsIDs) {
          return { ...sprotty_1.SelectAction.addSelection(selectedElementsIDs), kind: SelectFeedbackAction2.KIND };
        }
        SelectFeedbackAction2.addSelection = addSelection;
        function removeSelection(deselectedElementsIDs) {
          return { ...sprotty_1.SelectAction.removeSelection(deselectedElementsIDs), kind: SelectFeedbackAction2.KIND };
        }
        SelectFeedbackAction2.removeSelection = removeSelection;
        function setSelection(selectedElementsIDs) {
          return { ...sprotty_1.SelectAction.setSelection(selectedElementsIDs), kind: SelectFeedbackAction2.KIND };
        }
        SelectFeedbackAction2.setSelection = setSelection;
      })(SelectFeedbackAction || (exports.SelectFeedbackAction = SelectFeedbackAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/editor-context-service.js
  var require_editor_context_service = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/editor-context-service.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EditorContextService = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var focus_tracker_1 = require_focus_tracker();
      var selection_service_1 = require_selection_service();
      var EditorContextService2 = class EditorContextService {
        constructor() {
          this.onEditModeChangedEmitter = new sprotty_1.Emitter();
          this.onDirtyStateChangedEmitter = new sprotty_1.Emitter();
          this.onModelRootChangedEmitter = new sprotty_1.Emitter();
          this.toDispose = new sprotty_1.DisposableCollection();
        }
        /**
         * Event that is fired when the edit mode of the diagram changes i.e. after a {@link SetEditModeAction} has been handled.
         */
        get onEditModeChanged() {
          return this.onEditModeChangedEmitter.event;
        }
        /**
         * Event that is fired when the dirty state of the diagram changes i.e. after a {@link SetDirtyStateAction} has been handled.
         */
        get onDirtyStateChanged() {
          return this.onDirtyStateChangedEmitter.event;
        }
        get onModelRootChanged() {
          return this.onModelRootChangedEmitter.event;
        }
        /**
         * Event that is fired when the focus state of the diagram changes i.e. after a {@link FocusStateChangedAction} has been handled
         * by the {@link FocusTracker}.
         */
        get onFocusChanged() {
          return this.focusTracker.onFocusChanged;
        }
        /**
         * Event that is fired when the selection of the diagram changes i.e. a selection change has been handled
         * by the {@link SelectionService}.
         */
        get onSelectionChanged() {
          return this.selectionService.onSelectionChanged;
        }
        initialize() {
          var _a4;
          this._editMode = (_a4 = this.diagramOptions.editMode) !== null && _a4 !== void 0 ? _a4 : sprotty_1.EditMode.EDITABLE;
          this.toDispose.push(this.onEditModeChangedEmitter, this.onDirtyStateChangedEmitter);
        }
        preLoadDiagram() {
          this.lazyInjector.getAll(sprotty_1.TYPES.IGModelRootListener).forEach((listener) => {
            this.onModelRootChanged((event) => listener.modelRootChanged(event));
          });
          this.lazyInjector.getAll(sprotty_1.TYPES.IEditModeListener).forEach((listener) => {
            this.onEditModeChanged((event) => listener.editModeChanged(event.newValue, event.oldValue));
          });
        }
        dispose() {
          this.toDispose.dispose();
        }
        get(args) {
          return {
            selectedElementIds: Array.from(this.selectionService.getSelectedElementIDs()),
            lastMousePosition: this.mousePositionTracker.lastPositionOnDiagram,
            args
          };
        }
        getWithSelection(selectedElementIds, args) {
          return {
            selectedElementIds,
            lastMousePosition: this.mousePositionTracker.lastPositionOnDiagram,
            args
          };
        }
        /**
         * Notifies the service about a model root change. This method should not be called
         * directly. It is called by the `CommandStack` after a model update has been processed.
         * @throws an error if the notifier is not a `CommandStack`
         * @param root the new model root
         * @param notifier the object that triggered the model root change
         */
        notifyModelRootChanged(root, notifier) {
          if (!(notifier instanceof sprotty_1.CommandStack)) {
            throw new Error("Invalid model root change notification. Notifier is not an instance of `CommandStack`.");
          }
          this._modelRoot = root;
          this.onModelRootChangedEmitter.fire(root);
        }
        handle(action) {
          if (sprotty_1.SetEditModeAction.is(action)) {
            this.handleSetEditModeAction(action);
          } else if (sprotty_1.SetDirtyStateAction.is(action)) {
            this.handleSetDirtyStateAction(action);
          }
        }
        handleSetEditModeAction(action) {
          const oldValue = this._editMode;
          this._editMode = action.editMode;
          this.onEditModeChangedEmitter.fire({ newValue: this.editMode, oldValue });
        }
        handleSetDirtyStateAction(action) {
          if (action.isDirty !== this._isDirty) {
            this._isDirty = action.isDirty;
            this.onDirtyStateChangedEmitter.fire(action);
          }
        }
        get sourceUri() {
          return this.diagramOptions.sourceUri;
        }
        get editMode() {
          return this._editMode;
        }
        get diagramType() {
          return this.diagramOptions.diagramType;
        }
        get clientId() {
          return this.diagramOptions.clientId;
        }
        get modelRoot() {
          if (!this._modelRoot) {
            throw new Error("Model root not available yet");
          }
          return this._modelRoot;
        }
        get selectedElements() {
          return this.selectionService.getSelectedElements();
        }
        get isReadonly() {
          return this.editMode === sprotty_1.EditMode.READONLY;
        }
        get isDirty() {
          return this._isDirty;
        }
      };
      exports.EditorContextService = EditorContextService2;
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], EditorContextService2.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.MousePositionTracker),
        __metadata("design:type", sprotty_1.MousePositionTracker)
      ], EditorContextService2.prototype, "mousePositionTracker", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.LazyInjector),
        __metadata("design:type", Object)
      ], EditorContextService2.prototype, "lazyInjector", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], EditorContextService2.prototype, "diagramOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], EditorContextService2.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(focus_tracker_1.FocusTracker),
        __metadata("design:type", focus_tracker_1.FocusTracker)
      ], EditorContextService2.prototype, "focusTracker", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], EditorContextService2.prototype, "initialize", null);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], EditorContextService2.prototype, "dispose", null);
      exports.EditorContextService = EditorContextService2 = __decorate([
        (0, inversify_1.injectable)()
      ], EditorContextService2);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/command-stack.js
  var require_command_stack2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/command-stack.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPCommandStack = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var GLSPCommandStack = class GLSPCommandStack extends sprotty_1.CommandStack {
        constructor() {
          super(...arguments);
          this.toDispose = new sprotty_1.DisposableCollection();
        }
        dispose() {
          this.toDispose.dispose();
        }
        // Use lazyInjector to resolve circular dependency
        //  GLSPActionDispatcher --> GLSPCommandStack --> EditorContextService --> GLSPActionDispatcher
        get editorContext() {
          return this.lazyInjector.get(editor_context_service_1.EditorContextService);
        }
        /**
         * @deprecated Use the `EditorContext.onModelRootChanged` event instead
         */
        get onModelRootChanged() {
          return this.editorContext.onModelRootChanged;
        }
        /**
         * Client-side undo/redo is not supported in GLSP. The server is responsible for handling undo/redo requests.
         * If this method get called it's probably a mistake and a warning is logged
         */
        undo() {
          this.logger.warn(this, "GLSPCommandStack.undo() was called. This should never happen as the GLSP server is responsible for handling undo requests");
          return this.currentModel;
        }
        /**
         * Client-side undo/redo is not supported in GLSP. The server is responsible for handling undo/redo requests.
         * If this method get called it's probably a mistake and a warning is logged
         */
        redo() {
          this.logger.warn(this, "GLSPCommandStack.redo() was called. This should never happen as the GLSP server is responsible for handling redo requests");
          return this.currentModel;
        }
        /**
         * Client-side undo/redo is not supported in GLSP.
         * To avoid unnecessary infraction with the command stack (pushing/merging/popping commands)
         * related methods are overridden to no-ops.
         */
        pushToUndoStack(command) {
        }
        /**
         * Client-side undo/redo is not supported in GLSP.
         * To avoid unnecessary infraction with the command stack (pushing/merging/popping commands)
         * related methods are overridden to no-ops.
         */
        mergeOrPush(command, context) {
        }
        async execute(command) {
          const result = await super.execute(command);
          if (command instanceof sprotty_1.SetModelCommand || command instanceof sprotty_1.UpdateModelCommand) {
            this.notifyListeners(result);
          }
          return result;
        }
        notifyListeners(root) {
          this.editorContext.notifyModelRootChanged(root, this);
        }
      };
      exports.GLSPCommandStack = GLSPCommandStack;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.LazyInjector),
        __metadata("design:type", Object)
      ], GLSPCommandStack.prototype, "lazyInjector", void 0);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], GLSPCommandStack.prototype, "dispose", null);
      exports.GLSPCommandStack = GLSPCommandStack = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPCommandStack);
    }
  });

  // node_modules/@vscode/codicons/dist/codicon.css
  var require_codicon2 = __commonJS({
    "node_modules/@vscode/codicons/dist/codicon.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/css/glsp-sprotty.css
  var require_glsp_sprotty = __commonJS({
    "node_modules/@eclipse-glsp/client/css/glsp-sprotty.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/ranked.js
  var require_ranked = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/ranked.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Ranked = void 0;
      var sprotty_1 = require_lib4();
      var Ranked;
      (function(Ranked2) {
        Ranked2.DEFAULT_RANK = 0;
        function is(object) {
          return sprotty_1.AnyObject.is(object) && (0, sprotty_1.hasNumberProp)(object, "rank");
        }
        Ranked2.is = is;
        function getRank(object) {
          return is(object) ? object.rank : Ranked2.DEFAULT_RANK;
        }
        Ranked2.getRank = getRank;
        Ranked2.sortAsc = (left, right) => getRank(left) - getRank(right);
        Ranked2.sortDesc = (left, right) => getRank(right) - getRank(left);
        Ranked2.sort = Ranked2.sortAsc;
      })(Ranked || (exports.Ranked = Ranked = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-command.js
  var require_feedback_command = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-command.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFeedbackRank = exports.FeedbackCommand = void 0;
      var sprotty_1 = require_lib4();
      var ranked_1 = require_ranked();
      var FeedbackCommand = class extends sprotty_1.Command {
        constructor() {
          super(...arguments);
          this.priority = 0;
          this.rank = this.priority ? -this.priority : ranked_1.Ranked.DEFAULT_RANK;
        }
        undo(context) {
          return context.root;
        }
        redo(context) {
          return context.root;
        }
      };
      exports.FeedbackCommand = FeedbackCommand;
      function getFeedbackRank(command) {
        var _a4;
        const feedbackCommand = command;
        return (feedbackCommand === null || feedbackCommand === void 0 ? void 0 : feedbackCommand.priority) ? -feedbackCommand.priority : (_a4 = feedbackCommand.rank) !== null && _a4 !== void 0 ? _a4 : ranked_1.Ranked.DEFAULT_RANK;
      }
      exports.getFeedbackRank = getFeedbackRank;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/css-feedback.js
  var require_css_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/css-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toggleCssClasses = exports.deleteCssClasses = exports.applyCssClasses = exports.cursorFeedbackAction = exports.CursorCSS = exports.CSS_HIDDEN = exports.CSS_GHOST_ELEMENT = exports.ModifyCssFeedbackCommand = exports.ModifyCSSFeedbackAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var gmodel_util_1 = require_gmodel_util();
      var feedback_command_1 = require_feedback_command();
      var ModifyCSSFeedbackAction;
      (function(ModifyCSSFeedbackAction2) {
        ModifyCSSFeedbackAction2.KIND = "modifyCSSFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ModifyCSSFeedbackAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "elementIds");
        }
        ModifyCSSFeedbackAction2.is = is;
        function create(options) {
          const { elements, ...rest } = options;
          const elementIds = elements ? elements.map((element) => typeof element === "string" ? element : element.id) : void 0;
          return {
            kind: ModifyCSSFeedbackAction2.KIND,
            elementIds,
            ...rest
          };
        }
        ModifyCSSFeedbackAction2.create = create;
      })(ModifyCSSFeedbackAction || (exports.ModifyCSSFeedbackAction = ModifyCSSFeedbackAction = {}));
      var ModifyCssFeedbackCommand = class ModifyCssFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const elements = this.action.elementIds ? (0, gmodel_util_1.getElements)(context.root.index, this.action.elementIds) : [context.root];
          elements.forEach((e2) => {
            if (this.action.remove) {
              (0, gmodel_util_1.removeCssClasses)(e2, this.action.remove);
            }
            if (this.action.add) {
              (0, gmodel_util_1.addCssClasses)(e2, this.action.add);
            }
          });
          return context.root;
        }
      };
      exports.ModifyCssFeedbackCommand = ModifyCssFeedbackCommand;
      ModifyCssFeedbackCommand.KIND = ModifyCSSFeedbackAction.KIND;
      exports.ModifyCssFeedbackCommand = ModifyCssFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ModifyCssFeedbackCommand);
      exports.CSS_GHOST_ELEMENT = "ghost-element";
      exports.CSS_HIDDEN = "hidden";
      var CursorCSS;
      (function(CursorCSS2) {
        CursorCSS2["DEFAULT"] = "default-mode";
        CursorCSS2["OVERLAP_FORBIDDEN"] = "overlap-forbidden-mode";
        CursorCSS2["NODE_CREATION"] = "node-creation-mode";
        CursorCSS2["EDGE_CREATION_SOURCE"] = "edge-creation-select-source-mode";
        CursorCSS2["EDGE_CREATION_TARGET"] = "edge-creation-select-target-mode";
        CursorCSS2["EDGE_RECONNECT"] = "edge-reconnect-select-target-mode";
        CursorCSS2["EDGE_CHECK_PENDING"] = "edge-check-pending-mode";
        CursorCSS2["OPERATION_NOT_ALLOWED"] = "edge-modification-not-allowed-mode";
        CursorCSS2["ELEMENT_DELETION"] = "element-deletion-mode";
        CursorCSS2["RESIZE_NESW"] = "resize-nesw-mode";
        CursorCSS2["RESIZE_NWSE"] = "resize-nwse-mode";
        CursorCSS2["RESIZE_NW"] = "resize-nw-mode";
        CursorCSS2["RESIZE_N"] = "resize-n-mode";
        CursorCSS2["RESIZE_NE"] = "resize-ne-mode";
        CursorCSS2["RESIZE_E"] = "resize-e-mode";
        CursorCSS2["RESIZE_SE"] = "resize-se-mode";
        CursorCSS2["RESIZE_S"] = "resize-s-mode";
        CursorCSS2["RESIZE_SW"] = "resize-sw-mode";
        CursorCSS2["RESIZE_W"] = "resize-w-mode";
        CursorCSS2["MOVE"] = "move-mode";
        CursorCSS2["MARQUEE"] = "marquee-mode";
      })(CursorCSS || (exports.CursorCSS = CursorCSS = {}));
      function cursorFeedbackAction(cursorCss) {
        const add = [];
        if (cursorCss) {
          add.push(cursorCss);
        }
        return ModifyCSSFeedbackAction.create({ add, remove: Object.values(CursorCSS) });
      }
      exports.cursorFeedbackAction = cursorFeedbackAction;
      function applyCssClasses(element, ...add) {
        return ModifyCSSFeedbackAction.create({ elements: [element], add });
      }
      exports.applyCssClasses = applyCssClasses;
      function deleteCssClasses(element, ...remove) {
        return ModifyCSSFeedbackAction.create({ elements: [element], remove });
      }
      exports.deleteCssClasses = deleteCssClasses;
      function toggleCssClasses(element, add, ...cssClasses) {
        return add ? applyCssClasses(element, ...cssClasses) : deleteCssClasses(element, ...cssClasses);
      }
      exports.toggleCssClasses = toggleCssClasses;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-emitter.js
  var require_feedback_emitter = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-emitter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackEmitter = void 0;
      var sprotty_1 = require_lib4();
      var idCounter = 0;
      var FeedbackEmitter = class {
        constructor(feedbackDispatcher) {
          this.feedbackDispatcher = feedbackDispatcher;
          this.id = idCounter++;
          this.feedbackActions = [];
          this.cleanupActions = [];
        }
        /**
         * Adds an action as part of this emitters feedback. Please note that the action is only applied as feedback
         * once the {@link submit} method is called.
         *
         * @param action feedback action
         * @param cleanupAction action that undoes the feedback action. This is only triggered when {@link revert} or {@link dispose} is called.
         */
        add(action, cleanupAction) {
          if (!action && !cleanupAction) {
            return this;
          }
          const idx = this.feedbackActions.length;
          this.feedbackActions[idx] = action;
          if (cleanupAction) {
            this.cleanupActions[idx] = cleanupAction;
          }
          return this;
        }
        /**
         * Merges the feedback of another emitter into this emitter.
         *
         * @param feedback feedback to merge
         */
        merge(feedback) {
          this.feedbackActions.push(...feedback.feedbackActions);
          this.cleanupActions.push(...feedback.cleanupActions);
          return this;
        }
        /**
         * Removes the action as part of this emitters feedback. If the action cannot be found, this is a no-op.
         * Please note that this also removed the corresponding cleanup action.
         * If the feedback has already been submitted as part of the {@link submit} method, the whole feedback must be de-registered
         * or a new feedback without the given action needs to be registered.
         *
         * @param action feedback action
         */
        remove(action) {
          const idx = this.feedbackActions.indexOf(action);
          if (idx >= 0) {
            this.feedbackActions.splice(idx, 1);
            this.cleanupActions.splice(idx, 1);
          }
          return this;
        }
        /**
         * Clears any, not yet registered feedback actions and their corresponding cleanup actions.
         */
        clear() {
          this.feedbackActions = [];
          this.cleanupActions = [];
          return this;
        }
        /**
         * Registers any pending actions as feedback. Any previously submitted feedback becomes invalid.
         */
        submit() {
          const actions = (0, sprotty_1.arrayOf)(...this.feedbackActions);
          const cleanupActions = (0, sprotty_1.arrayOf)(...this.cleanupActions);
          if (actions.length > 0 || cleanupActions.length > 0) {
            this.deregistration = this.feedbackDispatcher.registerFeedback(this, actions, () => cleanupActions.flatMap(sprotty_1.MaybeActions.asArray));
            this.clear();
          }
          return this;
        }
        /**
         * Removes the registered feedback WITHOUT calling any potential cleanup actions
         * Any pending actions can still be registerd with the {@link submit} method.
         */
        discard() {
          this.feedbackDispatcher.deregisterFeedback(this);
          this.deregistration = void 0;
          return this;
        }
        /**
         * Removes the registered feedback and calls the registered cleanup actions.
         * Any pending actions can still be registerd with the {@link submit} method.
         */
        revert() {
          var _a4;
          (_a4 = this.deregistration) === null || _a4 === void 0 ? void 0 : _a4.dispose();
          this.deregistration = void 0;
          return this;
        }
        /**
         * Disposes any registered feedback and any pending, not yet registered feedback actions.
         */
        dispose() {
          this.revert();
          this.clear();
          return this;
        }
      };
      exports.FeedbackEmitter = FeedbackEmitter;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-action-dispatcher.js
  var require_feedback_action_dispatcher = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/feedback-action-dispatcher.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackActionDispatcher = exports.feedbackFeature = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var feedback_command_1 = require_feedback_command();
      var feedback_emitter_1 = require_feedback_emitter();
      exports.feedbackFeature = Symbol("feedbackFeature");
      var FeedbackActionDispatcher = class FeedbackActionDispatcher {
        constructor() {
          this.registeredFeedback = /* @__PURE__ */ new Map();
          this.isDisposed = false;
        }
        registerFeedback(feedbackEmitter, feedbackActions, cleanupActions) {
          if (feedbackEmitter instanceof sprotty_1.GModelElement) {
            this.logger.log(
              this,
              // eslint-disable-next-line max-len
              "GModelElements as feedback emitters are discouraged, as they usually change between model updates and are considered unstable."
            );
          }
          if (feedbackActions.length > 0) {
            this.registeredFeedback.set(feedbackEmitter, feedbackActions);
            this.dispatchFeedback(feedbackActions, feedbackEmitter);
          }
          return sprotty_1.Disposable.create(() => this.deregisterFeedback(feedbackEmitter, cleanupActions));
        }
        deregisterFeedback(feedbackEmitter, cleanupActions) {
          this.registeredFeedback.delete(feedbackEmitter);
          const actions = sprotty_1.MaybeActions.asArray(cleanupActions);
          if (actions.length > 0) {
            this.dispatchFeedback(actions, feedbackEmitter);
          }
        }
        getRegisteredFeedback() {
          const result = [];
          this.registeredFeedback.forEach((actions) => result.push(...actions));
          return result;
        }
        getRegisteredFeedbackEmitters(action) {
          const result = [];
          this.registeredFeedback.forEach((actions, emitter) => {
            if (actions.includes(action)) {
              result.push(emitter);
            }
          });
          return result;
        }
        getFeedbackCommands() {
          return this.getRegisteredFeedback().flatMap((action) => this.actionToCommands(action)).sort((left, right) => (0, feedback_command_1.getFeedbackRank)(left) - (0, feedback_command_1.getFeedbackRank)(right));
        }
        async applyFeedbackCommands(context) {
          var _a4;
          const feedbackCommands = (_a4 = this.getFeedbackCommands()) !== null && _a4 !== void 0 ? _a4 : [];
          if ((feedbackCommands === null || feedbackCommands === void 0 ? void 0 : feedbackCommands.length) > 0) {
            const results = feedbackCommands.map((command) => command.execute(context));
            await Promise.all(results);
          }
        }
        actionToCommands(action) {
          var _a4;
          return (_a4 = this.actionHandlerRegistry.get(action.kind).filter((0, sprotty_1.toTypeGuard)(sprotty_1.CommandActionHandler)).map((handler) => handler.handle(action))) !== null && _a4 !== void 0 ? _a4 : [];
        }
        createEmitter() {
          return new feedback_emitter_1.FeedbackEmitter(this);
        }
        async dispatchFeedback(actions, feedbackEmitter) {
          try {
            if (this.isDisposed) {
              return;
            }
            await this.actionDispatcher.dispatchAll(actions);
            this.logger.info(this, `Dispatched feedback actions for ${feedbackEmitter}`);
          } catch (reason) {
            this.logger.error(this, "Failed to dispatch feedback actions", reason);
          }
        }
        dispose() {
          this.registeredFeedback.clear();
          this.isDisposed = true;
        }
      };
      exports.FeedbackActionDispatcher = FeedbackActionDispatcher;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], FeedbackActionDispatcher.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], FeedbackActionDispatcher.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.ActionHandlerRegistry),
        __metadata("design:type", sprotty_1.ActionHandlerRegistry)
      ], FeedbackActionDispatcher.prototype, "actionHandlerRegistry", void 0);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], FeedbackActionDispatcher.prototype, "dispose", null);
      exports.FeedbackActionDispatcher = FeedbackActionDispatcher = __decorate([
        (0, inversify_1.injectable)()
      ], FeedbackActionDispatcher);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/set-model-command.js
  var require_set_model_command = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/set-model-command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackAwareSetModelCommand = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var FeedbackAwareSetModelCommand = class FeedbackAwareSetModelCommand extends sprotty_1.SetModelCommand {
        constructor(action) {
          super(action);
        }
        execute(context) {
          const root = super.execute(context);
          this.applyFeedback(root, context);
          return root;
        }
        applyFeedback(newRoot, context) {
          var _a4;
          const tempContext = { ...context, root: newRoot };
          (_a4 = this.feedbackActionDispatcher) === null || _a4 === void 0 ? void 0 : _a4.applyFeedbackCommands(tempContext);
        }
      };
      exports.FeedbackAwareSetModelCommand = FeedbackAwareSetModelCommand;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], FeedbackAwareSetModelCommand.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], FeedbackAwareSetModelCommand.prototype, "feedbackActionDispatcher", void 0);
      exports.FeedbackAwareSetModelCommand = FeedbackAwareSetModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], FeedbackAwareSetModelCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/feedback/update-model-command.js
  var require_update_model_command = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/feedback/update-model-command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackAwareUpdateModelCommand = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var FeedbackAwareUpdateModelCommand = class FeedbackAwareUpdateModelCommand extends sprotty_1.UpdateModelCommand {
        constructor(action) {
          super({ animate: true, ...action });
        }
        performUpdate(oldRoot, newRoot, context) {
          var _a4;
          const tempContext = { ...context, root: newRoot };
          (_a4 = this.feedbackActionDispatcher) === null || _a4 === void 0 ? void 0 : _a4.applyFeedbackCommands(tempContext);
          return super.performUpdate(oldRoot, newRoot, context);
        }
        // Override the `createAnimations` implementation and remove the animation for edge morphing. Otherwise routing & reconnect
        // handles flicker after each server update.
        createAnimations(data, root, context) {
          const animations = super.createAnimations(data, root, context);
          return animations.filter((animation) => !(animation instanceof sprotty_1.MorphEdgesAnimation));
        }
      };
      exports.FeedbackAwareUpdateModelCommand = FeedbackAwareUpdateModelCommand;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], FeedbackAwareUpdateModelCommand.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], FeedbackAwareUpdateModelCommand.prototype, "feedbackActionDispatcher", void 0);
      exports.FeedbackAwareUpdateModelCommand = FeedbackAwareUpdateModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], FeedbackAwareUpdateModelCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/model/diagram-loader.js
  var require_diagram_loader = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/model/diagram-loader.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramLoader = exports.IDiagramStartup = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ranked_1 = require_ranked();
      var glsp_model_source_1 = require_glsp_model_source();
      var model_initialization_constraint_1 = require_model_initialization_constraint();
      var IDiagramStartup;
      (function(IDiagramStartup2) {
        function is(object) {
          return sprotty_1.AnyObject.is(object) && (0, sprotty_1.hasNumberProp)(object, "rank", true) && ("preLoadDiagram" in object || "preInitialize" in object || "preRequestModel" in object || "postRequestModel" in object || "postModelInitialization" in object);
        }
        IDiagramStartup2.is = is;
      })(IDiagramStartup || (exports.IDiagramStartup = IDiagramStartup = {}));
      var DiagramLoader = class DiagramLoader {
        get diagramStartups() {
          return this.lazyInjector.getAll(sprotty_1.TYPES.IDiagramStartup);
        }
        async load(options = {}) {
          var _a4, _b2, _c, _d;
          this.diagramStartups.sort(ranked_1.Ranked.sort);
          await this.invokeStartupHook("preLoadDiagram");
          const resolvedOptions = {
            requestModelOptions: {
              sourceUri: (_a4 = this.options.sourceUri) !== null && _a4 !== void 0 ? _a4 : "",
              diagramType: this.options.diagramType,
              ...options.requestModelOptions
            },
            initializeParameters: {
              applicationId: sprotty_1.ApplicationIdProvider.get(),
              protocolVersion: sprotty_1.GLSPClient.protocolVersion,
              ...options.initializeParameters
            },
            enableNotifications: (_b2 = options.enableNotifications) !== null && _b2 !== void 0 ? _b2 : true
          };
          await ((_d = (_c = this.actionDispatcher).initialize) === null || _d === void 0 ? void 0 : _d.call(_c));
          await this.invokeStartupHook("preInitialize");
          await this.initialize(resolvedOptions);
          await this.invokeStartupHook("preRequestModel");
          await this.requestModel(resolvedOptions);
          await this.invokeStartupHook("postRequestModel");
          await this.modelInitializationConstraint.onInitialized();
          await this.invokeStartupHook("postModelInitialization");
        }
        async invokeStartupHook(hook) {
          var _a4;
          for (const startup of this.diagramStartups) {
            try {
              await ((_a4 = startup[hook]) === null || _a4 === void 0 ? void 0 : _a4.call(startup));
            } catch (err) {
              console.error(`Error invoking diagram startup hook '${hook}':`, "\n", err);
            }
          }
        }
        async requestModel(options) {
          await this.actionDispatcher.dispatch(sprotty_1.RequestModelAction.create({ options: options.requestModelOptions, requestId: sprotty_1.RequestAction.generateRequestId() }));
        }
        async initialize(options) {
          if (options.enableNotifications) {
            await this.actionDispatcher.dispatch(sprotty_1.StatusAction.create("Initializing...", { severity: "INFO" }));
          }
          const glspClient = await this.options.glspClientProvider();
          await glspClient.start();
          if (!glspClient.initializeResult) {
            await glspClient.initializeServer(options.initializeParameters);
          }
          this.modelSource.configure(glspClient);
          if (options.enableNotifications) {
            this.actionDispatcher.dispatch(sprotty_1.StatusAction.create("", { severity: "NONE" }));
          }
        }
      };
      exports.DiagramLoader = DiagramLoader;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], DiagramLoader.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], DiagramLoader.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(glsp_model_source_1.GLSPModelSource),
        __metadata("design:type", glsp_model_source_1.GLSPModelSource)
      ], DiagramLoader.prototype, "modelSource", void 0);
      __decorate([
        (0, inversify_1.inject)(model_initialization_constraint_1.ModelInitializationConstraint),
        __metadata("design:type", model_initialization_constraint_1.ModelInitializationConstraint)
      ], DiagramLoader.prototype, "modelInitializationConstraint", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.LazyInjector),
        __metadata("design:type", Object)
      ], DiagramLoader.prototype, "lazyInjector", void 0);
      exports.DiagramLoader = DiagramLoader = __decorate([
        (0, inversify_1.injectable)()
      ], DiagramLoader);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/model/model-registry.js
  var require_model_registry = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/model/model-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GModelRegistry = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var args_feature_1 = require_args_feature();
      var GModelRegistry = class GModelRegistry extends sprotty_1.SModelRegistry {
        /* Overwrite the `register` method to only log an info message (instead of thrown an error) if
           an existing registration is overwritten */
        register(key, factory) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            console.log(`Key is already registered: ${key}.Factory for model element '${key}' will be overwritten.`);
            console.warn("Implicit overwriting by registering the same key twice is deprecated\n Use 'overrideModelElement()' instead of 'configureModelElement()' for explicit overwriting.");
          }
          this.elements.set(key, factory);
        }
        getDefaultFeatures(constr) {
          var _a4;
          const features = [...(_a4 = super.getDefaultFeatures(constr)) !== null && _a4 !== void 0 ? _a4 : []];
          if (!features.includes(args_feature_1.argsFeature)) {
            features.push(args_feature_1.argsFeature);
          }
          return features;
        }
      };
      exports.GModelRegistry = GModelRegistry;
      exports.GModelRegistry = GModelRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], GModelRegistry);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/mouse-position-tracker.js
  var require_mouse_position_tracker = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/mouse-position-tracker.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPMousePositionTracker = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ranked_1 = require_ranked();
      var GLSPMousePositionTracker = class GLSPMousePositionTracker extends sprotty_1.MousePositionTracker {
        constructor() {
          super(...arguments);
          this.rank = ranked_1.Ranked.DEFAULT_RANK - 200;
        }
        mouseMove(target, event) {
          const globalOrigin = target.root.canvasBounds;
          const clientToPosition = { x: event.clientX, y: event.clientY };
          const rootToPosition = sprotty_1.Point.subtract(clientToPosition, globalOrigin);
          const positionOnDiagram = target.root.parentToLocal(rootToPosition);
          this.lastPosition = positionOnDiagram;
          return [];
        }
      };
      exports.GLSPMousePositionTracker = GLSPMousePositionTracker;
      exports.GLSPMousePositionTracker = GLSPMousePositionTracker = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPMousePositionTracker);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/selection-clearing-mouse-listener.js
  var require_selection_clearing_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/selection-clearing-mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectionClearingMouseListener = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var SelectionClearingMouseListener = class SelectionClearingMouseListener extends sprotty_1.MouseListener {
        mouseDown(_target, event) {
          const selection = document.getSelection();
          if (selection === null) {
            return [];
          }
          selection.removeAllRanges();
          selection.addRange(document.createRange());
          return [];
        }
      };
      exports.SelectionClearingMouseListener = SelectionClearingMouseListener;
      exports.SelectionClearingMouseListener = SelectionClearingMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], SelectionClearingMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/shortcuts/shortcuts-manager.js
  var require_shortcuts_manager = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/shortcuts/shortcuts-manager.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShortcutManager = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ShortcutManager = class ShortcutManager {
        constructor() {
          this.registrations = /* @__PURE__ */ new Map();
          this.onDidChangeEmitter = new sprotty_1.Emitter();
          this.onDidChange = this.onDidChangeEmitter.event;
        }
        getShortcuts() {
          return this.registrations;
        }
        getRegistrations() {
          return Array.from(this.registrations.values()).flat();
        }
        register(token, shortcuts) {
          this.registrations.set(token, shortcuts);
          this.onDidChangeEmitter.fire(this.registrations);
          return sprotty_1.Disposable.create(() => {
            this.deregister(token);
          });
        }
        deregister(token) {
          this.registrations.delete(token);
          this.onDidChangeEmitter.fire(this.registrations);
        }
      };
      exports.ShortcutManager = ShortcutManager;
      exports.ShortcutManager = ShortcutManager = __decorate([
        (0, inversify_1.injectable)()
      ], ShortcutManager);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/tool-manager/tool.js
  var require_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/tool-manager/tool.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Tool = exports.EnableDefaultToolsAction = exports.EnableToolsAction = void 0;
      var sprotty_1 = require_lib4();
      var EnableToolsAction;
      (function(EnableToolsAction2) {
        EnableToolsAction2.KIND = "enable-tools";
        function is(object) {
          return sprotty_1.Action.hasKind(object, EnableToolsAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "toolIds");
        }
        EnableToolsAction2.is = is;
        function create(toolIds) {
          return {
            kind: EnableToolsAction2.KIND,
            toolIds
          };
        }
        EnableToolsAction2.create = create;
      })(EnableToolsAction || (exports.EnableToolsAction = EnableToolsAction = {}));
      var EnableDefaultToolsAction;
      (function(EnableDefaultToolsAction2) {
        EnableDefaultToolsAction2.KIND = "enable-default-tools";
        function is(object) {
          return sprotty_1.Action.hasKind(object, EnableDefaultToolsAction2.KIND);
        }
        EnableDefaultToolsAction2.is = is;
        function create() {
          return {
            kind: EnableDefaultToolsAction2.KIND
          };
        }
        EnableDefaultToolsAction2.create = create;
      })(EnableDefaultToolsAction || (exports.EnableDefaultToolsAction = EnableDefaultToolsAction = {}));
      var Tool;
      (function(Tool2) {
        function is(object) {
          return sprotty_1.AnyObject.is(object) && (0, sprotty_1.hasStringProp)(object, "id") && (0, sprotty_1.hasFunctionProp)(object, "enable") && (0, sprotty_1.hasFunctionProp)(object, "disable") && (0, sprotty_1.hasBooleanProp)(object, "isEditTool", true);
        }
        Tool2.is = is;
      })(Tool || (exports.Tool = Tool = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/tool-manager/tool-manager.js
  var require_tool_manager = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/tool-manager/tool-manager.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultToolsEnablingKeyListener = exports.ToolManagerActionHandler = exports.ToolManager = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var ranked_1 = require_ranked();
      var tool_1 = require_tool();
      var ToolManager = class ToolManager {
        constructor() {
          this.actives = [];
          this.tools = [];
          this.defaultTools = [];
          this._defaultToolsEnabled = false;
        }
        get defaultToolsEnabled() {
          return this._defaultToolsEnabled;
        }
        preLoadDiagram() {
          const tools = this.lazyInjector.getAll(sprotty_1.TYPES.ITool);
          const defaultTools = this.lazyInjector.getAll(sprotty_1.TYPES.IDefaultTool);
          this.registerTools(...tools);
          this.registerDefaultTools(...defaultTools);
          this.enableDefaultTools();
        }
        get managedTools() {
          return this.defaultTools.concat(this.tools);
        }
        get activeTools() {
          return this.actives;
        }
        get rank() {
          return ranked_1.Ranked.DEFAULT_RANK - 100;
        }
        registerDefaultTools(...tools) {
          (0, sprotty_1.distinctAdd)(this.defaultTools, ...tools);
        }
        registerTools(...tools) {
          (0, sprotty_1.distinctAdd)(this.tools, ...tools);
        }
        disableActiveTools() {
          this._defaultToolsEnabled = false;
          this.actives.forEach((tool) => tool.disable());
          this.actives.splice(0, this.actives.length);
        }
        enableDefaultTools() {
          if (this.defaultToolsEnabled) {
            return;
          }
          this.enable((0, sprotty_1.pluck)(this.defaultTools, "id"));
          this._defaultToolsEnabled = true;
        }
        enable(toolIds) {
          this.disableActiveTools();
          let tools = toolIds.map((id) => this.tool(id));
          if (this.editorContext && this.editorContext.isReadonly) {
            tools = tools.filter((tool) => !(tool === null || tool === void 0 ? void 0 : tool.isEditTool));
          }
          tools.forEach((tool) => {
            if (tool !== void 0) {
              tool.enable();
              this.actives.push(tool);
            }
          });
        }
        tool(toolId) {
          return this.managedTools.find((tool) => tool.id === toolId);
        }
        disableEditTools() {
          this.disableActiveTools();
          this.enable(this.defaultTools.filter((tool) => !tool.isEditTool).map((tool) => tool.id));
        }
        editModeChanged(newValue, oldValue) {
          if (oldValue === newValue) {
            return;
          }
          if (newValue === sprotty_1.EditMode.READONLY) {
            this.disableEditTools();
          } else if (newValue === sprotty_1.EditMode.EDITABLE) {
            this.enableDefaultTools();
          }
        }
      };
      exports.ToolManager = ToolManager;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ToolManager.prototype, "editorContext", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.LazyInjector),
        __metadata("design:type", Object)
      ], ToolManager.prototype, "lazyInjector", void 0);
      exports.ToolManager = ToolManager = __decorate([
        (0, inversify_1.injectable)()
      ], ToolManager);
      var ToolManagerActionHandler = class ToolManagerActionHandler {
        handle(action) {
          if (tool_1.EnableDefaultToolsAction.is(action)) {
            this.toolManager.enableDefaultTools();
          } else if (tool_1.EnableToolsAction.is(action)) {
            this.toolManager.enable(action.toolIds);
          }
        }
      };
      exports.ToolManagerActionHandler = ToolManagerActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IToolManager),
        __metadata("design:type", Object)
      ], ToolManagerActionHandler.prototype, "toolManager", void 0);
      exports.ToolManagerActionHandler = ToolManagerActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ToolManagerActionHandler);
      var DefaultToolsEnablingKeyListener = class DefaultToolsEnablingKeyListener extends sprotty_1.KeyListener {
        keyDown(element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            return [tool_1.EnableDefaultToolsAction.create()];
          }
          return [];
        }
      };
      exports.DefaultToolsEnablingKeyListener = DefaultToolsEnablingKeyListener;
      exports.DefaultToolsEnablingKeyListener = DefaultToolsEnablingKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], DefaultToolsEnablingKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/ui-extension/ui-extension-registry.js
  var require_ui_extension_registry2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/ui-extension/ui-extension-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPUIExtensionRegistry = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var GLSPUIExtensionRegistry = class GLSPUIExtensionRegistry extends sprotty_1.UIExtensionRegistry {
        constructor(extensions) {
          super(extensions);
        }
        preLoadDiagram() {
          this.lazyInjector.getAll(sprotty_1.TYPES.IUIExtension).forEach((extension) => this.register(extension.id(), extension));
        }
      };
      exports.GLSPUIExtensionRegistry = GLSPUIExtensionRegistry;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.LazyInjector),
        __metadata("design:type", Object)
      ], GLSPUIExtensionRegistry.prototype, "lazyInjector", void 0);
      exports.GLSPUIExtensionRegistry = GLSPUIExtensionRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.EmptyArray)),
        __metadata("design:paramtypes", [Array])
      ], GLSPUIExtensionRegistry);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/view/key-tool.js
  var require_key_tool2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/view/key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPKeyTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var GLSPKeyTool = class GLSPKeyTool extends sprotty_1.KeyTool {
        constructor(keyListeners) {
          super(keyListeners);
        }
        registerListener(keyListener) {
          super.register(keyListener);
          return sprotty_1.Disposable.create(() => this.deregister(keyListener));
        }
        preLoadDiagram() {
          this.lazyInjector.getAll(sprotty_1.TYPES.KeyListener).forEach((listener) => this.register(listener));
        }
      };
      exports.GLSPKeyTool = GLSPKeyTool;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.LazyInjector),
        __metadata("design:type", Object)
      ], GLSPKeyTool.prototype, "lazyInjector", void 0);
      exports.GLSPKeyTool = GLSPKeyTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.EmptyArray)),
        __metadata("design:paramtypes", [Array])
      ], GLSPKeyTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/view/mouse-tool.js
  var require_mouse_tool2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/view/mouse-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPMouseTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ranked_1 = require_ranked();
      var GLSPMouseTool = class GLSPMouseTool extends sprotty_1.MouseTool {
        constructor(mouseListeners) {
          super(mouseListeners);
        }
        preLoadDiagram() {
          this.lazyInjector.getAll(sprotty_1.TYPES.MouseListener).forEach((listener) => this.register(listener));
        }
        register(mouseListener) {
          super.register(mouseListener);
          this.rankedMouseListeners = groupBy(this.mouseListeners, (listener) => ranked_1.Ranked.getRank(listener));
        }
        registerListener(mouseListener) {
          this.register(mouseListener);
          return sprotty_1.Disposable.create(() => this.deregister(mouseListener));
        }
        deregister(mouseListener) {
          super.deregister(mouseListener);
          this.rankedMouseListeners = groupBy(this.mouseListeners, (listener) => ranked_1.Ranked.getRank(listener));
        }
        handleEvent(methodName, model, event) {
          this.focusOnMouseEvent(methodName, model);
          const element = this.getTargetElement(model, event);
          if (!element) {
            return;
          }
          this.notifyListenersByRank(element, methodName, event);
        }
        async notifyListenersByRank(element, methodName, event) {
          for (const rank of this.rankedMouseListeners) {
            await this.dispatchActions(rank[1], methodName, element, event);
          }
        }
        async dispatchActions(mouseListeners, methodName, element, event) {
          const actions = mouseListeners.map((listener) => listener[methodName](element, event)).reduce((a3, b3) => a3.concat(b3));
          if (actions.length > 0) {
            event.preventDefault();
            for (const actionOrPromise of actions) {
              if (sprotty_1.Action.is(actionOrPromise)) {
                await this.actionDispatcher.dispatch(actionOrPromise);
              } else {
                actionOrPromise.then((action) => {
                  this.actionDispatcher.dispatch(action);
                });
              }
            }
          }
        }
      };
      exports.GLSPMouseTool = GLSPMouseTool;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.LazyInjector),
        __metadata("design:type", Object)
      ], GLSPMouseTool.prototype, "lazyInjector", void 0);
      exports.GLSPMouseTool = GLSPMouseTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.EmptyArray)),
        __metadata("design:paramtypes", [Array])
      ], GLSPMouseTool);
      function groupBy(array, keyFunction) {
        const unsortedMap = array.reduce((result, item) => {
          const key = keyFunction(item);
          if (!result.has(key)) {
            result.set(key, [item]);
          } else {
            const entries = result.get(key);
            if (entries) {
              entries.push(item);
            }
          }
          return result;
        }, /* @__PURE__ */ new Map());
        return new Map([...unsortedMap.entries()].sort());
      }
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/view/view-registry.js
  var require_view_registry = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/view/view-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GViewRegistry = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var GViewRegistry = class GViewRegistry extends sprotty_1.ViewRegistry {
        /* Overwrite the `register` method to only log an info message (instead of thrown an error) if
           an existing registration is overwritten */
        register(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            console.log(`View instance for type '${key}' will be overwritten.`);
          }
          this.elements.set(key, instance);
        }
      };
      exports.GViewRegistry = GViewRegistry;
      exports.GViewRegistry = GViewRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], GViewRegistry);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/default.module.js
  var require_default_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/default.module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultModule = void 0;
      var sprotty_1 = require_lib4();
      require_codicon2();
      require_glsp_sprotty();
      var action_dispatcher_1 = require_action_dispatcher2();
      var action_handler_registry_1 = require_action_handler_registry();
      var command_stack_1 = require_command_stack2();
      var editor_context_service_1 = require_editor_context_service();
      var css_feedback_1 = require_css_feedback();
      var feedback_action_dispatcher_1 = require_feedback_action_dispatcher();
      var set_model_command_1 = require_set_model_command();
      var update_model_command_1 = require_update_model_command();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var focus_tracker_1 = require_focus_tracker();
      var diagram_loader_1 = require_diagram_loader();
      var glsp_model_source_1 = require_glsp_model_source();
      var model_initialization_constraint_1 = require_model_initialization_constraint();
      var model_registry_1 = require_model_registry();
      var mouse_position_tracker_1 = require_mouse_position_tracker();
      var selection_clearing_mouse_listener_1 = require_selection_clearing_mouse_listener();
      var selection_service_1 = require_selection_service();
      var shortcuts_manager_1 = require_shortcuts_manager();
      var tool_1 = require_tool();
      var tool_manager_1 = require_tool_manager();
      var ui_extension_registry_1 = require_ui_extension_registry2();
      var key_tool_1 = require_key_tool2();
      var mouse_tool_1 = require_mouse_tool2();
      var view_registry_1 = require_view_registry();
      exports.defaultModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind, ...rest) => {
        sprotty_1.sprottyDefaultModule.registry(bind, unbind, isBound, rebind, ...rest);
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindLazyInjector)(context);
        bind(editor_context_service_1.EditorContextService).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.IDiagramStartup).toService(editor_context_service_1.EditorContextService);
        bind(sprotty_1.TYPES.IEditorContextServiceProvider).toProvider((ctx) => async () => ctx.container.get(editor_context_service_1.EditorContextService));
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetEditModeAction.KIND, editor_context_service_1.EditorContextService);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetDirtyStateAction.KIND, editor_context_service_1.EditorContextService);
        bind(focus_tracker_1.FocusTracker).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.IDiagramStartup).toService(focus_tracker_1.FocusTracker);
        (0, sprotty_1.configureActionHandler)(context, focus_state_change_action_1.FocusStateChangedAction.KIND, focus_tracker_1.FocusTracker);
        bind(sprotty_1.TYPES.IFeedbackActionDispatcher).to(feedback_action_dispatcher_1.FeedbackActionDispatcher).inSingletonScope();
        (0, sprotty_1.configureCommand)(context, update_model_command_1.FeedbackAwareUpdateModelCommand);
        rebind(sprotty_1.SetModelCommand).to(set_model_command_1.FeedbackAwareSetModelCommand);
        bind(mouse_tool_1.GLSPMouseTool).toSelf().inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.MouseTool).toService(mouse_tool_1.GLSPMouseTool);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(mouse_tool_1.GLSPMouseTool);
        bind(mouse_position_tracker_1.GLSPMousePositionTracker).toSelf().inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.MousePositionTracker).toService(mouse_position_tracker_1.GLSPMousePositionTracker);
        bind(key_tool_1.GLSPKeyTool).toSelf().inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.KeyTool).toService(key_tool_1.GLSPKeyTool);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(key_tool_1.GLSPKeyTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, selection_clearing_mouse_listener_1.SelectionClearingMouseListener);
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.TYPES.ICommandStack).to(command_stack_1.GLSPCommandStack).inSingletonScope();
        bind(action_dispatcher_1.GLSPActionDispatcher).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.IGModelRootListener).toService(action_dispatcher_1.GLSPActionDispatcher);
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.TYPES.IActionDispatcher).toService(action_dispatcher_1.GLSPActionDispatcher);
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.ActionHandlerRegistry).to(action_handler_registry_1.GLSPActionHandlerRegistry).inSingletonScope();
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ModelSource, glsp_model_source_1.GLSPModelSource);
        bind(diagram_loader_1.DiagramLoader).toSelf().inSingletonScope();
        bind(model_initialization_constraint_1.ModelInitializationConstraint).to(model_initialization_constraint_1.DefaultModelInitializationConstraint).inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.TYPES.SModelRegistry).to(model_registry_1.GModelRegistry).inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.TYPES.ViewRegistry).to(view_registry_1.GViewRegistry).inSingletonScope();
        bind(selection_service_1.SelectionService).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.IGModelRootListener).toService(selection_service_1.SelectionService);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(selection_service_1.SelectionService);
        (0, sprotty_1.configureCommand)(context, css_feedback_1.ModifyCssFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.MoveCommand);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IVNodePostprocessor, sprotty_1.LocationPostprocessor);
        bind(sprotty_1.TYPES.HiddenVNodePostprocessor).toService(sprotty_1.LocationPostprocessor);
        bind(sprotty_1.TYPES.IToolManager).to(tool_manager_1.ToolManager).inSingletonScope();
        bind(sprotty_1.TYPES.IDiagramStartup).toService(sprotty_1.TYPES.IToolManager);
        bind(sprotty_1.TYPES.IEditModeListener).toService(sprotty_1.TYPES.IToolManager);
        bind(tool_manager_1.DefaultToolsEnablingKeyListener).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.KeyListener).toService(tool_manager_1.DefaultToolsEnablingKeyListener);
        bind(tool_manager_1.ToolManagerActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, tool_manager_1.ToolManagerActionHandler);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableToolsAction.KIND, tool_manager_1.ToolManagerActionHandler);
        bind(ui_extension_registry_1.GLSPUIExtensionRegistry).toSelf().inSingletonScope();
        (0, sprotty_1.bindOrRebind)(context, sprotty_1.TYPES.UIExtensionRegistry).toService(ui_extension_registry_1.GLSPUIExtensionRegistry);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(ui_extension_registry_1.GLSPUIExtensionRegistry);
        bind(sprotty_1.TYPES.EmptyArray).toDynamicValue(() => []);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IShortcutManager, shortcuts_manager_1.ShortcutManager);
      }, {
        featureId: Symbol("default")
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/drag-aware-mouse-listener.js
  var require_drag_aware_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/drag-aware-mouse-listener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DragAwareMouseListener = void 0;
      var sprotty_1 = require_lib4();
      var DragAwareMouseListener = class extends sprotty_1.MouseListener {
        constructor(dragSensitivity = 0) {
          super();
          this._isMouseDown = false;
          this._isMouseDrag = false;
          this._dragSensitivity = 0;
          this._dragSensitivity = dragSensitivity;
        }
        mouseDown(target, event) {
          this._isMouseDown = true;
          this._dragStart = this._dragSensitivity > 0 ? { x: event.clientX, y: event.clientY } : void 0;
          return [];
        }
        mouseMove(target, event) {
          if (this._isMouseDown) {
            if (this._dragStart) {
              const dragDistance = sprotty_1.Point.maxDistance(this._dragStart, { x: event.clientX, y: event.clientY });
              if (dragDistance < this._dragSensitivity) {
                return this.nonDraggingMouseMove(target, event);
              }
            }
            this._isMouseDrag = true;
            return this.draggingMouseMove(target, event);
          }
          return this.nonDraggingMouseMove(target, event);
        }
        draggingMouseMove(target, event) {
          return [];
        }
        nonDraggingMouseMove(target, event) {
          return [];
        }
        mouseUp(element, event) {
          this._isMouseDown = false;
          this._dragStart = void 0;
          if (this._isMouseDrag) {
            this._isMouseDrag = false;
            return this.draggingMouseUp(element, event);
          }
          return this.nonDraggingMouseUp(element, event);
        }
        nonDraggingMouseUp(element, event) {
          return [];
        }
        draggingMouseUp(element, event) {
          return [];
        }
        get isMouseDrag() {
          return this._isMouseDrag;
        }
        get isMouseDown() {
          return this._isMouseDown;
        }
        dispose() {
          this._isMouseDrag = false;
          this._isMouseDown = false;
        }
      };
      exports.DragAwareMouseListener = DragAwareMouseListener;
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e2) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _3.defaults(root.Object(), context, _3.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e2) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = /* @__PURE__ */ function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e2) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e2) {
              }
              try {
                return func + "";
              } catch (e2) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt2 = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt2 = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at2 = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape2(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e2) {
              return isError(e2) ? e2 : new Error2(e2);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at2;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt2;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt2;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape2;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _3 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _3;
          define(function() {
            return _3;
          });
        } else if (freeModule) {
          (freeModule.exports = _3)._ = _3;
          freeExports._ = _3;
        } else {
          root._ = _3;
        }
      }).call(exports);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/shortcuts/available-shortcuts-extension.js
  var require_available_shortcuts_extension = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/shortcuts/available-shortcuts-extension.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var AvailableShortcutsUIExtension_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AvailableShortcutsUIExtension = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var lodash_1 = require_lodash();
      var ui_extension_1 = require_ui_extension2();
      var messages_1 = require_messages3();
      var AvailableShortcutsUIExtension = AvailableShortcutsUIExtension_1 = class AvailableShortcutsUIExtension extends ui_extension_1.GLSPAbstractUIExtension {
        id() {
          return AvailableShortcutsUIExtension_1.ID;
        }
        containerClass() {
          return AvailableShortcutsUIExtension_1.ID;
        }
        show(root, ...contextElementIds) {
          super.show(root, ...contextElementIds);
          this.shortcutsContainer.focus();
          this.toDisposeOnHide.push(this.shortcutManager.onDidChange(() => this.refreshUI()));
        }
        refreshUI() {
          this.shortcutsContainer.innerHTML = "";
          const registrations = this.shortcutManager.getRegistrations();
          registrations.sort((a3, b3) => {
            if (a3.group < b3.group) {
              return -1;
            }
            if (a3.group > b3.group) {
              return 1;
            }
            return a3.position - b3.position;
          });
          const grouped = (0, lodash_1.groupBy)(registrations, (k3) => k3.group);
          const groupTable = document.createElement("table");
          groupTable.classList.add("shortcut-table");
          const tableHead = document.createElement("thead");
          const tableBody = document.createElement("tbody");
          const headerRow = document.createElement("tr");
          const commandCell = document.createElement("th");
          const keybindingCell = document.createElement("th");
          commandCell.classList.add("column-title");
          commandCell.innerText = messages_1.messages.shortcut.header_command;
          keybindingCell.innerText = messages_1.messages.shortcut.header_shortcut;
          headerRow.appendChild(commandCell);
          headerRow.appendChild(keybindingCell);
          tableHead.appendChild(headerRow);
          for (const [group, shortcuts] of Object.entries(grouped)) {
            tableBody.appendChild(this.createGroupHeader(group));
            shortcuts.forEach((s3) => {
              tableBody.appendChild(this.createEntry(s3));
            });
          }
          groupTable.appendChild(tableHead);
          groupTable.appendChild(tableBody);
          this.shortcutsContainer.append(groupTable);
        }
        createGroupHeader(group) {
          const entryRow = document.createElement("tr");
          const groupElement = document.createElement("td");
          const text = document.createElement("strong");
          const emptyElement = document.createElement("td");
          text.innerText = group;
          groupElement.appendChild(text);
          entryRow.appendChild(groupElement);
          entryRow.appendChild(emptyElement);
          return entryRow;
        }
        getShortcutHTML(shortcuts) {
          const shortcutKeys = document.createElement("span");
          shortcutKeys.innerHTML = shortcuts.map((key) => `<kbd>${key}</kbd>`).join(" + ");
          return shortcutKeys;
        }
        createEntry(registration) {
          const entryRow = document.createElement("tr");
          const shortcutElement = document.createElement("td");
          const descElement = document.createElement("td");
          const shortcut = this.getShortcutHTML(registration.shortcuts);
          descElement.innerText = registration.description;
          shortcutElement.appendChild(shortcut);
          entryRow.appendChild(descElement);
          entryRow.appendChild(shortcutElement);
          return entryRow;
        }
        initializeContents(containerElement) {
          this.container = document.createElement("div");
          this.container.classList.add("keyboard-shortcuts-menu");
          const menuTitle = document.createElement("h3");
          menuTitle.classList.add("menu-header");
          menuTitle.innerText = messages_1.messages.shortcut.title;
          this.container.appendChild(menuTitle);
          const closeBtn = document.createElement("button");
          closeBtn.id = "key-shortcut-close-btn";
          closeBtn.textContent = "x";
          closeBtn.addEventListener("click", () => {
            this.hide();
          });
          this.container.appendChild(closeBtn);
          this.shortcutsContainer = document.createElement("div");
          this.shortcutsContainer.classList.add("keyboard-shortcuts-container");
          this.shortcutsContainer.tabIndex = 30;
          this.shortcutsContainer.addEventListener("keydown", (event) => {
            if (event.key === "Escape" || (0, sprotty_1.matchesKeystroke)(event, "KeyH", "alt")) {
              this.hide();
            }
          });
          this.container.appendChild(this.shortcutsContainer);
          containerElement.appendChild(this.container);
          containerElement.ariaLabel = messages_1.messages.shortcut.menu_title;
          this.refreshUI();
        }
      };
      exports.AvailableShortcutsUIExtension = AvailableShortcutsUIExtension;
      AvailableShortcutsUIExtension.ID = "key-shortcut";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
        __metadata("design:type", Object)
      ], AvailableShortcutsUIExtension.prototype, "shortcutManager", void 0);
      exports.AvailableShortcutsUIExtension = AvailableShortcutsUIExtension = AvailableShortcutsUIExtension_1 = __decorate([
        (0, inversify_1.injectable)()
      ], AvailableShortcutsUIExtension);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/base-tools.js
  var require_base_tools = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/base-tools.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseCreationTool = exports.BaseEditTool = exports.BaseTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var tool_1 = require_tool();
      var key_tool_1 = require_key_tool2();
      var mouse_tool_1 = require_mouse_tool2();
      var BaseTool = class BaseTool {
        constructor() {
          this.toDisposeOnDisable = new sprotty_1.DisposableCollection();
        }
        disable() {
          this.toDisposeOnDisable.dispose();
        }
        dispatchActions(actions) {
          return this.actionDispatcher.dispatchAll(actions);
        }
        createFeedbackEmitter() {
          return this.feedbackDispatcher.createEmitter();
        }
        registerFeedback(feedbackActions, feedbackEmitter = this, cleanupActions) {
          return this.feedbackDispatcher.registerFeedback(feedbackEmitter, feedbackActions, cleanupActions);
        }
        deregisterFeedback(feedbackEmitter = this, cleanupActions) {
          this.feedbackDispatcher.deregisterFeedback(feedbackEmitter, cleanupActions);
        }
      };
      exports.BaseTool = BaseTool;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], BaseTool.prototype, "feedbackDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], BaseTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(mouse_tool_1.GLSPMouseTool),
        __metadata("design:type", mouse_tool_1.GLSPMouseTool)
      ], BaseTool.prototype, "mouseTool", void 0);
      __decorate([
        (0, inversify_1.inject)(key_tool_1.GLSPKeyTool),
        __metadata("design:type", key_tool_1.GLSPKeyTool)
      ], BaseTool.prototype, "keyTool", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], BaseTool.prototype, "editorContext", void 0);
      exports.BaseTool = BaseTool = __decorate([
        (0, inversify_1.injectable)()
      ], BaseTool);
      var BaseEditTool = class BaseEditTool extends BaseTool {
        get isEditTool() {
          return true;
        }
      };
      exports.BaseEditTool = BaseEditTool;
      exports.BaseEditTool = BaseEditTool = __decorate([
        (0, inversify_1.injectable)()
      ], BaseEditTool);
      var BaseCreationTool = class BaseCreationTool extends BaseEditTool {
        handle(action) {
          if (this.isTriggerAction(action)) {
            this.triggerAction = action;
            return tool_1.EnableToolsAction.create([this.id]);
          }
        }
        enable() {
          if (this.triggerAction === void 0) {
            throw new TypeError(`Could not enable tool ${this.id}. The triggerAction cannot be undefined.`);
          }
          this.doEnable();
        }
      };
      exports.BaseCreationTool = BaseCreationTool;
      exports.BaseCreationTool = BaseCreationTool = __decorate([
        (0, inversify_1.injectable)()
      ], BaseCreationTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/shortcuts/available-shortcuts-tool.js
  var require_available_shortcuts_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/shortcuts/available-shortcuts-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var AvailableShortcutsTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AccessibleShortcutKeyListener = exports.AvailableShortcutsTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var base_tools_1 = require_base_tools();
      var available_shortcuts_extension_1 = require_available_shortcuts_extension();
      var AvailableShortcutsTool = AvailableShortcutsTool_1 = class AvailableShortcutsTool extends base_tools_1.BaseTool {
        constructor() {
          super(...arguments);
          this.shortcutKeyListener = new AccessibleShortcutKeyListener();
        }
        get id() {
          return AvailableShortcutsTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.keyTool.registerListener(this.shortcutKeyListener));
        }
      };
      exports.AvailableShortcutsTool = AvailableShortcutsTool;
      AvailableShortcutsTool.ID = "available-shortcuts-tool";
      exports.AvailableShortcutsTool = AvailableShortcutsTool = AvailableShortcutsTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], AvailableShortcutsTool);
      var AccessibleShortcutKeyListener = class _AccessibleShortcutKeyListener extends sprotty_1.KeyListener {
        constructor() {
          super(...arguments);
          this.token = Symbol(_AccessibleShortcutKeyListener.name);
        }
        keyDown(element, event) {
          if (this.matchesActivateShortcutHelpKeystroke(event)) {
            return [sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: available_shortcuts_extension_1.AvailableShortcutsUIExtension.ID, visible: true })];
          }
          return [];
        }
        matchesActivateShortcutHelpKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "KeyH", "alt");
        }
      };
      exports.AccessibleShortcutKeyListener = AccessibleShortcutKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/css/key-shortcut.css
  var require_key_shortcut = __commonJS({
    "node_modules/@eclipse-glsp/client/css/key-shortcut.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/base/shortcuts/shortcuts-module.js
  var require_shortcuts_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/base/shortcuts/shortcuts-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneShortcutsModule = void 0;
      var sprotty_1 = require_lib4();
      require_key_shortcut();
      var available_shortcuts_extension_1 = require_available_shortcuts_extension();
      var available_shortcuts_tool_1 = require_available_shortcuts_tool();
      exports.standaloneShortcutsModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, available_shortcuts_tool_1.AvailableShortcutsTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, available_shortcuts_extension_1.AvailableShortcutsUIExtension);
      }, { featureId: Symbol("standaloneShortcuts") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/move-element-action.js
  var require_move_element_action = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/move-element-action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MoveElementRelativeAction = void 0;
      var sprotty_1 = require_lib4();
      var MoveElementRelativeAction;
      (function(MoveElementRelativeAction2) {
        MoveElementRelativeAction2.KIND = "moveElementRelative";
        function is(object) {
          return sprotty_1.Action.hasKind(object, MoveElementRelativeAction2.KIND);
        }
        MoveElementRelativeAction2.is = is;
        function create(options) {
          return { kind: MoveElementRelativeAction2.KIND, snap: true, ...options };
        }
        MoveElementRelativeAction2.create = create;
      })(MoveElementRelativeAction || (exports.MoveElementRelativeAction = MoveElementRelativeAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/layout-utils.js
  var require_layout_utils = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/layout-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toValidElementAndBounds = exports.toValidElementMove = exports.isValidMove = exports.isValidSize = exports.getLayoutOptions = exports.minDimensions = exports.minHeight = exports.minWidth = void 0;
      function minWidth(element) {
        const layoutOptions = getLayoutOptions(element);
        if (layoutOptions !== void 0 && typeof layoutOptions.minWidth === "number") {
          return layoutOptions.minWidth;
        }
        return 1;
      }
      exports.minWidth = minWidth;
      function minHeight(element) {
        const layoutOptions = getLayoutOptions(element);
        if (layoutOptions !== void 0 && typeof layoutOptions.minHeight === "number") {
          return layoutOptions.minHeight;
        }
        return 1;
      }
      exports.minHeight = minHeight;
      function minDimensions(element) {
        return { width: minWidth(element), height: minHeight(element) };
      }
      exports.minDimensions = minDimensions;
      function getLayoutOptions(element) {
        const layoutOptions = element.layoutOptions;
        if (layoutOptions !== void 0) {
          return layoutOptions;
        }
        return void 0;
      }
      exports.getLayoutOptions = getLayoutOptions;
      function isValidSize(element, size) {
        return size.width >= minWidth(element) && size.height >= minHeight(element);
      }
      exports.isValidSize = isValidSize;
      function isValidMove(element, newPosition, movementRestrictor) {
        var _a4;
        return (_a4 = movementRestrictor === null || movementRestrictor === void 0 ? void 0 : movementRestrictor.validate(element, newPosition)) !== null && _a4 !== void 0 ? _a4 : true;
      }
      exports.isValidMove = isValidMove;
      function toValidElementMove(element, move, movementRestrictor) {
        if (!isValidMove(element, move.toPosition, movementRestrictor)) {
          return;
        }
        return move;
      }
      exports.toValidElementMove = toValidElementMove;
      function toValidElementAndBounds(element, bounds, movementRestrictor) {
        if (!isValidMove(element, bounds.newPosition, movementRestrictor)) {
          return;
        }
        const elementMinWidth = minWidth(element);
        if (bounds.newSize.width < elementMinWidth) {
          bounds.newSize.width = elementMinWidth;
        }
        const elementMinHeight = minHeight(element);
        if (bounds.newSize.height < elementMinHeight) {
          bounds.newSize.height = elementMinHeight;
        }
        return bounds;
      }
      exports.toValidElementAndBounds = toValidElementAndBounds;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/viewpoint-util.js
  var require_viewpoint_util = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/viewpoint-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.outsideOfViewport = exports.absoluteToLocal = exports.absoluteToParent = exports.toAbsoluteSize = exports.toAbsolutePosition = exports.toAbsoluteBounds = exports.getViewportBounds = exports.getAbsolutePositionByPoint = exports.getAbsolutePosition = void 0;
      var sprotty_1 = require_lib4();
      function getAbsolutePosition(target, mouseEvent) {
        return getAbsolutePositionByPoint(target, { x: mouseEvent.pageX, y: mouseEvent.pageY });
      }
      exports.getAbsolutePosition = getAbsolutePosition;
      function getAbsolutePositionByPoint(target, point) {
        let position = sprotty_1.Point.subtract(point, target.root.canvasBounds);
        const viewport = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isViewport);
        if (viewport) {
          const zoom = viewport.zoom;
          const zoomedScroll = sprotty_1.Point.multiplyScalar(viewport.scroll, zoom);
          position = sprotty_1.Point.add(position, zoomedScroll);
          position = sprotty_1.Point.divideScalar(position, zoom);
        }
        return position;
      }
      exports.getAbsolutePositionByPoint = getAbsolutePositionByPoint;
      function getViewportBounds(target, bounds) {
        const topLeft = getAbsolutePositionByPoint(target, sprotty_1.Bounds.topLeft(bounds));
        const bottomRight = getAbsolutePositionByPoint(target, sprotty_1.Bounds.bottomRight(bounds));
        return sprotty_1.Bounds.from(topLeft, bottomRight);
      }
      exports.getViewportBounds = getViewportBounds;
      function toAbsoluteBounds(element) {
        const location2 = (0, sprotty_1.isAlignable)(element) ? element.alignment : sprotty_1.Point.ORIGIN;
        const x3 = location2.x;
        const y3 = location2.y;
        const width = element.bounds.width;
        const height = element.bounds.height;
        return (0, sprotty_1.translateBounds)({ x: x3, y: y3, width, height }, element, element.root);
      }
      exports.toAbsoluteBounds = toAbsoluteBounds;
      function toAbsolutePosition(target) {
        return toAbsoluteBounds(target);
      }
      exports.toAbsolutePosition = toAbsolutePosition;
      function toAbsoluteSize(target) {
        return toAbsoluteBounds(target);
      }
      exports.toAbsoluteSize = toAbsoluteSize;
      function absoluteToParent(element, absolutePoint) {
        if ((0, sprotty_1.isBoundsAware)(element.parent)) {
          return absoluteToLocal(element.parent, absolutePoint);
        }
        return absoluteToLocal(element, absolutePoint);
      }
      exports.absoluteToParent = absoluteToParent;
      function absoluteToLocal(element, absolutePoint) {
        const absoluteElementBounds = toAbsoluteBounds(element);
        return sprotty_1.Point.subtract(absolutePoint, absoluteElementBounds);
      }
      exports.absoluteToLocal = absoluteToLocal;
      function outsideOfViewport(point, viewport) {
        return point.x < viewport.scroll.x || point.x > viewport.scroll.x + viewport.canvasBounds.width / viewport.zoom || point.y < viewport.scroll.y || point.y > viewport.scroll.y + viewport.canvasBounds.height / viewport.zoom;
      }
      exports.outsideOfViewport = outsideOfViewport;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/move-element-handler.js
  var require_move_element_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/move-element-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MoveElementHandler = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var lodash_1 = require_lodash();
      var editor_context_service_1 = require_editor_context_service();
      var gmodel_util_1 = require_gmodel_util();
      var layout_utils_1 = require_layout_utils();
      var viewpoint_util_1 = require_viewpoint_util();
      var move_element_action_1 = require_move_element_action();
      var MoveElementHandler = class MoveElementHandler {
        init() {
          this.moveFeedback = this.feedbackDispatcher.createEmitter();
        }
        handle(action) {
          if (move_element_action_1.MoveElementRelativeAction.is(action)) {
            this.handleMoveElement(action);
          }
        }
        handleMoveElement(action) {
          const modelRoot = this.editorContextService.modelRoot;
          const viewport = (0, sprotty_1.findParentByFeature)(modelRoot, sprotty_1.isViewport);
          if (!viewport) {
            return;
          }
          const viewportActions = [];
          const elementMoves = [];
          const elements = (0, gmodel_util_1.getElements)(modelRoot.index, action.elementIds, gmodel_util_1.isSelectableAndBoundsAware);
          for (const element of elements) {
            const newPosition = this.getTargetBounds(element, action);
            elementMoves.push({
              elementId: element.id,
              fromPosition: {
                x: element.bounds.x,
                y: element.bounds.y
              },
              toPosition: newPosition
            });
            const topLeftCorner = newPosition;
            const bottomRightCorner = sprotty_1.Point.add(newPosition, { x: element.bounds.width, y: element.bounds.height });
            if ((0, viewpoint_util_1.outsideOfViewport)(topLeftCorner, viewport) || (0, viewpoint_util_1.outsideOfViewport)(bottomRightCorner, viewport)) {
              viewportActions.push(sprotty_1.MoveViewportAction.create({ moveX: action.moveX, moveY: action.moveY }));
            }
          }
          this.dispatcher.dispatchAll(viewportActions);
          const moveAction = sprotty_1.MoveAction.create(elementMoves, { animate: false });
          this.moveFeedback.add(moveAction).submit();
          this.scheduleChangeBounds(this.toElementAndBounds(elementMoves));
        }
        getTargetBounds(element, action) {
          let position = sprotty_1.Point.add(element.bounds, { x: action.moveX, y: action.moveY });
          if (this.snapper && action.snap) {
            position = this.snapper.snap(position, element);
          }
          if (!(0, layout_utils_1.isValidMove)(element, position, this.movementRestrictor)) {
            position = { x: element.bounds.x, y: element.bounds.y };
          }
          return position;
        }
        scheduleChangeBounds(elementAndBounds) {
          var _a4;
          (_a4 = this.debouncedChangeBounds) === null || _a4 === void 0 ? void 0 : _a4.cancel();
          this.debouncedChangeBounds = (0, lodash_1.debounce)(() => {
            this.moveFeedback.dispose();
            this.dispatcher.dispatchAll([sprotty_1.ChangeBoundsOperation.create(elementAndBounds)]);
            this.debouncedChangeBounds = void 0;
          }, 300);
          this.debouncedChangeBounds();
        }
        toElementAndBounds(elementMoves) {
          const elementBounds = [];
          for (const elementMove of elementMoves) {
            const element = this.editorContextService.modelRoot.index.getById(elementMove.elementId);
            if (element && (0, sprotty_1.isBoundsAware)(element)) {
              elementBounds.push({
                elementId: elementMove.elementId,
                newSize: {
                  height: element.bounds.height,
                  width: element.bounds.width
                },
                newPosition: {
                  x: elementMove.toPosition.x,
                  y: elementMove.toPosition.y
                }
              });
            }
          }
          return elementBounds;
        }
      };
      exports.MoveElementHandler = MoveElementHandler;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], MoveElementHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], MoveElementHandler.prototype, "dispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], MoveElementHandler.prototype, "feedbackDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], MoveElementHandler.prototype, "snapper", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IMovementRestrictor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], MoveElementHandler.prototype, "movementRestrictor", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], MoveElementHandler.prototype, "init", null);
      exports.MoveElementHandler = MoveElementHandler = __decorate([
        (0, inversify_1.injectable)()
      ], MoveElementHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/model.js
  var require_model19 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SResizeHandle = exports.removeResizeHandles = exports.addResizeHandles = exports.GResizeHandle = exports.isBoundsAwareMoveable = exports.ResizeHandleLocation = exports.isResizable = exports.resizeFeature = void 0;
      var sprotty_1 = require_lib4();
      var css_feedback_1 = require_css_feedback();
      exports.resizeFeature = Symbol("resizeFeature");
      function isResizable(element) {
        return (0, sprotty_1.isBoundsAware)(element) && (0, sprotty_1.isSelectable)(element) && element instanceof sprotty_1.GParentElement && element.hasFeature(exports.resizeFeature);
      }
      exports.isResizable = isResizable;
      var ResizeHandleLocation;
      (function(ResizeHandleLocation2) {
        ResizeHandleLocation2["TopLeft"] = "top-left";
        ResizeHandleLocation2["Top"] = "top";
        ResizeHandleLocation2["TopRight"] = "top-right";
        ResizeHandleLocation2["Right"] = "right";
        ResizeHandleLocation2["BottomRight"] = "bottom-right";
        ResizeHandleLocation2["Bottom"] = "bottom";
        ResizeHandleLocation2["BottomLeft"] = "bottom-left";
        ResizeHandleLocation2["Left"] = "left";
      })(ResizeHandleLocation || (exports.ResizeHandleLocation = ResizeHandleLocation = {}));
      (function(ResizeHandleLocation2) {
        ResizeHandleLocation2.CORNERS = [
          ResizeHandleLocation2.TopLeft,
          ResizeHandleLocation2.TopRight,
          ResizeHandleLocation2.BottomRight,
          ResizeHandleLocation2.BottomLeft
        ];
        ResizeHandleLocation2.CROSS = [
          ResizeHandleLocation2.Top,
          ResizeHandleLocation2.Right,
          ResizeHandleLocation2.Bottom,
          ResizeHandleLocation2.Left
        ];
        ResizeHandleLocation2.ALL = [...ResizeHandleLocation2.CORNERS, ...ResizeHandleLocation2.CROSS];
        function opposite(location2) {
          switch (location2) {
            case ResizeHandleLocation2.TopLeft:
              return ResizeHandleLocation2.BottomRight;
            case ResizeHandleLocation2.Top:
              return ResizeHandleLocation2.Bottom;
            case ResizeHandleLocation2.TopRight:
              return ResizeHandleLocation2.BottomLeft;
            case ResizeHandleLocation2.Right:
              return ResizeHandleLocation2.Left;
            case ResizeHandleLocation2.BottomRight:
              return ResizeHandleLocation2.TopLeft;
            case ResizeHandleLocation2.Bottom:
              return ResizeHandleLocation2.Top;
            case ResizeHandleLocation2.BottomLeft:
              return ResizeHandleLocation2.TopRight;
            case ResizeHandleLocation2.Left:
              return ResizeHandleLocation2.Right;
          }
        }
        ResizeHandleLocation2.opposite = opposite;
        function direction(location2) {
          switch (location2) {
            case ResizeHandleLocation2.TopLeft:
              return [sprotty_1.Direction.Up, sprotty_1.Direction.Left];
            case ResizeHandleLocation2.Top:
              return [sprotty_1.Direction.Up];
            case ResizeHandleLocation2.TopRight:
              return [sprotty_1.Direction.Up, sprotty_1.Direction.Right];
            case ResizeHandleLocation2.Right:
              return [sprotty_1.Direction.Right];
            case ResizeHandleLocation2.BottomRight:
              return [sprotty_1.Direction.Down, sprotty_1.Direction.Right];
            case ResizeHandleLocation2.Bottom:
              return [sprotty_1.Direction.Down];
            case ResizeHandleLocation2.BottomLeft:
              return [sprotty_1.Direction.Down, sprotty_1.Direction.Left];
            case ResizeHandleLocation2.Left:
              return [sprotty_1.Direction.Left];
          }
        }
        ResizeHandleLocation2.direction = direction;
      })(ResizeHandleLocation || (exports.ResizeHandleLocation = ResizeHandleLocation = {}));
      function isBoundsAwareMoveable(element) {
        return (0, sprotty_1.isMoveable)(element) && (0, sprotty_1.isBoundsAware)(element);
      }
      exports.isBoundsAwareMoveable = isBoundsAwareMoveable;
      var GResizeHandle = class _GResizeHandle extends sprotty_1.GChildElement {
        constructor(location2, type = _GResizeHandle.TYPE, hoverFeedback = false) {
          super();
          this.location = location2;
          this.type = type;
          this.hoverFeedback = hoverFeedback;
        }
        hasFeature(feature) {
          return feature === sprotty_1.hoverFeedbackFeature;
        }
        isNwResize() {
          return this.location === ResizeHandleLocation.TopLeft;
        }
        isNResize() {
          return this.location === ResizeHandleLocation.Top;
        }
        isNeResize() {
          return this.location === ResizeHandleLocation.TopRight;
        }
        isEResize() {
          return this.location === ResizeHandleLocation.Right;
        }
        isSeResize() {
          return this.location === ResizeHandleLocation.BottomRight;
        }
        isSResize() {
          return this.location === ResizeHandleLocation.Bottom;
        }
        isSwResize() {
          return this.location === ResizeHandleLocation.BottomLeft;
        }
        isWResize() {
          return this.location === ResizeHandleLocation.Left;
        }
        isNwSeResize() {
          return this.isNwResize() || this.isSeResize();
        }
        isNeSwResize() {
          return this.isNeResize() || this.isSwResize();
        }
        static getHandlePosition(first, second) {
          const bounds = _GResizeHandle.is(first) ? first.parent.bounds : first instanceof sprotty_1.GModelElement ? first.bounds : first;
          const location2 = _GResizeHandle.is(first) ? first.location : second;
          switch (location2) {
            case ResizeHandleLocation.TopLeft:
              return sprotty_1.Bounds.topLeft(bounds);
            case ResizeHandleLocation.Top:
              return sprotty_1.Bounds.topCenter(bounds);
            case ResizeHandleLocation.TopRight:
              return sprotty_1.Bounds.topRight(bounds);
            case ResizeHandleLocation.Right:
              return sprotty_1.Bounds.middleRight(bounds);
            case ResizeHandleLocation.BottomRight:
              return sprotty_1.Bounds.bottomRight(bounds);
            case ResizeHandleLocation.Bottom:
              return sprotty_1.Bounds.bottomCenter(bounds);
            case ResizeHandleLocation.BottomLeft:
              return sprotty_1.Bounds.bottomLeft(bounds);
            case ResizeHandleLocation.Left:
              return sprotty_1.Bounds.middleLeft(bounds);
          }
        }
        static getCursorCss(handle) {
          switch (handle.location) {
            case ResizeHandleLocation.TopLeft:
              return css_feedback_1.CursorCSS.RESIZE_NW;
            case ResizeHandleLocation.Top:
              return css_feedback_1.CursorCSS.RESIZE_N;
            case ResizeHandleLocation.TopRight:
              return css_feedback_1.CursorCSS.RESIZE_NE;
            case ResizeHandleLocation.Right:
              return css_feedback_1.CursorCSS.RESIZE_E;
            case ResizeHandleLocation.BottomRight:
              return css_feedback_1.CursorCSS.RESIZE_SE;
            case ResizeHandleLocation.Bottom:
              return css_feedback_1.CursorCSS.RESIZE_S;
            case ResizeHandleLocation.BottomLeft:
              return css_feedback_1.CursorCSS.RESIZE_SW;
            case ResizeHandleLocation.Left:
              return css_feedback_1.CursorCSS.RESIZE_W;
          }
        }
        static is(handle) {
          return typeof handle === "object" && !!handle && "type" in handle && handle.type === _GResizeHandle.TYPE;
        }
      };
      exports.GResizeHandle = GResizeHandle;
      exports.SResizeHandle = GResizeHandle;
      GResizeHandle.TYPE = "resize-handle";
      function addResizeHandles(element, locations = ResizeHandleLocation.CORNERS) {
        for (const location2 of ResizeHandleLocation.ALL) {
          const existing = element.children.find((child) => child instanceof GResizeHandle && child.location === location2);
          if (locations.includes(location2) && !existing) {
            element.add(new GResizeHandle(location2));
          } else if (!locations.includes(location2) && existing) {
            element.remove(existing);
          }
        }
      }
      exports.addResizeHandles = addResizeHandles;
      function removeResizeHandles(element) {
        element.removeAll((child) => child instanceof GResizeHandle);
      }
      exports.removeResizeHandles = removeResizeHandles;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/helper-lines/model.js
  var require_model20 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/helper-lines/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Direction = exports.getDirectionFrom = exports.getDirectionOf = exports.isSelectionBounds = exports.SelectionBounds = exports.SELECTION_BOUNDS = exports.isHelperLine = exports.HelperLine = exports.HELPER_LINE = exports.HelperLineType = void 0;
      var sprotty_1 = require_lib4();
      var uuid_1 = require_commonjs_browser();
      var model_1 = require_model19();
      exports.HelperLineType = {
        Left: "left",
        Right: "right",
        Center: "center",
        Top: "top",
        Bottom: "bottom",
        Middle: "middle",
        LeftRight: "left-right",
        RightLeft: "right-left",
        BottomTop: "bottom-top",
        TopBottom: "top-bottom"
      };
      exports.HELPER_LINE = "helper-line";
      var HelperLine = class extends sprotty_1.GChildElement {
        constructor(startPoint = sprotty_1.Point.ORIGIN, endPoint = sprotty_1.Point.ORIGIN, lineType = exports.HelperLineType.Left) {
          super();
          this.startPoint = startPoint;
          this.endPoint = endPoint;
          this.lineType = lineType;
          this.id = (0, uuid_1.v4)();
          this.type = exports.HELPER_LINE;
        }
        get isLeft() {
          return this.lineType === exports.HelperLineType.Left || this.lineType === exports.HelperLineType.LeftRight;
        }
        get isRight() {
          return this.lineType === exports.HelperLineType.Right || this.lineType === exports.HelperLineType.RightLeft;
        }
        get isTop() {
          return this.lineType === exports.HelperLineType.Top || this.lineType === exports.HelperLineType.TopBottom;
        }
        get isBottom() {
          return this.lineType === exports.HelperLineType.Bottom || this.lineType === exports.HelperLineType.BottomTop;
        }
        get isMiddle() {
          return this.lineType === exports.HelperLineType.Middle;
        }
        get isCenter() {
          return this.lineType === exports.HelperLineType.Center;
        }
      };
      exports.HelperLine = HelperLine;
      function isHelperLine(element) {
        return element.type === exports.HELPER_LINE;
      }
      exports.isHelperLine = isHelperLine;
      exports.SELECTION_BOUNDS = "selection-bounds";
      var SelectionBounds = class extends sprotty_1.GShapeElement {
        constructor(bounds) {
          super();
          this.id = (0, uuid_1.v4)();
          this.type = exports.SELECTION_BOUNDS;
          if (bounds) {
            this.bounds = bounds;
          }
        }
      };
      exports.SelectionBounds = SelectionBounds;
      function isSelectionBounds(element) {
        return element.type === exports.SELECTION_BOUNDS;
      }
      exports.isSelectionBounds = isSelectionBounds;
      exports.getDirectionOf = sprotty_1.Vector.direction;
      function getDirectionFrom(resize) {
        if (resize === model_1.ResizeHandleLocation.TopLeft) {
          return [sprotty_1.Direction.Up, sprotty_1.Direction.Left];
        }
        if (resize === model_1.ResizeHandleLocation.TopRight) {
          return [sprotty_1.Direction.Up, sprotty_1.Direction.Right];
        }
        if (resize === model_1.ResizeHandleLocation.BottomLeft) {
          return [sprotty_1.Direction.Down, sprotty_1.Direction.Left];
        }
        if (resize === model_1.ResizeHandleLocation.BottomRight) {
          return [sprotty_1.Direction.Down, sprotty_1.Direction.Right];
        }
        return [];
      }
      exports.getDirectionFrom = getDirectionFrom;
      var sprotty_2 = require_lib4();
      Object.defineProperty(exports, "Direction", { enumerable: true, get: function() {
        return sprotty_2.Direction;
      } });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/position-snapper.js
  var require_position_snapper = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/position-snapper.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PositionSnapper = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var model_1 = require_model20();
      var PositionSnapper = class PositionSnapper {
        constructor(snapper, helperLineManager) {
          this.snapper = snapper;
          this.helperLineManager = helperLineManager;
        }
        snapPosition(position, element, isSnap = true) {
          return isSnap && this.snapper ? this.snapper.snap(position, element) : { x: position.x, y: position.y };
        }
        snapDelta(positionDelta, element, isSnap, directions) {
          const delta = this.snapPosition(positionDelta, element, isSnap);
          const minimumDelta = this.getMinimumDelta(element, isSnap, directions);
          if (!minimumDelta) {
            return delta;
          }
          delta.x = Math.abs(delta.x) >= minimumDelta.x ? delta.x : 0;
          delta.y = Math.abs(delta.y) >= minimumDelta.y ? delta.y : 0;
          return delta;
        }
        getMinimumDelta(target, isSnap, directions) {
          return this.getHelperLineMinimum(target, isSnap, directions);
        }
        getHelperLineMinimum(target, isSnap, directions) {
          if (!this.helperLineManager) {
            return void 0;
          }
          const helperLines = target.root.children.filter((child) => (0, model_1.isHelperLine)(child));
          if (helperLines.length === 0) {
            return void 0;
          }
          const minimum = { x: 0, y: 0 };
          if (directions.includes(model_1.Direction.Left) && helperLines.some((line) => line.isLeft || line.isCenter)) {
            minimum.x = this.helperLineManager.getMinimumMoveDelta(target, isSnap, model_1.Direction.Left);
          } else if (directions.includes(model_1.Direction.Right) && helperLines.some((line) => line.isRight || line.isCenter)) {
            minimum.x = this.helperLineManager.getMinimumMoveDelta(target, isSnap, model_1.Direction.Right);
          }
          if (directions.includes(model_1.Direction.Up) && helperLines.some((line) => line.isTop || line.isMiddle)) {
            minimum.y = this.helperLineManager.getMinimumMoveDelta(target, isSnap, model_1.Direction.Up);
          } else if (directions.includes(model_1.Direction.Down) && helperLines.some((line) => line.isBottom || line.isMiddle)) {
            minimum.y = this.helperLineManager.getMinimumMoveDelta(target, isSnap, model_1.Direction.Down);
          }
          return minimum;
        }
      };
      exports.PositionSnapper = PositionSnapper;
      exports.PositionSnapper = PositionSnapper = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.optional)()),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper)),
        __param(1, (0, inversify_1.optional)()),
        __param(1, (0, inversify_1.inject)(sprotty_1.TYPES.IHelperLineManager)),
        __metadata("design:paramtypes", [Object, Object])
      ], PositionSnapper);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/layout-data.js
  var require_layout_data = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/layout-data.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LayoutAware = void 0;
      var LayoutAware;
      (function(LayoutAware2) {
        function is(element) {
          return "layoutData" in element;
        }
        LayoutAware2.is = is;
        function getLayoutData(element) {
          return is(element) ? element.layoutData : void 0;
        }
        LayoutAware2.getLayoutData = getLayoutData;
        function setLayoutData(element, data) {
          element.layoutData = data;
        }
        LayoutAware2.setLayoutData = setLayoutData;
        function setComputedDimensions(element, computedDimensions) {
          ensureLayoutAware(element).layoutData.computedDimensions = computedDimensions;
        }
        LayoutAware2.setComputedDimensions = setComputedDimensions;
        function getComputedDimensions(element) {
          var _a4;
          return (_a4 = getLayoutData(element)) === null || _a4 === void 0 ? void 0 : _a4.computedDimensions;
        }
        LayoutAware2.getComputedDimensions = getComputedDimensions;
        function ensureLayoutAware(element) {
          var _a4;
          element.layoutData = (_a4 = element.layoutData) !== null && _a4 !== void 0 ? _a4 : {};
          return element;
        }
      })(LayoutAware || (exports.LayoutAware = LayoutAware = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/freeform-layout.js
  var require_freeform_layout = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/freeform-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FreeFormLayouter = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var layout_data_1 = require_layout_data();
      var FreeFormLayouter = class FreeFormLayouter extends sprotty_1.AbstractLayout {
        layout(container, layouter) {
          const boundsData = layouter.getBoundsData(container);
          const options = this.getLayoutOptions(container);
          const childrenSize = this.getChildrenSize(container, options, layouter);
          const maxWidth = childrenSize.width > 0 ? childrenSize.width + options.paddingLeft + options.paddingRight : 0;
          const maxHeight = childrenSize.height > 0 ? childrenSize.height + options.paddingTop + options.paddingBottom : 0;
          if (childrenSize.width > 0 && childrenSize.height > 0) {
            const offset = this.layoutChildren(container, layouter, options, maxWidth, maxHeight);
            const computed = this.getComputedContainerDimensions(options, childrenSize.width, childrenSize.height);
            layout_data_1.LayoutAware.setComputedDimensions(boundsData, computed);
            boundsData.bounds = this.getFinalContainerBounds(container, offset, options, computed.width, computed.height);
            boundsData.boundsChanged = true;
          } else {
            boundsData.bounds = { x: boundsData.bounds.x, y: boundsData.bounds.y, width: 0, height: 0 };
            boundsData.boundsChanged = true;
          }
        }
        getChildrenSize(container, containerOptions, layouter) {
          let maxX = 0;
          let maxY = 0;
          container.children.forEach((child) => {
            const bounds = layouter.getBoundsData(child).bounds;
            if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
              const childMaxX = bounds.x + bounds.width;
              const childMaxY = bounds.y + bounds.height;
              maxX = Math.max(maxX, childMaxX);
              maxY = Math.max(maxY, childMaxY);
            }
          });
          return {
            width: maxX,
            height: maxY
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          boundsData.bounds = {
            x: child.bounds.x,
            y: child.bounds.y,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return currentOffset;
        }
        getComputedContainerDimensions(options, maxWidth, maxHeight) {
          return {
            width: maxWidth + options.paddingLeft + options.paddingRight,
            height: maxHeight + options.paddingTop + options.paddingBottom
          };
        }
        getFinalContainerBounds(container, lastOffset, options, maxWidth, maxHeight) {
          const result = {
            x: container.bounds.x,
            y: container.bounds.y,
            width: Math.max(options.minWidth, maxWidth),
            height: Math.max(options.minHeight, maxHeight)
          };
          return result;
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
            paddingFactor: 1,
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a3, b3) {
          return { ...a3, ...b3 };
        }
      };
      exports.FreeFormLayouter = FreeFormLayouter;
      FreeFormLayouter.KIND = "freeform";
      exports.FreeFormLayouter = FreeFormLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], FreeFormLayouter);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/local-bounds.js
  var require_local_bounds = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/local-bounds.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocalComputedBoundsCommand = exports.LocalComputedBoundsAction = exports.LocalRequestBoundsAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var glsp_model_source_1 = require_glsp_model_source();
      var layout_data_1 = require_layout_data();
      var LocalRequestBoundsAction;
      (function(LocalRequestBoundsAction2) {
        function is(object) {
          return sprotty_1.RequestBoundsAction.is(object) && !glsp_model_source_1.ServerAction.is(object) && (0, sprotty_1.hasArrayProp)(object, "elementIDs", true);
        }
        LocalRequestBoundsAction2.is = is;
        function create(newRoot, elementIDs) {
          return {
            ...sprotty_1.RequestBoundsAction.create(newRoot),
            elementIDs
          };
        }
        LocalRequestBoundsAction2.create = create;
        function fromCommand({ root }, actionDispatcher, cause, elementIDs) {
          actionDispatcher.dispatch(LocalRequestBoundsAction2.create(root, elementIDs));
          return {
            model: root,
            modelChanged: false,
            cause
          };
        }
        LocalRequestBoundsAction2.fromCommand = fromCommand;
      })(LocalRequestBoundsAction || (exports.LocalRequestBoundsAction = LocalRequestBoundsAction = {}));
      var LocalComputedBoundsAction;
      (function(LocalComputedBoundsAction2) {
        function is(object) {
          return sprotty_1.ComputedBoundsAction.is(object) && glsp_model_source_1.ServerAction.is(object);
        }
        LocalComputedBoundsAction2.is = is;
        function mark(action) {
          glsp_model_source_1.ServerAction.mark(action);
          return action;
        }
        LocalComputedBoundsAction2.mark = mark;
      })(LocalComputedBoundsAction || (exports.LocalComputedBoundsAction = LocalComputedBoundsAction = {}));
      var LocalComputedBoundsCommand = class LocalComputedBoundsCommand extends sprotty_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          var _a4, _b2;
          if (LocalComputedBoundsAction.is(this.action)) {
            if (!this.viewerOptions.needsClientLayout) {
              return context.root;
            }
            this.computedBoundsApplicator.apply(context.root, this.action);
            (_a4 = this.action.layoutData) === null || _a4 === void 0 ? void 0 : _a4.forEach(({ elementId, layoutData }) => {
              const element = context.root.index.getById(elementId);
              if (element !== void 0) {
                layout_data_1.LayoutAware.setLayoutData(element, layoutData);
              }
            });
            return context.root;
          }
          (_b2 = this.action.layoutData) === null || _b2 === void 0 ? void 0 : _b2.forEach(({ elementId, layoutData }) => {
            const element = context.root.index.getById(elementId);
            if (element !== void 0) {
              layout_data_1.LayoutAware.setLayoutData(element, layoutData);
            }
          });
          return {
            model: context.root,
            modelChanged: false
          };
        }
        undo(context) {
          return context.root;
        }
        redo(context) {
          return context.root;
        }
      };
      exports.LocalComputedBoundsCommand = LocalComputedBoundsCommand;
      LocalComputedBoundsCommand.KIND = sprotty_1.ComputedBoundsAction.KIND;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.ComputedBoundsApplicator),
        __metadata("design:type", sprotty_1.ComputedBoundsApplicator)
      ], LocalComputedBoundsCommand.prototype, "computedBoundsApplicator", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], LocalComputedBoundsCommand.prototype, "viewerOptions", void 0);
      exports.LocalComputedBoundsCommand = LocalComputedBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], LocalComputedBoundsCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/glsp-hidden-bounds-updater.js
  var require_glsp_hidden_bounds_updater = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/glsp-hidden-bounds-updater.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPHiddenBoundsUpdater = exports.BoundsDataExt = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var gmodel_util_1 = require_gmodel_util();
      var layout_data_1 = require_layout_data();
      var local_bounds_1 = require_local_bounds();
      var BoundsDataExt = class extends sprotty_1.BoundsData {
      };
      exports.BoundsDataExt = BoundsDataExt;
      var GLSPHiddenBoundsUpdater = class GLSPHiddenBoundsUpdater extends sprotty_1.HiddenBoundsUpdater {
        constructor() {
          super(...arguments);
          this.element2route = [];
        }
        getElement2BoundsData() {
          return this["element2boundsData"];
        }
        decorate(vnode, element) {
          super.decorate(vnode, element);
          if ((0, gmodel_util_1.isRoutable)(element)) {
            this.element2route.push((0, gmodel_util_1.calcElementAndRoute)(element, this.edgeRouterRegistry));
          }
          return vnode;
        }
        postUpdate(cause) {
          if (local_bounds_1.LocalRequestBoundsAction.is(cause) && cause.elementIDs) {
            this.focusOnElements(cause.elementIDs);
          }
          this.getBoundsFromDOM();
          this.layouter.layout(this.getElement2BoundsData());
          const resizes = [];
          const alignments = [];
          const layoutData = [];
          this.getElement2BoundsData().forEach((boundsData, element) => {
            if (boundsData.boundsChanged && boundsData.bounds !== void 0) {
              const resize = {
                elementId: element.id,
                newSize: {
                  width: boundsData.bounds.width,
                  height: boundsData.bounds.height
                }
              };
              if (element instanceof sprotty_1.GChildElement && (0, sprotty_1.isLayoutContainer)(element.parent)) {
                resize.newPosition = {
                  x: boundsData.bounds.x,
                  y: boundsData.bounds.y
                };
              }
              resizes.push(resize);
            }
            if (boundsData.alignmentChanged && boundsData.alignment !== void 0) {
              alignments.push({
                elementId: element.id,
                newAlignment: boundsData.alignment
              });
            }
            if (layout_data_1.LayoutAware.is(boundsData)) {
              layoutData.push({ elementId: element.id, layoutData: boundsData.layoutData });
            }
          });
          const routes = this.element2route.length === 0 ? void 0 : this.element2route;
          const responseId = cause.requestId;
          const revision = this.root !== void 0 ? this.root.revision : void 0;
          const computedBoundsAction = sprotty_1.ComputedBoundsAction.create(resizes, { revision, alignments, layoutData, routes, responseId });
          if (local_bounds_1.LocalRequestBoundsAction.is(cause)) {
            local_bounds_1.LocalComputedBoundsAction.mark(computedBoundsAction);
          }
          this.actionDispatcher.dispatch(computedBoundsAction);
          this.getElement2BoundsData().clear();
          this.element2route = [];
        }
        focusOnElements(elementIDs) {
          const data = this.getElement2BoundsData();
          if (data.size > 0) {
            const index = [...data.keys()][0].index;
            const relevantIds = new Set(elementIDs.flatMap((elementId) => this.expandElementId(elementId, index, elementIDs)));
            data.forEach((_bounds, element) => !relevantIds.has(element.id) && data.delete(element));
          }
        }
        expandElementId(id, index, elementIDs) {
          return (0, gmodel_util_1.getDescendantIds)(index.getById(id));
        }
      };
      exports.GLSPHiddenBoundsUpdater = GLSPHiddenBoundsUpdater;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], GLSPHiddenBoundsUpdater.prototype, "edgeRouterRegistry", void 0);
      exports.GLSPHiddenBoundsUpdater = GLSPHiddenBoundsUpdater = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPHiddenBoundsUpdater);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/hbox-layout.js
  var require_hbox_layout2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/hbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HBoxLayouterExt = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var layout_data_1 = require_layout_data();
      var HBoxLayouterExt = class HBoxLayouterExt extends sprotty_1.HBoxLayouter {
        layout(container, layouter) {
          var _a4, _b2;
          const boundsData = layouter.getBoundsData(container);
          const options = this.getLayoutOptions(container);
          const childrenSize = this.getChildrenSize(container, options, layouter);
          const fixedSize = this.getFixedContainerBounds(container, options, layouter);
          const currentWidth = boundsData.bounds ? ((_a4 = boundsData.bounds) === null || _a4 === void 0 ? void 0 : _a4.width) - options.paddingLeft - options.paddingRight : 0;
          const currentHeight = boundsData.bounds ? ((_b2 = boundsData.bounds) === null || _b2 === void 0 ? void 0 : _b2.height) - options.paddingTop - options.paddingBottom : 0;
          const maxWidth = options.paddingFactor * (options.resizeContainer ? Math.max(fixedSize.width - options.paddingLeft - options.paddingRight, childrenSize.width) : Math.max(0, fixedSize.width - options.paddingLeft - options.paddingRight));
          const maxHeight = options.paddingFactor * (options.resizeContainer ? Math.max(fixedSize.height - options.paddingTop - options.paddingBottom, childrenSize.height) : Math.max(0, fixedSize.height - options.paddingTop - options.paddingBottom));
          const width = Math.max(currentWidth, maxWidth);
          const height = Math.max(currentHeight, maxHeight);
          const grabWidth = width - childrenSize.width;
          const grabbingChildren = container.children.map((child) => this.getChildLayoutOptions(child, options)).filter((opt) => opt.hGrab).length;
          if (width > 0 && height > 0) {
            const offset = this.layoutChildren(container, layouter, options, width, height, grabWidth, grabbingChildren);
            const computed = this.getComputedContainerDimensions(options, childrenSize.width, childrenSize.height);
            layout_data_1.LayoutAware.setComputedDimensions(boundsData, computed);
            boundsData.bounds = this.getFinalContainerBounds(container, offset, options, computed.width, computed.height);
            boundsData.boundsChanged = true;
          }
        }
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = 0;
          let maxHeight = -1;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, sprotty_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
                maxWidth += bounds.width;
                if (isFirst) {
                  isFirst = false;
                } else {
                  maxWidth += containerOptions.hGap;
                }
                maxHeight = Math.max(maxHeight, bounds.height);
              }
            }
          });
          const result = {
            width: maxWidth,
            height: maxHeight
          };
          return result;
        }
        layoutChildren(container, layouter, containerOptions, maxWidth, maxHeight, grabWidth, grabbingChildren) {
          let currentOffset = {
            x: containerOptions.paddingLeft + 0.5 * (maxWidth - maxWidth / containerOptions.paddingFactor),
            y: containerOptions.paddingTop + 0.5 * (maxHeight - maxHeight / containerOptions.paddingFactor)
          };
          container.children.forEach((child) => {
            if ((0, sprotty_1.isLayoutableChild)(child)) {
              const boundsData = layouter.getBoundsData(child);
              const bounds = boundsData.bounds;
              const childOptions = this.getChildLayoutOptions(child, containerOptions);
              if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
                currentOffset = this.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight, grabWidth, grabbingChildren);
              }
            }
          });
          return currentOffset;
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight, grabWidth, grabbingChildren) {
          const vAlign = childOptions.vGrab ? "top" : childOptions.vAlign;
          const dy = this.getDy(vAlign, bounds, maxHeight);
          let offset = super.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight);
          boundsData.bounds = {
            ...boundsData.bounds,
            x: currentOffset.x,
            y: currentOffset.y + dy
          };
          if (childOptions.vGrab) {
            boundsData.bounds = {
              x: boundsData.bounds.x,
              y: boundsData.bounds.y,
              width: boundsData.bounds.width,
              height: maxHeight
            };
            boundsData.boundsChanged = true;
          }
          if (childOptions.hGrab && grabWidth && grabbingChildren) {
            const width = boundsData.bounds.width + grabWidth / grabbingChildren;
            boundsData.bounds = {
              x: boundsData.bounds.x,
              y: boundsData.bounds.y,
              width,
              height: boundsData.bounds.height
            };
            boundsData.boundsChanged = true;
            offset = { x: currentOffset.x + width, y: currentOffset.y };
          }
          return offset;
        }
        getFixedContainerBounds(container, layoutOptions, layouter) {
          var _a4, _b2;
          const currentContainer = container;
          if ((0, sprotty_1.isBoundsAware)(currentContainer)) {
            const bounds = currentContainer.bounds;
            const elementOptions = this.getElementLayoutOptions(currentContainer);
            const width = (_a4 = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefWidth) !== null && _a4 !== void 0 ? _a4 : 0;
            const height = (_b2 = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefHeight) !== null && _b2 !== void 0 ? _b2 : 0;
            return { ...bounds, width, height };
          }
          return sprotty_1.Bounds.EMPTY;
        }
        getChildLayoutOptions(child, containerOptions) {
          return super.getChildLayoutOptions(child, this.filterContainerOptions(containerOptions));
        }
        getLayoutOptions(element) {
          return super.getLayoutOptions(element);
        }
        getElementLayoutOptions(element) {
          return element.layoutOptions;
        }
        getComputedContainerDimensions(options, maxWidth, maxHeight) {
          return {
            width: maxWidth + options.paddingLeft + options.paddingRight,
            height: maxHeight + options.paddingTop + options.paddingBottom
          };
        }
        getFinalContainerBounds(container, lastOffset, options, computedWidth, computedHeight) {
          var _a4, _b2;
          const elementOptions = this.getElementLayoutOptions(container);
          const width = (_a4 = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefWidth) !== null && _a4 !== void 0 ? _a4 : options.minWidth;
          const height = (_b2 = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefHeight) !== null && _b2 !== void 0 ? _b2 : options.minHeight;
          const result = {
            x: container.bounds.x,
            y: container.bounds.y,
            width: Math.max(width, computedWidth),
            height: Math.max(height, computedHeight)
          };
          return result;
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            hGap: 1,
            vAlign: "center",
            minWidth: 0,
            minHeight: 0,
            hGrab: false,
            vGrab: false,
            // eslint-disable-next-line no-null/no-null
            prefHeight: null,
            // eslint-disable-next-line no-null/no-null
            prefWidth: null
          };
        }
        filterContainerOptions(containerOptions) {
          const localOptions = { vGrab: false, hGrab: false, prefHeight: null, prefWidth: null };
          return { ...containerOptions, ...localOptions };
        }
      };
      exports.HBoxLayouterExt = HBoxLayouterExt;
      HBoxLayouterExt.KIND = sprotty_1.HBoxLayouter.KIND;
      exports.HBoxLayouterExt = HBoxLayouterExt = __decorate([
        (0, inversify_1.injectable)()
      ], HBoxLayouterExt);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/layouter.js
  var require_layouter = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/layouter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StatefulLayouterExt = exports.LayouterExt = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var LayouterExt = class LayouterExt extends sprotty_1.Layouter {
        layout(element2boundsData) {
          new StatefulLayouterExt(element2boundsData, this.layoutRegistry, this.logger).layout();
        }
      };
      exports.LayouterExt = LayouterExt;
      exports.LayouterExt = LayouterExt = __decorate([
        (0, inversify_1.injectable)()
      ], LayouterExt);
      var StatefulLayouterExt = class extends sprotty_1.StatefulLayouter {
        /**
         *
         * @param elementToBoundsData The map of element to bounds data. Bounds Data are computed from the hidden
         * SVG rendering pass.
         * @param layoutRegistry2 The registry of available layouts.
         * @param log The log.
         */
        constructor(elementToBoundsData, layoutRegistry2, log) {
          super(elementToBoundsData, layoutRegistry2, log);
          this.elementToBoundsData = elementToBoundsData;
          this.layoutRegistry2 = layoutRegistry2;
          this.toBeLayouted2 = [];
          elementToBoundsData.forEach((data, element) => {
            if ((0, sprotty_1.isLayoutContainer)(element)) {
              this.toBeLayouted2.push(element);
            }
          });
          for (const element of this.toBeLayouted2) {
            elementToBoundsData.delete(element);
          }
        }
        getBoundsData(element) {
          let boundsData = this.elementToBoundsData.get(element);
          let bounds = element.bounds;
          if ((0, sprotty_1.isLayoutContainer)(element) && this.toBeLayouted2.indexOf(element) >= 0) {
            bounds = this.doLayout(element);
          } else if ((0, sprotty_1.isLayoutContainer)(element)) {
            bounds = {
              x: 0,
              y: 0,
              width: -1,
              height: -1
            };
          }
          if (!boundsData) {
            boundsData = {
              bounds,
              boundsChanged: false,
              alignmentChanged: false
            };
            this.elementToBoundsData.set(element, boundsData);
          }
          return boundsData;
        }
        layout() {
          while (this.toBeLayouted2.length > 0) {
            const element = this.toBeLayouted2[0];
            this.doLayout(element);
          }
          this.toBeLayouted2 = [];
          this.elementToBoundsData.forEach((data, element) => {
            if ((0, sprotty_1.isLayoutContainer)(element)) {
              this.toBeLayouted2.push(element);
            }
          });
          while (this.toBeLayouted2.length > 0) {
            const element = this.toBeLayouted2[0];
            this.doLayout(element);
          }
        }
        doLayout(element) {
          const index = this.toBeLayouted2.indexOf(element);
          if (index >= 0) {
            this.toBeLayouted2.splice(index, 1);
          }
          const layout = this.layoutRegistry2.get(element.layout);
          if (layout) {
            layout.layout(element, this);
          }
          const boundsData = this.elementToBoundsData.get(element);
          if (boundsData !== void 0 && boundsData.bounds !== void 0) {
            return boundsData.bounds;
          } else {
            this.log.error(element, "Layout failed");
            return sprotty_1.Bounds.EMPTY;
          }
        }
      };
      exports.StatefulLayouterExt = StatefulLayouterExt;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/set-bounds-feedback-command.js
  var require_set_bounds_feedback_command = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/set-bounds-feedback-command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetBoundsFeedbackCommand = exports.SetBoundsFeedbackAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ranked_1 = require_ranked();
      var local_bounds_1 = require_local_bounds();
      var SetBoundsFeedbackAction;
      (function(SetBoundsFeedbackAction2) {
        SetBoundsFeedbackAction2.KIND = "setBoundsFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, SetBoundsFeedbackAction2.KIND);
        }
        SetBoundsFeedbackAction2.is = is;
        function create(bounds) {
          return { kind: SetBoundsFeedbackAction2.KIND, bounds };
        }
        SetBoundsFeedbackAction2.create = create;
      })(SetBoundsFeedbackAction || (exports.SetBoundsFeedbackAction = SetBoundsFeedbackAction = {}));
      var SetBoundsFeedbackCommand = class SetBoundsFeedbackCommand extends sprotty_1.SetBoundsCommand {
        constructor() {
          super(...arguments);
          this.rank = ranked_1.Ranked.DEFAULT_RANK;
        }
        execute(context) {
          super.execute(context);
          this.action.bounds.forEach((bounds) => {
            var _a4;
            const element = context.root.index.getById(bounds.elementId);
            if (element && (0, sprotty_1.isLayoutContainer)(element)) {
              const options = (_a4 = element.layoutOptions) !== null && _a4 !== void 0 ? _a4 : {};
              options.prefHeight = bounds.newSize.height;
              options.prefWidth = bounds.newSize.width;
              element.layoutOptions = options;
            }
          });
          const elementIDs = this.action.bounds.map((bounds) => bounds.elementId);
          return local_bounds_1.LocalRequestBoundsAction.fromCommand(context, this.actionDispatcher, this.action, elementIDs);
        }
      };
      exports.SetBoundsFeedbackCommand = SetBoundsFeedbackCommand;
      SetBoundsFeedbackCommand.KIND = SetBoundsFeedbackAction.KIND;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], SetBoundsFeedbackCommand.prototype, "actionDispatcher", void 0);
      exports.SetBoundsFeedbackCommand = SetBoundsFeedbackCommand = __decorate([
        (0, inversify_1.injectable)()
      ], SetBoundsFeedbackCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/vbox-layout.js
  var require_vbox_layout2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/vbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VBoxLayouterExt = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var layout_data_1 = require_layout_data();
      var VBoxLayouterExt = class VBoxLayouterExt extends sprotty_1.VBoxLayouter {
        layout(container, layouter) {
          var _a4, _b2;
          const boundsData = layouter.getBoundsData(container);
          const options = this.getLayoutOptions(container);
          const childrenSize = this.getChildrenSize(container, options, layouter);
          const fixedSize = this.getFixedContainerBounds(container, options, layouter);
          const currentWidth = (((_a4 = boundsData.bounds) === null || _a4 === void 0 ? void 0 : _a4.width) || 0) - options.paddingLeft - options.paddingRight;
          const currentHeight = (((_b2 = boundsData.bounds) === null || _b2 === void 0 ? void 0 : _b2.height) || 0) - options.paddingTop - options.paddingBottom;
          const maxWidth = options.paddingFactor * (options.resizeContainer ? Math.max(fixedSize.width - options.paddingLeft - options.paddingRight, childrenSize.width) : Math.max(0, fixedSize.width - options.paddingLeft - options.paddingRight));
          const maxHeight = options.paddingFactor * (options.resizeContainer ? Math.max(fixedSize.height - options.paddingTop - options.paddingBottom, childrenSize.height) : Math.max(0, fixedSize.height - options.paddingTop - options.paddingBottom));
          const width = Math.max(currentWidth, maxWidth);
          const height = Math.max(currentHeight, maxHeight);
          const grabHeight = height - childrenSize.height;
          const grabbingChildren = container.children.map((child) => this.getChildLayoutOptions(child, options)).filter((opt) => opt.vGrab).length;
          if (maxWidth > 0 && maxHeight > 0) {
            const offset = this.layoutChildren(container, layouter, options, width, height, grabHeight, grabbingChildren);
            const computed = this.getComputedContainerDimensions(options, childrenSize.width, childrenSize.height);
            layout_data_1.LayoutAware.setComputedDimensions(boundsData, computed);
            boundsData.bounds = this.getFinalContainerBounds(container, offset, options, computed.width, computed.height);
            boundsData.boundsChanged = true;
          }
        }
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = -1;
          let maxHeight = 0;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, sprotty_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
                maxHeight += bounds.height;
                if (isFirst) {
                  isFirst = false;
                } else {
                  maxHeight += containerOptions.vGap;
                }
                maxWidth = Math.max(maxWidth, bounds.width);
              }
            }
          });
          const result = {
            width: maxWidth,
            height: maxHeight
          };
          return result;
        }
        layoutChildren(container, layouter, containerOptions, maxWidth, maxHeight, grabHeight, grabbingChildren) {
          let currentOffset = {
            x: containerOptions.paddingLeft + 0.5 * (maxWidth - maxWidth / containerOptions.paddingFactor),
            y: containerOptions.paddingTop + 0.5 * (maxHeight - maxHeight / containerOptions.paddingFactor)
          };
          container.children.forEach((child) => {
            if ((0, sprotty_1.isLayoutableChild)(child)) {
              const boundsData = layouter.getBoundsData(child);
              const bounds = boundsData.bounds;
              const childOptions = this.getChildLayoutOptions(child, containerOptions);
              if (bounds !== void 0 && sprotty_1.Dimension.isValid(bounds)) {
                currentOffset = this.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight, grabHeight, grabbingChildren);
              }
            }
          });
          return currentOffset;
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight, grabHeight, grabbingChildren) {
          const hAlign = childOptions.hGrab ? "left" : childOptions.hAlign;
          const dx = this.getDx(hAlign, bounds, maxWidth);
          let offset = super.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight);
          boundsData.bounds = {
            ...boundsData.bounds,
            x: currentOffset.x + dx,
            y: currentOffset.y
          };
          if (childOptions.hGrab) {
            boundsData.bounds = {
              x: boundsData.bounds.x,
              y: boundsData.bounds.y,
              width: maxWidth,
              height: boundsData.bounds.height
            };
            boundsData.boundsChanged = true;
          }
          if (childOptions.vGrab && grabHeight && grabbingChildren) {
            const height = boundsData.bounds.height + grabHeight / grabbingChildren;
            boundsData.bounds = {
              x: boundsData.bounds.x,
              y: boundsData.bounds.y,
              width: boundsData.bounds.width,
              height
            };
            boundsData.boundsChanged = true;
            offset = { x: currentOffset.x, y: currentOffset.y + height };
          }
          return offset;
        }
        getFixedContainerBounds(container, layoutOptions, layouter) {
          var _a4, _b2;
          const currentContainer = container;
          if ((0, sprotty_1.isBoundsAware)(currentContainer)) {
            const bounds = currentContainer.bounds;
            const elementOptions = this.getElementLayoutOptions(currentContainer);
            const width = (_a4 = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefWidth) !== null && _a4 !== void 0 ? _a4 : 0;
            const height = (_b2 = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefHeight) !== null && _b2 !== void 0 ? _b2 : 0;
            return { ...bounds, width, height };
          }
          return sprotty_1.Bounds.EMPTY;
        }
        getChildLayoutOptions(child, containerOptions) {
          return super.getChildLayoutOptions(child, this.filterContainerOptions(containerOptions));
        }
        getLayoutOptions(element) {
          return super.getLayoutOptions(element);
        }
        getElementLayoutOptions(element) {
          return element.layoutOptions;
        }
        getComputedContainerDimensions(options, maxWidth, maxHeight) {
          return {
            width: maxWidth + options.paddingLeft + options.paddingRight,
            height: maxHeight + options.paddingTop + options.paddingBottom
          };
        }
        getFinalContainerBounds(container, lastOffset, options, computedWidth, computedHeight) {
          var _a4, _b2;
          const elementOptions = this.getElementLayoutOptions(container);
          const width = (_a4 = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefWidth) !== null && _a4 !== void 0 ? _a4 : options.minWidth;
          const height = (_b2 = elementOptions === null || elementOptions === void 0 ? void 0 : elementOptions.prefHeight) !== null && _b2 !== void 0 ? _b2 : options.minHeight;
          const result = {
            x: container.bounds.x,
            y: container.bounds.y,
            width: Math.max(width, computedWidth),
            height: Math.max(height, computedHeight)
          };
          return result;
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            vGap: 1,
            hAlign: "center",
            minWidth: 0,
            minHeight: 0,
            hGrab: false,
            vGrab: false,
            // eslint-disable-next-line no-null/no-null
            prefHeight: null,
            // eslint-disable-next-line no-null/no-null
            prefWidth: null
          };
        }
        filterContainerOptions(containerOptions) {
          const localOptions = { vGrab: false, hGrab: false, prefHeight: null, prefWidth: null };
          return { ...containerOptions, ...localOptions };
        }
      };
      exports.VBoxLayouterExt = VBoxLayouterExt;
      VBoxLayouterExt.KIND = sprotty_1.VBoxLayouter.KIND;
      exports.VBoxLayouterExt = VBoxLayouterExt = __decorate([
        (0, inversify_1.injectable)()
      ], VBoxLayouterExt);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/bounds/bounds-module.js
  var require_bounds_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/bounds/bounds-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.boundsModule = void 0;
      var sprotty_1 = require_lib4();
      var move_element_action_1 = require_move_element_action();
      var move_element_handler_1 = require_move_element_handler();
      var position_snapper_1 = require_position_snapper();
      var freeform_layout_1 = require_freeform_layout();
      var glsp_hidden_bounds_updater_1 = require_glsp_hidden_bounds_updater();
      var hbox_layout_1 = require_hbox_layout2();
      var layouter_1 = require_layouter();
      var local_bounds_1 = require_local_bounds();
      var set_bounds_feedback_command_1 = require_set_bounds_feedback_command();
      var vbox_layout_1 = require_vbox_layout2();
      exports.boundsModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, _rebind) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureCommand)(context, sprotty_1.SetBoundsCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.RequestBoundsCommand);
        bind(sprotty_1.HiddenBoundsUpdater).toSelf().inSingletonScope();
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.HiddenVNodePostprocessor, glsp_hidden_bounds_updater_1.GLSPHiddenBoundsUpdater);
        (0, sprotty_1.configureCommand)(context, local_bounds_1.LocalComputedBoundsCommand);
        (0, sprotty_1.configureCommand)(context, set_bounds_feedback_command_1.SetBoundsFeedbackCommand);
        bind(sprotty_1.TYPES.Layouter).to(layouter_1.LayouterExt).inSingletonScope();
        bind(sprotty_1.TYPES.LayoutRegistry).to(sprotty_1.LayoutRegistry).inSingletonScope();
        (0, sprotty_1.configureLayout)(context, sprotty_1.VBoxLayouter.KIND, vbox_layout_1.VBoxLayouterExt);
        (0, sprotty_1.configureLayout)(context, sprotty_1.HBoxLayouter.KIND, hbox_layout_1.HBoxLayouterExt);
        (0, sprotty_1.configureLayout)(context, freeform_layout_1.FreeFormLayouter.KIND, freeform_layout_1.FreeFormLayouter);
        bind(move_element_handler_1.MoveElementHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, move_element_action_1.MoveElementRelativeAction.KIND, move_element_handler_1.MoveElementHandler);
        bind(position_snapper_1.PositionSnapper).toSelf();
      }, { featureId: Symbol("bounds") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-handler.js
  var require_toast_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-handler.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShowToastMessageAction = exports.HideToastAction = void 0;
      var sprotty_1 = require_lib4();
      var HideToastAction;
      (function(HideToastAction2) {
        HideToastAction2.KIND = "hideToastMessageAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, HideToastAction2.KIND);
        }
        HideToastAction2.is = is;
        function create(options) {
          return { kind: HideToastAction2.KIND, options };
        }
        HideToastAction2.create = create;
      })(HideToastAction || (exports.HideToastAction = HideToastAction = {}));
      var ShowToastMessageAction;
      (function(ShowToastMessageAction2) {
        ShowToastMessageAction2.KIND = "showToastMessageAction";
        ShowToastMessageAction2.TIMEOUT = 2e3;
        function is(object) {
          return sprotty_1.Action.hasKind(object, ShowToastMessageAction2.KIND);
        }
        ShowToastMessageAction2.is = is;
        function create(options) {
          var _a4, _b2;
          return { kind: ShowToastMessageAction2.KIND, options: { ...options, position: (_a4 = options.position) !== null && _a4 !== void 0 ? _a4 : "center", id: (_b2 = options.id) !== null && _b2 !== void 0 ? _b2 : Symbol("toast id") } };
        }
        ShowToastMessageAction2.create = create;
        function createWithTimeout(options) {
          var _a4, _b2;
          return {
            kind: ShowToastMessageAction2.KIND,
            options: { timeout: ShowToastMessageAction2.TIMEOUT, ...options, position: (_a4 = options.position) !== null && _a4 !== void 0 ? _a4 : "center", id: (_b2 = options.id) !== null && _b2 !== void 0 ? _b2 : Symbol("toast id") }
          };
        }
        ShowToastMessageAction2.createWithTimeout = createWithTimeout;
      })(ShowToastMessageAction || (exports.ShowToastMessageAction = ShowToastMessageAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/grid/grid.js
  var require_grid = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/grid/grid.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Grid = void 0;
      var Grid;
      (function(Grid2) {
        Grid2.DEFAULT = { x: 10, y: 10 };
      })(Grid || (exports.Grid = Grid = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/resize/resize-handler.js
  var require_resize_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/resize/resize-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResizeElementHandler = exports.ResizeElementAction = exports.ResizeType = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var lodash_1 = require_lodash();
      var editor_context_service_1 = require_editor_context_service();
      var gmodel_util_1 = require_gmodel_util();
      var layout_utils_1 = require_layout_utils();
      var grid_1 = require_grid();
      var ResizeType;
      (function(ResizeType2) {
        ResizeType2[ResizeType2["Increase"] = 0] = "Increase";
        ResizeType2[ResizeType2["Decrease"] = 1] = "Decrease";
        ResizeType2[ResizeType2["MinSize"] = 2] = "MinSize";
      })(ResizeType || (exports.ResizeType = ResizeType = {}));
      var ResizeElementAction;
      (function(ResizeElementAction2) {
        ResizeElementAction2.KIND = "resizeElementAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ResizeElementAction2.KIND);
        }
        ResizeElementAction2.is = is;
        function create(elementIds, resizeType) {
          return { kind: ResizeElementAction2.KIND, elementIds, resizeType };
        }
        ResizeElementAction2.create = create;
      })(ResizeElementAction || (exports.ResizeElementAction = ResizeElementAction = {}));
      var ResizeElementHandler = class ResizeElementHandler {
        constructor() {
          this.grid = grid_1.Grid.DEFAULT;
        }
        init() {
          this.resizeFeedback = this.feedbackDispatcher.createEmitter();
        }
        handle(action) {
          if (ResizeElementAction.is(action)) {
            this.handleResizeElement(action);
          }
        }
        handleResizeElement(action) {
          var _a4;
          const elements = (0, gmodel_util_1.getElements)(this.editorContextService.modelRoot.index, action.elementIds, gmodel_util_1.isSelectableAndBoundsAware);
          const elementAndBounds = this.computeElementAndBounds(elements, action);
          this.resizeFeedback.add(sprotty_1.SetBoundsAction.create(elementAndBounds)).submit();
          (_a4 = this.debouncedChangeBounds) === null || _a4 === void 0 ? void 0 : _a4.cancel();
          this.debouncedChangeBounds = (0, lodash_1.debounce)(() => {
            this.resizeFeedback.dispose();
            this.dispatcher.dispatchAll([sprotty_1.ChangeBoundsOperation.create(elementAndBounds)]);
            this.debouncedChangeBounds = void 0;
          }, 300);
          this.debouncedChangeBounds();
        }
        computeElementAndBounds(elements, action) {
          const elementAndBounds = [];
          elements.forEach((element) => {
            const { x: x3, y: y3, width: oldWidth, height: oldHeight } = element.bounds;
            let width = 0;
            let height = 0;
            if (action.resizeType === ResizeType.Decrease) {
              width = oldWidth - this.grid.x;
              height = oldHeight - this.grid.y;
            } else if (action.resizeType === ResizeType.Increase) {
              width = oldWidth + this.grid.x;
              height = oldHeight + this.grid.y;
            } else if (action.resizeType === ResizeType.MinSize) {
              width = (0, layout_utils_1.minWidth)(element);
              height = (0, layout_utils_1.minHeight)(element);
            }
            if (this.isValidBoundChange(element, { x: x3, y: y3 }, { width, height })) {
              const resizeElement = { id: element.id, bounds: { x: x3, y: y3, width, height } };
              elementAndBounds.push((0, gmodel_util_1.toElementAndBounds)(resizeElement));
            }
          });
          return elementAndBounds;
        }
        isValidBoundChange(element, newPosition, newSize) {
          return (0, layout_utils_1.isValidSize)(element, newSize) && (0, layout_utils_1.isValidMove)(element, newPosition);
        }
      };
      exports.ResizeElementHandler = ResizeElementHandler;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ResizeElementHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ResizeElementHandler.prototype, "dispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], ResizeElementHandler.prototype, "feedbackDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.Grid),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ResizeElementHandler.prototype, "grid", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ResizeElementHandler.prototype, "snapper", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], ResizeElementHandler.prototype, "init", null);
      exports.ResizeElementHandler = ResizeElementHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ResizeElementHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/resize/resize-tool.js
  var require_resize_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/resize/resize-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var ResizeKeyTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResizeKeyTool = exports.ResizeKeyListener = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var vscode_jsonrpc_1 = require_main();
      var messages_1 = require_messages3();
      var selection_service_1 = require_selection_service();
      var toast_handler_1 = require_toast_handler();
      var base_tools_1 = require_base_tools();
      var model_1 = require_model19();
      var resize_handler_1 = require_resize_handler();
      var ResizeKeyListener = class ResizeKeyListener extends sprotty_1.KeyListener {
        keyDown(element, event) {
          const actions = [];
          const selectedElementsIds = this.selectionService.getSelectedElements().filter(model_1.isResizable).map((e2) => e2.id);
          if (selectedElementsIds.length > 0) {
            if (this.matchesIncreaseSizeKeystroke(event)) {
              actions.push(resize_handler_1.ResizeElementAction.create(selectedElementsIds, resize_handler_1.ResizeType.Increase));
            } else if (this.matchesDecreaseSizeKeystroke(event)) {
              actions.push(resize_handler_1.ResizeElementAction.create(selectedElementsIds, resize_handler_1.ResizeType.Decrease));
            } else if (this.matchesMinSizeKeystroke(event)) {
              actions.push(resize_handler_1.ResizeElementAction.create(selectedElementsIds, resize_handler_1.ResizeType.MinSize));
            }
          }
          return actions;
        }
        enable() {
          return [
            toast_handler_1.ShowToastMessageAction.create({
              id: ResizeKeyTool.TOKEN,
              message: messages_1.messages.resize.resize_mode_activated
            })
          ];
        }
        disable() {
          return [
            toast_handler_1.ShowToastMessageAction.createWithTimeout({
              id: ResizeKeyTool.TOKEN,
              message: messages_1.messages.resize.resize_mode_deactivated
            })
          ];
        }
        matchesIncreaseSizeKeystroke(event) {
          return event.key === "+" || (0, sprotty_1.matchesKeystroke)(event, "NumpadAdd");
        }
        matchesMinSizeKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Digit0", "ctrl") || (0, sprotty_1.matchesKeystroke)(event, "Numpad0", "ctrl");
        }
        matchesDecreaseSizeKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Minus") || (0, sprotty_1.matchesKeystroke)(event, "NumpadSubtract");
        }
      };
      exports.ResizeKeyListener = ResizeKeyListener;
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], ResizeKeyListener.prototype, "selectionService", void 0);
      exports.ResizeKeyListener = ResizeKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], ResizeKeyListener);
      var ResizeKeyTool = ResizeKeyTool_1 = class ResizeKeyTool extends base_tools_1.BaseEditTool {
        get id() {
          return ResizeKeyTool_1.ID;
        }
        enable() {
          this.dispatchActions(this.keyListener.enable());
          this.toDisposeOnDisable.push(this.keyTool.registerListener(this.keyListener), (0, messages_1.repeatOnMessagesUpdated)(() => this.shortcutManager.register(ResizeKeyTool_1.TOKEN, [
            {
              shortcuts: ["Escape"],
              description: messages_1.messages.resize.shortcut_deactivate,
              group: messages_1.messages.shortcut.group_resize,
              position: 0
            },
            {
              shortcuts: ["+"],
              description: messages_1.messages.resize.shortcut_increase,
              group: messages_1.messages.shortcut.group_resize,
              position: 1
            },
            {
              shortcuts: ["-"],
              description: messages_1.messages.resize.shortcut_decrease,
              group: messages_1.messages.shortcut.group_resize,
              position: 2
            },
            {
              shortcuts: ["CTRL", "0"],
              description: messages_1.messages.resize.shortcut_reset,
              group: messages_1.messages.shortcut.group_resize,
              position: 3
            }
          ])), vscode_jsonrpc_1.Disposable.create(() => {
            this.dispatchActions(this.keyListener.disable());
          }));
        }
      };
      exports.ResizeKeyTool = ResizeKeyTool;
      ResizeKeyTool.ID = "glsp.resize-key-tool";
      ResizeKeyTool.TOKEN = Symbol.for(ResizeKeyTool_1.name);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
        __metadata("design:type", Function)
      ], ResizeKeyTool.prototype, "shortcutManager", void 0);
      __decorate([
        (0, inversify_1.inject)(ResizeKeyListener),
        __metadata("design:type", ResizeKeyListener)
      ], ResizeKeyTool.prototype, "keyListener", void 0);
      exports.ResizeKeyTool = ResizeKeyTool = ResizeKeyTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ResizeKeyTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/resize/resize-default-tool.js
  var require_resize_default_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/resize/resize-default-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var DefaultResizeKeyTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultResizeKeyTool = exports.DefaultResizeKeyListener = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var messages_1 = require_messages3();
      var selection_service_1 = require_selection_service();
      var tool_1 = require_tool();
      var base_tools_1 = require_base_tools();
      var model_1 = require_model19();
      var resize_tool_1 = require_resize_tool();
      var DefaultResizeKeyListener = class DefaultResizeKeyListener extends sprotty_1.KeyListener {
        keyDown(element, event) {
          const selectedElementsIds = this.selectionService.getSelectedElements().filter(model_1.isResizable).map((e2) => e2.id);
          if (selectedElementsIds.length > 0) {
            if (this.matchesActivateResizeModeKeystroke(event)) {
              return [tool_1.EnableToolsAction.create([resize_tool_1.ResizeKeyTool.ID])];
            }
          }
          return [];
        }
        matchesActivateResizeModeKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "KeyA", "alt");
        }
      };
      exports.DefaultResizeKeyListener = DefaultResizeKeyListener;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], DefaultResizeKeyListener.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], DefaultResizeKeyListener.prototype, "selectionService", void 0);
      exports.DefaultResizeKeyListener = DefaultResizeKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], DefaultResizeKeyListener);
      var DefaultResizeKeyTool = DefaultResizeKeyTool_1 = class DefaultResizeKeyTool extends base_tools_1.BaseEditTool {
        get id() {
          return DefaultResizeKeyTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.keyTool.registerListener(this.keyListener), (0, messages_1.repeatOnMessagesUpdated)(() => this.shortcutManager.register(DefaultResizeKeyTool_1.TOKEN, [
            {
              shortcuts: ["ALT", "A"],
              description: messages_1.messages.resize.shortcut_activate,
              group: messages_1.messages.shortcut.group_resize,
              position: 0
            }
          ])));
        }
      };
      exports.DefaultResizeKeyTool = DefaultResizeKeyTool;
      DefaultResizeKeyTool.ID = "glsp.default-resize-key-tool";
      DefaultResizeKeyTool.TOKEN = Symbol.for(DefaultResizeKeyTool_1.name);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
        __metadata("design:type", Function)
      ], DefaultResizeKeyTool.prototype, "shortcutManager", void 0);
      __decorate([
        (0, inversify_1.inject)(DefaultResizeKeyListener),
        __metadata("design:type", DefaultResizeKeyListener)
      ], DefaultResizeKeyTool.prototype, "keyListener", void 0);
      exports.DefaultResizeKeyTool = DefaultResizeKeyTool = DefaultResizeKeyTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], DefaultResizeKeyTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/resize/resize-module.js
  var require_resize_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/resize/resize-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneResizeModule = exports.resizeModule = void 0;
      var sprotty_1 = require_lib4();
      var resize_default_tool_1 = require_resize_default_tool();
      var resize_handler_1 = require_resize_handler();
      var resize_tool_1 = require_resize_tool();
      exports.resizeModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.configureActionHandler)(context, resize_handler_1.ResizeElementAction.KIND, resize_handler_1.ResizeElementHandler);
      }, { featureId: Symbol("resize") });
      exports.standaloneResizeModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, resize_default_tool_1.DefaultResizeKeyTool);
        context.bind(resize_default_tool_1.DefaultResizeKeyListener).toSelf();
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITool, resize_tool_1.ResizeKeyTool);
        context.bind(resize_tool_1.ResizeKeyListener).toSelf();
      }, { featureId: Symbol("standaloneResize"), requires: exports.resizeModule });
    }
  });

  // node_modules/@eclipse-glsp/client/css/command-palette.css
  var require_command_palette2 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/command-palette.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette.js
  var require_command_palette3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GlspCommandPalette = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ui_extension_1 = require_ui_extension2();
      var GlspCommandPalette = class GlspCommandPalette extends sprotty_1.CommandPalette {
        initializeContents(containerElement) {
          super.initializeContents(containerElement);
          containerElement.classList.add(ui_extension_1.CSS_UI_EXTENSION_CLASS);
        }
        setContainerVisible(visible) {
          var _a4, _b2;
          if (visible) {
            (_a4 = this.containerElement) === null || _a4 === void 0 ? void 0 : _a4.classList.remove(ui_extension_1.CSS_HIDDEN_EXTENSION_CLASS);
          } else {
            (_b2 = this.containerElement) === null || _b2 === void 0 ? void 0 : _b2.classList.add(ui_extension_1.CSS_HIDDEN_EXTENSION_CLASS);
          }
        }
      };
      exports.GlspCommandPalette = GlspCommandPalette;
      exports.GlspCommandPalette = GlspCommandPalette = __decorate([
        (0, inversify_1.injectable)()
      ], GlspCommandPalette);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette-tool.js
  var require_command_palette_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var CommandPaletteTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommandPaletteTool = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var CommandPaletteTool = CommandPaletteTool_1 = class CommandPaletteTool {
        postConstruct() {
          this.commandPaletteKeyListener = this.createCommandPaletteKeyListener();
        }
        get id() {
          return CommandPaletteTool_1.ID;
        }
        enable() {
          this.keyTool.register(this.commandPaletteKeyListener);
        }
        disable() {
          this.keyTool.deregister(this.commandPaletteKeyListener);
        }
        createCommandPaletteKeyListener() {
          return new sprotty_1.CommandPaletteKeyListener();
        }
      };
      exports.CommandPaletteTool = CommandPaletteTool;
      CommandPaletteTool.ID = "glsp.command-palette-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], CommandPaletteTool.prototype, "keyTool", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], CommandPaletteTool.prototype, "postConstruct", null);
      exports.CommandPaletteTool = CommandPaletteTool = CommandPaletteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], CommandPaletteTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/command-palette/server-command-palette-provider.js
  var require_server_command_palette_provider = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/command-palette/server-command-palette-provider.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ServerCommandPaletteActionProvider = exports.ServerCommandPalette = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var ServerCommandPalette;
      (function(ServerCommandPalette2) {
        ServerCommandPalette2.CONTEXT_ID = "command-palette";
        ServerCommandPalette2.TEXT = "text";
        ServerCommandPalette2.INDEX = "index";
      })(ServerCommandPalette || (exports.ServerCommandPalette = ServerCommandPalette = {}));
      var ServerCommandPaletteActionProvider = class ServerCommandPaletteActionProvider {
        async getActions(_root, text, _lastMousePosition, index) {
          const requestAction = sprotty_1.RequestContextActions.create({
            contextId: ServerCommandPalette.CONTEXT_ID,
            editorContext: this.editorContext.get({
              [ServerCommandPalette.TEXT]: text,
              [ServerCommandPalette.INDEX]: index ? index : 0
            })
          });
          const response = await this.actionDispatcher.requestUntil(requestAction);
          return response ? this.getPaletteActionsFromResponse(response) : [];
        }
        getPaletteActionsFromResponse(action) {
          if (sprotty_1.SetContextActions.is(action)) {
            return action.actions;
          }
          return [];
        }
      };
      exports.ServerCommandPaletteActionProvider = ServerCommandPaletteActionProvider;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ServerCommandPaletteActionProvider.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ServerCommandPaletteActionProvider.prototype, "editorContext", void 0);
      exports.ServerCommandPaletteActionProvider = ServerCommandPaletteActionProvider = __decorate([
        (0, inversify_1.injectable)()
      ], ServerCommandPaletteActionProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette-module.js
  var require_command_palette_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/command-palette/command-palette-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.commandPaletteModule = void 0;
      var sprotty_1 = require_lib4();
      require_command_palette2();
      var command_palette_1 = require_command_palette3();
      var command_palette_tool_1 = require_command_palette_tool();
      var server_command_palette_provider_1 = require_server_command_palette_provider();
      exports.commandPaletteModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IUIExtension, command_palette_1.GlspCommandPalette);
        bind(sprotty_1.TYPES.ICommandPaletteActionProviderRegistry).to(sprotty_1.CommandPaletteActionProviderRegistry).inSingletonScope();
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.ICommandPaletteActionProvider, server_command_palette_provider_1.ServerCommandPaletteActionProvider);
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IDefaultTool, command_palette_tool_1.CommandPaletteTool);
      }, { featureId: Symbol("commandPalette") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/context-menu/glsp-context-menu-mouse-listener.js
  var require_glsp_context_menu_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/context-menu/glsp-context-menu-mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPContextMenuMouseListener = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var GLSPContextMenuMouseListener = class GLSPContextMenuMouseListener extends sprotty_1.MouseListener {
        initialize() {
          var _a4;
          (_a4 = this.contextMenuServiceProvider) === null || _a4 === void 0 ? void 0 : _a4.call(this).then((menuService) => this.menuService = menuService);
        }
        /**
         * Opens the context menu.
         */
        contextMenu(target, event) {
          return this.openContextMenu(target, event);
        }
        /**
         * Opens the context menu.
         *
         *   - update selection state (if context menu target is selectable)
         *   - query the context menu service and the context menu elements
         *   - show the context menu
         *   - send a focus state change to indicate that the diagram becomes inactive, once the context menu is shown
         *
         * When the context menu is closed, we focus the diagram element again.
         */
        openContextMenu(target, event) {
          if (!this.menuService || !this.menuProvider) {
            return [];
          }
          return [this.showContextMenuItems(target, event)];
        }
        async showContextMenuItems(target, event) {
          await this.handleContextElementSelection(target, event);
          const mousePosition = { x: event.x, y: event.y };
          const menuItems = await this.menuProvider.getItems(target.root, mousePosition);
          this.menuService.show(menuItems, mousePosition, () => this.focusEventTarget(event));
          return focus_state_change_action_1.FocusStateChangedAction.create(false);
        }
        // Clear selection if the context menu target is not selectable
        // Otherwise either maintain current selection if target is already selected or single select the current target.
        async handleContextElementSelection(target, event) {
          const selectableTarget = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isSelectable);
          if (!selectableTarget) {
            return this.actionDispatcher.dispatch(sprotty_1.SelectAction.setSelection([]));
          }
          if (!selectableTarget.selected) {
            return this.actionDispatcher.dispatch(sprotty_1.SelectAction.setSelection([selectableTarget.id]));
          }
          return;
        }
        focusEventTarget(event) {
          const targetElement = event.target instanceof SVGElement ? event.target : void 0;
          const svgParentElement = targetElement === null || targetElement === void 0 ? void 0 : targetElement.closest("svg");
          if (svgParentElement) {
            svgParentElement.focus();
          }
        }
      };
      exports.GLSPContextMenuMouseListener = GLSPContextMenuMouseListener;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IContextMenuServiceProvider),
        (0, inversify_1.optional)(),
        __metadata("design:type", Function)
      ], GLSPContextMenuMouseListener.prototype, "contextMenuServiceProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IContextMenuProviderRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.ContextMenuProviderRegistry)
      ], GLSPContextMenuMouseListener.prototype, "menuProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], GLSPContextMenuMouseListener.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], GLSPContextMenuMouseListener.prototype, "initialize", null);
      exports.GLSPContextMenuMouseListener = GLSPContextMenuMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPContextMenuMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/context-menu/server-context-menu-provider.js
  var require_server_context_menu_provider = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/context-menu/server-context-menu-provider.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ServerContextMenuItemProvider = exports.ServerContextMenu = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var ServerContextMenu;
      (function(ServerContextMenu2) {
        ServerContextMenu2.CONTEXT_ID = "context-menu";
      })(ServerContextMenu || (exports.ServerContextMenu = ServerContextMenu = {}));
      var ServerContextMenuItemProvider = class ServerContextMenuItemProvider {
        async getItems(root, _lastMousePosition) {
          const selectedElementIds = Array.from(root.index.all().filter(sprotty_1.isSelected).map((e2) => e2.id));
          const editorContext = this.editorContext.getWithSelection(selectedElementIds);
          const requestAction = sprotty_1.RequestContextActions.create({ contextId: ServerContextMenu.CONTEXT_ID, editorContext });
          const response = await this.actionDispatcher.requestUntil(requestAction);
          return response ? this.getContextActionsFromResponse(response) : [];
        }
        getContextActionsFromResponse(action) {
          if (sprotty_1.SetContextActions.is(action)) {
            return action.actions;
          }
          return [];
        }
      };
      exports.ServerContextMenuItemProvider = ServerContextMenuItemProvider;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ServerContextMenuItemProvider.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ServerContextMenuItemProvider.prototype, "editorContext", void 0);
      exports.ServerContextMenuItemProvider = ServerContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], ServerContextMenuItemProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/context-menu/context-menu-module.js
  var require_context_menu_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/context-menu/context-menu-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.contextMenuModule = void 0;
      var sprotty_1 = require_lib4();
      var glsp_context_menu_mouse_listener_1 = require_glsp_context_menu_mouse_listener();
      var server_context_menu_provider_1 = require_server_context_menu_provider();
      exports.contextMenuModule = new sprotty_1.FeatureModule((bind) => {
        bind(sprotty_1.TYPES.IContextMenuServiceProvider).toProvider((ctx) => async () => {
          if (ctx.container.isBound(sprotty_1.TYPES.IContextMenuService)) {
            return ctx.container.get(sprotty_1.TYPES.IContextMenuService);
          }
          console.warn("'TYPES.IContextMenuService' is not bound. Use no-op implementation instead");
          return { show: () => {
          } };
        });
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.MouseListener, glsp_context_menu_mouse_listener_1.GLSPContextMenuMouseListener);
        bind(sprotty_1.TYPES.IContextMenuProviderRegistry).to(sprotty_1.ContextMenuProviderRegistry);
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IContextMenuItemProvider, server_context_menu_provider_1.ServerContextMenuItemProvider);
      }, { featureId: Symbol("contextMenu") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-handler.js
  var require_copy_paste_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ServerCopyPasteHandler = exports.LocalClipboardService = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var uuid_1 = require_commonjs_browser();
      var editor_context_service_1 = require_editor_context_service();
      var LocalClipboardService = class LocalClipboardService {
        clear() {
          this.currentId = void 0;
          this.data = void 0;
        }
        put(data, id) {
          this.currentId = id;
          this.data = data;
        }
        get(id) {
          if (id !== this.currentId) {
            return void 0;
          }
          return this.data;
        }
      };
      exports.LocalClipboardService = LocalClipboardService;
      exports.LocalClipboardService = LocalClipboardService = __decorate([
        (0, inversify_1.injectable)()
      ], LocalClipboardService);
      function toClipboardId(clipboardId) {
        return JSON.stringify({ clipboardId });
      }
      function isClipboardId(jsonData) {
        return jsonData !== void 0 && "clipboardId" in jsonData;
      }
      function getClipboardIdFromDataTransfer(dataTransfer) {
        const jsonString = dataTransfer.getData(CLIPBOARD_DATA_FORMAT);
        const jsonObject = jsonString ? JSON.parse(jsonString) : void 0;
        return isClipboardId(jsonObject) ? jsonObject.clipboardId : void 0;
      }
      var CLIPBOARD_DATA_FORMAT = "text/plain";
      var ServerCopyPasteHandler = class ServerCopyPasteHandler {
        handleCopy(event) {
          if (event.clipboardData && this.shouldCopy(event)) {
            const clipboardId = (0, uuid_1.v4)();
            event.clipboardData.setData(CLIPBOARD_DATA_FORMAT, toClipboardId(clipboardId));
            this.actionDispatcher.request(sprotty_1.RequestClipboardDataAction.create(this.editorContext.get())).then((action) => this.clipboardService.put(action.clipboardData, clipboardId));
            event.preventDefault();
          } else {
            if (event.clipboardData) {
              event.clipboardData.clearData();
            }
            this.clipboardService.clear();
          }
        }
        handleCut(event) {
          if (event.clipboardData && this.shouldCopy(event)) {
            this.handleCopy(event);
            this.actionDispatcher.dispatch(sprotty_1.CutOperation.create(this.editorContext.get()));
            event.preventDefault();
          }
        }
        handlePaste(event) {
          if (event.clipboardData && this.shouldPaste(event)) {
            const clipboardId = getClipboardIdFromDataTransfer(event.clipboardData);
            const clipboardData = this.clipboardService.get(clipboardId);
            if (clipboardData) {
              this.actionDispatcher.dispatch(sprotty_1.PasteOperation.create({ clipboardData, editorContext: this.editorContext.get() }));
            }
            event.preventDefault();
          }
        }
        shouldCopy(_event) {
          return this.editorContext.get().selectedElementIds.length > 0 && this.isDiagramActive();
        }
        shouldPaste(_event) {
          return this.isDiagramActive();
        }
        isDiagramActive() {
          var _a4, _b2;
          return ((_b2 = (_a4 = document.activeElement) === null || _a4 === void 0 ? void 0 : _a4.parentElement) === null || _b2 === void 0 ? void 0 : _b2.id) === this.viewerOptions.baseDiv;
        }
      };
      exports.ServerCopyPasteHandler = ServerCopyPasteHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ServerCopyPasteHandler.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ServerCopyPasteHandler.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IAsyncClipboardService),
        __metadata("design:type", Object)
      ], ServerCopyPasteHandler.prototype, "clipboardService", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ServerCopyPasteHandler.prototype, "editorContext", void 0);
      exports.ServerCopyPasteHandler = ServerCopyPasteHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ServerCopyPasteHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-standalone.js
  var require_copy_paste_standalone = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-standalone.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CopyPasteStartup = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var CopyPasteStartup = class CopyPasteStartup {
        constructor() {
          this.toDispose = new sprotty_1.DisposableCollection();
        }
        modelRootChanged(root) {
          if (root.id !== sprotty_1.EMPTY_ROOT.id) {
            this.graphElementId = this.domHelper.createUniqueDOMElementId(root);
          }
        }
        postModelInitialization() {
          if (!this.copyPasteHandler) {
            return;
          }
          const copyListener = (e2) => {
            var _a4, _b2;
            if (this.graphElementId && ((_a4 = document.activeElement) === null || _a4 === void 0 ? void 0 : _a4.id) === this.graphElementId) {
              (_b2 = this.copyPasteHandler) === null || _b2 === void 0 ? void 0 : _b2.handleCopy(e2);
            }
          };
          const cutListener = (e2) => {
            var _a4, _b2;
            if (this.graphElementId && ((_a4 = document.activeElement) === null || _a4 === void 0 ? void 0 : _a4.id) === this.graphElementId) {
              (_b2 = this.copyPasteHandler) === null || _b2 === void 0 ? void 0 : _b2.handleCut(e2);
            }
          };
          const pasteListener = (e2) => {
            var _a4, _b2;
            if (this.graphElementId && ((_a4 = document.activeElement) === null || _a4 === void 0 ? void 0 : _a4.id) === this.graphElementId) {
              (_b2 = this.copyPasteHandler) === null || _b2 === void 0 ? void 0 : _b2.handlePaste(e2);
            }
          };
          window.addEventListener("copy", copyListener);
          window.addEventListener("cut", cutListener);
          window.addEventListener("paste", pasteListener);
          this.toDispose.push(sprotty_1.Disposable.create(() => {
            window.removeEventListener("copy", copyListener);
            window.removeEventListener("cut", cutListener);
            window.removeEventListener("paste", pasteListener);
          }));
        }
        dispose() {
          this.toDispose.dispose();
        }
      };
      exports.CopyPasteStartup = CopyPasteStartup;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ICopyPasteHandler),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], CopyPasteStartup.prototype, "copyPasteHandler", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.DOMHelper),
        __metadata("design:type", sprotty_1.DOMHelper)
      ], CopyPasteStartup.prototype, "domHelper", void 0);
      __decorate([
        (0, inversify_1.preDestroy)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], CopyPasteStartup.prototype, "dispose", null);
      exports.CopyPasteStartup = CopyPasteStartup = __decorate([
        (0, inversify_1.injectable)()
      ], CopyPasteStartup);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-modules.js
  var require_copy_paste_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneCopyPasteModule = exports.copyPasteModule = void 0;
      var sprotty_1 = require_lib4();
      var copy_paste_handler_1 = require_copy_paste_handler();
      var copy_paste_standalone_1 = require_copy_paste_standalone();
      exports.copyPasteModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        bind(sprotty_1.TYPES.ICopyPasteHandler).to(copy_paste_handler_1.ServerCopyPasteHandler);
        bind(sprotty_1.TYPES.IAsyncClipboardService).to(copy_paste_handler_1.LocalClipboardService).inSingletonScope();
      }, { featureId: Symbol("copyPaste") });
      exports.standaloneCopyPasteModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IDiagramStartup, copy_paste_standalone_1.CopyPasteStartup);
        bind(sprotty_1.TYPES.IGModelRootListener).toService(copy_paste_standalone_1.CopyPasteStartup);
      }, {
        featureId: Symbol("standaloneCopyPaste"),
        requires: exports.copyPasteModule
      });
    }
  });

  // node_modules/@eclipse-glsp/client/css/decoration.css
  var require_decoration = __commonJS({
    "node_modules/@eclipse-glsp/client/css/decoration.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/decoration/decoration-placer.js
  var require_decoration_placer2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/decoration/decoration-placer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var GlspDecorationPlacer_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GlspDecorationPlacer = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var GlspDecorationPlacer = GlspDecorationPlacer_1 = class GlspDecorationPlacer extends sprotty_1.DecorationPlacer {
        getPosition(element) {
          if (element instanceof sprotty_1.GChildElement && element.parent instanceof sprotty_1.GRoutableElement) {
            return super.getPosition(element);
          }
          if ((0, sprotty_1.isSizeable)(element)) {
            return {
              x: -GlspDecorationPlacer_1.DECORATION_OFFSET.x,
              y: -GlspDecorationPlacer_1.DECORATION_OFFSET.y
            };
          }
          return sprotty_1.Point.ORIGIN;
        }
      };
      exports.GlspDecorationPlacer = GlspDecorationPlacer;
      GlspDecorationPlacer.DECORATION_OFFSET = { x: 12, y: 10 };
      exports.GlspDecorationPlacer = GlspDecorationPlacer = GlspDecorationPlacer_1 = __decorate([
        (0, inversify_1.injectable)()
      ], GlspDecorationPlacer);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/decoration/decoration-module.js
  var require_decoration_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/decoration/decoration-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.decorationModule = void 0;
      var sprotty_1 = require_lib4();
      require_decoration();
      var decoration_placer_1 = require_decoration_placer2();
      exports.decorationModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IVNodePostprocessor, decoration_placer_1.GlspDecorationPlacer);
      }, { featureId: Symbol("decoration") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/element-template/add-template-element.js
  var require_add_template_element = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/element-template/add-template-element.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.templateToSchema = exports.AddTemplateElementsFeedbackCommand = exports.getTemplateElementId = exports.AddTemplateElementsAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var local_bounds_1 = require_local_bounds();
      var AddTemplateElementsAction;
      (function(AddTemplateElementsAction2) {
        AddTemplateElementsAction2.KIND = "addTemplateElements";
        function create(options) {
          return {
            kind: AddTemplateElementsAction2.KIND,
            ...options
          };
        }
        AddTemplateElementsAction2.create = create;
      })(AddTemplateElementsAction || (exports.AddTemplateElementsAction = AddTemplateElementsAction = {}));
      function getTemplateElementId(template) {
        return typeof template === "string" ? `${template}_feedback` : template.id;
      }
      exports.getTemplateElementId = getTemplateElementId;
      var AddTemplateElementsFeedbackCommand = class AddTemplateElementsFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const templateElements = this.action.templates.map((template) => templateToSchema(template, context)).filter(gmodel_util_1.isNotUndefined).map((schema) => context.modelFactory.createElement(schema)).map((element) => this.applyRootCssClasses(element, this.action.addClasses, this.action.removeClasses));
          templateElements.forEach((templateElement) => context.root.add(templateElement));
          const templateElementIDs = templateElements.map((element) => element.id);
          return local_bounds_1.LocalRequestBoundsAction.fromCommand(context, this.actionDispatcher, this.action, templateElementIDs);
        }
        applyRootCssClasses(element, addClasses, removeClasses) {
          element.cssClasses = modifyCssClasses(element.cssClasses, addClasses, removeClasses);
          return element;
        }
      };
      exports.AddTemplateElementsFeedbackCommand = AddTemplateElementsFeedbackCommand;
      AddTemplateElementsFeedbackCommand.KIND = AddTemplateElementsAction.KIND;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], AddTemplateElementsFeedbackCommand.prototype, "actionDispatcher", void 0);
      exports.AddTemplateElementsFeedbackCommand = AddTemplateElementsFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], AddTemplateElementsFeedbackCommand);
      function templateToSchema(template, context) {
        if (typeof template === "string") {
          const element = context.root.index.getById(template);
          const schema = element ? context.modelFactory.createSchema(element) : void 0;
          if (schema) {
            adaptSchemaIds(schema);
          }
          return schema;
        }
        return template;
      }
      exports.templateToSchema = templateToSchema;
      function adaptSchemaIds(schema) {
        var _a4;
        schema.id = getTemplateElementId(schema.id);
        (_a4 = schema.children) === null || _a4 === void 0 ? void 0 : _a4.forEach((child) => adaptSchemaIds(child));
        return schema;
      }
      function modifyCssClasses(source, toAdd, toRemove) {
        const classes = source !== null && source !== void 0 ? source : [];
        if (toAdd) {
          (0, sprotty_1.distinctAdd)(classes, ...toAdd);
        }
        if (toRemove) {
          (0, sprotty_1.remove)(classes, ...toRemove);
        }
        return classes;
      }
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/element-template/remove-template-element.js
  var require_remove_template_element = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/element-template/remove-template-element.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RemoveTemplateElementsFeedbackCommand = exports.RemoveTemplateElementsAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var feedback_command_1 = require_feedback_command();
      var add_template_element_1 = require_add_template_element();
      var RemoveTemplateElementsAction;
      (function(RemoveTemplateElementsAction2) {
        RemoveTemplateElementsAction2.KIND = "removeTemplateElements";
        function create(options) {
          return {
            kind: RemoveTemplateElementsAction2.KIND,
            ...options
          };
        }
        RemoveTemplateElementsAction2.create = create;
      })(RemoveTemplateElementsAction || (exports.RemoveTemplateElementsAction = RemoveTemplateElementsAction = {}));
      var RemoveTemplateElementsFeedbackCommand = class RemoveTemplateElementsFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const index = context.root.index;
          for (const template of this.action.templates) {
            const element = index.getById((0, add_template_element_1.getTemplateElementId)(template));
            if (element && element instanceof sprotty_1.GChildElement) {
              element.parent.remove(element);
            }
          }
          return context.root;
        }
      };
      exports.RemoveTemplateElementsFeedbackCommand = RemoveTemplateElementsFeedbackCommand;
      RemoveTemplateElementsFeedbackCommand.KIND = RemoveTemplateElementsAction.KIND;
      exports.RemoveTemplateElementsFeedbackCommand = RemoveTemplateElementsFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], RemoveTemplateElementsFeedbackCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/element-template/element-template-module.js
  var require_element_template_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/element-template/element-template-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.elementTemplateModule = void 0;
      var sprotty_1 = require_lib4();
      var add_template_element_1 = require_add_template_element();
      var remove_template_element_1 = require_remove_template_element();
      exports.elementTemplateModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.configureCommand)(context, add_template_element_1.AddTemplateElementsFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, remove_template_element_1.RemoveTemplateElementsFeedbackCommand);
      }, { featureId: Symbol("elementTemplate") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/export/export-svg-action-handler.js
  var require_export_svg_action_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/export/export-svg-action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExportSvgActionHandler = void 0;
      var file_saver_1 = require_FileSaver_min();
      var inversify_1 = require_cjs4();
      var ExportSvgActionHandler = class ExportSvgActionHandler {
        handle(action) {
          const blob = new Blob([action.svg], { type: "text/plain;charset=utf-8" });
          (0, file_saver_1.saveAs)(blob, "diagram.svg");
        }
      };
      exports.ExportSvgActionHandler = ExportSvgActionHandler;
      exports.ExportSvgActionHandler = ExportSvgActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ExportSvgActionHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/export/glsp-svg-exporter.js
  var require_glsp_svg_exporter = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/export/glsp-svg-exporter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPSvgExporter = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var uuid_1 = require_commonjs_browser();
      var GLSPSvgExporter = class GLSPSvgExporter extends sprotty_1.SvgExporter {
        export(root, request) {
          var _a4;
          if (typeof document !== "undefined") {
            let svgElement = this.findSvgElement();
            if (svgElement) {
              svgElement = this.prepareSvgElement(svgElement, root, request);
              const serializedSvg = this.createSvg(svgElement, root, (_a4 = request === null || request === void 0 ? void 0 : request.options) !== null && _a4 !== void 0 ? _a4 : {}, request);
              const svgExport = this.getSvgExport(serializedSvg, svgElement, root, request);
              this.actionDispatcher.dispatch(sprotty_1.ExportSvgAction.create(svgExport, { responseId: request === null || request === void 0 ? void 0 : request.requestId, options: request === null || request === void 0 ? void 0 : request.options }));
            }
          }
        }
        createSvg(svgElement, root, options, cause) {
          const originalId = svgElement.id;
          try {
            svgElement.id = originalId || (0, uuid_1.v4)();
            return super.createSvg(svgElement, root, options, cause);
          } finally {
            svgElement.id = originalId;
          }
        }
        findSvgElement() {
          const div = document.getElementById(this.options.hiddenDiv);
          return div && div.querySelector("svg");
        }
        prepareSvgElement(svgElement, root, request) {
          return svgElement;
        }
        copyStyles(source, target, skippedProperties) {
          this.copyStyle(source, target, skippedProperties);
          for (let i2 = 0; i2 < source.childNodes.length; ++i2) {
            const sourceChild = source.childNodes[i2];
            const targetChild = target.childNodes[i2];
            if (sourceChild instanceof Element) {
              this.copyStyles(sourceChild, targetChild, []);
            }
          }
        }
        copyStyle(source, target, skippedProperties) {
          const sourceStyle = getComputedStyle(source);
          const targetStyle = getComputedStyle(target);
          let style = "";
          for (let i2 = 0; i2 < sourceStyle.length; i2++) {
            const propertyName = sourceStyle[i2];
            if (!skippedProperties.includes(propertyName)) {
              const propertyValue = sourceStyle.getPropertyValue(propertyName);
              const propertyPriority = sourceStyle.getPropertyPriority(propertyName);
              if (targetStyle.getPropertyValue(propertyName) !== propertyValue) {
                if (this.shouldUpdateStyle(target)) {
                  target.style.setProperty(propertyName, propertyValue);
                } else {
                  style += `${propertyName}: ${propertyValue}${propertyPriority ? " !" + propertyPriority : ""}; `;
                }
              }
            }
          }
          if (style !== "") {
            target.setAttribute("style", style.trim());
          }
        }
        shouldUpdateStyle(element) {
          return "tagName" in element && "style" in element;
        }
        getSvgExport(serializedSvgElement, svgElement, root, request) {
          const svgExportStyle = this.getSvgExportStyle(svgElement, root, request);
          return svgExportStyle ? serializedSvgElement.replace('style="', `style="${svgExportStyle}`) : serializedSvgElement;
        }
        getSvgExportStyle(svgElement, root, request) {
          const bounds = this.getBounds(root, document);
          return `width: ${bounds.width}px !important;height: ${bounds.height}px !important;border: none !important;cursor: default !important;`;
        }
      };
      exports.GLSPSvgExporter = GLSPSvgExporter;
      exports.GLSPSvgExporter = GLSPSvgExporter = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPSvgExporter);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/export/export-modules.js
  var require_export_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/export/export-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneExportModule = exports.exportModule = void 0;
      var sprotty_1 = require_lib4();
      var export_svg_action_handler_1 = require_export_svg_action_handler();
      var glsp_svg_exporter_1 = require_glsp_svg_exporter();
      exports.exportModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.HiddenVNodePostprocessor, sprotty_1.ExportSvgPostprocessor);
        (0, sprotty_1.configureCommand)(context, sprotty_1.ExportSvgCommand);
        bind(sprotty_1.TYPES.SvgExporter).to(glsp_svg_exporter_1.GLSPSvgExporter).inSingletonScope();
      }, { featureId: Symbol("export") });
      exports.standaloneExportModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.KeyListener, sprotty_1.ExportSvgKeyListener);
        bind(export_svg_action_handler_1.ExportSvgActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.ExportSvgAction.KIND, export_svg_action_handler_1.ExportSvgActionHandler);
      }, { featureId: Symbol("standaloneExport"), requires: exports.exportModule });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hints/model.js
  var require_model21 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hints/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isReparentable = exports.reparentFeature = exports.isContainable = exports.containerFeature = void 0;
      exports.containerFeature = Symbol("containable");
      function isContainable(element) {
        return element.hasFeature(exports.containerFeature);
      }
      exports.isContainable = isContainable;
      exports.reparentFeature = Symbol("reparentFeature");
      function isReparentable(element) {
        return element.hasFeature(exports.reparentFeature);
      }
      exports.isReparentable = isReparentable;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/model.js
  var require_model22 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GEdge = exports.GGraph = void 0;
      var sprotty_1 = require_lib4();
      var args_feature_1 = require_args_feature();
      var model_1 = require_model21();
      var GGraph = class extends sprotty_1.SGraphImpl {
        isContainableElement(_input) {
          return true;
        }
      };
      exports.GGraph = GGraph;
      GGraph.DEFAULT_FEATURES = [...sprotty_1.SGraphImpl.DEFAULT_FEATURES, model_1.containerFeature, args_feature_1.argsFeature];
      var GEdge2 = class extends sprotty_1.SEdgeImpl {
        localToParent(point) {
          const bounds = (0, sprotty_1.getRouteBounds)(this.routingPoints);
          const result = {
            x: point.x + bounds.x,
            y: point.y + bounds.y,
            width: -1,
            height: -1
          };
          if ((0, sprotty_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
        parentToLocal(point) {
          const bounds = (0, sprotty_1.getRouteBounds)(this.routingPoints);
          const result = {
            x: point.x - bounds.x,
            y: point.y - bounds.y,
            width: -1,
            height: -1
          };
          if ((0, sprotty_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
      };
      exports.GEdge = GEdge2;
      GEdge2.DEFAULT_FEATURES = [...sprotty_1.SEdgeImpl.DEFAULT_FEATURES, args_feature_1.argsFeature];
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/reconnect/model.js
  var require_model23 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/reconnect/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GReconnectHandle = exports.createReconnectHandle = exports.isTargetRoutingHandle = exports.isSourceRoutingHandle = exports.removeReconnectHandles = exports.addReconnectHandles = exports.isReconnectHandle = exports.isReconnectable = exports.reconnectFeature = void 0;
      var sprotty_1 = require_lib4();
      exports.reconnectFeature = Symbol("reconnectFeature");
      function isReconnectable(element) {
        return element instanceof sprotty_1.GRoutableElement && element.hasFeature(exports.reconnectFeature);
      }
      exports.isReconnectable = isReconnectable;
      var ROUTING_HANDLE_SOURCE_INDEX = -2;
      function isReconnectHandle(element) {
        return element !== void 0 && element instanceof GReconnectHandle;
      }
      exports.isReconnectHandle = isReconnectHandle;
      function addReconnectHandles(element) {
        removeReconnectHandles(element);
        createReconnectHandle(element, "source", ROUTING_HANDLE_SOURCE_INDEX);
        createReconnectHandle(element, "target", element.routingPoints.length);
      }
      exports.addReconnectHandles = addReconnectHandles;
      function removeReconnectHandles(element) {
        element.removeAll((child) => child instanceof GReconnectHandle);
      }
      exports.removeReconnectHandles = removeReconnectHandles;
      function isSourceRoutingHandle(edge, routingHandle) {
        return routingHandle.pointIndex === ROUTING_HANDLE_SOURCE_INDEX;
      }
      exports.isSourceRoutingHandle = isSourceRoutingHandle;
      function isTargetRoutingHandle(edge, routingHandle) {
        return routingHandle.pointIndex === edge.routingPoints.length;
      }
      exports.isTargetRoutingHandle = isTargetRoutingHandle;
      function createReconnectHandle(edge, kind, routingPointIndex) {
        const handle = new GReconnectHandle();
        handle.kind = kind;
        handle.pointIndex = routingPointIndex;
        handle.type = "routing-point";
        if (kind === "target" && edge.id === sprotty_1.edgeInProgressID) {
          handle.id = sprotty_1.edgeInProgressTargetHandleID;
        }
        edge.add(handle);
        return handle;
      }
      exports.createReconnectHandle = createReconnectHandle;
      var GReconnectHandle = class extends sprotty_1.GRoutingHandle {
        hasFeature(feature) {
          return feature !== sprotty_1.selectFeature && super.hasFeature(feature);
        }
      };
      exports.GReconnectHandle = GReconnectHandle;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hints/type-hint-provider.js
  var require_type_hint_provider = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hints/type-hint-provider.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TypeHintProvider = exports.ApplyTypeHintsCommand = exports.ApplyTypeHintsAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var feedback_command_1 = require_feedback_command();
      var model_1 = require_model22();
      var gmodel_util_1 = require_gmodel_util();
      var model_2 = require_model19();
      var model_3 = require_model23();
      var model_4 = require_model21();
      var ApplyTypeHintsAction;
      (function(ApplyTypeHintsAction2) {
        ApplyTypeHintsAction2.KIND = "applyTypeHints";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ApplyTypeHintsAction2.KIND);
        }
        ApplyTypeHintsAction2.is = is;
        function create() {
          return { kind: ApplyTypeHintsAction2.KIND };
        }
        ApplyTypeHintsAction2.create = create;
      })(ApplyTypeHintsAction || (exports.ApplyTypeHintsAction = ApplyTypeHintsAction = {}));
      var ApplyTypeHintsCommand = class ApplyTypeHintsCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
          this.rank = -10;
        }
        execute(context) {
          context.root.index.all().forEach((element) => {
            if (element instanceof sprotty_1.GShapeElement || element instanceof sprotty_1.GModelRoot) {
              return this.applyShapeTypeHint(element);
            }
            if (element instanceof model_1.GEdge) {
              this.applyEdgeTypeHint(element);
            }
          });
          return context.root;
        }
        applyEdgeTypeHint(element) {
          const hint = this.typeHintProvider.getEdgeTypeHint(element);
          if (hint && element.features instanceof Set) {
            addOrRemove(element.features, sprotty_1.deletableFeature, hint.deletable);
            addOrRemove(element.features, sprotty_1.editFeature, hint.routable);
            addOrRemove(element.features, model_3.reconnectFeature, hint.repositionable);
          }
        }
        applyShapeTypeHint(element) {
          const hint = this.typeHintProvider.getShapeTypeHint(element);
          if (hint && element.features instanceof Set) {
            addOrRemove(element.features, sprotty_1.deletableFeature, hint.deletable);
            addOrRemove(element.features, sprotty_1.moveFeature, hint.repositionable);
            addOrRemove(element.features, model_2.resizeFeature, hint.resizable);
            addOrRemove(element.features, model_4.reparentFeature, hint.reparentable);
            addOrRemove(element.features, model_4.containerFeature, true);
            if ((0, model_4.isContainable)(element)) {
              element.isContainableElement = (input) => this.isContainableElement(input, hint);
            }
            const fallbackCanConnect = (0, sprotty_1.isConnectable)(element) ? element.canConnect.bind(element) : void 0;
            addOrRemove(element.features, sprotty_1.connectableFeature, true);
            if ((0, sprotty_1.isConnectable)(element)) {
              element.canConnect = (routable, role) => this.canConnect(routable, role, element, fallbackCanConnect);
            }
          }
        }
        /**
         * Type hints aware wrapper function for  `Connectable.canConnect`. After type hints have been applied
         * the `canConnect` implementation of `connectable` model elements  (with a matching hint) will forward to this method.
         */
        canConnect(routable, role, element, fallbackCanConnect) {
          var _a4;
          const edgeHint = this.typeHintProvider.getEdgeTypeHint(routable.type);
          if (!edgeHint) {
            return (_a4 = fallbackCanConnect === null || fallbackCanConnect === void 0 ? void 0 : fallbackCanConnect(routable, role)) !== null && _a4 !== void 0 ? _a4 : false;
          }
          const validElementIds = role === "source" ? edgeHint.sourceElementTypeIds : edgeHint.targetElementTypeIds;
          if (!validElementIds) {
            return true;
          }
          const elementType = element.type + ":";
          return validElementIds.some((type) => elementType.startsWith(type));
        }
        /**
         * Type hints aware wrapper function for  `Containable.isContainableElement`. After type hints have been applied
         * the `isContainableElement` implementation of `containable` model elements (with a matching hint) will forward to this method.
         */
        isContainableElement(input, hint) {
          var _a4, _b2;
          const elemenType = (0, gmodel_util_1.getElementTypeId)(input) + ":";
          return (_b2 = (_a4 = hint.containableElementTypeIds) === null || _a4 === void 0 ? void 0 : _a4.some((type) => elemenType.startsWith(type))) !== null && _b2 !== void 0 ? _b2 : false;
        }
      };
      exports.ApplyTypeHintsCommand = ApplyTypeHintsCommand;
      ApplyTypeHintsCommand.KIND = ApplyTypeHintsAction.KIND;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ITypeHintProvider),
        __metadata("design:type", Object)
      ], ApplyTypeHintsCommand.prototype, "typeHintProvider", void 0);
      exports.ApplyTypeHintsCommand = ApplyTypeHintsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ApplyTypeHintsCommand);
      function addOrRemove(features, feature, add) {
        if (add && !features.has(feature)) {
          features.add(feature);
        } else if (!add && features.has(feature)) {
          features.delete(feature);
        }
      }
      var TypeHintProvider = class TypeHintProvider {
        constructor() {
          this.shapeHints = /* @__PURE__ */ new Map();
          this.edgeHints = /* @__PURE__ */ new Map();
        }
        init() {
          this.typeHintsFeedback = this.feedbackActionDispatcher.createEmitter();
        }
        handle(action) {
          this.shapeHints.clear();
          this.edgeHints.clear();
          action.shapeHints.forEach((hint) => this.shapeHints.set(hint.elementTypeId, hint));
          action.edgeHints.forEach((hint) => this.edgeHints.set(hint.elementTypeId, hint));
          this.typeHintsFeedback.add(ApplyTypeHintsAction.create()).submit();
        }
        getShapeTypeHint(input) {
          return this.getTypeHint(input, this.shapeHints);
        }
        getEdgeTypeHint(input) {
          return this.getTypeHint(input, this.edgeHints);
        }
        getTypeHint(input, hints) {
          const type = (0, gmodel_util_1.getElementTypeId)(input);
          let hint = hints.get(type);
          if (hint === void 0) {
            const subtypes = type.split(":");
            while (hint === void 0 && subtypes.length > 0) {
              subtypes.pop();
              hint = hints.get(subtypes.join(":"));
              if (hint) {
                hints.set(type, hint);
                break;
              }
            }
          }
          return hint;
        }
        async postRequestModel() {
          const setTypeHintsAction = await this.actionDispatcher.request(sprotty_1.RequestTypeHintsAction.create());
          this.handle(setTypeHintsAction);
        }
      };
      exports.TypeHintProvider = TypeHintProvider;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], TypeHintProvider.prototype, "feedbackActionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], TypeHintProvider.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], TypeHintProvider.prototype, "init", null);
      exports.TypeHintProvider = TypeHintProvider = __decorate([
        (0, inversify_1.injectable)()
      ], TypeHintProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hints/type-hints-module.js
  var require_type_hints_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hints/type-hints-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.typeHintsModule = void 0;
      var sprotty_1 = require_lib4();
      var type_hint_provider_1 = require_type_hint_provider();
      exports.typeHintsModule = new sprotty_1.FeatureModule((bind, unbind, isBound) => {
        const context = { bind, unbind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITypeHintProvider, type_hint_provider_1.TypeHintProvider);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(type_hint_provider_1.TypeHintProvider);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetTypeHintsAction.KIND, type_hint_provider_1.TypeHintProvider);
        (0, sprotty_1.configureCommand)(context, type_hint_provider_1.ApplyTypeHintsCommand);
      }, { featureId: Symbol("typeHints") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/view.js
  var require_view2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackEdgeEndView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var FeedbackEdgeEndView = class FeedbackEdgeEndView {
        render(model, context) {
          var _a4;
          const position = (_a4 = model.position) !== null && _a4 !== void 0 ? _a4 : sprotty_1.Point.ORIGIN;
          return (0, sprotty_1.svg)("g", { x: position.x, y: position.y });
        }
      };
      exports.FeedbackEdgeEndView = FeedbackEdgeEndView;
      exports.FeedbackEdgeEndView = FeedbackEdgeEndView = __decorate([
        (0, inversify_1.injectable)()
      ], FeedbackEdgeEndView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/dangling-edge-feedback.js
  var require_dangling_edge_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/dangling-edge-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureDanglingFeedbackEdge = exports.removeDanglingFeedbackEdge = exports.drawFeedbackEdge = exports.defaultFeedbackEdgeSchema = exports.feedbackEdgeEndId = exports.feedbackEdgeId = exports.FeedbackEdgeEnd = exports.RemoveFeedbackEdgeCommand = exports.RemoveFeedbackEdgeAction = exports.DrawFeedbackEdgeCommand = exports.DrawFeedbackEdgeAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var feedback_action_dispatcher_1 = require_feedback_action_dispatcher();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var viewpoint_util_1 = require_viewpoint_util();
      var view_1 = require_view2();
      var DrawFeedbackEdgeAction;
      (function(DrawFeedbackEdgeAction2) {
        DrawFeedbackEdgeAction2.KIND = "drawFeedbackEdge";
        function is(object) {
          return sprotty_1.Action.hasKind(object, DrawFeedbackEdgeAction2.KIND);
        }
        DrawFeedbackEdgeAction2.is = is;
        function create(options) {
          return {
            kind: DrawFeedbackEdgeAction2.KIND,
            ...options
          };
        }
        DrawFeedbackEdgeAction2.create = create;
      })(DrawFeedbackEdgeAction || (exports.DrawFeedbackEdgeAction = DrawFeedbackEdgeAction = {}));
      var DrawFeedbackEdgeCommand = class DrawFeedbackEdgeCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          drawFeedbackEdge(context, this.action.sourceId, this.action.elementTypeId, this.action.edgeSchema);
          return context.root;
        }
      };
      exports.DrawFeedbackEdgeCommand = DrawFeedbackEdgeCommand;
      DrawFeedbackEdgeCommand.KIND = DrawFeedbackEdgeAction.KIND;
      exports.DrawFeedbackEdgeCommand = DrawFeedbackEdgeCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DrawFeedbackEdgeCommand);
      var RemoveFeedbackEdgeAction;
      (function(RemoveFeedbackEdgeAction2) {
        RemoveFeedbackEdgeAction2.KIND = "removeFeedbackEdgeCommand";
        function is(object) {
          return sprotty_1.Action.hasKind(object, RemoveFeedbackEdgeAction2.KIND);
        }
        RemoveFeedbackEdgeAction2.is = is;
        function create() {
          return { kind: RemoveFeedbackEdgeAction2.KIND };
        }
        RemoveFeedbackEdgeAction2.create = create;
      })(RemoveFeedbackEdgeAction || (exports.RemoveFeedbackEdgeAction = RemoveFeedbackEdgeAction = {}));
      var RemoveFeedbackEdgeCommand = class RemoveFeedbackEdgeCommand extends feedback_command_1.FeedbackCommand {
        execute(context) {
          removeDanglingFeedbackEdge(context.root);
          return context.root;
        }
      };
      exports.RemoveFeedbackEdgeCommand = RemoveFeedbackEdgeCommand;
      RemoveFeedbackEdgeCommand.KIND = RemoveFeedbackEdgeAction.KIND;
      exports.RemoveFeedbackEdgeCommand = RemoveFeedbackEdgeCommand = __decorate([
        (0, inversify_1.injectable)()
      ], RemoveFeedbackEdgeCommand);
      var FeedbackEdgeEnd = class _FeedbackEdgeEnd extends sprotty_1.GDanglingAnchor {
        constructor(sourceId, elementTypeId, feedbackEdge = void 0, type = _FeedbackEdgeEnd.TYPE) {
          super();
          this.sourceId = sourceId;
          this.elementTypeId = elementTypeId;
          this.feedbackEdge = feedbackEdge;
          this.type = type;
        }
      };
      exports.FeedbackEdgeEnd = FeedbackEdgeEnd;
      FeedbackEdgeEnd.DEFAULT_FEATURES = [sprotty_1.deletableFeature, feedback_action_dispatcher_1.feedbackFeature];
      FeedbackEdgeEnd.TYPE = "feedback-edge-end";
      function feedbackEdgeId(root) {
        return root.id + "_feedback_edge";
      }
      exports.feedbackEdgeId = feedbackEdgeId;
      function feedbackEdgeEndId(root) {
        return root.id + "_feedback_anchor";
      }
      exports.feedbackEdgeEndId = feedbackEdgeEndId;
      exports.defaultFeedbackEdgeSchema = {
        cssClasses: ["feedback-edge"],
        opacity: 0.3
      };
      function drawFeedbackEdge(context, sourceId, elementTypeId, edgeTemplate) {
        const root = context.root;
        const sourceChild = root.index.getById(sourceId);
        if (!sourceChild) {
          return;
        }
        const source = (0, sprotty_1.findParentByFeature)(sourceChild, sprotty_1.isConnectable);
        if (!source || !(0, sprotty_1.isBoundsAware)(source)) {
          return;
        }
        const edgeEnd = new FeedbackEdgeEnd(source.id, elementTypeId);
        edgeEnd.id = feedbackEdgeEndId(root);
        edgeEnd.position = (0, viewpoint_util_1.toAbsolutePosition)(source);
        const edgeSchema = {
          id: feedbackEdgeId(root),
          type: elementTypeId,
          sourceId: source.id,
          targetId: edgeEnd.id,
          ...exports.defaultFeedbackEdgeSchema,
          ...edgeTemplate
        };
        const feedbackEdge = context.modelFactory.createElement(edgeSchema);
        if ((0, gmodel_util_1.isRoutable)(feedbackEdge)) {
          edgeEnd.feedbackEdge = feedbackEdge;
          root.add(edgeEnd);
          root.add(feedbackEdge);
        }
      }
      exports.drawFeedbackEdge = drawFeedbackEdge;
      function removeDanglingFeedbackEdge(root) {
        const feedbackEdge = root.index.getById(feedbackEdgeId(root));
        const feedbackEdgeEnd = root.index.getById(feedbackEdgeEndId(root));
        if (feedbackEdge instanceof sprotty_1.GChildElement) {
          root.remove(feedbackEdge);
        }
        if (feedbackEdgeEnd instanceof sprotty_1.GChildElement) {
          root.remove(feedbackEdgeEnd);
        }
      }
      exports.removeDanglingFeedbackEdge = removeDanglingFeedbackEdge;
      function configureDanglingFeedbackEdge(context) {
        if (!context.isBound(DrawFeedbackEdgeCommand) && !context.isBound(RemoveFeedbackEdgeCommand) && !context.isBound(view_1.FeedbackEdgeEndView)) {
          (0, sprotty_1.configureCommand)(context, DrawFeedbackEdgeCommand);
          (0, sprotty_1.configureCommand)(context, RemoveFeedbackEdgeCommand);
          (0, sprotty_1.configureView)(context, FeedbackEdgeEnd.TYPE, view_1.FeedbackEdgeEndView);
        }
      }
      exports.configureDanglingFeedbackEdge = configureDanglingFeedbackEdge;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edge-creation-tool-feedback.js
  var require_edge_creation_tool_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edge-creation-tool-feedback.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackEdgeEndMovingMouseListener = void 0;
      var sprotty_1 = require_lib4();
      var viewpoint_util_1 = require_viewpoint_util();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var FeedbackEdgeEndMovingMouseListener = class extends sprotty_1.MouseListener {
        constructor(anchorRegistry, feedbackDispatcher) {
          super();
          this.anchorRegistry = anchorRegistry;
          this.feedbackDispatcher = feedbackDispatcher;
          this.feedback = feedbackDispatcher.createEmitter();
        }
        mouseMove(target, event) {
          const root = target.root;
          const edgeEnd = root.index.getById((0, dangling_edge_feedback_1.feedbackEdgeEndId)(root));
          if (!(edgeEnd instanceof dangling_edge_feedback_1.FeedbackEdgeEnd) || !edgeEnd.feedbackEdge) {
            return [];
          }
          const edge = edgeEnd.feedbackEdge;
          const position = (0, viewpoint_util_1.getAbsolutePosition)(edgeEnd, event);
          const endAtMousePosition = (0, sprotty_1.findChildrenAtPosition)(target.root, position).reverse().find((element) => (0, sprotty_1.isConnectable)(element) && element.canConnect(edge, "target"));
          if (endAtMousePosition instanceof sprotty_1.GConnectableElement && edge.source && (0, sprotty_1.isBoundsAware)(edge.source)) {
            const anchor = this.computeAbsoluteAnchor(endAtMousePosition, sprotty_1.Bounds.center((0, viewpoint_util_1.toAbsoluteBounds)(edge.source)));
            if (sprotty_1.Point.euclideanDistance(anchor, edgeEnd.position) > 1) {
              this.feedback.add(sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: anchor }], { animate: false })).submit();
            }
          } else {
            this.feedback.add(sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: position }], { animate: false })).submit();
          }
          return [];
        }
        computeAbsoluteAnchor(element, absoluteReferencePoint, offset) {
          const referencePointInParent = (0, viewpoint_util_1.absoluteToParent)(element, absoluteReferencePoint);
          const anchorComputer = this.anchorRegistry.get(sprotty_1.PolylineEdgeRouter.KIND, element.anchorKind);
          let anchor = anchorComputer.getAnchor(element, referencePointInParent, offset);
          if (element.parent !== element.root) {
            const parent = (0, sprotty_1.findParentByFeature)(element.parent, sprotty_1.isBoundsAware);
            if (parent) {
              const absoluteParentPosition = (0, viewpoint_util_1.toAbsoluteBounds)(parent);
              anchor = sprotty_1.Point.add(absoluteParentPosition, anchor);
            }
          }
          return anchor;
        }
        dispose() {
          this.feedback.dispose();
        }
      };
      exports.FeedbackEdgeEndMovingMouseListener = FeedbackEdgeEndMovingMouseListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edge-creation-tool.js
  var require_edge_creation_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edge-creation-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var EdgeCreationTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeCreationToolMouseListener = exports.EdgeCreationTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var tool_1 = require_tool();
      var model_1 = require_model22();
      var grid_1 = require_grid();
      var base_tools_1 = require_base_tools();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_creation_tool_feedback_1 = require_edge_creation_tool_feedback();
      var EdgeCreationTool = EdgeCreationTool_1 = class EdgeCreationTool extends base_tools_1.BaseCreationTool {
        constructor() {
          super(...arguments);
          this.isTriggerAction = sprotty_1.TriggerEdgeCreationAction.is;
        }
        get id() {
          return EdgeCreationTool_1.ID;
        }
        doEnable() {
          this.toolFeedback();
          this.creationListener();
          this.trackFeedbackEdge();
        }
        toolFeedback() {
          const toolFeedback = this.createFeedbackEmitter().add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED), (0, css_feedback_1.cursorFeedbackAction)()).submit();
          this.toDisposeOnDisable.push(toolFeedback);
        }
        creationListener() {
          const creationListener = new EdgeCreationToolMouseListener(this.triggerAction, this.actionDispatcher, this.typeHintProvider, this, this.grid ? this.grid.x / 2 : void 0);
          this.toDisposeOnDisable.push(creationListener, this.mouseTool.registerListener(creationListener));
        }
        trackFeedbackEdge() {
          const mouseMovingFeedback = new edge_creation_tool_feedback_1.FeedbackEdgeEndMovingMouseListener(this.anchorRegistry, this.feedbackDispatcher);
          this.toDisposeOnDisable.push(mouseMovingFeedback, this.mouseTool.registerListener(mouseMovingFeedback));
        }
      };
      exports.EdgeCreationTool = EdgeCreationTool;
      EdgeCreationTool.ID = "tool_create_edge";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.AnchorComputerRegistry),
        __metadata("design:type", sprotty_1.AnchorComputerRegistry)
      ], EdgeCreationTool.prototype, "anchorRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ITypeHintProvider),
        __metadata("design:type", Object)
      ], EdgeCreationTool.prototype, "typeHintProvider", void 0);
      __decorate([
        (0, inversify_1.optional)(),
        (0, inversify_1.inject)(sprotty_1.TYPES.Grid),
        __metadata("design:type", Object)
      ], EdgeCreationTool.prototype, "grid", void 0);
      exports.EdgeCreationTool = EdgeCreationTool = EdgeCreationTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeCreationTool);
      var EdgeCreationToolMouseListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(triggerAction, actionDispatcher, typeHintProvider, tool, dragSensitivity) {
          super(dragSensitivity);
          this.triggerAction = triggerAction;
          this.actionDispatcher = actionDispatcher;
          this.typeHintProvider = typeHintProvider;
          this.tool = tool;
          this.dragSensitivity = dragSensitivity;
          this.allowedTarget = false;
          this.pendingDynamicCheck = false;
          this.proxyEdge = new model_1.GEdge();
          this.proxyEdge.type = triggerAction.elementTypeId;
          this.cursorFeedback = tool.createFeedbackEmitter();
          this.feedbackEdgeFeedback = tool.createFeedbackEmitter();
        }
        nonDraggingMouseUp(element, event) {
          const result = [];
          if (event.button === 0) {
            if (!this.isSourceSelected()) {
              if (this.currentTarget && this.allowedTarget) {
                this.source = this.currentTarget.id;
                this.feedbackEdgeFeedback.add(dangling_edge_feedback_1.DrawFeedbackEdgeAction.create({ elementTypeId: this.triggerAction.elementTypeId, sourceId: this.source }), dangling_edge_feedback_1.RemoveFeedbackEdgeAction.create()).submit();
              }
            } else if (this.currentTarget && this.allowedTarget) {
              this.target = this.currentTarget.id;
            }
            if (this.source && this.target) {
              result.push(this.getCreateOperation(element, event, this.source, this.target));
              if (!this.isContinuousMode(element, event)) {
                result.push(tool_1.EnableDefaultToolsAction.create());
              } else {
                this.dispose();
              }
            }
          } else if (event.button === 2) {
            this.dispose();
            result.push(tool_1.EnableDefaultToolsAction.create());
          }
          return result;
        }
        /**
         * Determines wether the tool should run in continuous mode (also called stamp mode) or not.
         * If continuous mode is enabled, the tool will stay after a successful creation.
         * The user can then create more elements of the same type without having to re-trigger the tool.
         * By default, continuous mode is enabled if the user holds the CTRL key.
         * @param element the current model element
         * @param event
         */
        isContinuousMode(element, event) {
          return (0, sprotty_1.isCtrlOrCmd)(event);
        }
        getCreateOperation(element, event, sourceElementId, targetElementId) {
          return sprotty_1.CreateEdgeOperation.create({
            elementTypeId: this.triggerAction.elementTypeId,
            sourceElementId,
            targetElementId,
            args: this.getCreateEdgeOperationArgs(element, event)
          });
        }
        getCreateEdgeOperationArgs(ctx, event) {
          return { ...this.triggerAction.args };
        }
        isSourceSelected() {
          return this.source !== void 0;
        }
        isTargetSelected() {
          return this.target !== void 0;
        }
        mouseOver(target, event) {
          const newCurrentTarget = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isConnectable);
          if (newCurrentTarget !== this.currentTarget) {
            this.pendingDynamicCheck = false;
            this.currentTarget = newCurrentTarget;
            if (this.currentTarget) {
              if (!this.isSourceSelected()) {
                this.allowedTarget = this.canConnect(newCurrentTarget, "source");
              } else if (!this.isTargetSelected()) {
                this.allowedTarget = this.canConnect(newCurrentTarget, "target");
              }
              if (this.pendingDynamicCheck) {
                return [(0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_CHECK_PENDING)];
              }
            } else {
              this.allowedTarget = false;
            }
            return [this.updateEdgeFeedback()];
          }
          return [];
        }
        updateEdgeFeedback() {
          if (this.allowedTarget) {
            const action = !this.isSourceSelected() ? (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_CREATION_SOURCE) : (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_CREATION_TARGET);
            return action;
          }
          return (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED);
        }
        canConnect(element, role) {
          var _a4;
          if (!element || !(0, sprotty_1.isConnectable)(element) || !element.canConnect(this.proxyEdge, role)) {
            return false;
          }
          if (!this.isDynamic(this.proxyEdge.type)) {
            return true;
          }
          const sourceElement = (_a4 = this.source) !== null && _a4 !== void 0 ? _a4 : element;
          const targetElement = this.source ? element : void 0;
          this.pendingDynamicCheck = true;
          this.actionDispatcher.request(sprotty_1.RequestCheckEdgeAction.create({ sourceElement, targetElement, edgeType: this.proxyEdge.type })).then((result) => {
            if (this.pendingDynamicCheck) {
              this.allowedTarget = result.isValid;
              this.actionDispatcher.dispatch(this.updateEdgeFeedback());
              this.pendingDynamicCheck = false;
            }
          }).catch((err) => console.error("Dynamic edge check failed with: ", err));
          return false;
        }
        isDynamic(edgeTypeId) {
          var _a4;
          const typeHint = this.typeHintProvider.getEdgeTypeHint(edgeTypeId);
          return (_a4 = typeHint === null || typeHint === void 0 ? void 0 : typeHint.dynamic) !== null && _a4 !== void 0 ? _a4 : false;
        }
        dispose() {
          this.source = void 0;
          this.target = void 0;
          this.currentTarget = void 0;
          this.allowedTarget = false;
          this.feedbackEdgeFeedback.dispose();
          this.cursorFeedback.dispose();
          super.dispose();
        }
      };
      exports.EdgeCreationToolMouseListener = EdgeCreationToolMouseListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/validation/issue-marker.js
  var require_issue_marker = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/validation/issue-marker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSeverity = exports.createGIssue = exports.getGIssueMarker = exports.getOrCreateGIssueMarker = exports.GIssueMarker = void 0;
      var sprotty_1 = require_lib4();
      var GIssueMarker = class extends sprotty_1.SIssueMarkerImpl {
        constructor() {
          super();
          this.issues = [];
          this.type = "marker";
          this.features = new Set(sprotty_1.GDecoration.DEFAULT_FEATURES);
        }
        computeProjectionCssClasses() {
          const severityCss = getSeverity(this);
          this.projectionCssClasses = ["sprotty-issue", "sprotty-" + severityCss];
        }
      };
      exports.GIssueMarker = GIssueMarker;
      function getOrCreateGIssueMarker(modelElement) {
        let issueMarker;
        issueMarker = getGIssueMarker(modelElement);
        if (issueMarker === void 0) {
          issueMarker = new GIssueMarker();
          if ((0, sprotty_1.isBoundsAware)(modelElement)) {
            issueMarker.projectedBounds = modelElement.parentToLocal(modelElement.bounds);
          }
          modelElement.add(issueMarker);
        }
        return issueMarker;
      }
      exports.getOrCreateGIssueMarker = getOrCreateGIssueMarker;
      function getGIssueMarker(modelElement) {
        let issueMarker;
        for (const child of modelElement.children) {
          if (child instanceof GIssueMarker) {
            issueMarker = child;
          }
        }
        return issueMarker;
      }
      exports.getGIssueMarker = getGIssueMarker;
      function createGIssue(marker, parent) {
        const issue = {
          message: marker.description,
          severity: "info"
        };
        switch (marker.kind) {
          case sprotty_1.MarkerKind.ERROR: {
            issue.severity = "error";
            break;
          }
          case sprotty_1.MarkerKind.INFO: {
            issue.severity = "info";
            break;
          }
          case sprotty_1.MarkerKind.WARNING: {
            issue.severity = "warning";
            break;
          }
        }
        return issue;
      }
      exports.createGIssue = createGIssue;
      function getSeverity(marker) {
        let currentSeverity = "info";
        for (const severity of marker.issues.map((s3) => s3.severity)) {
          if (severity === "error") {
            return severity;
          }
          if (severity === "warning" && currentSeverity === "info") {
            currentSeverity = severity;
          }
        }
        return currentSeverity;
      }
      exports.getSeverity = getSeverity;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hover/hover.js
  var require_hover2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hover/hover.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GlspHoverMouseListener = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var tool_1 = require_tool();
      var edge_creation_tool_1 = require_edge_creation_tool();
      var issue_marker_1 = require_issue_marker();
      var GlspHoverMouseListener = class GlspHoverMouseListener extends sprotty_1.HoverMouseListener {
        constructor() {
          super(...arguments);
          this.enableHover = true;
        }
        /**
         * Stops mouse over timer and remove hover feedback, if focus is lost.
         *
         * This fixes strange effects that appear if the mouse left the element via e.g. a context menu,
         * which explicitly removes the focus of the diagram.
         * @see SelectionServiceAwareContextMenuMouseListener
         * @param action should be a `FocusStateChangedAction`
         * @returns a `HoverFeedbackAction` resetting the state, if the specified action indicates lost focus
         */
        handle(action) {
          if (focus_state_change_action_1.FocusStateChangedAction.is(action) && !action.hasFocus) {
            this.stopMouseOverTimer();
            if (this.lastHoverFeedbackElementId) {
              const previousTargetId = this.lastHoverFeedbackElementId;
              this.lastHoverFeedbackElementId = void 0;
              return sprotty_1.HoverFeedbackAction.create({ mouseoverElement: previousTargetId, mouseIsOver: false });
            }
          } else if (tool_1.EnableToolsAction.is(action)) {
            this.enableHover = !action.toolIds.includes(edge_creation_tool_1.EdgeCreationTool.ID);
          } else if (tool_1.EnableDefaultToolsAction.is(action)) {
            this.enableHover = true;
          }
        }
        mouseOver(target, event) {
          if (this.enableHover) {
            return super.mouseOver(target, event);
          }
          return [];
        }
        startMouseOverTimer(target, event) {
          this.stopMouseOverTimer();
          return new Promise((resolve) => {
            this.state.mouseOverTimer = window.setTimeout(() => {
              const popupBounds = this.computePopupBounds(target, { x: event.pageX, y: event.pageY });
              if (target instanceof issue_marker_1.GIssueMarker) {
                resolve(sprotty_1.SetPopupModelAction.create(this.createPopupModel(target, popupBounds)));
              } else {
                resolve(sprotty_1.RequestPopupModelAction.create({ elementId: target.id, bounds: popupBounds }));
              }
              this.state.popupOpen = true;
              this.state.previousPopupElement = target;
            }, this.options.popupOpenDelay);
          });
        }
        createPopupModel(marker, bounds) {
          if (marker.issues !== void 0 && marker.issues.length > 0) {
            return {
              type: "html",
              id: "sprotty-popup",
              children: [this.createMarkerIssuePopup(marker)],
              canvasBounds: this.modifyBounds(bounds)
            };
          }
          return { type: sprotty_1.EMPTY_ROOT.type, id: sprotty_1.EMPTY_ROOT.id };
        }
        createMarkerIssuePopup(marker) {
          const message = this.createIssueMessage(marker);
          return {
            type: "pre-rendered",
            id: "popup-title",
            code: `<div class="${(0, issue_marker_1.getSeverity)(marker)}"><div class="sprotty-popup-title">${message}</div></div>`
          };
        }
        createIssueMessage(marker) {
          return "<ul>" + marker.issues.map((i2) => "<li>" + i2.severity.toUpperCase() + ": " + i2.message + "</li>").join("") + "</ul>";
        }
        modifyBounds(bounds) {
          return bounds;
        }
      };
      exports.GlspHoverMouseListener = GlspHoverMouseListener;
      exports.GlspHoverMouseListener = GlspHoverMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], GlspHoverMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/hover/hover-module.js
  var require_hover_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/hover/hover-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hoverModule = void 0;
      var sprotty_1 = require_lib4();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var tool_1 = require_tool();
      var hover_1 = require_hover2();
      exports.hoverModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.PopupVNodePostprocessor, sprotty_1.PopupPositionUpdater);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, hover_1.GlspHoverMouseListener);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.PopupMouseListener, sprotty_1.PopupHoverMouseListener);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.KeyListener, sprotty_1.HoverKeyListener);
        bind(sprotty_1.TYPES.HoverState).toConstantValue({
          mouseOverTimer: void 0,
          mouseOutTimer: void 0,
          popupOpen: false,
          previousPopupElement: void 0
        });
        bind(sprotty_1.ClosePopupActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureCommand)(context, sprotty_1.HoverFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.SetPopupModelCommand);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetPopupModelCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.FitToScreenCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.CenterCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetViewportCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.MoveCommand.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, focus_state_change_action_1.FocusStateChangedAction.KIND, sprotty_1.ClosePopupActionHandler);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableToolsAction.KIND, hover_1.GlspHoverMouseListener);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, hover_1.GlspHoverMouseListener);
        (0, sprotty_1.configureActionHandler)(context, focus_state_change_action_1.FocusStateChangedAction.KIND, hover_1.GlspHoverMouseListener);
      }, { featureId: Symbol("hover") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/label-edit-ui/label-edit-ui.js
  var require_label_edit_ui = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/label-edit-ui/label-edit-ui.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GlspEditLabelUI = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ui_extension_1 = require_ui_extension2();
      var GlspEditLabelUI = class GlspEditLabelUI extends sprotty_1.EditLabelUI {
        initializeContents(containerElement) {
          super.initializeContents(containerElement);
          containerElement.classList.add(ui_extension_1.CSS_UI_EXTENSION_CLASS);
        }
        setContainerVisible(visible) {
          var _a4, _b2;
          if (visible) {
            (_a4 = this.containerElement) === null || _a4 === void 0 ? void 0 : _a4.classList.remove(ui_extension_1.CSS_HIDDEN_EXTENSION_CLASS);
            this.editControl.focus();
          } else {
            (_b2 = this.containerElement) === null || _b2 === void 0 ? void 0 : _b2.classList.add(ui_extension_1.CSS_HIDDEN_EXTENSION_CLASS);
          }
        }
      };
      exports.GlspEditLabelUI = GlspEditLabelUI;
      exports.GlspEditLabelUI = GlspEditLabelUI = __decorate([
        (0, inversify_1.injectable)()
      ], GlspEditLabelUI);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/label-edit-ui/label-edit-ui-module.js
  var require_label_edit_ui_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/label-edit-ui/label-edit-ui-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.labelEditUiModule = void 0;
      var sprotty_1 = require_lib4();
      var label_edit_ui_1 = require_label_edit_ui();
      exports.labelEditUiModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind, ...rest) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.EditLabelAction.KIND, sprotty_1.EditLabelActionHandler);
        bind(label_edit_ui_1.GlspEditLabelUI).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.IUIExtension).toService(label_edit_ui_1.GlspEditLabelUI);
      }, { featureId: Symbol("labelEditUi") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/label-edit/edit-label-tool.js
  var require_edit_label_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/label-edit/edit-label-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var DirectLabelEditTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DirectLabelEditTool = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var base_tools_1 = require_base_tools();
      var DirectLabelEditTool = DirectLabelEditTool_1 = class DirectLabelEditTool extends base_tools_1.BaseEditTool {
        get id() {
          return DirectLabelEditTool_1.ID;
        }
        createEditLabelMouseListener() {
          return new sprotty_1.EditLabelMouseListener();
        }
        createEditLabelKeyListener() {
          return new sprotty_1.EditLabelKeyListener();
        }
        enable() {
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(this.createEditLabelMouseListener()), this.keyTool.registerListener(this.createEditLabelKeyListener()));
        }
      };
      exports.DirectLabelEditTool = DirectLabelEditTool;
      DirectLabelEditTool.ID = "glsp.direct-label-edit-tool";
      exports.DirectLabelEditTool = DirectLabelEditTool = DirectLabelEditTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], DirectLabelEditTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/label-edit/edit-label-validator.js
  var require_edit_label_validator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/label-edit/edit-label-validator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BalloonLabelValidationDecorator = exports.ServerEditLabelValidator = exports.LabelEditValidation = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var LabelEditValidation;
      (function(LabelEditValidation2) {
        LabelEditValidation2.CONTEXT_ID = "label-edit";
        function toEditLabelValidationResult(status) {
          const message = status.message;
          let severity = "ok";
          if (sprotty_1.ValidationStatus.isError(status)) {
            severity = "error";
          } else if (sprotty_1.ValidationStatus.isWarning(status)) {
            severity = "warning";
          }
          return { message, severity };
        }
        LabelEditValidation2.toEditLabelValidationResult = toEditLabelValidationResult;
        function createValidationRequestAction(value, labelId) {
          return sprotty_1.RequestEditValidationAction.create({ contextId: LabelEditValidation2.CONTEXT_ID, modelElementId: labelId, text: value });
        }
        LabelEditValidation2.createValidationRequestAction = createValidationRequestAction;
      })(LabelEditValidation || (exports.LabelEditValidation = LabelEditValidation = {}));
      var ServerEditLabelValidator = class ServerEditLabelValidator {
        async validate(value, label) {
          const action = LabelEditValidation.createValidationRequestAction(value, label.id);
          const response = await this.actionDispatcher.requestUntil(action);
          return response ? this.getValidationResultFromResponse(response) : { severity: "ok" };
        }
        getValidationResultFromResponse(action) {
          if (sprotty_1.SetEditValidationResultAction.is(action)) {
            return LabelEditValidation.toEditLabelValidationResult(action.status);
          }
          return { severity: "ok" };
        }
      };
      exports.ServerEditLabelValidator = ServerEditLabelValidator;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ServerEditLabelValidator.prototype, "actionDispatcher", void 0);
      exports.ServerEditLabelValidator = ServerEditLabelValidator = __decorate([
        (0, inversify_1.injectable)()
      ], ServerEditLabelValidator);
      var BalloonLabelValidationDecorator = class BalloonLabelValidationDecorator {
        decorate(input, result) {
          const containerElement = input.parentElement;
          if (!containerElement) {
            return;
          }
          if (result.message) {
            containerElement.setAttribute("data-balloon", result.message);
            containerElement.setAttribute("data-balloon-pos", "up-left");
            containerElement.setAttribute("data-balloon-visible", "true");
          }
          switch (result.severity) {
            case "ok":
              containerElement.classList.add("validation-ok");
              break;
            case "warning":
              containerElement.classList.add("validation-warning");
              break;
            case "error":
              containerElement.classList.add("validation-error");
              break;
          }
        }
        dispose(input) {
          const containerElement = input.parentElement;
          if (containerElement) {
            containerElement.removeAttribute("data-balloon");
            containerElement.removeAttribute("data-balloon-pos");
            containerElement.removeAttribute("data-balloon-visible");
            containerElement.classList.remove("validation-ok", "validation-warning", "validation-error");
          }
        }
      };
      exports.BalloonLabelValidationDecorator = BalloonLabelValidationDecorator;
      exports.BalloonLabelValidationDecorator = BalloonLabelValidationDecorator = __decorate([
        (0, inversify_1.injectable)()
      ], BalloonLabelValidationDecorator);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/label-edit/label-edit-module.js
  var require_label_edit_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/label-edit/label-edit-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.labelEditModule = void 0;
      var sprotty_1 = require_lib4();
      var edit_label_tool_1 = require_edit_label_tool();
      var edit_label_validator_1 = require_edit_label_validator();
      exports.labelEditModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, _rebind) => {
        bind(sprotty_1.TYPES.IEditLabelValidator).to(edit_label_validator_1.ServerEditLabelValidator);
        bind(sprotty_1.TYPES.IEditLabelValidationDecorator).to(edit_label_validator_1.BalloonLabelValidationDecorator);
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IDefaultTool, edit_label_tool_1.DirectLabelEditTool);
        (0, sprotty_1.configureCommand)({ bind, isBound }, sprotty_1.ApplyLabelEditCommand);
      }, { featureId: Symbol("labelEdit") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/layout/layout-elements-action.js
  var require_layout_elements_action = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/layout/layout-elements-action.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AlignElementsActionHandler = exports.AlignElementsAction = exports.SelectFunction = exports.Alignment = exports.ResizeElementsActionHandler = exports.LayoutElementsActionHandler = exports.ResizeElementsAction = exports.ReduceFunction = exports.ResizeDimension = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var selection_service_1 = require_selection_service();
      var gmodel_util_1 = require_gmodel_util();
      var layout_utils_1 = require_layout_utils();
      var model_1 = require_model19();
      var ResizeDimension;
      (function(ResizeDimension2) {
        ResizeDimension2[ResizeDimension2["Width"] = 0] = "Width";
        ResizeDimension2[ResizeDimension2["Height"] = 1] = "Height";
        ResizeDimension2[ResizeDimension2["Width_And_Height"] = 2] = "Width_And_Height";
      })(ResizeDimension || (exports.ResizeDimension = ResizeDimension = {}));
      var ReduceFunction;
      (function(ReduceFunction2) {
        function min(...values) {
          return Math.min(...values);
        }
        ReduceFunction2.min = min;
        function max(...values) {
          return Math.max(...values);
        }
        ReduceFunction2.max = max;
        function avg(...values) {
          return values.reduce((a3, b3) => a3 + b3, 0) / values.length;
        }
        ReduceFunction2.avg = avg;
        function first(...values) {
          return values[0];
        }
        ReduceFunction2.first = first;
        function last(...values) {
          return values[values.length - 1];
        }
        ReduceFunction2.last = last;
        function get(type) {
          return ReduceFunction2[type];
        }
        ReduceFunction2.get = get;
      })(ReduceFunction || (exports.ReduceFunction = ReduceFunction = {}));
      var ResizeElementsAction;
      (function(ResizeElementsAction2) {
        ResizeElementsAction2.KIND = "resizeElementAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ResizeElementsAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "elementIds") && (0, sprotty_1.hasNumberProp)(object, "dimension") && (0, sprotty_1.hasStringProp)(object, "reduceFunction");
        }
        ResizeElementsAction2.is = is;
        function create(options) {
          return {
            kind: ResizeElementsAction2.KIND,
            dimension: ResizeDimension.Width,
            elementIds: [],
            ...options
          };
        }
        ResizeElementsAction2.create = create;
      })(ResizeElementsAction || (exports.ResizeElementsAction = ResizeElementsAction = {}));
      var LayoutElementsActionHandler = class LayoutElementsActionHandler {
        getSelectedElements(selection) {
          const index = this.selectionService.getModelRoot().index;
          const selectedElements = selection.elementIds.length > 0 ? selection.elementIds : this.selectionService.getSelectedElementIDs();
          return (0, gmodel_util_1.getElements)(index, selectedElements, this.isActionElement);
        }
        dispatchAction(action) {
          this.actionDispatcher.dispatch(action);
        }
        dispatchActions(actions) {
          this.actionDispatcher.dispatchAll(actions);
        }
      };
      exports.LayoutElementsActionHandler = LayoutElementsActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], LayoutElementsActionHandler.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], LayoutElementsActionHandler.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IMovementRestrictor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], LayoutElementsActionHandler.prototype, "movementRestrictor", void 0);
      exports.LayoutElementsActionHandler = LayoutElementsActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], LayoutElementsActionHandler);
      var ResizeElementsActionHandler = class ResizeElementsActionHandler extends LayoutElementsActionHandler {
        handle(action) {
          const elements = this.getSelectedElements(action);
          if (elements.length > 1) {
            const reduceFn = ReduceFunction.get(action.reduceFunction);
            switch (action.dimension) {
              case ResizeDimension.Width:
                return this.resizeWidth(elements, reduceFn);
              case ResizeDimension.Height:
                return this.resizeHeight(elements, reduceFn);
              case ResizeDimension.Width_And_Height:
                return this.resizeWidthAndHeight(elements, reduceFn);
            }
          }
        }
        resizeWidth(elements, reduceFn) {
          const targetWidth = reduceFn(...elements.map((element) => element.bounds.width));
          this.dispatchResizeActions(elements, (element, bounds) => {
            const halfDiffWidth = 0.5 * (targetWidth - element.bounds.width);
            bounds.newPosition.x = element.bounds.x - halfDiffWidth;
            bounds.newSize.width = targetWidth;
          });
        }
        resizeHeight(elements, reduceFn) {
          const targetHeight = reduceFn(...elements.map((element) => element.bounds.height));
          this.dispatchResizeActions(elements, (element, bounds) => {
            const halfDiffHeight = 0.5 * (targetHeight - element.bounds.height);
            bounds.newPosition.y = element.bounds.y - halfDiffHeight;
            bounds.newSize.height = targetHeight;
          });
        }
        resizeWidthAndHeight(elements, reduceFn) {
          const targetWidth = reduceFn(...elements.map((element) => element.bounds.width));
          const targetHeight = reduceFn(...elements.map((element) => element.bounds.height));
          const targetDimension = { width: targetWidth, height: targetHeight };
          this.dispatchResizeActions(elements, (element, bounds) => {
            const difference = sprotty_1.Dimension.subtract(targetDimension, element.bounds);
            const center = sprotty_1.Dimension.center(difference);
            bounds.newPosition = sprotty_1.Point.subtract(element.bounds, center);
            bounds.newSize = targetDimension;
          });
        }
        dispatchResizeActions(elements, change) {
          const elementAndBounds = [];
          elements.forEach((element) => {
            const elementChange = this.createElementAndBounds(element, change);
            if (elementChange) {
              elementAndBounds.push(elementChange);
            }
          });
          this.dispatchActions([sprotty_1.SetBoundsAction.create(elementAndBounds), sprotty_1.ChangeBoundsOperation.create(elementAndBounds)]);
        }
        createElementAndBounds(element, change) {
          const bounds = {
            elementId: element.id,
            newPosition: {
              x: element.bounds.x,
              y: element.bounds.y
            },
            newSize: {
              width: element.bounds.width,
              height: element.bounds.height
            }
          };
          change(element, bounds);
          return (0, layout_utils_1.toValidElementAndBounds)(element, bounds, this.movementRestrictor);
        }
        isActionElement(element) {
          return (0, model_1.isResizable)(element);
        }
      };
      exports.ResizeElementsActionHandler = ResizeElementsActionHandler;
      exports.ResizeElementsActionHandler = ResizeElementsActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ResizeElementsActionHandler);
      var Alignment;
      (function(Alignment2) {
        Alignment2[Alignment2["Left"] = 0] = "Left";
        Alignment2[Alignment2["Center"] = 1] = "Center";
        Alignment2[Alignment2["Right"] = 2] = "Right";
        Alignment2[Alignment2["Top"] = 3] = "Top";
        Alignment2[Alignment2["Middle"] = 4] = "Middle";
        Alignment2[Alignment2["Bottom"] = 5] = "Bottom";
      })(Alignment || (exports.Alignment = Alignment = {}));
      var SelectFunction;
      (function(SelectFunction2) {
        function all(elements) {
          return elements;
        }
        SelectFunction2.all = all;
        function first(elements) {
          return [elements[0]];
        }
        SelectFunction2.first = first;
        function last(elements) {
          return [elements[elements.length - 1]];
        }
        SelectFunction2.last = last;
        function get(kind) {
          return SelectFunction2[kind];
        }
        SelectFunction2.get = get;
      })(SelectFunction || (exports.SelectFunction = SelectFunction = {}));
      var AlignElementsAction;
      (function(AlignElementsAction2) {
        AlignElementsAction2.KIND = "alignElements";
        function is(object) {
          return sprotty_1.Action.hasKind(object, AlignElementsAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "elementIds") && (0, sprotty_1.hasNumberProp)(object, "alignment") && (0, sprotty_1.hasStringProp)(object, "selectFunction");
        }
        AlignElementsAction2.is = is;
        function create(options = {}) {
          return {
            kind: AlignElementsAction2.KIND,
            elementIds: [],
            alignment: Alignment.Left,
            selectFunction: "all",
            ...options
          };
        }
        AlignElementsAction2.create = create;
      })(AlignElementsAction || (exports.AlignElementsAction = AlignElementsAction = {}));
      var AlignElementsActionHandler = class AlignElementsActionHandler extends LayoutElementsActionHandler {
        handle(action) {
          const elements = this.getSelectedElements(action);
          const selectFn = SelectFunction.get(action.selectFunction);
          const calculatedElements = selectFn(elements);
          if (elements.length > 1) {
            switch (action.alignment) {
              case Alignment.Left:
                return this.alignLeft(calculatedElements);
              case Alignment.Center:
                return this.alignCenter(calculatedElements);
              case Alignment.Right:
                return this.alignRight(calculatedElements);
              case Alignment.Top:
                return this.alignTop(calculatedElements);
              case Alignment.Middle:
                return this.alignMiddle(calculatedElements);
              case Alignment.Bottom:
                return this.alignBottom(calculatedElements);
            }
          }
        }
        alignLeft(elements) {
          const minX = elements.map((element) => element.bounds.x).reduce((a3, b3) => Math.min(a3, b3));
          this.dispatchAlignActions(elements, (_3, move) => move.toPosition.x = minX);
        }
        alignCenter(elements) {
          const minX = elements.map((element) => element.bounds.x).reduce((a3, b3) => Math.min(a3, b3));
          const maxX = elements.map((element) => element.bounds.x + element.bounds.width).reduce((a3, b3) => Math.max(a3, b3));
          const diffX = maxX - minX;
          const centerX = minX + 0.5 * diffX;
          this.dispatchAlignActions(elements, (element, move) => move.toPosition.x = centerX - 0.5 * element.bounds.width);
        }
        alignRight(elements) {
          const maxX = elements.map((element) => element.bounds.x + element.bounds.width).reduce((a3, b3) => Math.max(a3, b3));
          this.dispatchAlignActions(elements, (element, move) => move.toPosition.x = maxX - element.bounds.width);
        }
        alignTop(elements) {
          const minY = elements.map((element) => element.bounds.y).reduce((a3, b3) => Math.min(a3, b3));
          this.dispatchAlignActions(elements, (_3, move) => move.toPosition.y = minY);
        }
        alignMiddle(elements) {
          const minY = elements.map((element) => element.bounds.y).reduce((a3, b3) => Math.min(a3, b3));
          const maxY = elements.map((element) => element.bounds.y + element.bounds.height).reduce((a3, b3) => Math.max(a3, b3));
          const diffY = maxY - minY;
          const middleY = minY + 0.5 * diffY;
          this.dispatchAlignActions(elements, (element, move) => move.toPosition.y = middleY - 0.5 * element.bounds.height);
        }
        alignBottom(elements) {
          const maxY = elements.map((element) => element.bounds.y + element.bounds.height).reduce((a3, b3) => Math.max(a3, b3));
          this.dispatchAlignActions(elements, (element, move) => move.toPosition.y = maxY - element.bounds.height);
        }
        dispatchAlignActions(elements, change) {
          const moves = [];
          const elementAndBounds = [];
          elements.forEach((element) => {
            const move = this.createElementMove(element, change);
            if (move) {
              moves.push(move);
              const elementAndBound = this.createElementAndBounds(element, move);
              elementAndBounds.push(elementAndBound);
            }
          });
          this.dispatchActions([sprotty_1.MoveAction.create(moves), sprotty_1.ChangeBoundsOperation.create(elementAndBounds)]);
        }
        createElementMove(element, change) {
          const move = {
            elementId: element.id,
            fromPosition: {
              x: element.bounds.x,
              y: element.bounds.y
            },
            toPosition: {
              x: element.bounds.x,
              y: element.bounds.y
            }
          };
          change(element, move);
          return (0, layout_utils_1.toValidElementMove)(element, move, this.movementRestrictor);
        }
        createElementAndBounds(element, move) {
          return {
            elementId: element.id,
            newPosition: {
              x: move.toPosition.x,
              y: move.toPosition.y
            },
            newSize: {
              width: element.bounds.width,
              height: element.bounds.height
            }
          };
        }
        isActionElement(element) {
          return (0, model_1.isBoundsAwareMoveable)(element);
        }
      };
      exports.AlignElementsActionHandler = AlignElementsActionHandler;
      exports.AlignElementsActionHandler = AlignElementsActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], AlignElementsActionHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/layout/layout-module.js
  var require_layout_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/layout/layout-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.layoutModule = void 0;
      var sprotty_1 = require_lib4();
      var layout_elements_action_1 = require_layout_elements_action();
      exports.layoutModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureActionHandler)(context, layout_elements_action_1.ResizeElementsAction.KIND, layout_elements_action_1.ResizeElementsActionHandler);
        (0, sprotty_1.configureActionHandler)(context, layout_elements_action_1.AlignElementsAction.KIND, layout_elements_action_1.AlignElementsActionHandler);
      }, { featureId: Symbol("layout") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-target-resolver.js
  var require_navigation_target_resolver = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-target-resolver.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NavigationTargetResolver = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var NavigationTargetResolver = class NavigationTargetResolver {
        async resolve(navigationTarget) {
          return this.resolveWithSourceUri(this.diagramOptions.sourceUri, navigationTarget);
        }
        async resolveWithSourceUri(sourceUri, target) {
          const targetUri = decodeURIComponent(target.uri);
          const normalizedSourceUri = sourceUri === null || sourceUri === void 0 ? void 0 : sourceUri.replace(/^file:\/\//, "");
          const normalizedTargetUri = targetUri.replace(/^file:\/\//, "");
          if (normalizedSourceUri && normalizedSourceUri !== normalizedTargetUri) {
            this.logger.info("Source and Target URI are different. Can't resolve locally.", normalizedSourceUri, normalizedTargetUri);
            return void 0;
          }
          if (sprotty_1.NavigationTarget.getElementIds(target).length > 0) {
            return sprotty_1.SetResolvedNavigationTargetAction.create(sprotty_1.NavigationTarget.getElementIds(target));
          }
          const response = await this.requestResolution(target);
          if (sprotty_1.SetResolvedNavigationTargetAction.is(response)) {
            return response;
          }
          return void 0;
        }
        requestResolution(target) {
          return this.dispatcher.request(sprotty_1.ResolveNavigationTargetAction.create(target));
        }
      };
      exports.NavigationTargetResolver = NavigationTargetResolver;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], NavigationTargetResolver.prototype, "dispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], NavigationTargetResolver.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], NavigationTargetResolver.prototype, "diagramOptions", void 0);
      exports.NavigationTargetResolver = NavigationTargetResolver = __decorate([
        (0, inversify_1.injectable)()
      ], NavigationTargetResolver);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-action-handler.js
  var require_navigation_action_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NavigationActionHandler = exports.ProcessNavigationArgumentsAction = exports.NavigateAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var navigation_target_resolver_1 = require_navigation_target_resolver();
      var NavigateAction;
      (function(NavigateAction2) {
        NavigateAction2.KIND = "navigate";
        function is(object) {
          return sprotty_1.Action.hasKind(object, NavigateAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "targetTypeId");
        }
        NavigateAction2.is = is;
        function create(targetTypeId, options = {}) {
          return {
            kind: NavigateAction2.KIND,
            targetTypeId,
            ...options
          };
        }
        NavigateAction2.create = create;
      })(NavigateAction || (exports.NavigateAction = NavigateAction = {}));
      var ProcessNavigationArgumentsAction;
      (function(ProcessNavigationArgumentsAction2) {
        ProcessNavigationArgumentsAction2.KIND = "processNavigationArguments";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ProcessNavigationArgumentsAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "args");
        }
        ProcessNavigationArgumentsAction2.is = is;
        function create(args) {
          return {
            kind: ProcessNavigationArgumentsAction2.KIND,
            args
          };
        }
        ProcessNavigationArgumentsAction2.create = create;
      })(ProcessNavigationArgumentsAction || (exports.ProcessNavigationArgumentsAction = ProcessNavigationArgumentsAction = {}));
      var NavigationActionHandler = class NavigationActionHandler {
        constructor() {
          this.notificationTimeout = 5e3;
        }
        handle(action) {
          if (NavigateAction.is(action)) {
            this.handleNavigateAction(action);
          } else if (sprotty_1.NavigateToTargetAction.is(action)) {
            this.handleNavigateToTarget(action);
          } else if (ProcessNavigationArgumentsAction.is(action)) {
            this.processNavigationArguments(action.args);
          } else if (sprotty_1.NavigateToExternalTargetAction.is(action)) {
            this.handleNavigateToExternalTarget(action);
          }
        }
        async handleNavigateAction(action) {
          try {
            const editorContext = this.editorContext.get(action.args);
            const response = await this.dispatcher.request(sprotty_1.RequestNavigationTargetsAction.create({ targetTypeId: action.targetTypeId, editorContext }));
            if (sprotty_1.SetNavigationTargetsAction.is(response) && response.targets && response.targets.length === 1) {
              if (response.targets.length > 1) {
                this.logger.warn(this, "Processing of multiple targets is not supported yet. Only the first is being processed.", response.targets);
              }
              return this.dispatcher.dispatch(sprotty_1.NavigateToTargetAction.create(response.targets[0]));
            }
            this.warnAboutFailedNavigation("No valid navigation target found");
          } catch (reason) {
            this.logger.error(this, "Failed to obtain navigation target", reason, action);
          }
        }
        async handleNavigateToTarget(action) {
          try {
            const resolvedElements = await this.resolveElements(action);
            if (this.containsElementIdsOrArguments(resolvedElements)) {
              this.navigateTo(resolvedElements);
              this.handleResolutionArguments(resolvedElements);
              return;
            } else {
              this.navigateToExternal(action.target);
              return;
            }
          } catch (reason) {
            this.logger.error(this, "Failed to navigate", reason, action);
          }
        }
        resolveElements(action) {
          return this.resolver.resolve(action.target);
        }
        containsElementIdsOrArguments(target) {
          return target !== void 0 && (this.containsElementIds(target.elementIds) || this.containsArguments(target.args));
        }
        containsElementIds(elementIds) {
          return elementIds !== void 0 && elementIds.length > 0;
        }
        containsArguments(args) {
          return args !== void 0 && args !== void 0 && Object.keys(args).length > 0;
        }
        navigateTo(target) {
          const elementIds = target.elementIds;
          if (!this.containsElementIds(elementIds)) {
            return;
          }
          this.dispatcher.dispatchAll([
            sprotty_1.SelectAllAction.create(false),
            sprotty_1.SelectAction.create({ selectedElementsIDs: elementIds }),
            sprotty_1.CenterAction.create(elementIds)
          ]);
        }
        handleResolutionArguments(target) {
          const args = target.args;
          if (!this.containsArguments(args)) {
            return;
          }
          this.dispatcher.dispatch(ProcessNavigationArgumentsAction.create(args));
        }
        navigateToExternal(target) {
          return this.dispatcher.dispatch(sprotty_1.NavigateToExternalTargetAction.create(target));
        }
        processNavigationArguments(args) {
          if (args.info && args.info.toString().length > 0) {
            this.notify("INFO", args.info.toString());
          }
          if (args.warning && args.warning.toString().length > 0) {
            this.notify("WARNING", args.warning.toString());
          }
          if (args.error && args.error.toString().length > 0) {
            this.notify("ERROR", args.error.toString());
          }
        }
        async handleNavigateToExternalTarget(action) {
          const handlers = this.actionHandlerRegistry.get(sprotty_1.NavigateToExternalTargetAction.KIND);
          if (handlers.length === 1) {
            this.warnAboutFailedNavigation("Could not resolve or navigate to target", action.target);
          }
        }
        warnAboutFailedNavigation(msg, target) {
          const message = `${msg}` + (target ? `: '${target.uri}' (arguments: ${JSON.stringify(target.args)})` : "");
          this.logger.warn(this, msg, target);
          this.notify("WARNING", message);
        }
        notify(severity, message) {
          const timeout = this.notificationTimeout;
          this.dispatcher.dispatchAll([sprotty_1.StatusAction.create(message, { severity, timeout }), sprotty_1.MessageAction.create(message, { severity })]);
        }
      };
      exports.NavigationActionHandler = NavigationActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], NavigationActionHandler.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], NavigationActionHandler.prototype, "dispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ActionHandlerRegistryProvider),
        __metadata("design:type", Function)
      ], NavigationActionHandler.prototype, "actionHandlerRegistryProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IEditorContextServiceProvider),
        __metadata("design:type", Function)
      ], NavigationActionHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.ActionHandlerRegistry),
        __metadata("design:type", sprotty_1.ActionHandlerRegistry)
      ], NavigationActionHandler.prototype, "actionHandlerRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(navigation_target_resolver_1.NavigationTargetResolver),
        __metadata("design:type", navigation_target_resolver_1.NavigationTargetResolver)
      ], NavigationActionHandler.prototype, "resolver", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], NavigationActionHandler.prototype, "editorContext", void 0);
      exports.NavigationActionHandler = NavigationActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], NavigationActionHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-module.js
  var require_navigation_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/navigation/navigation-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.navigationModule = void 0;
      var sprotty_1 = require_lib4();
      var navigation_action_handler_1 = require_navigation_action_handler();
      var navigation_target_resolver_1 = require_navigation_target_resolver();
      exports.navigationModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        bind(navigation_target_resolver_1.NavigationTargetResolver).toSelf().inSingletonScope();
        bind(navigation_action_handler_1.NavigationActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, navigation_action_handler_1.NavigateAction.KIND, navigation_action_handler_1.NavigationActionHandler);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, sprotty_1.NavigateToTargetAction.KIND, navigation_action_handler_1.NavigationActionHandler);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, navigation_action_handler_1.ProcessNavigationArgumentsAction.KIND, navigation_action_handler_1.NavigationActionHandler);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, sprotty_1.NavigateToExternalTargetAction.KIND, navigation_action_handler_1.NavigationActionHandler);
      }, { featureId: Symbol("navigation") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/routing/edge-router.js
  var require_edge_router = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/routing/edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPBezierEdgeRouter = exports.GLSPManhattanEdgeRouter = exports.GLSPPolylineEdgeRouter = exports.GLSPAbstractEdgeRouter = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var GLSPAbstractEdgeRouter = class GLSPAbstractEdgeRouter extends sprotty_1.AbstractEdgeRouter {
        getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection) {
          const anchor = super.getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection);
          return sprotty_1.Point.isValid(anchor) ? anchor : refPoint;
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          if (ensureBounds(edge.source) && ensureBounds(edge.target)) {
            super.cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints);
          }
        }
      };
      exports.GLSPAbstractEdgeRouter = GLSPAbstractEdgeRouter;
      exports.GLSPAbstractEdgeRouter = GLSPAbstractEdgeRouter = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPAbstractEdgeRouter);
      var GLSPPolylineEdgeRouter = class GLSPPolylineEdgeRouter extends sprotty_1.PolylineEdgeRouter {
        getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection) {
          const anchor = super.getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection);
          return sprotty_1.Point.isValid(anchor) ? anchor : refPoint;
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          if (ensureBounds(edge.source) && ensureBounds(edge.target)) {
            super.cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints);
          }
        }
      };
      exports.GLSPPolylineEdgeRouter = GLSPPolylineEdgeRouter;
      exports.GLSPPolylineEdgeRouter = GLSPPolylineEdgeRouter = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPPolylineEdgeRouter);
      var GLSPManhattanEdgeRouter = class GLSPManhattanEdgeRouter extends sprotty_1.ManhattanEdgeRouter {
        getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection) {
          const anchor = super.getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection);
          return sprotty_1.Point.isValid(anchor) ? anchor : refPoint;
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          if (ensureBounds(edge.source) && ensureBounds(edge.target)) {
            super.cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints);
          }
        }
      };
      exports.GLSPManhattanEdgeRouter = GLSPManhattanEdgeRouter;
      exports.GLSPManhattanEdgeRouter = GLSPManhattanEdgeRouter = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPManhattanEdgeRouter);
      var GLSPBezierEdgeRouter = class GLSPBezierEdgeRouter extends sprotty_1.BezierEdgeRouter {
        getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection) {
          const anchor = super.getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection);
          return sprotty_1.Point.isValid(anchor) ? anchor : refPoint;
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          if (ensureBounds(edge.source) && ensureBounds(edge.target)) {
            super.cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints);
          }
        }
      };
      exports.GLSPBezierEdgeRouter = GLSPBezierEdgeRouter;
      exports.GLSPBezierEdgeRouter = GLSPBezierEdgeRouter = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPBezierEdgeRouter);
      function ensureBounds(element) {
        if (!element) {
          return false;
        }
        if (element.bounds) {
          return true;
        }
        if (element.position && element.size) {
          element.bounds = { ...element.position, ...element.size };
          return true;
        }
        return false;
      }
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/routing/routing-module.js
  var require_routing_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/routing/routing-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.routingModule = void 0;
      var sprotty_1 = require_lib4();
      var edge_router_1 = require_edge_router();
      exports.routingModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        bind(sprotty_1.EdgeRouterRegistry).toSelf().inSingletonScope();
        bind(sprotty_1.AnchorComputerRegistry).toSelf().inSingletonScope();
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IEdgeRouter, edge_router_1.GLSPManhattanEdgeRouter);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.ManhattanEllipticAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.ManhattanRectangularAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.ManhattanDiamondAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IEdgeRouter, edge_router_1.GLSPPolylineEdgeRouter);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.EllipseAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.RectangleAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.DiamondAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IEdgeRouter, edge_router_1.GLSPBezierEdgeRouter);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.BezierEllipseAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.BezierRectangleAnchor);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IAnchorComputer, sprotty_1.BezierDiamondAnchor);
        (0, sprotty_1.configureCommand)({ bind, isBound }, sprotty_1.AddRemoveBezierSegmentCommand);
      }, { featureId: Symbol("routing") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/select/select-feedback-command.js
  var require_select_feedback_command = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/select/select-feedback-command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectFeedbackCommand = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var selection_service_1 = require_selection_service();
      var SelectFeedbackCommand = class SelectFeedbackCommand extends sprotty_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.sprottySelectCommand = new sprotty_1.SprottySelectCommand({ ...action, kind: sprotty_1.SelectAction.KIND });
        }
        execute(context) {
          return this.sprottySelectCommand.execute(context);
        }
        undo(context) {
          return this.sprottySelectCommand.undo(context);
        }
        redo(context) {
          return this.sprottySelectCommand.redo(context);
        }
      };
      exports.SelectFeedbackCommand = SelectFeedbackCommand;
      SelectFeedbackCommand.KIND = selection_service_1.SelectFeedbackAction.KIND;
      exports.SelectFeedbackCommand = SelectFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SelectFeedbackCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/select/select-mouse-listener.js
  var require_select_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/select/select-mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RankedSelectMouseListener = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ranked_1 = require_ranked();
      var model_1 = require_model19();
      var RankedSelectMouseListener = class RankedSelectMouseListener extends sprotty_1.SelectMouseListener {
        constructor() {
          super(...arguments);
          this.rank = ranked_1.Ranked.DEFAULT_RANK - 100;
        }
        handleSelectTarget(selectableTarget, deselectedElements, event) {
          const result = [];
          result.push(sprotty_1.SelectAction.create({
            selectedElementsIDs: [selectableTarget.id],
            deselectedElementsIDs: deselectedElements.map((e2) => e2.id)
          }));
          result.push(sprotty_1.BringToFrontAction.create([selectableTarget.id]));
          return result;
        }
        handleDeselectTarget(selectableTarget, event) {
          const result = [];
          result.push(sprotty_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: [selectableTarget.id] }));
          return result;
        }
        handleDeselectAll(deselectedElements, event) {
          const result = [];
          result.push(sprotty_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: deselectedElements.map((e2) => e2.id) }));
          return result;
        }
        handleButton(target, event) {
          var _a4;
          if (target instanceof model_1.GResizeHandle && ((_a4 = this.changeBoundsManager) === null || _a4 === void 0 ? void 0 : _a4.useSymmetricResize(event))) {
            return [];
          }
          return super.handleButton(target, event);
        }
      };
      exports.RankedSelectMouseListener = RankedSelectMouseListener;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IChangeBoundsManager),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], RankedSelectMouseListener.prototype, "changeBoundsManager", void 0);
      exports.RankedSelectMouseListener = RankedSelectMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], RankedSelectMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/select/select-module.js
  var require_select_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/select/select-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneSelectModule = exports.selectModule = void 0;
      var sprotty_1 = require_lib4();
      var selection_service_1 = require_selection_service();
      var select_feedback_command_1 = require_select_feedback_command();
      var select_mouse_listener_1 = require_select_mouse_listener();
      exports.selectModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureCommand)(context, selection_service_1.SelectCommand);
        (0, sprotty_1.configureCommand)(context, selection_service_1.SelectAllCommand);
        (0, sprotty_1.configureCommand)(context, select_feedback_command_1.SelectFeedbackCommand);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, select_mouse_listener_1.RankedSelectMouseListener);
      }, { featureId: Symbol("select") });
      exports.standaloneSelectModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.KeyListener, sprotty_1.SelectKeyboardListener);
      }, { featureId: Symbol("standaloneSelect"), requires: exports.selectModule });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/source-model-watcher/source-model-changed-action-handler.js
  var require_source_model_changed_action_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/source-model-watcher/source-model-changed-action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SourceModelChangedActionHandler = exports.ExternalSourceModelChangedHandler = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var ExternalSourceModelChangedHandler = class ExternalSourceModelChangedHandler {
      };
      exports.ExternalSourceModelChangedHandler = ExternalSourceModelChangedHandler;
      exports.ExternalSourceModelChangedHandler = ExternalSourceModelChangedHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ExternalSourceModelChangedHandler);
      var SourceModelChangedActionHandler = class SourceModelChangedActionHandler {
        handle(action) {
          if (sprotty_1.SourceModelChangedAction.is(action)) {
            if (this.externalModelSourceChangedHandler) {
              this.externalModelSourceChangedHandler.notifySourceModelChange(action.sourceModelName, this.options).then((actions) => this.dispatcher.dispatchAll(actions));
              return;
            }
            this.showSimpleNotification(action);
          }
        }
        showSimpleNotification(action) {
          const message = `The source model ${action.sourceModelName} has changed. You might want to consider reloading.`;
          const timeout = 0;
          const severity = "WARNING";
          this.dispatcher.dispatchAll([sprotty_1.StatusAction.create(message, { severity, timeout }), sprotty_1.MessageAction.create(message, { severity })]);
        }
      };
      exports.SourceModelChangedActionHandler = SourceModelChangedActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], SourceModelChangedActionHandler.prototype, "dispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], SourceModelChangedActionHandler.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(ExternalSourceModelChangedHandler),
        (0, inversify_1.optional)(),
        __metadata("design:type", ExternalSourceModelChangedHandler)
      ], SourceModelChangedActionHandler.prototype, "externalModelSourceChangedHandler", void 0);
      exports.SourceModelChangedActionHandler = SourceModelChangedActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], SourceModelChangedActionHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/source-model-watcher/source-model-watcher-module.js
  var require_source_model_watcher_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/source-model-watcher/source-model-watcher-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sourceModelWatcherModule = void 0;
      var sprotty_1 = require_lib4();
      var source_model_changed_action_handler_1 = require_source_model_changed_action_handler();
      exports.sourceModelWatcherModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, sprotty_1.SourceModelChangedAction.KIND, source_model_changed_action_handler_1.SourceModelChangedActionHandler);
      }, { featureId: Symbol("sourceModelWatcher") });
    }
  });

  // node_modules/@eclipse-glsp/client/css/status-overlay.css
  var require_status_overlay = __commonJS({
    "node_modules/@eclipse-glsp/client/css/status-overlay.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/status/status-overlay.js
  var require_status_overlay2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/status/status-overlay.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var StatusOverlay_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StatusOverlay = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ui_extension_1 = require_ui_extension2();
      var StatusOverlay = StatusOverlay_1 = class StatusOverlay extends ui_extension_1.GLSPAbstractUIExtension {
        id() {
          return StatusOverlay_1.ID;
        }
        containerClass() {
          return "sprotty-status";
        }
        initializeContents(containerElement) {
          this.statusIconDiv = document.createElement("div");
          containerElement.appendChild(this.statusIconDiv);
          this.statusMessageDiv = document.createElement("div");
          this.statusMessageDiv.classList.add("sprotty-status-message");
          containerElement.appendChild(this.statusMessageDiv);
        }
        setStatus(status) {
          if (this.statusMessageDiv) {
            this.statusMessageDiv.textContent = status.message;
            this.removeClasses(this.statusMessageDiv, 1);
            this.statusMessageDiv.classList.add(status.severity.toLowerCase());
          }
          if (this.statusIconDiv) {
            this.removeClasses(this.statusIconDiv, 0);
            const classes = this.statusIconDiv.classList;
            classes.add(status.severity.toLowerCase());
            switch (status.severity) {
              case "FATAL":
                classes.add(...(0, sprotty_1.codiconCSSClasses)("error"));
                break;
              case "ERROR":
                classes.add(...(0, sprotty_1.codiconCSSClasses)("warning"));
                break;
              case "WARNING":
                classes.add(...(0, sprotty_1.codiconCSSClasses)("warning"));
                break;
              case "INFO":
                classes.add(...(0, sprotty_1.codiconCSSClasses)("info"));
                break;
            }
          }
        }
        clearStatus() {
          this.setStatus(sprotty_1.StatusAction.create("", { severity: "NONE" }));
        }
        clearTimeout() {
          if (this.pendingTimeout) {
            window.clearTimeout(this.pendingTimeout);
            this.pendingTimeout = void 0;
          }
        }
        removeClasses(element, keep) {
          const classes = element.classList;
          while (classes.length > keep) {
            const item = classes.item(classes.length - 1);
            if (item) {
              classes.remove(item);
            }
          }
        }
        handle(action) {
          var _a4;
          this.clearTimeout();
          if (action.severity === "NONE") {
            this.clearStatus();
            return;
          }
          this.setStatus(action);
          const statusTimeout = (_a4 = action.timeout) !== null && _a4 !== void 0 ? _a4 : -1;
          if (statusTimeout > 0) {
            this.pendingTimeout = window.setTimeout(() => this.clearStatus(), statusTimeout);
          }
        }
        preInitialize() {
          return this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: this.id(), visible: true }));
        }
      };
      exports.StatusOverlay = StatusOverlay;
      StatusOverlay.ID = "glsp.server.status.overlay";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], StatusOverlay.prototype, "actionDispatcher", void 0);
      exports.StatusOverlay = StatusOverlay = StatusOverlay_1 = __decorate([
        (0, inversify_1.injectable)()
      ], StatusOverlay);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/status/status-module.js
  var require_status_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/status/status-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.statusModule = void 0;
      var sprotty_1 = require_lib4();
      require_status_overlay();
      var status_overlay_1 = require_status_overlay2();
      exports.statusModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, status_overlay_1.StatusOverlay);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(status_overlay_1.StatusOverlay);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.StatusAction.KIND, status_overlay_1.StatusOverlay);
      }, { featureId: Symbol("status") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/svg-metadata/metadata-placer.js
  var require_metadata_placer = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/svg-metadata/metadata-placer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MetadataPlacer = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var model_1 = require_model22();
      var MetadataPlacer = class MetadataPlacer {
        decorate(vnode, element) {
          if (element instanceof sprotty_1.GModelRoot) {
            (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-api", true);
          }
          (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-type", element.type);
          if (element instanceof sprotty_1.GChildElement) {
            (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-parent-id", this.domHelper.createUniqueDOMElementId(element.parent));
          }
          if (element instanceof model_1.GEdge) {
            if (element.source !== void 0) {
              (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-edge-source-id", this.domHelper.createUniqueDOMElementId(element.source));
            }
            if (element.target !== void 0) {
              (0, sprotty_1.setAttr)(vnode, "data-svg-metadata-edge-target-id", this.domHelper.createUniqueDOMElementId(element.target));
            }
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.MetadataPlacer = MetadataPlacer;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.DOMHelper),
        __metadata("design:type", sprotty_1.DOMHelper)
      ], MetadataPlacer.prototype, "domHelper", void 0);
      exports.MetadataPlacer = MetadataPlacer = __decorate([
        (0, inversify_1.injectable)()
      ], MetadataPlacer);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/svg-metadata/svg-metadata-module.js
  var require_svg_metadata_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/svg-metadata/svg-metadata-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.svgMetadataModule = void 0;
      var sprotty_1 = require_lib4();
      var metadata_placer_1 = require_metadata_placer();
      exports.svgMetadataModule = new sprotty_1.FeatureModule((bind) => {
        bind(metadata_placer_1.MetadataPlacer).toSelf().inSingletonScope();
        bind(sprotty_1.TYPES.IVNodePostprocessor).toService(metadata_placer_1.MetadataPlacer);
      }, { featureId: Symbol("svgMetadata") });
    }
  });

  // node_modules/@eclipse-glsp/client/css/tool-palette.css
  var require_tool_palette2 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/tool-palette.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/deletion/delete-tool.js
  var require_delete_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/deletion/delete-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var DelKeyDeleteTool_1;
      var MouseDeleteTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteToolMouseListener = exports.MouseDeleteTool = exports.DeleteKeyListener = exports.DelKeyDeleteTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var css_feedback_1 = require_css_feedback();
      var tool_1 = require_tool();
      var base_tools_1 = require_base_tools();
      var DelKeyDeleteTool = DelKeyDeleteTool_1 = class DelKeyDeleteTool {
        constructor() {
          this.isEditTool = true;
          this.deleteKeyListener = new DeleteKeyListener();
        }
        get id() {
          return DelKeyDeleteTool_1.ID;
        }
        enable() {
          this.keytool.register(this.deleteKeyListener);
        }
        disable() {
          this.keytool.deregister(this.deleteKeyListener);
        }
      };
      exports.DelKeyDeleteTool = DelKeyDeleteTool;
      DelKeyDeleteTool.ID = "glsp.delete-keyboard";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], DelKeyDeleteTool.prototype, "keytool", void 0);
      exports.DelKeyDeleteTool = DelKeyDeleteTool = DelKeyDeleteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], DelKeyDeleteTool);
      var DeleteKeyListener = class DeleteKeyListener extends sprotty_1.KeyListener {
        keyDown(element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Delete")) {
            const deleteElementIds = Array.from(element.root.index.all().filter((e2) => (0, sprotty_1.isDeletable)(e2) && (0, sprotty_1.isSelectable)(e2) && e2.selected).filter((e2) => e2.id !== e2.root.id).map((e2) => e2.id));
            if (deleteElementIds.length > 0) {
              return [sprotty_1.DeleteElementOperation.create(deleteElementIds)];
            }
          }
          return [];
        }
      };
      exports.DeleteKeyListener = DeleteKeyListener;
      exports.DeleteKeyListener = DeleteKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], DeleteKeyListener);
      var MouseDeleteTool = MouseDeleteTool_1 = class MouseDeleteTool extends base_tools_1.BaseEditTool {
        constructor() {
          super(...arguments);
          this.deleteToolMouseListener = new DeleteToolMouseListener();
        }
        get id() {
          return MouseDeleteTool_1.ID;
        }
        enable() {
          const cursorFeedback = this.createFeedbackEmitter().add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.ELEMENT_DELETION), (0, css_feedback_1.cursorFeedbackAction)()).submit();
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(this.deleteToolMouseListener), cursorFeedback);
        }
      };
      exports.MouseDeleteTool = MouseDeleteTool;
      MouseDeleteTool.ID = "glsp.delete-mouse";
      exports.MouseDeleteTool = MouseDeleteTool = MouseDeleteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], MouseDeleteTool);
      var DeleteToolMouseListener = class DeleteToolMouseListener extends sprotty_1.MouseListener {
        mouseUp(target, event) {
          const deletableParent = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isDeletable);
          if (deletableParent === void 0) {
            return [];
          }
          const result = [];
          result.push(sprotty_1.DeleteElementOperation.create([deletableParent.id]));
          if (!(0, sprotty_1.isCtrlOrCmd)(event)) {
            result.push(tool_1.EnableDefaultToolsAction.create());
          }
          return result;
        }
      };
      exports.DeleteToolMouseListener = DeleteToolMouseListener;
      exports.DeleteToolMouseListener = DeleteToolMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], DeleteToolMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-tool-feedback.js
  var require_marquee_tool_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-tool-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.removeMarquee = exports.drawMarquee = exports.MARQUEE = exports.marqueeId = exports.MarqueeEndMovingMouseListener = exports.RemoveMarqueeCommand = exports.RemoveMarqueeAction = exports.DrawMarqueeCommand = exports.DrawMarqueeAction = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var feedback_command_1 = require_feedback_command();
      var DrawMarqueeAction;
      (function(DrawMarqueeAction2) {
        DrawMarqueeAction2.KIND = "drawMarquee";
        function is(object) {
          return sprotty_1.Action.hasKind(object, DrawMarqueeAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "startPoint") && (0, sprotty_1.hasObjectProp)(object, "endPoint");
        }
        DrawMarqueeAction2.is = is;
        function create(options) {
          return {
            kind: DrawMarqueeAction2.KIND,
            ...options
          };
        }
        DrawMarqueeAction2.create = create;
      })(DrawMarqueeAction || (exports.DrawMarqueeAction = DrawMarqueeAction = {}));
      var DrawMarqueeCommand = class DrawMarqueeCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          drawMarquee(context, this.action.startPoint, this.action.endPoint);
          return context.root;
        }
      };
      exports.DrawMarqueeCommand = DrawMarqueeCommand;
      DrawMarqueeCommand.KIND = DrawMarqueeAction.KIND;
      exports.DrawMarqueeCommand = DrawMarqueeCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DrawMarqueeCommand);
      var RemoveMarqueeAction;
      (function(RemoveMarqueeAction2) {
        RemoveMarqueeAction2.KIND = "removeMarquee";
        function is(object) {
          return sprotty_1.Action.hasKind(object, RemoveMarqueeAction2.KIND);
        }
        RemoveMarqueeAction2.is = is;
        function create() {
          return { kind: RemoveMarqueeAction2.KIND };
        }
        RemoveMarqueeAction2.create = create;
      })(RemoveMarqueeAction || (exports.RemoveMarqueeAction = RemoveMarqueeAction = {}));
      var RemoveMarqueeCommand = class RemoveMarqueeCommand extends feedback_command_1.FeedbackCommand {
        execute(context) {
          removeMarquee(context.root);
          return context.root;
        }
      };
      exports.RemoveMarqueeCommand = RemoveMarqueeCommand;
      RemoveMarqueeCommand.KIND = RemoveMarqueeAction.KIND;
      exports.RemoveMarqueeCommand = RemoveMarqueeCommand = __decorate([
        (0, inversify_1.injectable)()
      ], RemoveMarqueeCommand);
      var MarqueeEndMovingMouseListener = class extends sprotty_1.MouseListener {
        constructor(anchorRegistry) {
          super();
          this.anchorRegistry = anchorRegistry;
        }
        mouseMove(target, event) {
          return [];
        }
      };
      exports.MarqueeEndMovingMouseListener = MarqueeEndMovingMouseListener;
      function marqueeId(root) {
        return root.id + "_" + exports.MARQUEE;
      }
      exports.marqueeId = marqueeId;
      exports.MARQUEE = "marquee";
      function drawMarquee(context, startPoint, endPoint) {
        const root = context.root;
        removeMarquee(root);
        const marqueeSchema = {
          type: exports.MARQUEE,
          id: marqueeId(root),
          startPoint,
          endPoint
        };
        const marquee = context.modelFactory.createElement(marqueeSchema);
        root.add(marquee);
      }
      exports.drawMarquee = drawMarquee;
      function removeMarquee(root) {
        const marquee = root.index.getById(marqueeId(root));
        if (marquee instanceof sprotty_1.GChildElement) {
          root.remove(marquee);
        }
      }
      exports.removeMarquee = removeMarquee;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-behavior.js
  var require_marquee_behavior = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-behavior.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarqueeUtil = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var model_1 = require_model22();
      var gmodel_util_1 = require_gmodel_util();
      var viewpoint_util_1 = require_viewpoint_util();
      var marquee_tool_feedback_1 = require_marquee_tool_feedback();
      var MarqueeUtil = class MarqueeUtil {
        constructor(marqueeBehavior = { entireElement: false, entireEdge: false }, domHelper) {
          this.marqueeBehavior = marqueeBehavior;
          this.domHelper = domHelper;
        }
        isContinuousMode(element, event) {
          return event.shiftKey;
        }
        getMarkableNodes(root) {
          return (0, gmodel_util_1.getMatchingElements)(root.index, this.isMarkableNode());
        }
        isMarkableNode() {
          return (0, sprotty_1.typeGuard)((0, sprotty_1.toTypeGuard)(sprotty_1.GNode), gmodel_util_1.isSelectableAndBoundsAware);
        }
        getMarkableEdges(root) {
          return (0, gmodel_util_1.getMatchingElements)(root.index, this.isMarkableEdge());
        }
        isMarkableEdge() {
          return (0, sprotty_1.typeGuard)((0, sprotty_1.toTypeGuard)(model_1.GEdge), sprotty_1.isSelectable);
        }
        updateStartPoint(position) {
          this.startPoint = position;
        }
        updateCurrentPoint(position) {
          this.currentPoint = position;
        }
        isMarked(element) {
          return element instanceof model_1.GEdge ? this.isMarkedEdge(element) : this.isMarkedNode(element);
        }
        drawMarqueeAction() {
          return marquee_tool_feedback_1.DrawMarqueeAction.create({ startPoint: this.startPoint, endPoint: this.currentPoint });
        }
        isMarkedEdge(edge) {
          const domId = this.domHelper.createUniqueDOMElementId(edge);
          const domEdge = document.getElementById(domId);
          if (!domEdge || domEdge.getAttribute("transform") || !domEdge.children[0]) {
            return false;
          }
          const path = domEdge.children[0].getAttribute("d");
          return this.isEdgePathMarked(path);
        }
        isMarkedNode(node) {
          return this.isNodeMarked(this.getNodeBounds(node));
        }
        getNodeBounds(node) {
          return (0, viewpoint_util_1.toAbsoluteBounds)(node);
        }
        isEdgePathMarked(path) {
          if (!path) {
            return false;
          }
          const points = path.split(/M|L/).filter((p3) => p3).map((p3) => {
            const coord = p3.split(",");
            return { x: parseInt(coord[0], 10), y: parseInt(coord[1], 10) };
          });
          return this.isEdgeMarked(points);
        }
        isEdgeMarked(points) {
          return this.marqueeBehavior.entireEdge ? this.isEntireEdgeMarked(points) : this.isPartOfEdgeMarked(points);
        }
        isNodeMarked(elementBounds) {
          const horizontallyIn = this.startPoint.x < this.currentPoint.x ? this.isElementBetweenXAxis(elementBounds, this.startPoint.x, this.currentPoint.x) : this.isElementBetweenXAxis(elementBounds, this.currentPoint.x, this.startPoint.x);
          const verticallyIn = this.startPoint.y < this.currentPoint.y ? this.isElementBetweenYAxis(elementBounds, this.startPoint.y, this.currentPoint.y) : this.isElementBetweenYAxis(elementBounds, this.currentPoint.y, this.startPoint.y);
          return horizontallyIn && verticallyIn;
        }
        isEntireEdgeMarked(points) {
          for (let i2 = 0; i2 < points.length; i2++) {
            if (!this.pointInRect(points[i2])) {
              return false;
            }
          }
          return true;
        }
        isPartOfEdgeMarked(points) {
          for (let i2 = 0; i2 < points.length - 1; i2++) {
            if (this.isLineMarked(points[i2], points[i2 + 1])) {
              return true;
            }
          }
          return false;
        }
        isLineMarked(point1, point2) {
          const line = new sprotty_1.PointToPointLine(point1, point2);
          return this.pointInRect(point1) || this.pointInRect(point2) || this.lineIntersect(line, this.startPoint, { x: this.startPoint.x, y: this.currentPoint.y }) || this.lineIntersect(line, this.startPoint, { x: this.currentPoint.x, y: this.startPoint.y }) || this.lineIntersect(line, { x: this.currentPoint.x, y: this.startPoint.y }, this.currentPoint) || this.lineIntersect(line, { x: this.startPoint.x, y: this.currentPoint.y }, this.currentPoint);
        }
        lineIntersect(line, p1, p22) {
          return line.intersection(new sprotty_1.PointToPointLine(p1, p22)) !== void 0;
        }
        pointInRect(point) {
          const boolX = this.startPoint.x <= this.currentPoint.x ? this.isBetween(point.x, this.startPoint.x, this.currentPoint.x) : this.isBetween(point.x, this.currentPoint.x, this.startPoint.x);
          const boolY = this.startPoint.y <= this.currentPoint.y ? this.isBetween(point.y, this.startPoint.y, this.currentPoint.y) : this.isBetween(point.y, this.currentPoint.y, this.startPoint.y);
          return boolX && boolY;
        }
        isElementBetweenXAxis(elementBounds, marqueeLeft, marqueeRight) {
          const leftEdge = this.isBetween(elementBounds.x, marqueeLeft, marqueeRight);
          const rightEdge = this.isBetween(elementBounds.x + elementBounds.width, marqueeLeft, marqueeRight);
          if (this.marqueeBehavior.entireElement) {
            return leftEdge && rightEdge;
          }
          return leftEdge || rightEdge || this.isBetween(marqueeLeft, elementBounds.x, elementBounds.x + elementBounds.width) || this.isBetween(marqueeRight, elementBounds.x, elementBounds.x + elementBounds.width);
        }
        isElementBetweenYAxis(elementBounds, marqueeTop, marqueeBottom) {
          const topEdge = this.isBetween(elementBounds.y, marqueeTop, marqueeBottom);
          const bottomEdge = this.isBetween(elementBounds.y + elementBounds.height, marqueeTop, marqueeBottom);
          if (this.marqueeBehavior.entireElement) {
            return topEdge && bottomEdge;
          }
          return topEdge || bottomEdge || this.isBetween(marqueeTop, elementBounds.y, elementBounds.y + elementBounds.height) || this.isBetween(marqueeBottom, elementBounds.y, elementBounds.y + elementBounds.height);
        }
        isBetween(x3, lower, upper) {
          return lower <= x3 && x3 <= upper;
        }
      };
      exports.MarqueeUtil = MarqueeUtil;
      exports.MarqueeUtil = MarqueeUtil = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.IMarqueeBehavior)),
        __param(0, (0, inversify_1.optional)()),
        __param(1, (0, inversify_1.inject)(sprotty_1.TYPES.DOMHelper)),
        __metadata("design:paramtypes", [Object, sprotty_1.DOMHelper])
      ], MarqueeUtil);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-mouse-tool.js
  var require_marquee_mouse_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-mouse-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var MarqueeMouseTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShiftKeyListener = exports.MarqueeMouseListener = exports.MarqueeMouseTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var tool_1 = require_tool();
      var gmodel_util_1 = require_gmodel_util();
      var viewpoint_util_1 = require_viewpoint_util();
      var base_tools_1 = require_base_tools();
      var marquee_behavior_1 = require_marquee_behavior();
      var marquee_tool_feedback_1 = require_marquee_tool_feedback();
      var MarqueeMouseTool = MarqueeMouseTool_1 = class MarqueeMouseTool extends base_tools_1.BaseEditTool {
        constructor() {
          super(...arguments);
          this.shiftKeyListener = new ShiftKeyListener();
        }
        get id() {
          return MarqueeMouseTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(new MarqueeMouseListener(this.editorContext.modelRoot, this.marqueeUtil)), this.keyTool.registerListener(this.shiftKeyListener), this.createFeedbackEmitter().add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.MARQUEE), (0, css_feedback_1.cursorFeedbackAction)()).submit());
        }
        get isEditTool() {
          return false;
        }
      };
      exports.MarqueeMouseTool = MarqueeMouseTool;
      MarqueeMouseTool.ID = "glsp.marquee-mouse-tool";
      __decorate([
        (0, inversify_1.inject)(marquee_behavior_1.MarqueeUtil),
        __metadata("design:type", marquee_behavior_1.MarqueeUtil)
      ], MarqueeMouseTool.prototype, "marqueeUtil", void 0);
      exports.MarqueeMouseTool = MarqueeMouseTool = MarqueeMouseTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], MarqueeMouseTool);
      var MarqueeMouseListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(root, marqueeUtil) {
          super();
          this.marqueeUtil = marqueeUtil;
          this.isActive = false;
          this.nodes = this.marqueeUtil.getMarkableNodes(root);
          this.edges = this.marqueeUtil.getMarkableEdges(root);
        }
        mouseDown(target, event) {
          this.isActive = true;
          this.marqueeUtil.updateStartPoint((0, viewpoint_util_1.getAbsolutePosition)(target, event));
          if (event.ctrlKey) {
            this.previouslySelected = (0, gmodel_util_1.getMatchingElements)(target.index, (0, sprotty_1.typeGuard)(gmodel_util_1.isSelectableAndBoundsAware, sprotty_1.isSelected)).map((e2) => e2.id);
          }
          return [];
        }
        mouseMove(target, event) {
          this.marqueeUtil.updateCurrentPoint((0, viewpoint_util_1.getAbsolutePosition)(target, event));
          if (this.isActive) {
            const nodeIdsSelected = this.nodes.filter((e2) => this.marqueeUtil.isMarked(e2)).map((e2) => e2.id);
            const edgeIdsSelected = this.edges.filter((e2) => this.marqueeUtil.isMarked(e2)).map((e2) => e2.id);
            const currentSelected = nodeIdsSelected.concat(edgeIdsSelected);
            const selection = currentSelected.concat(this.previouslySelected);
            return [sprotty_1.SelectAction.setSelection(selection), this.marqueeUtil.drawMarqueeAction()];
          }
          return [];
        }
        mouseUp(target, event) {
          this.isActive = false;
          return this.marqueeUtil.isContinuousMode(target, event) ? [marquee_tool_feedback_1.RemoveMarqueeAction.create()] : [marquee_tool_feedback_1.RemoveMarqueeAction.create(), tool_1.EnableDefaultToolsAction.create()];
        }
      };
      exports.MarqueeMouseListener = MarqueeMouseListener;
      var ShiftKeyListener = class ShiftKeyListener extends sprotty_1.KeyListener {
        keyUp(element, event) {
          if (event.shiftKey) {
            return [];
          }
          return [marquee_tool_feedback_1.RemoveMarqueeAction.create(), tool_1.EnableDefaultToolsAction.create()];
        }
      };
      exports.ShiftKeyListener = ShiftKeyListener;
      exports.ShiftKeyListener = ShiftKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], ShiftKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/origin-viewport.js
  var require_origin_viewport = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/origin-viewport.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OriginViewportCommand = exports.OriginViewportAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var OriginViewportAction;
      (function(OriginViewportAction2) {
        OriginViewportAction2.KIND = "originViewport";
        function is(object) {
          return sprotty_1.Action.hasKind(object, OriginViewportAction2.KIND);
        }
        OriginViewportAction2.is = is;
        function create(options = {}) {
          return {
            kind: OriginViewportAction2.KIND,
            animate: true,
            ...options
          };
        }
        OriginViewportAction2.create = create;
      })(OriginViewportAction || (exports.OriginViewportAction = OriginViewportAction = {}));
      var OriginViewportCommand = class OriginViewportCommand extends sprotty_1.BoundsAwareViewportCommand {
        constructor(action) {
          super(action.animate);
          this.action = action;
        }
        getElementIds() {
          return [];
        }
        initialize(model) {
          if (!(0, sprotty_1.isViewport)(model)) {
            return;
          }
          this.oldViewport = { scroll: model.scroll, zoom: model.zoom };
          const newViewport = this.getNewViewport(sprotty_1.Bounds.EMPTY, model);
          if (newViewport) {
            const { zoomLimits, horizontalScrollLimits, verticalScrollLimits } = this.viewerOptions;
            this.newViewport = (0, sprotty_1.limitViewport)(newViewport, model.canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits);
          }
        }
        getNewViewport(_bounds, _model) {
          return { zoom: 1, scroll: { x: 0, y: 0 } };
        }
      };
      exports.OriginViewportCommand = OriginViewportCommand;
      OriginViewportCommand.KIND = OriginViewportAction.KIND;
      exports.OriginViewportCommand = OriginViewportCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], OriginViewportCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tool-palette/tool-palette.js
  var require_tool_palette3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tool-palette/tool-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var ToolPalette_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.changeCodiconClass = exports.changeCSSClass = exports.createToolGroup = exports.createIcon = exports.compare = exports.ToolPalette = exports.EnableToolPaletteAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var focus_tracker_1 = require_focus_tracker();
      var messages_1 = require_messages3();
      var tool_1 = require_tool();
      var ui_extension_1 = require_ui_extension2();
      var delete_tool_1 = require_delete_tool();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var origin_viewport_1 = require_origin_viewport();
      var CLICKED_CSS_CLASS = "clicked";
      var SEARCH_ICON_ID = "search";
      var PALETTE_ICON_ID = "tools";
      var CHEVRON_DOWN_ICON_ID = "chevron-right";
      var PALETTE_HEIGHT = "500px";
      var EnableToolPaletteAction;
      (function(EnableToolPaletteAction2) {
        EnableToolPaletteAction2.KIND = "enableToolPalette";
        function is(object) {
          return sprotty_1.Action.hasKind(object, EnableToolPaletteAction2.KIND);
        }
        EnableToolPaletteAction2.is = is;
        function create() {
          return { kind: EnableToolPaletteAction2.KIND };
        }
        EnableToolPaletteAction2.create = create;
      })(EnableToolPaletteAction || (exports.EnableToolPaletteAction = EnableToolPaletteAction = {}));
      var ToolPalette = ToolPalette_1 = class ToolPalette extends ui_extension_1.GLSPAbstractUIExtension {
        constructor() {
          super(...arguments);
          this.paletteItemsCopy = [];
          this.dynamic = false;
        }
        id() {
          return ToolPalette_1.ID;
        }
        containerClass() {
          return ToolPalette_1.ID;
        }
        postConstruct() {
          this.editorContext.onEditModeChanged((change) => this.editModeChanged(change.newValue, change.oldValue));
          (0, messages_1.repeatOnMessagesUpdated)(() => {
            this.createHeader();
            this.addMinimizePaletteButton();
          }, { initial: false });
        }
        initialize() {
          if (!this.paletteItems) {
            return false;
          }
          return super.initialize();
        }
        initializeContents(containerElement) {
          this.addMinimizePaletteButton();
          this.createHeader();
          this.createBody();
          this.lastActiveButton = this.defaultToolsButton;
          containerElement.setAttribute("aria-label", messages_1.messages.tool_palette.label);
        }
        onBeforeShow(_containerElement, root) {
          this.modelRootId = root.id;
          this.containerElement.style.maxHeight = PALETTE_HEIGHT;
        }
        addMinimizePaletteButton() {
          const baseDiv = document.getElementById(this.options.baseDiv);
          if (!baseDiv) {
            return;
          }
          const toggleButton = document.createElement("div");
          toggleButton.classList.add("minimize-palette-button");
          this.containerElement.classList.add("collapsible-palette");
          const minimizeIcon = createIcon(CHEVRON_DOWN_ICON_ID);
          this.updateMinimizePaletteButtonTooltip(toggleButton);
          minimizeIcon.onclick = (_event) => {
            if (this.isPaletteMaximized()) {
              this.containerElement.style.maxHeight = "0px";
            } else {
              this.containerElement.style.maxHeight = PALETTE_HEIGHT;
            }
            this.updateMinimizePaletteButtonTooltip(toggleButton);
            changeCodiconClass(minimizeIcon, PALETTE_ICON_ID);
            changeCodiconClass(minimizeIcon, CHEVRON_DOWN_ICON_ID);
          };
          toggleButton.appendChild(minimizeIcon);
          if (this.toggleButton) {
            this.toggleButton.replaceWith(toggleButton);
          } else {
            baseDiv.insertBefore(toggleButton, baseDiv.firstChild);
          }
          this.toggleButton = toggleButton;
        }
        updateMinimizePaletteButtonTooltip(button) {
          if (this.isPaletteMaximized()) {
            button.title = messages_1.messages.tool_palette.minimize;
          } else {
            button.title = messages_1.messages.tool_palette.maximize;
          }
        }
        isPaletteMaximized() {
          return this.containerElement && this.containerElement.style.maxHeight !== "0px";
        }
        createBody() {
          const bodyDiv = document.createElement("div");
          bodyDiv.classList.add("palette-body");
          let tabIndex = 0;
          this.paletteItems.sort(compare).forEach((item) => {
            if (item.children) {
              const group = createToolGroup(item);
              item.children.sort(compare).forEach((child) => group.appendChild(this.createToolButton(child, tabIndex++)));
              bodyDiv.appendChild(group);
            } else {
              bodyDiv.appendChild(this.createToolButton(item, tabIndex++));
            }
          });
          if (this.paletteItems.length === 0) {
            const noResultsDiv = document.createElement("div");
            noResultsDiv.innerText = messages_1.messages.tool_palette.no_items;
            noResultsDiv.classList.add("tool-button");
            bodyDiv.appendChild(noResultsDiv);
          }
          if (this.bodyDiv) {
            this.bodyDiv.replaceWith(bodyDiv);
          } else {
            this.containerElement.appendChild(bodyDiv);
          }
          this.bodyDiv = bodyDiv;
        }
        createHeader() {
          const headerCompartment = document.createElement("div");
          headerCompartment.classList.add("palette-header");
          headerCompartment.append(this.createHeaderTitle());
          headerCompartment.appendChild(this.createHeaderTools());
          headerCompartment.appendChild(this.searchField = this.createHeaderSearchField());
          if (this.headerDiv) {
            this.headerDiv.replaceWith(headerCompartment);
          } else {
            this.containerElement.appendChild(headerCompartment);
          }
          this.headerDiv = headerCompartment;
        }
        createHeaderTools() {
          const headerTools = document.createElement("div");
          headerTools.classList.add("header-tools");
          this.defaultToolsButton = this.createDefaultToolButton();
          headerTools.appendChild(this.defaultToolsButton);
          const deleteToolButton = this.createMouseDeleteToolButton();
          headerTools.appendChild(deleteToolButton);
          const marqueeToolButton = this.createMarqueeToolButton();
          headerTools.appendChild(marqueeToolButton);
          const validateActionButton = this.createValidateButton();
          headerTools.appendChild(validateActionButton);
          const resetViewportButton = this.createResetViewportButton();
          headerTools.appendChild(resetViewportButton);
          if (this.gridManager) {
            const toggleGridButton = this.createToggleGridButton();
            headerTools.appendChild(toggleGridButton);
          }
          if (this.debugManager) {
            const toggleDebugButton = this.createToggleDebugButton();
            headerTools.appendChild(toggleDebugButton);
          }
          const searchIcon = this.createSearchButton();
          headerTools.appendChild(searchIcon);
          return headerTools;
        }
        createDefaultToolButton() {
          const button = createIcon("inspect");
          button.id = "btn_default_tools";
          button.title = messages_1.messages.tool_palette.selection_button;
          button.onclick = this.onClickStaticToolButton(button);
          button.ariaLabel = button.title;
          button.tabIndex = 1;
          return button;
        }
        createMouseDeleteToolButton() {
          const deleteToolButton = createIcon("chrome-close");
          deleteToolButton.title = messages_1.messages.tool_palette.delete_button;
          deleteToolButton.onclick = this.onClickStaticToolButton(deleteToolButton, delete_tool_1.MouseDeleteTool.ID);
          deleteToolButton.ariaLabel = deleteToolButton.title;
          deleteToolButton.tabIndex = 1;
          return deleteToolButton;
        }
        createMarqueeToolButton() {
          const marqueeToolButton = createIcon("screen-full");
          marqueeToolButton.title = messages_1.messages.tool_palette.marquee_button;
          marqueeToolButton.onclick = this.onClickStaticToolButton(marqueeToolButton, marquee_mouse_tool_1.MarqueeMouseTool.ID);
          marqueeToolButton.ariaLabel = marqueeToolButton.title;
          marqueeToolButton.tabIndex = 1;
          return marqueeToolButton;
        }
        createValidateButton() {
          const validateActionButton = createIcon("pass");
          validateActionButton.title = messages_1.messages.tool_palette.validate_button;
          validateActionButton.onclick = (_event) => {
            const modelIds = [this.modelRootId];
            this.actionDispatcher.dispatch(sprotty_1.RequestMarkersAction.create(modelIds, { reason: sprotty_1.MarkersReason.BATCH }));
            validateActionButton.focus();
          };
          validateActionButton.ariaLabel = validateActionButton.title;
          validateActionButton.tabIndex = 1;
          return validateActionButton;
        }
        createResetViewportButton() {
          const resetViewportButton = createIcon("screen-normal");
          resetViewportButton.title = messages_1.messages.tool_palette.reset_viewport_button;
          resetViewportButton.onclick = (_event) => {
            this.actionDispatcher.dispatch(origin_viewport_1.OriginViewportAction.create());
            resetViewportButton.focus();
          };
          resetViewportButton.ariaLabel = resetViewportButton.title;
          resetViewportButton.tabIndex = 1;
          return resetViewportButton;
        }
        createToggleGridButton() {
          var _a4;
          const toggleGridButton = createIcon("symbol-numeric");
          toggleGridButton.title = messages_1.messages.tool_palette.toggle_grid_button;
          toggleGridButton.onclick = () => {
            var _a5, _b2, _c;
            if ((_a5 = this.gridManager) === null || _a5 === void 0 ? void 0 : _a5.isGridVisible) {
              toggleGridButton.classList.remove(CLICKED_CSS_CLASS);
              (_b2 = this.gridManager) === null || _b2 === void 0 ? void 0 : _b2.setGridVisible(false);
            } else {
              toggleGridButton.classList.add(CLICKED_CSS_CLASS);
              (_c = this.gridManager) === null || _c === void 0 ? void 0 : _c.setGridVisible(true);
            }
          };
          if ((_a4 = this.gridManager) === null || _a4 === void 0 ? void 0 : _a4.isGridVisible) {
            toggleGridButton.classList.add(CLICKED_CSS_CLASS);
          }
          toggleGridButton.ariaLabel = toggleGridButton.title;
          toggleGridButton.tabIndex = 1;
          return toggleGridButton;
        }
        createToggleDebugButton() {
          var _a4;
          const toggleDebugButton = createIcon("debug");
          toggleDebugButton.title = messages_1.messages.tool_palette.debug_mode_button;
          toggleDebugButton.onclick = () => {
            var _a5, _b2, _c;
            if ((_a5 = this.debugManager) === null || _a5 === void 0 ? void 0 : _a5.isDebugEnabled) {
              toggleDebugButton.classList.remove(CLICKED_CSS_CLASS);
              (_b2 = this.debugManager) === null || _b2 === void 0 ? void 0 : _b2.setDebugEnabled(false);
            } else {
              toggleDebugButton.classList.add(CLICKED_CSS_CLASS);
              (_c = this.debugManager) === null || _c === void 0 ? void 0 : _c.setDebugEnabled(true);
            }
          };
          if ((_a4 = this.debugManager) === null || _a4 === void 0 ? void 0 : _a4.isDebugEnabled) {
            toggleDebugButton.classList.add(CLICKED_CSS_CLASS);
          }
          toggleDebugButton.ariaLabel = toggleDebugButton.title;
          toggleDebugButton.tabIndex = 1;
          return toggleDebugButton;
        }
        createSearchButton() {
          const searchIcon = createIcon(SEARCH_ICON_ID);
          searchIcon.onclick = (_ev) => {
            const searchField = document.getElementById(this.containerElement.id + "_search_field");
            if (searchField) {
              if (searchField.style.display === "none") {
                searchField.style.display = "";
                searchField.focus();
              } else {
                searchField.style.display = "none";
              }
            }
          };
          searchIcon.classList.add("search-icon");
          searchIcon.title = messages_1.messages.tool_palette.search_button;
          searchIcon.ariaLabel = searchIcon.title;
          searchIcon.tabIndex = 1;
          return searchIcon;
        }
        createHeaderSearchField() {
          const searchField = document.createElement("input");
          searchField.classList.add("search-input");
          searchField.id = this.containerElement.id + "_search_field";
          searchField.type = "text";
          searchField.placeholder = messages_1.messages.tool_palette.search_placeholder;
          searchField.style.display = "none";
          searchField.onkeyup = () => this.requestFilterUpdate(this.searchField.value);
          searchField.onkeydown = (ev) => this.clearOnEscape(ev);
          return searchField;
        }
        createHeaderTitle() {
          const header = document.createElement("div");
          header.classList.add("header-icon");
          header.appendChild(createIcon(PALETTE_ICON_ID));
          header.insertAdjacentText("beforeend", "Palette");
          return header;
        }
        createToolButton(item, index) {
          const button = document.createElement("div");
          button.tabIndex = index;
          button.classList.add("tool-button");
          if (item.icon) {
            button.appendChild(createIcon(item.icon));
          }
          button.insertAdjacentText("beforeend", item.label);
          button.onclick = this.onClickCreateToolButton(button, item);
          button.onkeydown = (ev) => this.clearToolOnEscape(ev);
          return button;
        }
        onClickCreateToolButton(button, item) {
          return (_ev) => {
            if (!this.editorContext.isReadonly) {
              this.actionDispatcher.dispatchAll(item.actions);
              this.changeActiveButton(button);
              button.focus();
            }
          };
        }
        onClickStaticToolButton(button, toolId) {
          return (_ev) => {
            if (!this.editorContext.isReadonly) {
              const action = toolId ? tool_1.EnableToolsAction.create([toolId]) : tool_1.EnableDefaultToolsAction.create();
              this.actionDispatcher.dispatch(action);
              this.changeActiveButton(button);
              button.focus();
            }
          };
        }
        changeActiveButton(button) {
          if (this.lastActiveButton) {
            this.lastActiveButton.classList.remove(CLICKED_CSS_CLASS);
          }
          if (button) {
            button.classList.add(CLICKED_CSS_CLASS);
            this.lastActiveButton = button;
          } else if (this.defaultToolsButton) {
            this.defaultToolsButton.classList.add(CLICKED_CSS_CLASS);
            this.lastActiveButton = this.defaultToolsButton;
          }
        }
        handle(action) {
          var _a4;
          this.changeActiveButton();
          if (sprotty_1.UpdateModelAction.is(action) || sprotty_1.SetModelAction.is(action)) {
            this.reloadPaletteBody();
          } else if (tool_1.EnableDefaultToolsAction.is(action)) {
            if (this.focusTracker.hasFocus) {
              (_a4 = this.focusTracker.diagramElement) === null || _a4 === void 0 ? void 0 : _a4.focus();
            }
          }
        }
        editModeChanged(_newValue, _oldValue) {
          this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: ToolPalette_1.ID, visible: !this.editorContext.isReadonly }));
        }
        clearOnEscape(event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            this.searchField.value = "";
            this.requestFilterUpdate("");
          }
        }
        clearToolOnEscape(event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            this.actionDispatcher.dispatch(tool_1.EnableDefaultToolsAction.create());
          }
        }
        requestFilterUpdate(filter) {
          if (this.paletteItemsCopy.length === 0) {
            this.paletteItemsCopy = JSON.parse(JSON.stringify(this.paletteItems));
          }
          this.paletteItems = JSON.parse(JSON.stringify(this.paletteItemsCopy));
          const filteredPaletteItems = [];
          for (const itemGroup of this.paletteItems) {
            if (itemGroup.children) {
              const matchingChildren = itemGroup.children.filter((child) => child.label.toLowerCase().includes(filter.toLowerCase()));
              if (matchingChildren.length > 0) {
                itemGroup.children.splice(0, itemGroup.children.length);
                matchingChildren.forEach((child) => itemGroup.children.push(child));
                filteredPaletteItems.push(itemGroup);
              }
            }
          }
          this.paletteItems = filteredPaletteItems;
          this.createBody();
        }
        /**
         *  @deprecated This hook is no longer used by the ToolPalette.
         *              It is kept for compatibility reasons and will be removed in the future.
         *              Move initialization logic to the `postRequestModel` method.
         *              This ensures that tool palette initialization does not block the diagram loading process.
         */
        async preRequestModel() {
        }
        async postRequestModel() {
          await this.setPaletteItems();
          if (!this.editorContext.isReadonly) {
            this.show(this.editorContext.modelRoot);
          }
        }
        async setPaletteItems() {
          const requestAction = sprotty_1.RequestContextActions.create({
            contextId: ToolPalette_1.ID,
            editorContext: {
              selectedElementIds: []
            }
          });
          const response = await this.actionDispatcher.request(requestAction);
          this.paletteItems = response.actions.map((action) => action);
          this.dynamic = this.paletteItems.some((item) => this.hasDynamicAction(item));
        }
        hasDynamicAction(item) {
          var _a4;
          const dynamic = !!item.actions.find((action) => {
            var _a5;
            return sprotty_1.TriggerNodeCreationAction.is(action) && ((_a5 = action.ghostElement) === null || _a5 === void 0 ? void 0 : _a5.dynamic);
          });
          if (dynamic) {
            return dynamic;
          }
          return ((_a4 = item.children) === null || _a4 === void 0 ? void 0 : _a4.some((child) => this.hasDynamicAction(child))) || false;
        }
        async reloadPaletteBody() {
          if (!this.editorContext.isReadonly && this.dynamic) {
            await this.setPaletteItems();
            this.paletteItemsCopy = [];
            this.requestFilterUpdate(this.searchField.value);
          }
        }
      };
      exports.ToolPalette = ToolPalette;
      ToolPalette.ID = "tool-palette";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ToolPalette.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ToolPalette.prototype, "editorContext", void 0);
      __decorate([
        (0, inversify_1.inject)(focus_tracker_1.FocusTracker),
        __metadata("design:type", focus_tracker_1.FocusTracker)
      ], ToolPalette.prototype, "focusTracker", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IGridManager),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ToolPalette.prototype, "gridManager", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDebugManager),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ToolPalette.prototype, "debugManager", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], ToolPalette.prototype, "postConstruct", null);
      exports.ToolPalette = ToolPalette = ToolPalette_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ToolPalette);
      function compare(a3, b3) {
        const sortStringBased = a3.sortString.localeCompare(b3.sortString);
        if (sortStringBased !== 0) {
          return sortStringBased;
        }
        return a3.label.localeCompare(b3.label);
      }
      exports.compare = compare;
      function createIcon(codiconId) {
        const icon = document.createElement("i");
        icon.classList.add(...(0, sprotty_1.codiconCSSClasses)(codiconId));
        return icon;
      }
      exports.createIcon = createIcon;
      function createToolGroup(item) {
        const group = document.createElement("div");
        group.classList.add("tool-group");
        group.id = item.id;
        const header = document.createElement("div");
        header.classList.add("group-header");
        if (item.icon) {
          header.appendChild(createIcon(item.icon));
        }
        header.insertAdjacentText("beforeend", item.label);
        header.ondblclick = (_ev) => {
          const css = "collapsed";
          changeCSSClass(group, css);
          Array.from(group.children).forEach((child) => changeCSSClass(child, css));
          window.getSelection().removeAllRanges();
        };
        group.appendChild(header);
        return group;
      }
      exports.createToolGroup = createToolGroup;
      function changeCSSClass(element, css) {
        element.classList.contains(css) ? element.classList.remove(css) : element.classList.add(css);
      }
      exports.changeCSSClass = changeCSSClass;
      function changeCodiconClass(element, codiconId) {
        element.classList.contains((0, sprotty_1.codiconCSSClasses)(codiconId)[1]) ? element.classList.remove((0, sprotty_1.codiconCSSClasses)(codiconId)[1]) : element.classList.add((0, sprotty_1.codiconCSSClasses)(codiconId)[1]);
      }
      exports.changeCodiconClass = changeCodiconClass;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tool-palette/tool-palette-module.js
  var require_tool_palette_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tool-palette/tool-palette-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toolPaletteModule = void 0;
      var sprotty_1 = require_lib4();
      require_tool_palette2();
      var tool_1 = require_tool();
      var tool_palette_1 = require_tool_palette3();
      exports.toolPaletteModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, _rebind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IUIExtension, tool_palette_1.ToolPalette);
        bind(sprotty_1.TYPES.IDiagramStartup).toService(tool_palette_1.ToolPalette);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, tool_1.EnableDefaultToolsAction.KIND, tool_palette_1.ToolPalette);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, sprotty_1.UpdateModelAction.KIND, tool_palette_1.ToolPalette);
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, sprotty_1.SetModelAction.KIND, tool_palette_1.ToolPalette);
      }, { featureId: Symbol("toolPalette") });
    }
  });

  // node_modules/@eclipse-glsp/client/css/change-bounds.css
  var require_change_bounds = __commonJS({
    "node_modules/@eclipse-glsp/client/css/change-bounds.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/movement-restrictor.js
  var require_movement_restrictor = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/movement-restrictor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.movementRestrictionFeedback = exports.removeMovementRestrictionFeedback = exports.createMovementRestrictionFeedback = exports.NoOverlapMovementRestrictor = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var css_feedback_1 = require_css_feedback();
      var viewpoint_util_1 = require_viewpoint_util();
      var model_1 = require_model19();
      var NoOverlapMovementRestrictor = class NoOverlapMovementRestrictor {
        constructor() {
          this.cssClasses = ["movement-not-allowed"];
        }
        validate(element, newLocation) {
          if (!(0, sprotty_1.isMoveable)(element) || !newLocation) {
            return false;
          }
          const dimensions = (0, sprotty_1.isBoundsAware)(element) ? element.bounds : { width: 1, height: 1 };
          const ghostElement = Object.create(element);
          ghostElement.bounds = { ...dimensions, ...newLocation };
          ghostElement.type = "Ghost";
          ghostElement.id = element.id;
          return !Array.from(element.root.index.all().filter((node) => node.id !== ghostElement.id && node !== ghostElement.root && node instanceof sprotty_1.GNode).map((node) => node)).some((e2) => this.areOverlapping(e2, ghostElement));
        }
        isBoundsRelevant(element, ghostElement) {
          return element.id !== ghostElement.id && element !== ghostElement.root && element instanceof sprotty_1.GNode && (0, sprotty_1.isBoundsAware)(element);
        }
        areOverlapping(element1, element2) {
          return sprotty_1.Bounds.overlap((0, viewpoint_util_1.toAbsoluteBounds)(element1), (0, viewpoint_util_1.toAbsoluteBounds)(element2));
        }
      };
      exports.NoOverlapMovementRestrictor = NoOverlapMovementRestrictor;
      exports.NoOverlapMovementRestrictor = NoOverlapMovementRestrictor = __decorate([
        (0, inversify_1.injectable)()
      ], NoOverlapMovementRestrictor);
      function createMovementRestrictionFeedback(element, movementRestrictor) {
        const elements = [element];
        if (element instanceof sprotty_1.GParentElement) {
          element.children.filter((child) => child instanceof model_1.GResizeHandle).forEach((e2) => elements.push(e2));
        }
        return css_feedback_1.ModifyCSSFeedbackAction.create({ elements, add: movementRestrictor.cssClasses });
      }
      exports.createMovementRestrictionFeedback = createMovementRestrictionFeedback;
      function removeMovementRestrictionFeedback(element, movementRestrictor) {
        const elements = [element];
        if (element instanceof sprotty_1.GParentElement) {
          element.children.filter((child) => child instanceof model_1.GResizeHandle).forEach((e2) => elements.push(e2));
        }
        return css_feedback_1.ModifyCSSFeedbackAction.create({ elements, remove: movementRestrictor.cssClasses });
      }
      exports.removeMovementRestrictionFeedback = removeMovementRestrictionFeedback;
      function movementRestrictionFeedback(element, movementRestrictor, valid) {
        return valid ? removeMovementRestrictionFeedback(element, movementRestrictor) : createMovementRestrictionFeedback(element, movementRestrictor);
      }
      exports.movementRestrictionFeedback = movementRestrictionFeedback;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/insert-indicator.js
  var require_insert_indicator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/insert-indicator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InsertIndicator = exports.ARG_LENGTH = void 0;
      var sprotty_1 = require_lib4();
      var uuid_1 = require_commonjs_browser();
      var args_feature_1 = require_args_feature();
      exports.ARG_LENGTH = "length";
      var InsertIndicator = class _InsertIndicator extends sprotty_1.GNode {
        constructor(length) {
          super();
          this.id = (0, uuid_1.v4)();
          this.type = _InsertIndicator.TYPE;
          this.features = (0, sprotty_1.createFeatureSet)(_InsertIndicator.DEFAULT_FEATURES);
          this.cssClasses = ["insert-indicator", "sprotty-node"];
          this.size = sprotty_1.Dimension.ZERO;
          this.args = {};
          if (length) {
            this.args = { [exports.ARG_LENGTH]: length };
          }
        }
      };
      exports.InsertIndicator = InsertIndicator;
      InsertIndicator.DEFAULT_FEATURES = [sprotty_1.boundsFeature, sprotty_1.moveFeature, args_feature_1.argsFeature];
      InsertIndicator.TYPE = "node:insert-indicator";
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/tracker.js
  var require_tracker = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/tracker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramMovementCalculator = exports.MovementCalculator = void 0;
      var sprotty_1 = require_lib4();
      var MovementCalculator = class {
        setPosition(position) {
          this.position = { ...position };
        }
        updatePosition(param) {
          var _a4;
          const vector = sprotty_1.Vector.is(param) ? param : param.vector;
          this.setPosition(sprotty_1.Point.add((_a4 = this.position) !== null && _a4 !== void 0 ? _a4 : sprotty_1.Point.ORIGIN, vector));
        }
        get hasPosition() {
          return this.position !== void 0;
        }
        calculateMoveTo(targetPosition) {
          return !this.position ? sprotty_1.Movement.ZERO : sprotty_1.Point.move(this.position, targetPosition);
        }
        dispose() {
          this.position = void 0;
        }
      };
      exports.MovementCalculator = MovementCalculator;
      var DiagramMovementCalculator = class extends MovementCalculator {
        constructor(positionTracker) {
          super();
          this.positionTracker = positionTracker;
        }
        init() {
          const position = this.positionTracker.lastPositionOnDiagram;
          if (position) {
            this.setPosition(position);
          }
        }
        calculateMoveToCurrent() {
          const targetPosition = this.positionTracker.lastPositionOnDiagram;
          return targetPosition ? this.calculateMoveTo(targetPosition) : sprotty_1.Movement.ZERO;
        }
        reset() {
          this.dispose();
        }
      };
      exports.DiagramMovementCalculator = DiagramMovementCalculator;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tracker.js
  var require_change_bounds_tracker = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tracker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MoveableRoutingHandle = exports.MoveableResizeHandle = exports.ChangeBoundsTracker = exports.TrackedElementResize = exports.DEFAULT_RESIZE_OPTIONS = exports.TrackedMove = exports.TrackedElementMove = exports.DEFAULT_MOVE_OPTIONS = void 0;
      var sprotty_1 = require_lib4();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model19();
      var tracker_1 = require_tracker();
      exports.DEFAULT_MOVE_OPTIONS = {
        snap: true,
        restrict: true,
        validate: true,
        skipStatic: true,
        skipInvalid: false
      };
      var TrackedElementMove;
      (function(TrackedElementMove2) {
        function is(obj) {
          return (0, sprotty_1.hasObjectProp)(obj, "element") && (0, sprotty_1.hasObjectProp)(obj, "fromPosition") && (0, sprotty_1.hasObjectProp)(obj, "toPosition") && (0, sprotty_1.hasBooleanProp)(obj, "valid");
        }
        TrackedElementMove2.is = is;
      })(TrackedElementMove || (exports.TrackedElementMove = TrackedElementMove = {}));
      var TrackedMove;
      (function(TrackedMove2) {
        function is(obj) {
          return sprotty_1.Movement.is(obj) && (0, sprotty_1.hasBooleanProp)(obj, "valid");
        }
        TrackedMove2.is = is;
      })(TrackedMove || (exports.TrackedMove = TrackedMove = {}));
      exports.DEFAULT_RESIZE_OPTIONS = {
        snap: true,
        restrict: true,
        validate: true,
        symmetric: true,
        constrainResize: true,
        skipStatic: true,
        skipInvalidSize: false,
        skipInvalidMove: false
      };
      var TrackedElementResize;
      (function(TrackedElementResize2) {
        function is(obj) {
          return (0, sprotty_1.isBoundsAware)(obj.element) && (0, sprotty_1.hasObjectProp)(obj, "fromBounds") && (0, sprotty_1.hasObjectProp)(obj, "toBounds") && (0, sprotty_1.hasObjectProp)(obj, "valid");
        }
        TrackedElementResize2.is = is;
      })(TrackedElementResize || (exports.TrackedElementResize = TrackedElementResize = {}));
      var ChangeBoundsTracker = class {
        constructor(manager) {
          this.manager = manager;
          this.diagramMovement = new tracker_1.DiagramMovementCalculator(manager.positionTracker);
        }
        startTracking() {
          this.diagramMovement.init();
          return this;
        }
        updateTrackingPosition(param) {
          const update = TrackedMove.is(param) ? sprotty_1.Vector.max(...param.elementMoves.map((move) => move.moveVector)) : param;
          this.diagramMovement.updatePosition(update);
        }
        isTracking() {
          return this.diagramMovement.hasPosition;
        }
        stopTracking() {
          this.diagramMovement.dispose();
          return this;
        }
        //
        // MOVE
        //
        moveElements(elements, opts) {
          const options = this.resolveMoveOptions(opts);
          const update = this.calculateDiagramMovement();
          const move = { ...update, elementMoves: [], valid: true, options };
          if (sprotty_1.Vector.isZero(update.vector) && options.skipStatic) {
            return move;
          }
          const elementsToMove = this.getMoveableElements(elements, options);
          for (const element of elementsToMove) {
            const elementMove = this.calculateElementMove(element, update.vector, options);
            if (!this.skipElementMove(elementMove, options)) {
              move.elementMoves.push(elementMove);
              move.valid && (move.valid = elementMove.valid);
            }
          }
          return move;
        }
        resolveMoveOptions(opts) {
          var _a4, _b2;
          return {
            ...exports.DEFAULT_MOVE_OPTIONS,
            ...opts,
            snap: this.manager.usePositionSnap((_a4 = opts === null || opts === void 0 ? void 0 : opts.snap) !== null && _a4 !== void 0 ? _a4 : exports.DEFAULT_MOVE_OPTIONS.snap),
            restrict: this.manager.useMovementRestriction((_b2 = opts === null || opts === void 0 ? void 0 : opts.restrict) !== null && _b2 !== void 0 ? _b2 : exports.DEFAULT_MOVE_OPTIONS.restrict)
          };
        }
        calculateDiagramMovement() {
          return this.diagramMovement.calculateMoveToCurrent();
        }
        getMoveableElements(elements, options) {
          var _a4;
          return Array.isArray(elements) ? elements : (0, gmodel_util_1.getElements)(elements.ctx.index, elements.elementIDs, (_a4 = elements.guard) !== null && _a4 !== void 0 ? _a4 : sprotty_1.isMoveable);
        }
        skipElementMove(elementMove, options) {
          return options.skipInvalid && !elementMove.valid || options.skipStatic && sprotty_1.Vector.isZero(elementMove.moveVector);
        }
        calculateElementMove(element, vector, options) {
          const fromPosition = element.position;
          const toPosition = sprotty_1.Point.add(fromPosition, vector);
          const move = { element, fromPosition, toPosition, valid: true, moveVector: vector, sourceVector: vector };
          if (options.snap) {
            move.toPosition = this.snapPosition(move, options);
          }
          if (options.restrict) {
            move.toPosition = this.restrictMovement(move, options);
          }
          if (options.validate) {
            move.valid = this.validateElementMove(move, options);
          }
          move.moveVector = sprotty_1.Point.vector(move.fromPosition, move.toPosition);
          return move;
        }
        snapPosition(elementMove, opts) {
          return this.manager.snapPosition(elementMove.element, elementMove.toPosition);
        }
        restrictMovement(elementMove, opts) {
          const movement = sprotty_1.Point.move(elementMove.fromPosition, elementMove.toPosition);
          return this.manager.restrictMovement(elementMove.element, movement).to;
        }
        validateElementMove(elementMove, opts) {
          return this.manager.hasValidPosition(elementMove.element, elementMove.toPosition);
        }
        //
        // RESIZE
        //
        resizeElements(handle, opts) {
          const options = this.resolveResizeOptions(opts);
          const update = this.calculateDiagramMovement();
          const handleMove = this.calculateHandleMove(new MoveableResizeHandle(handle), update.vector, options);
          const resize = { ...update, valid: { move: true, size: true }, options, handleMove, elementResizes: [] };
          if (sprotty_1.Vector.isZero(handleMove.moveVector) && options.skipStatic) {
            return resize;
          }
          const elementsToResize = this.getResizableElements(handle, options);
          for (const element of elementsToResize) {
            const elementResize = this.calculateElementResize(element, handleMove, options);
            if (!this.skipElementResize(elementResize, options)) {
              resize.elementResizes.push(elementResize);
              resize.valid.move = resize.valid.move && elementResize.valid.move;
              resize.valid.size = resize.valid.size && elementResize.valid.size;
            }
          }
          return resize;
        }
        resolveResizeOptions(opts) {
          var _a4, _b2, _c;
          return {
            ...exports.DEFAULT_RESIZE_OPTIONS,
            ...opts,
            snap: this.manager.usePositionSnap((_a4 = opts === null || opts === void 0 ? void 0 : opts.snap) !== null && _a4 !== void 0 ? _a4 : exports.DEFAULT_RESIZE_OPTIONS.snap),
            restrict: this.manager.useMovementRestriction((_b2 = opts === null || opts === void 0 ? void 0 : opts.restrict) !== null && _b2 !== void 0 ? _b2 : exports.DEFAULT_RESIZE_OPTIONS.restrict),
            symmetric: this.manager.useSymmetricResize((_c = opts === null || opts === void 0 ? void 0 : opts.symmetric) !== null && _c !== void 0 ? _c : exports.DEFAULT_RESIZE_OPTIONS.symmetric)
          };
        }
        calculateHandleMove(handle, diagramMovement, opts) {
          const moveOptions = this.resolveMoveOptions({ ...opts, validate: false });
          return this.calculateElementMove(handle, diagramMovement, moveOptions);
        }
        getResizableElements(handle, options) {
          return [handle.parent];
        }
        skipElementResize(elementResize, options) {
          return options.skipInvalidMove && !elementResize.valid.move || options.skipInvalidSize && !elementResize.valid.size || options.skipStatic && sprotty_1.Dimension.equals(elementResize.fromBounds, elementResize.toBounds);
        }
        calculateElementResize(element, handleMove, options) {
          const fromBounds = element.bounds;
          const toBounds = this.calculateElementBounds(element, handleMove, options);
          const resize = { element, fromBounds, toBounds, valid: { size: true, move: true } };
          if (options.validate) {
            resize.valid.size = this.manager.hasValidSize(resize.element, resize.toBounds);
            resize.valid.move = handleMove.valid && this.manager.hasValidPosition(resize.element, resize.toBounds);
          }
          return resize;
        }
        calculateElementBounds(element, handleMove, options) {
          let toBounds = this.calculateBounds(element.bounds, handleMove);
          if (options.symmetric) {
            const symmetricHandleMove = this.calculateSymmetricHandleMove(handleMove, options);
            toBounds = this.calculateBounds(toBounds, symmetricHandleMove);
          }
          if (!options.constrainResize || this.manager.hasValidSize(element, toBounds)) {
            return toBounds;
          }
          const minimum = this.manager.getMinimumSize(element);
          handleMove.moveVector = this.constrainResizeVector(element.bounds, handleMove, minimum);
          if (options.symmetric) {
            handleMove.moveVector.x = element.bounds.width > minimum.width ? handleMove.moveVector.x / 2 : handleMove.moveVector.x;
            handleMove.moveVector.y = element.bounds.height > minimum.height ? handleMove.moveVector.y / 2 : handleMove.moveVector.y;
          }
          toBounds = this.calculateBounds(element.bounds, handleMove);
          if (options.symmetric) {
            const symmetricHandleMove = this.calculateSymmetricHandleMove(handleMove, { ...options, snap: false });
            toBounds = this.calculateBounds(toBounds, symmetricHandleMove);
          }
          return toBounds;
        }
        calculateSymmetricHandleMove(handleMove, options) {
          const moveOptions = this.resolveMoveOptions({ ...options, validate: false, restrict: false });
          return this.calculateElementMove(handleMove.element.opposite(), sprotty_1.Vector.reverse(handleMove.moveVector), moveOptions);
        }
        calculateBounds(src, handleMove) {
          if (!handleMove || sprotty_1.Vector.isZero(handleMove.moveVector)) {
            return src;
          }
          return this.doCalculateBounds(src, handleMove.moveVector, handleMove.element.location);
        }
        doCalculateBounds(src, vector, location2) {
          switch (location2) {
            case model_1.ResizeHandleLocation.TopLeft:
              return { x: src.x + vector.x, y: src.y + vector.y, width: src.width - vector.x, height: src.height - vector.y };
            case model_1.ResizeHandleLocation.Top:
              return { ...src, y: src.y + vector.y, height: src.height - vector.y };
            case model_1.ResizeHandleLocation.TopRight:
              return { ...src, y: src.y + vector.y, width: src.width + vector.x, height: src.height - vector.y };
            case model_1.ResizeHandleLocation.Right:
              return { ...src, width: src.width + vector.x };
            case model_1.ResizeHandleLocation.BottomRight:
              return { ...src, width: src.width + vector.x, height: src.height + vector.y };
            case model_1.ResizeHandleLocation.Bottom:
              return { ...src, height: src.height + vector.y };
            case model_1.ResizeHandleLocation.BottomLeft:
              return { ...src, x: src.x + vector.x, width: src.width - vector.x, height: src.height + vector.y };
            case model_1.ResizeHandleLocation.Left:
              return { ...src, x: src.x + vector.x, width: src.width - vector.x };
          }
        }
        constrainResizeVector(src, handleMove, minimum) {
          const vector = handleMove.moveVector;
          switch (handleMove.element.location) {
            case model_1.ResizeHandleLocation.TopLeft:
              vector.x = src.width - vector.x < minimum.width ? src.width - minimum.width : vector.x;
              vector.y = src.height - vector.y < minimum.height ? src.height - minimum.height : vector.y;
              break;
            case model_1.ResizeHandleLocation.Top:
              vector.y = src.height - vector.y < minimum.height ? src.height - minimum.height : vector.y;
              break;
            case model_1.ResizeHandleLocation.TopRight:
              vector.x = src.width + vector.x < minimum.width ? minimum.width - src.width : vector.x;
              vector.y = src.height - vector.y < minimum.height ? src.height - minimum.height : vector.y;
              break;
            case model_1.ResizeHandleLocation.Right:
              vector.x = src.width + vector.x < minimum.width ? minimum.width - src.width : vector.x;
              break;
            case model_1.ResizeHandleLocation.BottomRight:
              vector.x = src.width + vector.x < minimum.width ? minimum.width - src.width : vector.x;
              vector.y = src.height + vector.y < minimum.height ? minimum.height - src.height : vector.y;
              break;
            case model_1.ResizeHandleLocation.Bottom:
              vector.y = src.height + vector.y < minimum.height ? minimum.height - src.height : vector.y;
              break;
            case model_1.ResizeHandleLocation.BottomLeft:
              vector.x = src.width - vector.x < minimum.width ? src.width - minimum.width : vector.x;
              vector.y = src.height + vector.y < minimum.height ? minimum.height - src.height : vector.y;
              break;
            case model_1.ResizeHandleLocation.Left:
              vector.x = src.width - vector.x < minimum.width ? src.width - minimum.width : vector.x;
              break;
          }
          return vector;
        }
        dispose() {
          this.stopTracking();
        }
      };
      exports.ChangeBoundsTracker = ChangeBoundsTracker;
      var MoveableResizeHandle = class _MoveableResizeHandle extends model_1.GResizeHandle {
        constructor(handle, location2 = handle.location, position = model_1.GResizeHandle.getHandlePosition(handle.parent, location2)) {
          super(location2, handle.type, handle.hoverFeedback);
          this.handle = handle;
          this.location = location2;
          this.position = position;
          this.id = handle.id;
          this.parent = handle.parent;
        }
        opposite() {
          return new _MoveableResizeHandle(this.handle, model_1.ResizeHandleLocation.opposite(this.location));
        }
      };
      exports.MoveableResizeHandle = MoveableResizeHandle;
      var MoveableRoutingHandle = class extends sprotty_1.GRoutingHandle {
        constructor(handle, position) {
          super();
          this.handle = handle;
          this.position = position;
          this.id = handle.id;
          this.parent = handle.parent;
        }
      };
      exports.MoveableRoutingHandle = MoveableRoutingHandle;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-manager.js
  var require_change_bounds_manager = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-manager.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ChangeBoundsManager = exports.CSS_ACTIVE_HANDLE = exports.CSS_RESTRICTED_RESIZE = exports.CSS_RESIZE_MODE = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var css_feedback_1 = require_css_feedback();
      var layout_utils_1 = require_layout_utils();
      var layout_data_1 = require_layout_data();
      var model_1 = require_model19();
      var movement_restrictor_1 = require_movement_restrictor();
      var insert_indicator_1 = require_insert_indicator();
      var change_bounds_tracker_1 = require_change_bounds_tracker();
      exports.CSS_RESIZE_MODE = "resize-mode";
      exports.CSS_RESTRICTED_RESIZE = "resize-not-allowed";
      exports.CSS_ACTIVE_HANDLE = "active";
      var ChangeBoundsManager = class ChangeBoundsManager {
        constructor(positionTracker, movementRestrictor, snapper, helperLineManager, gridManager) {
          this.positionTracker = positionTracker;
          this.movementRestrictor = movementRestrictor;
          this.snapper = snapper;
          this.helperLineManager = helperLineManager;
          this.gridManager = gridManager;
        }
        unsnapModifier() {
          return "shift";
        }
        usePositionSnap(arg) {
          return typeof arg === "boolean" ? arg : !arg.shiftKey;
        }
        snapPosition(element, position) {
          var _a4, _b2;
          return (_b2 = (_a4 = this.snapper) === null || _a4 === void 0 ? void 0 : _a4.snap(position, element)) !== null && _b2 !== void 0 ? _b2 : position;
        }
        isValid(element) {
          return this.hasValidPosition(element) && this.hasValidSize(element);
        }
        hasValidPosition(element, position) {
          return !(0, sprotty_1.isLocateable)(element) || (0, layout_utils_1.isValidMove)(element, position !== null && position !== void 0 ? position : element.position, this.movementRestrictor);
        }
        hasValidSize(element, size) {
          if (!(0, sprotty_1.isBoundsAware)(element)) {
            return true;
          }
          const dimension = size !== null && size !== void 0 ? size : element.bounds;
          const minimum = this.getMinimumSize(element);
          if (dimension.width < minimum.width || dimension.height < minimum.height) {
            return false;
          }
          return true;
        }
        getMinimumSize(element) {
          if (!(0, sprotty_1.isBoundsAware)(element)) {
            return sprotty_1.Dimension.EMPTY;
          }
          const definedMinimum = (0, layout_utils_1.minDimensions)(element);
          const computedMinimum = layout_data_1.LayoutAware.getComputedDimensions(element);
          return computedMinimum ? {
            width: Math.max(definedMinimum.width, computedMinimum.width),
            height: Math.max(definedMinimum.height, computedMinimum.height)
          } : definedMinimum;
        }
        useMovementRestriction(arg) {
          return this.usePositionSnap(arg);
        }
        restrictMovement(element, movement) {
          const minimumMovement = this.getMinimumMovement(element, movement);
          if (!minimumMovement) {
            return movement;
          }
          const absVector = sprotty_1.Vector.abs(movement.vector);
          const targetPosition = {
            x: absVector.x < minimumMovement.x ? movement.from.x : movement.to.x,
            y: absVector.y < minimumMovement.y ? movement.from.y : movement.to.y
          };
          return sprotty_1.Point.move(movement.from, targetPosition);
        }
        getMinimumMovement(element, movement) {
          var _a4;
          return element instanceof insert_indicator_1.InsertIndicator && this.gridManager ? this.gridManager.grid : (_a4 = this.helperLineManager) === null || _a4 === void 0 ? void 0 : _a4.getMinimumMoveVector(element, true, movement.direction);
        }
        addMoveFeedback(feedback, trackedMove, ctx, event) {
          feedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.MOVE), (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
          trackedMove.elementMoves.forEach((move) => this.addMoveRestrictionFeedback(feedback, move, ctx, event));
          return feedback;
        }
        addResizeFeedback(feedback, resize, ctx, event) {
          feedback.add(css_feedback_1.ModifyCSSFeedbackAction.create({ add: [exports.CSS_RESIZE_MODE] }), css_feedback_1.ModifyCSSFeedbackAction.create({ remove: [exports.CSS_RESIZE_MODE] }));
          const cursorClass = model_1.GResizeHandle.getCursorCss(resize.handleMove.element);
          feedback.add((0, css_feedback_1.cursorFeedbackAction)(cursorClass), (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
          const handle = resize.handleMove.element;
          feedback.add((0, css_feedback_1.applyCssClasses)(handle, exports.CSS_ACTIVE_HANDLE), (0, css_feedback_1.deleteCssClasses)(handle, exports.CSS_ACTIVE_HANDLE));
          feedback.add((0, css_feedback_1.toggleCssClasses)(handle, !resize.valid.size, exports.CSS_RESTRICTED_RESIZE), (0, css_feedback_1.deleteCssClasses)(handle, exports.CSS_RESTRICTED_RESIZE));
          resize.elementResizes.forEach((elementResize) => {
            this.addMoveRestrictionFeedback(feedback, elementResize, ctx, event);
            feedback.add((0, css_feedback_1.toggleCssClasses)(elementResize.element, !elementResize.valid.size, exports.CSS_RESTRICTED_RESIZE), (0, css_feedback_1.deleteCssClasses)(elementResize.element, exports.CSS_RESTRICTED_RESIZE));
          });
          return feedback;
        }
        addMoveRestrictionFeedback(feedback, change, ctx, event) {
          if (this.movementRestrictor) {
            const valid = change_bounds_tracker_1.TrackedElementMove.is(change) ? change.valid : change.valid.move;
            feedback.add((0, movement_restrictor_1.movementRestrictionFeedback)(change.element, this.movementRestrictor, valid), (0, movement_restrictor_1.removeMovementRestrictionFeedback)(change.element, this.movementRestrictor));
          }
          return feedback;
        }
        defaultResizeLocations() {
          return model_1.ResizeHandleLocation.CORNERS;
        }
        useSymmetricResize(arg) {
          return typeof arg === "boolean" ? arg : arg.ctrlKey;
        }
        createTracker() {
          return new change_bounds_tracker_1.ChangeBoundsTracker(this);
        }
      };
      exports.ChangeBoundsManager = ChangeBoundsManager;
      exports.ChangeBoundsManager = ChangeBoundsManager = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.MousePositionTracker)),
        __param(1, (0, inversify_1.optional)()),
        __param(1, (0, inversify_1.inject)(sprotty_1.TYPES.IMovementRestrictor)),
        __param(2, (0, inversify_1.optional)()),
        __param(2, (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper)),
        __param(3, (0, inversify_1.optional)()),
        __param(3, (0, inversify_1.inject)(sprotty_1.TYPES.IHelperLineManager)),
        __param(4, (0, inversify_1.optional)()),
        __param(4, (0, inversify_1.inject)(sprotty_1.TYPES.IGridManager)),
        __metadata("design:paramtypes", [sprotty_1.MousePositionTracker, Object, Object, Object, Object])
      ], ChangeBoundsManager);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/move-element-key-listener.js
  var require_move_element_key_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/move-element-key-listener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MoveElementKeyListener = void 0;
      var sprotty_1 = require_lib4();
      var grid_1 = require_grid();
      var move_element_action_1 = require_move_element_action();
      var MoveElementKeyListener = class extends sprotty_1.KeyListener {
        constructor(selectionService, changeBoundsManager, grid = grid_1.Grid.DEFAULT) {
          super();
          this.selectionService = selectionService;
          this.changeBoundsManager = changeBoundsManager;
          this.grid = grid;
        }
        keyDown(_element, event) {
          const selectedElementIds = this.selectionService.getSelectedElements().filter((element) => (0, sprotty_1.isMoveable)(element)).map((element) => element.id);
          const snap = this.changeBoundsManager.usePositionSnap(event);
          const offsetX = snap ? this.grid.x : 1;
          const offsetY = snap ? this.grid.y : 1;
          if (selectedElementIds.length > 0) {
            if (this.matchesMoveUpKeystroke(event)) {
              return [move_element_action_1.MoveElementRelativeAction.create({ elementIds: selectedElementIds, moveX: 0, moveY: -offsetY, snap })];
            } else if (this.matchesMoveDownKeystroke(event)) {
              return [move_element_action_1.MoveElementRelativeAction.create({ elementIds: selectedElementIds, moveX: 0, moveY: offsetY, snap })];
            } else if (this.matchesMoveRightKeystroke(event)) {
              return [move_element_action_1.MoveElementRelativeAction.create({ elementIds: selectedElementIds, moveX: offsetX, moveY: 0, snap })];
            } else if (this.matchesMoveLeftKeystroke(event)) {
              return [move_element_action_1.MoveElementRelativeAction.create({ elementIds: selectedElementIds, moveX: -offsetX, moveY: 0, snap })];
            }
          }
          return [];
        }
        matchesMoveUpKeystroke(event) {
          const unsnap = this.changeBoundsManager.unsnapModifier();
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowUp") || !!unsnap && (0, sprotty_1.matchesKeystroke)(event, "ArrowUp", unsnap);
        }
        matchesMoveDownKeystroke(event) {
          const unsnap = this.changeBoundsManager.unsnapModifier();
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowDown") || !!unsnap && (0, sprotty_1.matchesKeystroke)(event, "ArrowDown", unsnap);
        }
        matchesMoveRightKeystroke(event) {
          const unsnap = this.changeBoundsManager.unsnapModifier();
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowRight") || !!unsnap && (0, sprotty_1.matchesKeystroke)(event, "ArrowRight", unsnap);
        }
        matchesMoveLeftKeystroke(event) {
          const unsnap = this.changeBoundsManager.unsnapModifier();
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowLeft") || !!unsnap && (0, sprotty_1.matchesKeystroke)(event, "ArrowLeft", unsnap);
        }
      };
      exports.MoveElementKeyListener = MoveElementKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool-feedback.js
  var require_change_bounds_tool_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MoveFinishedEventAction = exports.MoveInitializedEventAction = exports.HideChangeBoundsToolResizeFeedbackCommand = exports.ShowChangeBoundsToolResizeFeedbackCommand = exports.HideChangeBoundsToolResizeFeedbackAction = exports.ShowChangeBoundsToolResizeFeedbackAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var feedback_command_1 = require_feedback_command();
      var glsp_model_source_1 = require_glsp_model_source();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model19();
      var ShowChangeBoundsToolResizeFeedbackAction;
      (function(ShowChangeBoundsToolResizeFeedbackAction2) {
        ShowChangeBoundsToolResizeFeedbackAction2.KIND = "showChangeBoundsToolResizeFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ShowChangeBoundsToolResizeFeedbackAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "elementId");
        }
        ShowChangeBoundsToolResizeFeedbackAction2.is = is;
        function create(options) {
          const opts = typeof options === "string" ? { elementId: options } : options;
          return {
            kind: ShowChangeBoundsToolResizeFeedbackAction2.KIND,
            ...opts
          };
        }
        ShowChangeBoundsToolResizeFeedbackAction2.create = create;
      })(ShowChangeBoundsToolResizeFeedbackAction || (exports.ShowChangeBoundsToolResizeFeedbackAction = ShowChangeBoundsToolResizeFeedbackAction = {}));
      var HideChangeBoundsToolResizeFeedbackAction;
      (function(HideChangeBoundsToolResizeFeedbackAction2) {
        HideChangeBoundsToolResizeFeedbackAction2.KIND = "hideChangeBoundsToolResizeFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, HideChangeBoundsToolResizeFeedbackAction2.KIND);
        }
        HideChangeBoundsToolResizeFeedbackAction2.is = is;
        function create() {
          return { kind: HideChangeBoundsToolResizeFeedbackAction2.KIND };
        }
        HideChangeBoundsToolResizeFeedbackAction2.create = create;
      })(HideChangeBoundsToolResizeFeedbackAction || (exports.HideChangeBoundsToolResizeFeedbackAction = HideChangeBoundsToolResizeFeedbackAction = {}));
      var ShowChangeBoundsToolResizeFeedbackCommand = class ShowChangeBoundsToolResizeFeedbackCommand extends feedback_command_1.FeedbackCommand {
        execute(context) {
          var _a4, _b2;
          const index = context.root.index;
          (0, gmodel_util_1.forEachElement)(index, model_1.isResizable, (element) => element.id !== this.action.elementId && (0, model_1.removeResizeHandles)(element));
          if (this.action.elementId) {
            const resizeElement = index.getById(this.action.elementId);
            if (resizeElement && (0, model_1.isResizable)(resizeElement)) {
              (0, model_1.addResizeHandles)(resizeElement, (_b2 = (_a4 = this.action.resizeLocations) !== null && _a4 !== void 0 ? _a4 : resizeElement.resizeLocations) !== null && _b2 !== void 0 ? _b2 : this.changeBoundsManager.defaultResizeLocations());
            }
          }
          return context.root;
        }
      };
      exports.ShowChangeBoundsToolResizeFeedbackCommand = ShowChangeBoundsToolResizeFeedbackCommand;
      ShowChangeBoundsToolResizeFeedbackCommand.KIND = ShowChangeBoundsToolResizeFeedbackAction.KIND;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.Action),
        __metadata("design:type", Object)
      ], ShowChangeBoundsToolResizeFeedbackCommand.prototype, "action", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IChangeBoundsManager),
        __metadata("design:type", Object)
      ], ShowChangeBoundsToolResizeFeedbackCommand.prototype, "changeBoundsManager", void 0);
      exports.ShowChangeBoundsToolResizeFeedbackCommand = ShowChangeBoundsToolResizeFeedbackCommand = __decorate([
        (0, inversify_1.injectable)()
      ], ShowChangeBoundsToolResizeFeedbackCommand);
      var HideChangeBoundsToolResizeFeedbackCommand = class HideChangeBoundsToolResizeFeedbackCommand extends feedback_command_1.FeedbackCommand {
        execute(context) {
          const index = context.root.index;
          (0, gmodel_util_1.forEachElement)(index, model_1.isResizable, model_1.removeResizeHandles);
          return context.root;
        }
      };
      exports.HideChangeBoundsToolResizeFeedbackCommand = HideChangeBoundsToolResizeFeedbackCommand;
      HideChangeBoundsToolResizeFeedbackCommand.KIND = HideChangeBoundsToolResizeFeedbackAction.KIND;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.Action),
        __metadata("design:type", Object)
      ], HideChangeBoundsToolResizeFeedbackCommand.prototype, "action", void 0);
      exports.HideChangeBoundsToolResizeFeedbackCommand = HideChangeBoundsToolResizeFeedbackCommand = __decorate([
        (0, inversify_1.injectable)()
      ], HideChangeBoundsToolResizeFeedbackCommand);
      var MoveInitializedEventAction;
      (function(MoveInitializedEventAction2) {
        MoveInitializedEventAction2.KIND = "move-initialized-event";
        function is(object) {
          return sprotty_1.Action.hasKind(object, MoveInitializedEventAction2.KIND);
        }
        MoveInitializedEventAction2.is = is;
        function create() {
          return glsp_model_source_1.OptionalAction.mark({ kind: MoveInitializedEventAction2.KIND });
        }
        MoveInitializedEventAction2.create = create;
      })(MoveInitializedEventAction || (exports.MoveInitializedEventAction = MoveInitializedEventAction = {}));
      var MoveFinishedEventAction;
      (function(MoveFinishedEventAction2) {
        MoveFinishedEventAction2.KIND = "move-finished-event";
        function is(object) {
          return sprotty_1.Action.hasKind(object, MoveFinishedEventAction2.KIND);
        }
        MoveFinishedEventAction2.is = is;
        function create() {
          return glsp_model_source_1.OptionalAction.mark({ kind: MoveFinishedEventAction2.KIND });
        }
        MoveFinishedEventAction2.create = create;
      })(MoveFinishedEventAction || (exports.MoveFinishedEventAction = MoveFinishedEventAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool-move-feedback.js
  var require_change_bounds_tool_move_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool-move-feedback.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FeedbackMoveMouseListener = void 0;
      var sprotty_1 = require_lib4();
      var lodash_1 = require_lodash();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model19();
      var change_bounds_tool_feedback_1 = require_change_bounds_tool_feedback();
      var FeedbackMoveMouseListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.elementId2startPos = /* @__PURE__ */ new Map();
          this.tracker = tool.createChangeBoundsTracker();
          this.moveInitializedFeedback = tool.createFeedbackEmitter();
          this.moveFeedback = tool.createFeedbackEmitter();
        }
        mouseDown(target, event) {
          super.mouseDown(target, event);
          if (event.button === 0) {
            if (this.tracker.isTracking()) {
              this.draggingMouseUp(target, event);
              return [];
            }
            this.initializeMove(target, event);
            return [];
          }
          this.tracker.stopTracking();
          return [];
        }
        initializeMove(target, event) {
          if (target instanceof model_1.GResizeHandle) {
            return;
          }
          const moveable = (0, sprotty_1.findParentByFeature)(target, this.isValidMoveable);
          if (moveable !== void 0) {
            this.tracker.startTracking();
            this.scheduleMoveInitialized();
          } else {
            this.tracker.stopTracking();
          }
        }
        scheduleMoveInitialized() {
          var _a4;
          (_a4 = this.pendingMoveInitialized) === null || _a4 === void 0 ? void 0 : _a4.cancel();
          this.pendingMoveInitialized = (0, lodash_1.debounce)(() => {
            this.moveInitialized();
            this.pendingMoveInitialized = void 0;
          }, 750);
          this.pendingMoveInitialized();
        }
        moveInitializationTimeout() {
          return 750;
        }
        moveInitialized() {
          if (this.isMouseDown) {
            this.moveInitializedFeedback.add(change_bounds_tool_feedback_1.MoveInitializedEventAction.create(), change_bounds_tool_feedback_1.MoveFinishedEventAction.create()).add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.MOVE), (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT)).submit();
          }
        }
        isValidMoveable(element) {
          return !!element && (0, gmodel_util_1.isNonRoutableSelectedMovableBoundsAware)(element) && !(element instanceof model_1.GResizeHandle);
        }
        isValidRevertable(element) {
          return !!element && (0, gmodel_util_1.isNonRoutableMovableBoundsAware)(element) && !(element instanceof model_1.GResizeHandle);
        }
        nonDraggingMouseUp(element, event) {
          this.moveInitializedFeedback.dispose();
          this.tracker.stopTracking();
          return [];
        }
        draggingMouseMove(target, event) {
          super.draggingMouseMove(target, event);
          if (this.tracker.isTracking()) {
            return this.moveElements(target, event);
          }
          return [];
        }
        moveElements(target, event) {
          var _a4;
          if (this.elementId2startPos.size === 0) {
            this.initializeElementsToMove(target.root);
          }
          const elementsToMove = this.getElementsToMove(target);
          const move = this.tracker.moveElements(elementsToMove, { snap: event, restrict: event });
          if (move.elementMoves.length === 0) {
            return [];
          }
          (_a4 = this.pendingMoveInitialized) === null || _a4 === void 0 ? void 0 : _a4.cancel();
          this.moveFeedback.add(this.createMoveAction(move), () => this.resetElementPositions(target));
          this.addMoveFeedback(move, target, event);
          this.tracker.updateTrackingPosition(move);
          this.moveFeedback.submit();
          return [];
        }
        createMoveAction(trackedMove) {
          return sprotty_1.MoveAction.create(trackedMove.elementMoves.map((move) => ({ elementId: move.element.id, toPosition: move.toPosition })), { animate: false });
        }
        addMoveFeedback(trackedMove, ctx, event) {
          this.tool.changeBoundsManager.addMoveFeedback(this.moveFeedback, trackedMove, ctx, event);
        }
        initializeElementsToMove(root) {
          const elementsToMove = this.collectElementsToMove(root);
          elementsToMove.forEach((element) => this.elementId2startPos.set(element.id, element.position));
        }
        collectElementsToMove(root) {
          const moveableElements = (0, gmodel_util_1.filter)(root.index, this.isValidMoveable);
          const topLevelElements = (0, gmodel_util_1.removeDescendants)(moveableElements);
          return Array.from(topLevelElements);
        }
        getElementsToMove(context, moveable = this.isValidMoveable) {
          return (0, gmodel_util_1.getElements)(context.root.index, Array.from(this.elementId2startPos.keys()), moveable);
        }
        resetElementPositions(context) {
          const elementMoves = this.revertElementMoves(context);
          return sprotty_1.MoveAction.create(elementMoves, { animate: false, finished: true });
        }
        revertElementMoves(context) {
          var _a4;
          const elementMoves = [];
          if ((_a4 = context === null || context === void 0 ? void 0 : context.root) === null || _a4 === void 0 ? void 0 : _a4.index) {
            const movableElements = this.getElementsToMove(context, this.isValidRevertable);
            movableElements.forEach((element) => elementMoves.push({ elementId: element.id, toPosition: this.elementId2startPos.get(element.id) }));
          }
          return elementMoves;
        }
        draggingMouseUp(target, event) {
          if (!this.tracker.isTracking()) {
            return [];
          }
          const elementsToMove = this.getElementsToMove(target);
          if (!this.tool.movementOptions.allElementsNeedToBeValid) {
            elementsToMove.filter((element) => this.tool.changeBoundsManager.isValid(element)).forEach((element) => this.elementId2startPos.delete(element.id));
          } else {
            if (elementsToMove.length > 0 && elementsToMove.every((element) => this.tool.changeBoundsManager.isValid(element))) {
              this.elementId2startPos.clear();
            }
          }
          this.dispose();
          return [];
        }
        selectionChanged(root, selectedElements, deselectedElements) {
          this.dispose();
        }
        dispose() {
          var _a4;
          (_a4 = this.pendingMoveInitialized) === null || _a4 === void 0 ? void 0 : _a4.cancel();
          this.moveInitializedFeedback.dispose();
          this.moveFeedback.dispose();
          this.tracker.dispose();
          this.elementId2startPos.clear();
          super.dispose();
        }
      };
      exports.FeedbackMoveMouseListener = FeedbackMoveMouseListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool.js
  var require_change_bounds_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var ChangeBoundsTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ChangeBoundsListener = exports.ChangeBoundsTool = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var messages_1 = require_messages3();
      var selection_service_1 = require_selection_service();
      var gmodel_util_1 = require_gmodel_util();
      var local_bounds_1 = require_local_bounds();
      var set_bounds_feedback_command_1 = require_set_bounds_feedback_command();
      var model_1 = require_model19();
      var move_element_key_listener_1 = require_move_element_key_listener();
      var grid_1 = require_grid();
      var base_tools_1 = require_base_tools();
      var change_bounds_manager_1 = require_change_bounds_manager();
      var change_bounds_tool_feedback_1 = require_change_bounds_tool_feedback();
      var change_bounds_tool_move_feedback_1 = require_change_bounds_tool_move_feedback();
      var ChangeBoundsTool = ChangeBoundsTool_1 = class ChangeBoundsTool extends base_tools_1.BaseEditTool {
        constructor() {
          super(...arguments);
          this.movementOptions = { allElementsNeedToBeValid: true };
        }
        get id() {
          return ChangeBoundsTool_1.ID;
        }
        enable() {
          const feedbackMoveMouseListener = this.createMoveMouseListener();
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(feedbackMoveMouseListener));
          if (sprotty_1.Disposable.is(feedbackMoveMouseListener)) {
            this.toDisposeOnDisable.push(feedbackMoveMouseListener);
          }
          if (selection_service_1.ISelectionListener.is(feedbackMoveMouseListener)) {
            this.toDisposeOnDisable.push(this.selectionService.addListener(feedbackMoveMouseListener));
          }
          const createMoveKeyListener = this.createMoveKeyListener();
          this.toDisposeOnDisable.push(this.keyTool.registerListener(createMoveKeyListener), (0, messages_1.repeatOnMessagesUpdated)(() => this.shortcutManager.register(ChangeBoundsTool_1.TOKEN, [
            {
              shortcuts: ["\u2B05 \u2B06 \u27A1 \u2B07"],
              description: messages_1.messages.move.shortcut_move,
              group: messages_1.messages.shortcut.group_move,
              position: 0
            }
          ])));
          if (sprotty_1.Disposable.is(createMoveKeyListener)) {
            this.toDisposeOnDisable.push(createMoveKeyListener);
          }
          const changeBoundsListener = this.createChangeBoundsListener();
          this.toDisposeOnDisable.push(this.mouseTool.registerListener(changeBoundsListener));
          if (sprotty_1.Disposable.is(changeBoundsListener)) {
            this.toDisposeOnDisable.push(changeBoundsListener);
          }
          if (selection_service_1.ISelectionListener.is(changeBoundsListener)) {
            this.toDisposeOnDisable.push(this.selectionService.addListener(changeBoundsListener));
          }
        }
        createChangeBoundsTracker() {
          return this.changeBoundsManager.createTracker();
        }
        createMoveMouseListener() {
          return new change_bounds_tool_move_feedback_1.FeedbackMoveMouseListener(this);
        }
        createMoveKeyListener() {
          return new move_element_key_listener_1.MoveElementKeyListener(this.selectionService, this.changeBoundsManager, this.grid);
        }
        createChangeBoundsListener() {
          return new ChangeBoundsListener(this);
        }
      };
      exports.ChangeBoundsTool = ChangeBoundsTool;
      ChangeBoundsTool.ID = "glsp.change-bounds-tool";
      ChangeBoundsTool.TOKEN = Symbol.for(ChangeBoundsTool_1.ID);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], ChangeBoundsTool.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], ChangeBoundsTool.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IMovementRestrictor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ChangeBoundsTool.prototype, "movementRestrictor", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IChangeBoundsManager),
        __metadata("design:type", Object)
      ], ChangeBoundsTool.prototype, "changeBoundsManager", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IMovementOptions),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ChangeBoundsTool.prototype, "movementOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.Grid),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], ChangeBoundsTool.prototype, "grid", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
        __metadata("design:type", Object)
      ], ChangeBoundsTool.prototype, "shortcutManager", void 0);
      exports.ChangeBoundsTool = ChangeBoundsTool = ChangeBoundsTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ChangeBoundsTool);
      var ChangeBoundsListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.tracker = tool.createChangeBoundsTracker();
          this.handleFeedback = tool.createFeedbackEmitter();
          this.resizeFeedback = tool.createFeedbackEmitter();
        }
        mouseDown(target, event) {
          super.mouseDown(target, event);
          if (event.button !== 0 || target instanceof sprotty_1.GModelRoot) {
            return [];
          }
          this.updateResizeElement(target, event);
          return [];
        }
        updateResizeElement(target, event) {
          var _a4, _b2;
          this.activeResizeHandle = target instanceof model_1.GResizeHandle ? target : void 0;
          this.activeResizeElement = (_b2 = (_a4 = this.activeResizeHandle) === null || _a4 === void 0 ? void 0 : _a4.parent) !== null && _b2 !== void 0 ? _b2 : this.findResizeElement(target);
          if (this.activeResizeElement) {
            if (event) {
              this.tracker.startTracking();
            }
            this.initialBounds = {
              newSize: this.activeResizeElement.bounds,
              newPosition: this.activeResizeElement.bounds,
              elementId: this.activeResizeElement.id
            };
            this.tool.createFeedbackEmitter().add(local_bounds_1.LocalRequestBoundsAction.create(target.root, [this.activeResizeElement.id])).submit().dispose();
            this.handleFeedback.add(change_bounds_tool_feedback_1.ShowChangeBoundsToolResizeFeedbackAction.create({ elementId: this.activeResizeElement.id }), change_bounds_tool_feedback_1.HideChangeBoundsToolResizeFeedbackAction.create());
            this.handleFeedback.submit();
            return true;
          } else {
            this.disposeResize();
            return false;
          }
        }
        findResizeElement(target) {
          return (0, sprotty_1.findParentByFeature)(target, model_1.isResizable);
        }
        draggingMouseMove(target, event) {
          if (this.activeResizeHandle && this.tracker.isTracking()) {
            const resize = this.tracker.resizeElements(this.activeResizeHandle, { snap: event, symmetric: event, restrict: event });
            const resizeAction = this.resizeBoundsAction(resize);
            if (resizeAction.bounds.length > 0) {
              this.resizeFeedback.add(resizeAction, () => this.resetBounds());
              this.tracker.updateTrackingPosition(resize.handleMove.moveVector);
              this.addResizeFeedback(resize, target, event);
              this.resizeFeedback.submit();
            }
          }
          return super.draggingMouseMove(target, event);
        }
        resizeBoundsAction(resize) {
          const elementResizes = resize.elementResizes.filter((elementResize) => elementResize.valid.size);
          return set_bounds_feedback_command_1.SetBoundsFeedbackAction.create(elementResizes.map((elementResize) => this.toElementAndBounds(elementResize)));
        }
        toElementAndBounds(elementResize) {
          return {
            elementId: elementResize.element.id,
            newSize: elementResize.toBounds,
            newPosition: elementResize.toBounds
          };
        }
        addResizeFeedback(resize, target, event) {
          this.tool.changeBoundsManager.addResizeFeedback(this.resizeFeedback, resize, target, event);
        }
        resetBounds() {
          return this.initialBounds ? [set_bounds_feedback_command_1.SetBoundsFeedbackAction.create([this.initialBounds]), change_bounds_tool_feedback_1.MoveFinishedEventAction.create()] : [change_bounds_tool_feedback_1.MoveFinishedEventAction.create()];
        }
        draggingMouseUp(target, event) {
          const actions = [];
          if (this.activeResizeHandle) {
            actions.push(...this.handleResizeOnServer(this.activeResizeHandle));
          } else {
            actions.push(...this.handleMoveOnServer(target));
          }
          this.disposeResize({ keepHandles: true });
          return actions;
        }
        nonDraggingMouseUp(element, event) {
          this.disposeResize({ keepHandles: true });
          return super.nonDraggingMouseUp(element, event);
        }
        handleMoveOnServer(target) {
          const operations = [];
          const elementToMove = this.getElementsToMove(target);
          operations.push(...this.handleMoveElementsOnServer(elementToMove));
          operations.push(...this.handleMoveRoutingPointsOnServer(elementToMove));
          return operations.length > 0 ? [sprotty_1.CompoundOperation.create(operations)] : [];
        }
        getElementsToMove(target) {
          const selectedElements = (0, gmodel_util_1.getMatchingElements)(target.index, gmodel_util_1.isNonRoutableSelectedMovableBoundsAware);
          const selectionSet = new Set(selectedElements);
          const elementsToMove = selectedElements.filter((element) => this.isValidMove(element, selectionSet));
          if (this.tool.movementOptions.allElementsNeedToBeValid && elementsToMove.length !== selectionSet.size) {
            return [];
          }
          return elementsToMove;
        }
        handleMoveElementsOnServer(elementsToMove) {
          const newBounds = elementsToMove.map(gmodel_util_1.toElementAndBounds);
          return newBounds.length > 0 ? [sprotty_1.ChangeBoundsOperation.create(newBounds)] : [];
        }
        isValidMove(element, selectedElements = /* @__PURE__ */ new Set()) {
          return this.tool.changeBoundsManager.hasValidPosition(element) && !this.isChildOfSelected(selectedElements, element);
        }
        isChildOfSelected(selectedElements, element) {
          if (selectedElements.size === 0) {
            return false;
          }
          while (element instanceof sprotty_1.GChildElement) {
            element = element.parent;
            if (selectedElements.has(element)) {
              return true;
            }
          }
          return false;
        }
        handleMoveRoutingPointsOnServer(elementsToMove) {
          const newRoutingPoints = [];
          const routerRegistry = this.tool.edgeRouterRegistry;
          if (routerRegistry) {
            elementsToMove.forEach((element) => {
              if (element instanceof sprotty_1.GConnectableElement) {
                element.incomingEdges.map((connectable) => (0, gmodel_util_1.calcElementAndRoutingPoints)(connectable, routerRegistry)).forEach((ear) => newRoutingPoints.push(ear));
                element.outgoingEdges.map((connectable) => (0, gmodel_util_1.calcElementAndRoutingPoints)(connectable, routerRegistry)).forEach((ear) => newRoutingPoints.push(ear));
              }
            });
          }
          return newRoutingPoints.length > 0 ? [sprotty_1.ChangeRoutingPointsOperation.create(newRoutingPoints)] : [];
        }
        handleResizeOnServer(activeResizeHandle) {
          if (this.initialBounds && this.isValidResize(activeResizeHandle.parent)) {
            const elementAndBounds = (0, gmodel_util_1.toElementAndBounds)(activeResizeHandle.parent);
            if (!this.initialBounds.newPosition || !elementAndBounds.newPosition) {
              return [];
            }
            if (!sprotty_1.Point.equals(this.initialBounds.newPosition, elementAndBounds.newPosition) || !sprotty_1.Dimension.equals(this.initialBounds.newSize, elementAndBounds.newSize)) {
              this.initialBounds = void 0;
              return [sprotty_1.ChangeBoundsOperation.create([elementAndBounds])];
            }
          }
          return [];
        }
        isValidResize(element) {
          return this.tool.changeBoundsManager.isValid(element);
        }
        selectionChanged(root, selectedElements) {
          if (this.activeResizeElement && selectedElements.includes(this.activeResizeElement.id)) {
            return;
          }
          for (const elementId of selectedElements.reverse()) {
            const element = root.index.getById(elementId);
            if (element && this.updateResizeElement(element)) {
              return;
            }
          }
          this.dispose();
        }
        isActiveResizeElement(element) {
          return element !== void 0 && this.activeResizeElement !== void 0 && element.id === this.activeResizeElement.id;
        }
        disposeResize(opts = { keepHandles: false }) {
          if (!opts.keepHandles) {
            this.handleFeedback.dispose();
          }
          this.resizeFeedback.dispose();
          this.tracker.dispose();
          this.activeResizeElement = void 0;
          this.activeResizeHandle = void 0;
          this.initialBounds = void 0;
        }
        dispose() {
          this.disposeResize();
          super.dispose();
        }
      };
      exports.ChangeBoundsListener = ChangeBoundsListener;
      ChangeBoundsListener.CSS_CLASS_ACTIVE = change_bounds_manager_1.CSS_ACTIVE_HANDLE;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/view.js
  var require_view3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SResizeHandleView = exports.GResizeHandleView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var model_1 = require_model19();
      var GResizeHandleView = class GResizeHandleView {
        render(handle, context) {
          if (context.targetKind === "hidden") {
            return void 0;
          }
          const position = this.getPosition(handle);
          if (position !== void 0) {
            const node = (0, sprotty_1.svg)("circle", { "class-sprotty-resize-handle": true, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y, r: this.getRadius() });
            (0, sprotty_1.setAttr)(node, "data-kind", handle.location);
            return node;
          }
          return (0, sprotty_1.svg)("g", null);
        }
        getPosition(handle) {
          return sprotty_1.Point.subtract(model_1.GResizeHandle.getHandlePosition(handle), handle.parent.bounds);
        }
        getRadius() {
          return 7;
        }
      };
      exports.GResizeHandleView = GResizeHandleView;
      exports.SResizeHandleView = GResizeHandleView;
      exports.SResizeHandleView = exports.GResizeHandleView = GResizeHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], GResizeHandleView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool-module.js
  var require_change_bounds_tool_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/change-bounds/change-bounds-tool-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.changeBoundsToolModule = void 0;
      var sprotty_1 = require_lib4();
      require_change_bounds();
      var model_1 = require_model19();
      var change_bounds_manager_1 = require_change_bounds_manager();
      var change_bounds_tool_1 = require_change_bounds_tool();
      var change_bounds_tool_feedback_1 = require_change_bounds_tool_feedback();
      var view_1 = require_view3();
      exports.changeBoundsToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IChangeBoundsManager, change_bounds_manager_1.ChangeBoundsManager);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, change_bounds_tool_1.ChangeBoundsTool);
        (0, sprotty_1.configureCommand)(context, change_bounds_tool_feedback_1.ShowChangeBoundsToolResizeFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, change_bounds_tool_feedback_1.HideChangeBoundsToolResizeFeedbackCommand);
        (0, sprotty_1.configureView)(context, model_1.GResizeHandle.TYPE, view_1.GResizeHandleView);
      }, { featureId: Symbol("changeBoundsTool") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/deletion/deletion-tool-module.js
  var require_deletion_tool_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/deletion/deletion-tool-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deletionToolModule = void 0;
      var sprotty_1 = require_lib4();
      var delete_tool_1 = require_delete_tool();
      exports.deletionToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, delete_tool_1.DelKeyDeleteTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITool, delete_tool_1.MouseDeleteTool);
      }, { featureId: Symbol("deletionTool") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edege-creation-module.js
  var require_edege_creation_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-creation/edege-creation-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.edgeCreationToolModule = void 0;
      var sprotty_1 = require_lib4();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_creation_tool_1 = require_edge_creation_tool();
      exports.edgeCreationToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITool, edge_creation_tool_1.EdgeCreationTool);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.TriggerEdgeCreationAction.KIND, edge_creation_tool_1.EdgeCreationTool);
        (0, dangling_edge_feedback_1.configureDanglingFeedbackEdge)(context);
      }, { featureId: Symbol("edgeCreationTool") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-tool-feedback.js
  var require_edge_edit_tool_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-tool-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.drawFeedbackEdgeSource = exports.FeedbackEdgeRouteMovingMouseListener = exports.FeedbackEdgeSourceMovingMouseListener = exports.FeedbackEdgeTargetMovingMouseListener = exports.DrawFeedbackEdgeSourceCommand = exports.DrawFeedbackEdgeSourceAction = exports.SwitchRoutingModeCommand = exports.SwitchRoutingModeAction = exports.HideEdgeReconnectHandlesFeedbackCommand = exports.ShowEdgeReconnectHandlesFeedbackCommand = exports.HideEdgeReconnectHandlesFeedbackAction = exports.ShowEdgeReconnectHandlesFeedbackAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var viewpoint_util_1 = require_viewpoint_util();
      var model_1 = require_model23();
      var change_bounds_tracker_1 = require_change_bounds_tracker();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_creation_tool_feedback_1 = require_edge_creation_tool_feedback();
      var ShowEdgeReconnectHandlesFeedbackAction;
      (function(ShowEdgeReconnectHandlesFeedbackAction2) {
        ShowEdgeReconnectHandlesFeedbackAction2.KIND = "showReconnectHandlesFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ShowEdgeReconnectHandlesFeedbackAction2.KIND);
        }
        ShowEdgeReconnectHandlesFeedbackAction2.is = is;
        function create(elementId) {
          return { kind: ShowEdgeReconnectHandlesFeedbackAction2.KIND, elementId };
        }
        ShowEdgeReconnectHandlesFeedbackAction2.create = create;
      })(ShowEdgeReconnectHandlesFeedbackAction || (exports.ShowEdgeReconnectHandlesFeedbackAction = ShowEdgeReconnectHandlesFeedbackAction = {}));
      var HideEdgeReconnectHandlesFeedbackAction;
      (function(HideEdgeReconnectHandlesFeedbackAction2) {
        HideEdgeReconnectHandlesFeedbackAction2.KIND = "hideReconnectHandlesFeedback";
        function is(object) {
          return sprotty_1.Action.hasKind(object, HideEdgeReconnectHandlesFeedbackAction2.KIND);
        }
        HideEdgeReconnectHandlesFeedbackAction2.is = is;
        function create() {
          return { kind: HideEdgeReconnectHandlesFeedbackAction2.KIND };
        }
        HideEdgeReconnectHandlesFeedbackAction2.create = create;
      })(HideEdgeReconnectHandlesFeedbackAction || (exports.HideEdgeReconnectHandlesFeedbackAction = HideEdgeReconnectHandlesFeedbackAction = {}));
      var ShowEdgeReconnectHandlesFeedbackCommand = class ShowEdgeReconnectHandlesFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const index = context.root.index;
          (0, gmodel_util_1.forEachElement)(index, gmodel_util_1.isRoutable, model_1.removeReconnectHandles);
          const routableElement = index.getById(this.action.elementId);
          if (routableElement && (0, gmodel_util_1.isRoutable)(routableElement)) {
            (0, model_1.addReconnectHandles)(routableElement);
          }
          return context.root;
        }
      };
      exports.ShowEdgeReconnectHandlesFeedbackCommand = ShowEdgeReconnectHandlesFeedbackCommand;
      ShowEdgeReconnectHandlesFeedbackCommand.KIND = ShowEdgeReconnectHandlesFeedbackAction.KIND;
      exports.ShowEdgeReconnectHandlesFeedbackCommand = ShowEdgeReconnectHandlesFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ShowEdgeReconnectHandlesFeedbackCommand);
      var HideEdgeReconnectHandlesFeedbackCommand = class HideEdgeReconnectHandlesFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const index = context.root.index;
          (0, gmodel_util_1.forEachElement)(index, gmodel_util_1.isRoutable, model_1.removeReconnectHandles);
          return context.root;
        }
      };
      exports.HideEdgeReconnectHandlesFeedbackCommand = HideEdgeReconnectHandlesFeedbackCommand;
      HideEdgeReconnectHandlesFeedbackCommand.KIND = HideEdgeReconnectHandlesFeedbackAction.KIND;
      exports.HideEdgeReconnectHandlesFeedbackCommand = HideEdgeReconnectHandlesFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], HideEdgeReconnectHandlesFeedbackCommand);
      var SwitchRoutingModeAction;
      (function(SwitchRoutingModeAction2) {
        SwitchRoutingModeAction2.KIND = "switchRoutingMode";
        function create(options) {
          return {
            ...sprotty_1.SwitchEditModeAction.create(options),
            kind: SwitchRoutingModeAction2.KIND
          };
        }
        SwitchRoutingModeAction2.create = create;
      })(SwitchRoutingModeAction || (exports.SwitchRoutingModeAction = SwitchRoutingModeAction = {}));
      var SwitchRoutingModeCommand = class SwitchRoutingModeCommand extends sprotty_1.SwitchEditModeCommand {
        constructor(action) {
          super({ ...action, kind: sprotty_1.SwitchEditModeAction.KIND });
        }
      };
      exports.SwitchRoutingModeCommand = SwitchRoutingModeCommand;
      SwitchRoutingModeCommand.KIND = SwitchRoutingModeAction.KIND;
      exports.SwitchRoutingModeCommand = SwitchRoutingModeCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SwitchRoutingModeCommand);
      var DrawFeedbackEdgeSourceAction;
      (function(DrawFeedbackEdgeSourceAction2) {
        DrawFeedbackEdgeSourceAction2.KIND = "drawFeedbackEdgeSource";
        function is(object) {
          return sprotty_1.Action.hasKind(object, DrawFeedbackEdgeSourceAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "elementTypeId") && (0, sprotty_1.hasStringProp)(object, "targetId");
        }
        DrawFeedbackEdgeSourceAction2.is = is;
        function create(options) {
          return {
            kind: DrawFeedbackEdgeSourceAction2.KIND,
            ...options
          };
        }
        DrawFeedbackEdgeSourceAction2.create = create;
      })(DrawFeedbackEdgeSourceAction || (exports.DrawFeedbackEdgeSourceAction = DrawFeedbackEdgeSourceAction = {}));
      var DrawFeedbackEdgeSourceCommand = class DrawFeedbackEdgeSourceCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          drawFeedbackEdgeSource(context, this.action.targetId, this.action.elementTypeId);
          return context.root;
        }
      };
      exports.DrawFeedbackEdgeSourceCommand = DrawFeedbackEdgeSourceCommand;
      DrawFeedbackEdgeSourceCommand.KIND = DrawFeedbackEdgeSourceAction.KIND;
      exports.DrawFeedbackEdgeSourceCommand = DrawFeedbackEdgeSourceCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DrawFeedbackEdgeSourceCommand);
      var FeedbackEdgeTargetMovingMouseListener = class extends edge_creation_tool_feedback_1.FeedbackEdgeEndMovingMouseListener {
        constructor(anchorRegistry, feedbackDispatcher) {
          super(anchorRegistry, feedbackDispatcher);
        }
      };
      exports.FeedbackEdgeTargetMovingMouseListener = FeedbackEdgeTargetMovingMouseListener;
      var FeedbackEdgeSourceMovingMouseListener = class extends sprotty_1.MouseListener {
        constructor(anchorRegistry, feedbackDispatcher) {
          super();
          this.anchorRegistry = anchorRegistry;
          this.feedbackDispatcher = feedbackDispatcher;
          this.feedback = feedbackDispatcher.createEmitter();
        }
        mouseMove(target, event) {
          const root = target.root;
          const edgeEnd = root.index.getById((0, dangling_edge_feedback_1.feedbackEdgeEndId)(root));
          if (!(edgeEnd instanceof dangling_edge_feedback_1.FeedbackEdgeEnd) || !edgeEnd.feedbackEdge) {
            return [];
          }
          const edge = edgeEnd.feedbackEdge;
          const position = (0, viewpoint_util_1.getAbsolutePosition)(edgeEnd, event);
          const endAtMousePosition = (0, sprotty_1.findChildrenAtPosition)(target.root, position).find((element) => (0, sprotty_1.isConnectable)(element) && element.canConnect(edge, "source"));
          if (endAtMousePosition instanceof sprotty_1.GConnectableElement && edge.target && (0, sprotty_1.isBoundsAware)(edge.target)) {
            const anchor = this.computeAbsoluteAnchor(endAtMousePosition, sprotty_1.Bounds.center(edge.target.bounds));
            if (sprotty_1.Point.euclideanDistance(anchor, edgeEnd.position) > 1) {
              this.feedback.add(sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: anchor }], { animate: false })).submit();
            }
          } else {
            this.feedback.add(sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: position }], { animate: false })).submit();
          }
          return [];
        }
        computeAbsoluteAnchor(element, referencePoint, offset) {
          const anchorComputer = this.anchorRegistry.get(sprotty_1.PolylineEdgeRouter.KIND, element.anchorKind);
          let anchor = anchorComputer.getAnchor(element, referencePoint, offset);
          if (element.parent !== element.root) {
            const parent = (0, sprotty_1.findParentByFeature)(element.parent, sprotty_1.isBoundsAware);
            if (parent) {
              const absoluteParentPosition = (0, viewpoint_util_1.toAbsoluteBounds)(parent);
              anchor = sprotty_1.Point.add(absoluteParentPosition, anchor);
            }
          }
          return anchor;
        }
        dispose() {
          this.feedback.dispose();
        }
      };
      exports.FeedbackEdgeSourceMovingMouseListener = FeedbackEdgeSourceMovingMouseListener;
      var FeedbackEdgeRouteMovingMouseListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(changeBoundsManager, edgeRouterRegistry) {
          super();
          this.changeBoundsManager = changeBoundsManager;
          this.edgeRouterRegistry = edgeRouterRegistry;
          this.tracker = this.changeBoundsManager.createTracker();
        }
        mouseDown(target, event) {
          const result = super.mouseDown(target, event);
          if (event.button === 0) {
            const routingHandle = (0, sprotty_1.findParentByFeature)(target, gmodel_util_1.isRoutingHandle);
            if (routingHandle !== void 0) {
              result.push(SwitchRoutingModeAction.create({ elementsToActivate: [target.id] }));
              this.tracker.startTracking();
            } else {
              this.tracker.dispose();
            }
          }
          return result;
        }
        draggingMouseMove(target, event) {
          super.draggingMouseMove(target, event);
          if (this.tracker.isTracking()) {
            return this.moveRoutingHandles(target, event);
          }
          return [];
        }
        moveRoutingHandles(target, event) {
          const routingHandlesToMove = this.getRoutingHandlesToMove(target);
          const move = this.tracker.moveElements(routingHandlesToMove, { snap: event, restrict: event });
          if (move.elementMoves.length === 0) {
            return [];
          }
          this.tracker.updateTrackingPosition(move);
          return [
            sprotty_1.MoveAction.create(move.elementMoves.map((elementMove) => ({ elementId: elementMove.element.id, toPosition: elementMove.toPosition })), { animate: false })
          ];
        }
        getRoutingHandlesToMove(context) {
          const selectedRoutingHandles = (0, gmodel_util_1.getMatchingElements)(context.root.index, (0, sprotty_1.typeGuard)(gmodel_util_1.isRoutingHandle, sprotty_1.isSelected));
          return selectedRoutingHandles.map((handle) => {
            const position = this.getHandlePosition(handle);
            return position ? new change_bounds_tracker_1.MoveableRoutingHandle(handle, position) : void 0;
          }).filter((0, sprotty_1.toTypeGuard)(change_bounds_tracker_1.MoveableRoutingHandle));
        }
        getHandlePosition(handle) {
          if (this.edgeRouterRegistry) {
            const parent = handle.parent;
            if (!(0, gmodel_util_1.isRoutable)(parent)) {
              return void 0;
            }
            const router = this.edgeRouterRegistry.get(parent.routerKind);
            const route = router.route(parent);
            return router.getHandlePosition(parent, route, handle);
          }
          return void 0;
        }
        nonDraggingMouseUp(element, event) {
          this.tracker.stopTracking();
          return [];
        }
        draggingMouseUp(_target, _event) {
          if (!this.tracker.isTracking()) {
            return [];
          }
          this.dispose();
          return [];
        }
        dispose() {
          this.tracker.dispose();
          super.dispose();
        }
      };
      exports.FeedbackEdgeRouteMovingMouseListener = FeedbackEdgeRouteMovingMouseListener;
      function drawFeedbackEdgeSource(context, targetId, elementTypeId) {
        const root = context.root;
        const targetChild = root.index.getById(targetId);
        if (!targetChild) {
          return;
        }
        const target = (0, sprotty_1.findParentByFeature)(targetChild, sprotty_1.isConnectable);
        if (!target || !(0, sprotty_1.isBoundsAware)(target)) {
          return;
        }
        const edgeEnd = new dangling_edge_feedback_1.FeedbackEdgeEnd(target.id, elementTypeId);
        edgeEnd.id = (0, dangling_edge_feedback_1.feedbackEdgeEndId)(root);
        edgeEnd.position = { x: target.bounds.x, y: target.bounds.y };
        const feedbackEdgeSchema = {
          type: "edge",
          id: (0, dangling_edge_feedback_1.feedbackEdgeId)(root),
          sourceId: edgeEnd.id,
          targetId: target.id,
          opacity: 0.3
        };
        const feedbackEdge = context.modelFactory.createElement(feedbackEdgeSchema);
        if ((0, gmodel_util_1.isRoutable)(feedbackEdge)) {
          edgeEnd.feedbackEdge = feedbackEdge;
          root.add(edgeEnd);
          root.add(feedbackEdge);
        }
      }
      exports.drawFeedbackEdgeSource = drawFeedbackEdgeSource;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-tool.js
  var require_edge_edit_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var EdgeEditTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeEditListener = exports.EdgeEditTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var selection_service_1 = require_selection_service();
      var gmodel_util_1 = require_gmodel_util();
      var model_1 = require_model23();
      var base_tools_1 = require_base_tools();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_edit_tool_feedback_1 = require_edge_edit_tool_feedback();
      var EdgeEditTool = EdgeEditTool_1 = class EdgeEditTool extends base_tools_1.BaseEditTool {
        get id() {
          return EdgeEditTool_1.ID;
        }
        enable() {
          this.edgeEditListener = new EdgeEditListener(this);
          this.feedbackEdgeSourceMovingListener = new edge_edit_tool_feedback_1.FeedbackEdgeSourceMovingMouseListener(this.anchorRegistry, this.feedbackDispatcher);
          this.feedbackEdgeTargetMovingListener = new edge_edit_tool_feedback_1.FeedbackEdgeTargetMovingMouseListener(this.anchorRegistry, this.feedbackDispatcher);
          this.feedbackMovingListener = new edge_edit_tool_feedback_1.FeedbackEdgeRouteMovingMouseListener(this.changeBoundsManager, this.edgeRouterRegistry);
          this.toDisposeOnDisable.push(this.edgeEditListener, this.mouseTool.registerListener(this.edgeEditListener), this.feedbackEdgeSourceMovingListener, this.feedbackEdgeTargetMovingListener, this.feedbackMovingListener, this.selectionService.addListener(this.edgeEditListener));
        }
        registerFeedbackListeners() {
          this.mouseTool.register(this.feedbackMovingListener);
          this.mouseTool.register(this.feedbackEdgeSourceMovingListener);
          this.mouseTool.register(this.feedbackEdgeTargetMovingListener);
        }
        deregisterFeedbackListeners() {
          this.feedbackEdgeSourceMovingListener.dispose();
          this.feedbackEdgeTargetMovingListener.dispose();
          this.mouseTool.deregister(this.feedbackEdgeSourceMovingListener);
          this.mouseTool.deregister(this.feedbackEdgeTargetMovingListener);
          this.mouseTool.deregister(this.feedbackMovingListener);
        }
      };
      exports.EdgeEditTool = EdgeEditTool;
      EdgeEditTool.ID = "glsp.edge-edit-tool";
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], EdgeEditTool.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.AnchorComputerRegistry),
        __metadata("design:type", sprotty_1.AnchorComputerRegistry)
      ], EdgeEditTool.prototype, "anchorRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], EdgeEditTool.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IChangeBoundsManager),
        __metadata("design:type", Object)
      ], EdgeEditTool.prototype, "changeBoundsManager", void 0);
      exports.EdgeEditTool = EdgeEditTool = EdgeEditTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeEditTool);
      var EdgeEditListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.cursorFeedback = this.tool.createFeedbackEmitter();
          this.editFeedback = this.tool.createFeedbackEmitter();
        }
        isValidEdge(edge) {
          return edge !== void 0 && edge.id !== (0, dangling_edge_feedback_1.feedbackEdgeId)(edge.root) && (0, sprotty_1.isSelected)(edge);
        }
        setEdgeSelected(edge) {
          this.edge = edge;
          if ((0, sprotty_1.canEditRouting)(edge)) {
            this.editFeedback.add(edge_edit_tool_feedback_1.SwitchRoutingModeAction.create({ elementsToActivate: [this.edge.id] }), edge_edit_tool_feedback_1.SwitchRoutingModeAction.create({ elementsToDeactivate: [this.edge.id] }));
          }
          if ((0, model_1.isReconnectable)(edge)) {
            this.editFeedback.add(edge_edit_tool_feedback_1.ShowEdgeReconnectHandlesFeedbackAction.create(this.edge.id), edge_edit_tool_feedback_1.HideEdgeReconnectHandlesFeedbackAction.create());
          }
          this.editFeedback.submit();
        }
        isEdgeSelected() {
          return this.edge !== void 0 && (0, sprotty_1.isSelected)(this.edge);
        }
        setReconnectHandleSelected(edge, reconnectHandle) {
          if (this.edge && this.edge.target && this.edge.source) {
            this.editFeedback.dispose();
            if ((0, model_1.isSourceRoutingHandle)(edge, reconnectHandle)) {
              this.editFeedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_RECONNECT), (0, css_feedback_1.cursorFeedbackAction)()).add(edge_edit_tool_feedback_1.DrawFeedbackEdgeSourceAction.create({ elementTypeId: this.edge.type, targetId: this.edge.targetId }), dangling_edge_feedback_1.RemoveFeedbackEdgeAction.create()).submit();
              this.reconnectMode = "NEW_SOURCE";
            } else if ((0, model_1.isTargetRoutingHandle)(edge, reconnectHandle)) {
              this.editFeedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_CREATION_TARGET), (0, css_feedback_1.cursorFeedbackAction)()).add(dangling_edge_feedback_1.DrawFeedbackEdgeAction.create({ elementTypeId: this.edge.type, sourceId: this.edge.sourceId }), dangling_edge_feedback_1.RemoveFeedbackEdgeAction.create()).submit();
              this.reconnectMode = "NEW_TARGET";
            }
          }
        }
        isReconnecting() {
          return this.reconnectMode !== void 0;
        }
        isReconnectingNewSource() {
          return this.reconnectMode === "NEW_SOURCE";
        }
        setRoutingHandleSelected(edge, routingHandle) {
          if (this.edge && this.edge.target && this.edge.source) {
            this.routingHandle = routingHandle;
          }
        }
        requiresReconnect(sourceId, targetId) {
          return this.edge !== void 0 && (this.edge.sourceId !== sourceId || this.edge.targetId !== targetId);
        }
        setNewConnectable(connectable) {
          this.newConnectable = connectable;
        }
        isReadyToReconnect() {
          return this.edge && this.isReconnecting() && this.newConnectable !== void 0;
        }
        isReadyToReroute() {
          return this.routingHandle !== void 0;
        }
        mouseDown(target, event) {
          const result = super.mouseDown(target, event);
          if (event.button === 0) {
            const reconnectHandle = (0, sprotty_1.findParentByFeature)(target, model_1.isReconnectHandle);
            const routingHandle = !reconnectHandle ? (0, sprotty_1.findParentByFeature)(target, gmodel_util_1.isRoutingHandle) : void 0;
            const edge = (0, sprotty_1.findParentByFeature)(target, gmodel_util_1.isRoutable);
            if (this.isEdgeSelected() && edge && reconnectHandle) {
              this.setReconnectHandleSelected(edge, reconnectHandle);
            } else if (this.isEdgeSelected() && edge && routingHandle) {
              this.setRoutingHandleSelected(edge, routingHandle);
            } else if (this.isValidEdge(edge)) {
              this.dispose();
              this.tool.registerFeedbackListeners();
              this.setEdgeSelected(edge);
            }
          } else if (event.button === 2) {
            this.dispose();
          }
          return result;
        }
        draggingMouseMove(target, event) {
          this.setNewConnectable(void 0);
          return super.draggingMouseMove(target, event);
        }
        mouseUp(target, event) {
          const result = super.mouseUp(target, event);
          if (!this.isReadyToReconnect() && !this.isReadyToReroute()) {
            return result;
          }
          if (this.edge && this.newConnectable) {
            const sourceElementId = this.isReconnectingNewSource() ? this.newConnectable.id : this.edge.sourceId;
            const targetElementId = this.isReconnectingNewSource() ? this.edge.targetId : this.newConnectable.id;
            if (this.requiresReconnect(sourceElementId, targetElementId)) {
              result.push(sprotty_1.ReconnectEdgeOperation.create({ edgeElementId: this.edge.id, sourceElementId, targetElementId }));
            }
            this.dispose();
          } else if (this.edge && this.routingHandle) {
            const latestEdge = target.index.getById(this.edge.id);
            if (latestEdge && (0, gmodel_util_1.isRoutable)(latestEdge)) {
              const newRoutingPoints = (0, gmodel_util_1.calcElementAndRoutingPoints)(latestEdge, this.tool.edgeRouterRegistry);
              result.push(sprotty_1.ChangeRoutingPointsOperation.create([newRoutingPoints]));
              this.routingHandle = void 0;
            }
          }
          return result;
        }
        mouseOver(target, _event) {
          if (this.edge && this.isReconnecting()) {
            const currentTarget = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isConnectable);
            if (!this.newConnectable || currentTarget !== this.newConnectable) {
              this.setNewConnectable(currentTarget);
              if (currentTarget) {
                if (this.reconnectMode === "NEW_SOURCE" && currentTarget.canConnect(this.edge, "source") || this.reconnectMode === "NEW_TARGET" && currentTarget.canConnect(this.edge, "target")) {
                  this.cursorFeedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.EDGE_RECONNECT), (0, css_feedback_1.cursorFeedbackAction)()).submit();
                  return [];
                }
              }
              this.cursorFeedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED), (0, css_feedback_1.cursorFeedbackAction)()).submit();
            }
          }
          return [];
        }
        selectionChanged(root, selectedElements) {
          if (this.edge) {
            if (selectedElements.indexOf(this.edge.id) > -1) {
              return;
            }
            if (this.isReconnecting()) {
              return;
            }
            for (const elementId of selectedElements.reverse()) {
              const element = root.index.getById(elementId);
              if (element) {
                const edge = (0, sprotty_1.findParentByFeature)(element, gmodel_util_1.isRoutable);
                if (this.isValidEdge(edge)) {
                  this.setEdgeSelected(edge);
                  return;
                }
              }
            }
            this.dispose();
          }
        }
        dispose() {
          this.edge = void 0;
          this.reconnectMode = void 0;
          this.newConnectable = void 0;
          this.routingHandle = void 0;
          this.cursorFeedback.dispose();
          this.editFeedback.dispose();
          this.tool.deregisterFeedbackListeners();
          super.dispose();
        }
      };
      exports.EdgeEditListener = EdgeEditListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-module.js
  var require_edge_edit_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/edge-edit/edge-edit-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.edgeEditToolModule = void 0;
      var sprotty_1 = require_lib4();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var edge_edit_tool_1 = require_edge_edit_tool();
      var edge_edit_tool_feedback_1 = require_edge_edit_tool_feedback();
      exports.edgeEditToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, edge_edit_tool_1.EdgeEditTool);
        (0, sprotty_1.configureCommand)(context, edge_edit_tool_feedback_1.ShowEdgeReconnectHandlesFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, edge_edit_tool_feedback_1.HideEdgeReconnectHandlesFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, edge_edit_tool_feedback_1.DrawFeedbackEdgeSourceCommand);
        (0, sprotty_1.configureCommand)(context, edge_edit_tool_feedback_1.SwitchRoutingModeCommand);
        (0, dangling_edge_feedback_1.configureDanglingFeedbackEdge)(context);
      }, { featureId: Symbol("edgeEditTool") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-tool.js
  var require_marquee_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var MarqueeTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarqueeKeyListener = exports.MarqueeTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var selection_service_1 = require_selection_service();
      var tool_1 = require_tool();
      var base_tools_1 = require_base_tools();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var MarqueeTool = MarqueeTool_1 = class MarqueeTool extends base_tools_1.BaseEditTool {
        get id() {
          return MarqueeTool_1.ID;
        }
        enable() {
          if (!this.marqueeKeyListener) {
            this.marqueeKeyListener = new MarqueeKeyListener(this.selectionService);
          }
          this.toDisposeOnDisable.push(this.keyTool.registerListener(this.marqueeKeyListener));
        }
      };
      exports.MarqueeTool = MarqueeTool;
      MarqueeTool.ID = "glsp.marquee-tool";
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], MarqueeTool.prototype, "selectionService", void 0);
      exports.MarqueeTool = MarqueeTool = MarqueeTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], MarqueeTool);
      var MarqueeKeyListener = class MarqueeKeyListener extends sprotty_1.KeyListener {
        constructor(selectionService) {
          super();
          this.selectionService = selectionService;
        }
        keyDown(_element, event) {
          if (event.shiftKey && !this.selectionService.hasSelectedElements()) {
            return [tool_1.EnableToolsAction.create([marquee_mouse_tool_1.MarqueeMouseTool.ID])];
          }
          return [];
        }
      };
      exports.MarqueeKeyListener = MarqueeKeyListener;
      exports.MarqueeKeyListener = MarqueeKeyListener = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [selection_service_1.SelectionService])
      ], MarqueeKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/model.js
  var require_model24 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarqueeNode = void 0;
      var sprotty_1 = require_lib4();
      var MarqueeNode = class extends sprotty_1.RectangularNode {
      };
      exports.MarqueeNode = MarqueeNode;
      MarqueeNode.DEFAULT_FEATURES = [sprotty_1.boundsFeature];
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/view.js
  var require_view4 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarqueeView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var MarqueeView = class MarqueeView extends sprotty_1.RectangularNodeView {
        render(node, context) {
          const graph = (0, sprotty_1.svg)(
            "g",
            null,
            (0, sprotty_1.svg)("rect", { "class-sprotty-node": true, "class-marquee": true, x: node.startPoint.x - node.endPoint.x <= 0 ? node.startPoint.x : node.endPoint.x, y: node.startPoint.y - node.endPoint.y <= 0 ? node.startPoint.y : node.endPoint.y, rx: 0, ry: 0, width: Math.abs(node.startPoint.x - node.endPoint.x), height: Math.abs(node.startPoint.y - node.endPoint.y) })
          );
          return graph;
        }
      };
      exports.MarqueeView = MarqueeView;
      exports.MarqueeView = MarqueeView = __decorate([
        (0, inversify_1.injectable)()
      ], MarqueeView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-selection-module.js
  var require_marquee_selection_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/marquee-selection/marquee-selection-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.marqueeSelectionToolModule = void 0;
      var sprotty_1 = require_lib4();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var marquee_tool_1 = require_marquee_tool();
      var marquee_tool_feedback_1 = require_marquee_tool_feedback();
      var model_1 = require_model24();
      var view_1 = require_view4();
      var marquee_behavior_1 = require_marquee_behavior();
      exports.marqueeSelectionToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        context.bind(marquee_behavior_1.MarqueeUtil).toSelf().inSingletonScope();
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, marquee_tool_1.MarqueeTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITool, marquee_mouse_tool_1.MarqueeMouseTool);
        (0, sprotty_1.configureCommand)(context, marquee_tool_feedback_1.DrawMarqueeCommand);
        (0, sprotty_1.configureCommand)(context, marquee_tool_feedback_1.RemoveMarqueeCommand);
        (0, sprotty_1.configureModelElement)(context, marquee_tool_feedback_1.MARQUEE, model_1.MarqueeNode, view_1.MarqueeView);
      }, { featureId: Symbol("marqueeSelectionTool") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/container-manager.js
  var require_container_manager = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/container-manager.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContainerManager = exports.DEFAULT_INSERT_OPTIONS = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var css_feedback_1 = require_css_feedback();
      var model_1 = require_model21();
      exports.DEFAULT_INSERT_OPTIONS = {
        validateLocationInContainer: false
      };
      var ContainerManager = class ContainerManager {
        insert(proxy, location2, elementTypeId, opts) {
          var _a4;
          const options = { ...exports.DEFAULT_INSERT_OPTIONS, ...opts };
          const container = this.findContainer(location2, proxy, opts === null || opts === void 0 ? void 0 : opts.evt);
          let valid = this.isCreationAllowed(container, elementTypeId, opts);
          if (valid && (!container || options.validateLocationInContainer)) {
            valid = (_a4 = opts === null || opts === void 0 ? void 0 : opts.validLocationOverwrite) !== null && _a4 !== void 0 ? _a4 : this.changeBoundsManager.hasValidPosition(proxy, location2);
          }
          return { elementTypeId, container, location: location2, valid, options };
        }
        isCreationAllowed(container, elementTypeId, opts) {
          return !container || container.isContainableElement(elementTypeId);
        }
        findContainer(location2, ctx, evt) {
          return [ctx.root, ...(0, sprotty_1.findChildrenAtPosition)(ctx.root, location2)].reverse().find((element) => {
            var _a4;
            return (0, model_1.isContainable)(element) && !((_a4 = element.cssClasses) === null || _a4 === void 0 ? void 0 : _a4.includes(css_feedback_1.CSS_GHOST_ELEMENT));
          });
        }
        addInsertFeedback(feedback, trackedInsert, ctx, event) {
          if (!trackedInsert.valid) {
            feedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED), (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
          } else {
            feedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.NODE_CREATION), (0, css_feedback_1.cursorFeedbackAction)());
          }
          return feedback;
        }
      };
      exports.ContainerManager = ContainerManager;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IChangeBoundsManager),
        __metadata("design:type", Object)
      ], ContainerManager.prototype, "changeBoundsManager", void 0);
      exports.ContainerManager = ContainerManager = __decorate([
        (0, inversify_1.injectable)()
      ], ContainerManager);
    }
  });

  // node_modules/@eclipse-glsp/client/css/ghost-element.css
  var require_ghost_element = __commonJS({
    "node_modules/@eclipse-glsp/client/css/ghost-element.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/element-template/mouse-tracking-element-position-listener.js
  var require_mouse_tracking_element_position_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/element-template/mouse-tracking-element-position-listener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MouseTrackingElementPositionListener = void 0;
      var sprotty_1 = require_lib4();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var viewpoint_util_1 = require_viewpoint_util();
      var change_bounds_tool_feedback_1 = require_change_bounds_tool_feedback();
      var MouseTrackingElementPositionListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(elementId, tool, cursorPosition = "top-left", editorContext) {
          super();
          this.elementId = elementId;
          this.tool = tool;
          this.cursorPosition = cursorPosition;
          this.editorContext = editorContext;
          this.toDispose = new sprotty_1.DisposableCollection();
          this.tracker = this.tool.changeBoundsManager.createTracker();
          this.moveGhostFeedback = this.tool.createFeedbackEmitter();
          this.toDispose.push(this.moveGhostFeedback);
          const modelRootChangedListener = editorContext === null || editorContext === void 0 ? void 0 : editorContext.onModelRootChanged((newRoot) => this.modelRootChanged(newRoot));
          if (modelRootChangedListener) {
            this.toDispose.push(modelRootChangedListener);
          }
        }
        getTrackedElement(target, event) {
          const element = target.root.index.getById(this.elementId);
          return !element || !(0, sprotty_1.isMoveable)(element) ? void 0 : element;
        }
        mouseMove(ctx, event) {
          super.mouseMove(ctx, event);
          const element = this.getTrackedElement(ctx, event);
          if (!element) {
            return [];
          }
          const isInitializing = !this.tracker.isTracking();
          if (isInitializing) {
            this.initialize(element, ctx, event);
          }
          const move = this.tracker.moveElements([element], { snap: event, restrict: event, skipStatic: !isInitializing });
          const elementMove = move.elementMoves[0];
          if (!elementMove) {
            return [];
          }
          this.moveGhostFeedback.add(sprotty_1.MoveAction.create([{ elementId: this.elementId, toPosition: elementMove.toPosition }], { animate: false }), change_bounds_tool_feedback_1.MoveFinishedEventAction.create());
          this.addMoveFeedback(move, ctx, event);
          this.moveGhostFeedback.submit();
          this.tracker.updateTrackingPosition(elementMove.moveVector);
          return [];
        }
        initialize(element, target, event) {
          this.tracker.startTracking();
          element.position = this.initializeElementPosition(element, target, event);
        }
        initializeElementPosition(element, target, event) {
          const mousePosition = (0, viewpoint_util_1.getAbsolutePosition)(target, event);
          return this.cursorPosition === "middle" && (0, sprotty_1.isBoundsAware)(element) ? sprotty_1.Point.subtract(mousePosition, sprotty_1.Dimension.center(element.bounds)) : mousePosition;
        }
        addMoveFeedback(move, ctx, event) {
          this.moveGhostFeedback.add(css_feedback_1.ModifyCSSFeedbackAction.create({ elements: [this.elementId], remove: [css_feedback_1.CSS_HIDDEN] }));
          this.tool.changeBoundsManager.addMoveFeedback(this.moveGhostFeedback, move, ctx, event);
        }
        modelRootChanged(root) {
          this.tracker.stopTracking();
        }
        dispose() {
          this.toDispose.dispose();
          super.dispose();
        }
      };
      exports.MouseTrackingElementPositionListener = MouseTrackingElementPositionListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-tool.js
  var require_node_creation_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var NodeCreationTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NodeCreationToolMouseListener = exports.NodeInsertTrackingListener = exports.NodeCreationTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      require_ghost_element();
      var drag_aware_mouse_listener_1 = require_drag_aware_mouse_listener();
      var css_feedback_1 = require_css_feedback();
      var tool_1 = require_tool();
      var add_template_element_1 = require_add_template_element();
      var mouse_tracking_element_position_listener_1 = require_mouse_tracking_element_position_listener();
      var remove_template_element_1 = require_remove_template_element();
      var base_tools_1 = require_base_tools();
      var insert_indicator_1 = require_insert_indicator();
      var NodeCreationTool = NodeCreationTool_1 = class NodeCreationTool extends base_tools_1.BaseCreationTool {
        constructor() {
          super(...arguments);
          this.isTriggerAction = sprotty_1.TriggerNodeCreationAction.is;
        }
        get id() {
          return NodeCreationTool_1.ID;
        }
        doEnable() {
          var _a4;
          const ghostElement = (_a4 = this.triggerAction.ghostElement) !== null && _a4 !== void 0 ? _a4 : { template: this.modelFactory.createSchema(this.createInsertIndicator()) };
          this.toDisposeOnDisable.push(this.createGhostElementTracker(ghostElement, "middle"));
          this.toDisposeOnDisable.push(this.createNodeCreationListener(ghostElement));
          this.toDisposeOnDisable.push(this.createNodeCreationCursorFeedback().submit());
        }
        createInsertIndicator() {
          return new insert_indicator_1.InsertIndicator();
        }
        createGhostElementTracker(ghostElement, position) {
          const trackingListener = new NodeInsertTrackingListener((0, add_template_element_1.getTemplateElementId)(ghostElement.template), this.triggerAction.elementTypeId, this, position, this.editorContext);
          return new sprotty_1.DisposableCollection(trackingListener, this.mouseTool.registerListener(trackingListener));
        }
        createNodeCreationListener(ghostElement) {
          const toolListener = new NodeCreationToolMouseListener(this.triggerAction, this, ghostElement);
          return new sprotty_1.DisposableCollection(toolListener, this.mouseTool.registerListener(toolListener));
        }
        createNodeCreationCursorFeedback() {
          return this.createFeedbackEmitter().add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.NODE_CREATION), (0, css_feedback_1.cursorFeedbackAction)());
        }
      };
      exports.NodeCreationTool = NodeCreationTool;
      NodeCreationTool.ID = "tool_create_node";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IChangeBoundsManager),
        __metadata("design:type", Object)
      ], NodeCreationTool.prototype, "changeBoundsManager", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IContainerManager),
        __metadata("design:type", Object)
      ], NodeCreationTool.prototype, "containerManager", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IModelFactory),
        __metadata("design:type", Object)
      ], NodeCreationTool.prototype, "modelFactory", void 0);
      exports.NodeCreationTool = NodeCreationTool = NodeCreationTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], NodeCreationTool);
      var NodeInsertTrackingListener = class extends mouse_tracking_element_position_listener_1.MouseTrackingElementPositionListener {
        constructor(elementId, elementTypeId, tool, cursorPosition = "top-left", editorContext) {
          super(elementId, tool, cursorPosition, editorContext);
          this.elementTypeId = elementTypeId;
          this.tool = tool;
        }
        addMoveFeedback(move, ctx, event) {
          super.addMoveFeedback(move, ctx, event);
          const element = move.elementMoves[0].element;
          const location2 = move.elementMoves[0].toPosition;
          const insert = this.tool.containerManager.insert(element, location2, this.elementTypeId, { evt: event });
          this.tool.containerManager.addInsertFeedback(this.moveGhostFeedback, insert, ctx, event);
        }
      };
      exports.NodeInsertTrackingListener = NodeInsertTrackingListener;
      var NodeCreationToolMouseListener = class extends drag_aware_mouse_listener_1.DragAwareMouseListener {
        constructor(triggerAction, tool, ghostElement) {
          super();
          this.triggerAction = triggerAction;
          this.tool = tool;
          this.ghostElement = ghostElement;
          this.cursorFeedback = tool.createFeedbackEmitter();
          this.ghostElementFeedback = tool.createFeedbackEmitter();
          this.ghostElementId = (0, add_template_element_1.getTemplateElementId)(ghostElement.template);
          this.createGhostElement(ghostElement);
        }
        get elementTypeId() {
          return this.triggerAction.elementTypeId;
        }
        nonDraggingMouseUp(ctx, event) {
          const result = [];
          const insert = this.getTrackedInsert(ctx, event);
          if (insert.valid) {
            result.push(this.getCreateOperation(ctx, event, insert));
          }
          if (this.isContinuousMode(ctx, event)) {
            this.disposeAllButGhostElement();
            return result;
          }
          if (insert.valid) {
            this.ghostElementFeedback.discard();
          } else {
            this.dispose();
          }
          result.push(tool_1.EnableDefaultToolsAction.create());
          return result;
        }
        /**
         * Determines wether the tool should run in continuous mode (also called stamp mode) or not.
         * If continuous mode is enabled, the tool will stay after a successful creation.
         * The user can then create more elements of the same type without having to re-trigger the tool.
         * By default, continuous mode is enabled if the user holds the CTRL key.
         * @param ctx the current model context
         * @param event
         */
        isContinuousMode(ctx, event) {
          return (0, sprotty_1.isCtrlOrCmd)(event);
        }
        getCreateOperation(ctx, event, insert) {
          var _a4;
          return sprotty_1.CreateNodeOperation.create(this.elementTypeId, {
            location: insert.location,
            containerId: (_a4 = insert.container) === null || _a4 === void 0 ? void 0 : _a4.id,
            args: this.getCreateNodeOperationArgs(insert, ctx, event)
          });
        }
        getCreateNodeOperationArgs(insert, ctx, event) {
          let args = { ...this.triggerAction.args };
          const ghostElement = this.getGhostElement(ctx, event);
          if (ghostElement) {
            const ghostDimensions = (0, sprotty_1.isBoundsAware)(ghostElement) ? sprotty_1.Bounds.dimension(ghostElement.bounds) : sprotty_1.Dimension.ZERO;
            args = {
              ...args,
              "ghost-x": ghostElement.position.x,
              "ghost-y": ghostElement.position.y,
              "ghost-width": ghostDimensions.width,
              "ghost-height": ghostDimensions.height
            };
          }
          return args;
        }
        createGhostElement(ghostElement) {
          const templates = [ghostElement.template];
          this.ghostElementFeedback.add(add_template_element_1.AddTemplateElementsAction.create({ templates, addClasses: [css_feedback_1.CSS_HIDDEN, css_feedback_1.CSS_GHOST_ELEMENT] }), remove_template_element_1.RemoveTemplateElementsAction.create({ templates }));
          this.ghostElementFeedback.submit();
          return (0, add_template_element_1.getTemplateElementId)(ghostElement.template);
        }
        getGhostElement(ctx, event) {
          const ghostElement = ctx.index.getById(this.ghostElementId);
          return ghostElement && (0, sprotty_1.isMoveable)(ghostElement) ? ghostElement : void 0;
        }
        getTrackedInsert(ctx, event) {
          const ghostElement = this.getGhostElement(ctx, event);
          if (!ghostElement) {
            return { elementTypeId: this.elementTypeId, location: sprotty_1.Point.ORIGIN, valid: false, options: { evt: event } };
          }
          return this.tool.containerManager.insert(ghostElement, ghostElement.position, this.elementTypeId, { evt: event });
        }
        disposeAllButGhostElement() {
          super.dispose();
        }
        dispose() {
          this.ghostElementFeedback.dispose();
          this.disposeAllButGhostElement();
        }
      };
      exports.NodeCreationToolMouseListener = NodeCreationToolMouseListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/argument-utils.js
  var require_argument_utils = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/argument-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CornerRadius = exports.EdgePadding = exports.GArgument = void 0;
      var args_feature_1 = require_args_feature();
      var GArgument;
      (function(GArgument2) {
        function asNumber(argValue) {
          return typeof argValue === "number" ? argValue : void 0;
        }
        GArgument2.asNumber = asNumber;
        function asNumbers(argValues) {
          return argValues.map(asNumber);
        }
        GArgument2.asNumbers = asNumbers;
        function asString(argValue) {
          return typeof argValue === "string" ? argValue : void 0;
        }
        GArgument2.asString = asString;
        function asStrings(argValues) {
          return argValues.map(asString);
        }
        GArgument2.asStrings = asStrings;
        function asBoolean(argValue) {
          return typeof argValue === "boolean" ? argValue : void 0;
        }
        GArgument2.asBoolean = asBoolean;
        function asBooleans(argValues) {
          return argValues.map(asBoolean);
        }
        GArgument2.asBooleans = asBooleans;
        function getArgument(element, key) {
          return (0, args_feature_1.hasArgs)(element) ? element.args[key] : void 0;
        }
        GArgument2.getArgument = getArgument;
        function getNumber(element, key) {
          return (0, args_feature_1.hasArgs)(element) ? asNumber(element.args[key]) : void 0;
        }
        GArgument2.getNumber = getNumber;
        function getString(element, key) {
          return (0, args_feature_1.hasArgs)(element) ? asString(element.args[key]) : void 0;
        }
        GArgument2.getString = getString;
        function getBoolean(element, key) {
          return (0, args_feature_1.hasArgs)(element) ? asBoolean(element.args[key]) : void 0;
        }
        GArgument2.getBoolean = getBoolean;
        function getArguments(element, ...keys) {
          if (!(0, args_feature_1.hasArgs)(element)) {
            return void 0;
          }
          const values = [];
          for (const key of keys) {
            const value = element.args[key];
            if (value) {
              values.push(value);
            }
          }
          return values;
        }
        GArgument2.getArguments = getArguments;
        function getNumbers(element, ...keys) {
          const values = getArguments(element, ...keys);
          return values ? asNumbers(values) : void 0;
        }
        GArgument2.getNumbers = getNumbers;
        function getStrings(element, ...keys) {
          const values = getArguments(element, ...keys);
          return values ? asStrings(values) : void 0;
        }
        GArgument2.getStrings = getStrings;
        function getBooleans(element, ...keys) {
          const values = getArguments(element, ...keys);
          return values ? asBooleans(values) : void 0;
        }
        GArgument2.getBooleans = getBooleans;
        function hasNValues(values, length) {
          return values.length === length && values.filter((e2) => e2 === void 0).length === 0;
        }
        GArgument2.hasNValues = hasNValues;
      })(GArgument || (exports.GArgument = GArgument = {}));
      var EdgePadding;
      (function(EdgePadding2) {
        const KEY = "edgePadding";
        function from(element) {
          return GArgument.getNumber(element, KEY);
        }
        EdgePadding2.from = from;
      })(EdgePadding || (exports.EdgePadding = EdgePadding = {}));
      var CornerRadius = class _CornerRadius {
        constructor(topLeft = 0, topRight = topLeft, bottomRight = topLeft, bottomLeft = topRight) {
          this.topLeft = topLeft;
          this.topRight = topRight;
          this.bottomRight = bottomRight;
          this.bottomLeft = bottomLeft;
        }
        static from(element) {
          const radius = GArgument.getNumbers(element, this.KEY_RADIUS_TOP_LEFT, this.KEY_RADIUS_TOP_RIGHT, this.KEY_RADIUS_BOTTOM_RIGHT, this.KEY_RADIUS_BOTTOM_LEFT);
          if (radius === void 0 || radius[0] === void 0) {
            return void 0;
          }
          return GArgument.hasNValues(radius, 4) ? new _CornerRadius(radius[0], radius[1], radius[2], radius[3]) : new _CornerRadius(radius[0]);
        }
      };
      exports.CornerRadius = CornerRadius;
      CornerRadius.NO_RADIUS = new CornerRadius(0);
      CornerRadius.KEY_RADIUS_TOP_LEFT = "radiusTopLeft";
      CornerRadius.KEY_RADIUS_TOP_RIGHT = "radiusTopRight";
      CornerRadius.KEY_RADIUS_BOTTOM_RIGHT = "radiusBottomRight";
      CornerRadius.KEY_RADIUS_BOTTOM_LEFT = "radiusBottomLeft";
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-views.js
  var require_node_creation_views = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InsertIndicatorView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var argument_utils_1 = require_argument_utils();
      var grid_1 = require_grid();
      var insert_indicator_1 = require_insert_indicator();
      var InsertIndicatorView = class InsertIndicatorView {
        render(model, context) {
          if (context.targetKind === "hidden") {
            return void 0;
          }
          const size = this.getSize(model);
          const node = (0, sprotty_1.svg)(
            "g",
            null,
            (0, sprotty_1.svg)("polyline", { "class-sprotty-node": true, "class-insert-indicator": true, points: `0,${-size / 2} 0,${size / 2}` }),
            (0, sprotty_1.svg)("polyline", { "class-sprotty-node": true, "class-insert-indicator": true, points: `${-size / 2},0 ${size / 2},0` })
          );
          model.cssClasses.forEach((cl) => (0, sprotty_1.setClass)(node, cl, true));
          return node;
        }
        getSize(model) {
          var _a4, _b2, _c;
          return (_c = (_a4 = argument_utils_1.GArgument.getNumber(model, insert_indicator_1.ARG_LENGTH)) !== null && _a4 !== void 0 ? _a4 : (_b2 = this.grid) === null || _b2 === void 0 ? void 0 : _b2.x) !== null && _c !== void 0 ? _c : 10;
        }
      };
      exports.InsertIndicatorView = InsertIndicatorView;
      __decorate([
        (0, inversify_1.optional)(),
        (0, inversify_1.inject)(sprotty_1.TYPES.Grid),
        __metadata("design:type", Object)
      ], InsertIndicatorView.prototype, "grid", void 0);
      exports.InsertIndicatorView = InsertIndicatorView = __decorate([
        (0, inversify_1.injectable)()
      ], InsertIndicatorView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-module.js
  var require_node_creation_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/node-creation/node-creation-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.nodeCreationToolModule = void 0;
      var sprotty_1 = require_lib4();
      var element_template_module_1 = require_element_template_module();
      var container_manager_1 = require_container_manager();
      var insert_indicator_1 = require_insert_indicator();
      var node_creation_tool_1 = require_node_creation_tool();
      var node_creation_views_1 = require_node_creation_views();
      exports.nodeCreationToolModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IContainerManager, container_manager_1.ContainerManager);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ITool, node_creation_tool_1.NodeCreationTool);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.TriggerNodeCreationAction.KIND, node_creation_tool_1.NodeCreationTool);
        (0, sprotty_1.configureModelElement)(context, insert_indicator_1.InsertIndicator.TYPE, insert_indicator_1.InsertIndicator, node_creation_views_1.InsertIndicatorView);
      }, {
        featureId: Symbol("nodeCreationTool"),
        requires: element_template_module_1.elementTemplateModule
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/tools/tool-focus-loss-module.js
  var require_tool_focus_loss_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/tools/tool-focus-loss-module.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toolFocusLossModule = exports.EnableDefaultToolsOnFocusLossHandler = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var focus_state_change_action_1 = require_focus_state_change_action();
      var tool_1 = require_tool();
      var EnableDefaultToolsOnFocusLossHandler = class EnableDefaultToolsOnFocusLossHandler {
        handle(action) {
          if (focus_state_change_action_1.FocusStateChangedAction.is(action) && !action.hasFocus) {
            return tool_1.EnableDefaultToolsAction.create();
          }
        }
      };
      exports.EnableDefaultToolsOnFocusLossHandler = EnableDefaultToolsOnFocusLossHandler;
      exports.EnableDefaultToolsOnFocusLossHandler = EnableDefaultToolsOnFocusLossHandler = __decorate([
        (0, inversify_1.injectable)()
      ], EnableDefaultToolsOnFocusLossHandler);
      exports.toolFocusLossModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, focus_state_change_action_1.FocusStateChangedAction.KIND, EnableDefaultToolsOnFocusLossHandler);
      }, { featureId: Symbol("toolFocusLoss ") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/marker.js
  var require_marker = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/marker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.collectIssueMarkers = exports.MarkerPredicates = void 0;
      var sprotty_1 = require_lib4();
      var issue_marker_1 = require_issue_marker();
      var MarkerPredicates;
      (function(MarkerPredicates2) {
        MarkerPredicates2.ALL = () => true;
        MarkerPredicates2.ERRORS = (marker) => hasIssueWithSeverity(marker, sprotty_1.MarkerKind.ERROR);
        MarkerPredicates2.WARNINGS = (marker) => hasIssueWithSeverity(marker, sprotty_1.MarkerKind.WARNING);
        MarkerPredicates2.INFOS = (marker) => hasIssueWithSeverity(marker, sprotty_1.MarkerKind.INFO);
        function hasIssueWithSeverity(marker, severity) {
          return marker.issues.find((issue) => issue.severity === severity) !== void 0;
        }
        MarkerPredicates2.hasIssueWithSeverity = hasIssueWithSeverity;
      })(MarkerPredicates || (exports.MarkerPredicates = MarkerPredicates = {}));
      function collectIssueMarkers(root) {
        const markers = [];
        for (const child of root.children) {
          if (child instanceof issue_marker_1.GIssueMarker) {
            markers.push(child);
          }
          markers.push(...collectIssueMarkers(child));
        }
        return markers;
      }
      exports.collectIssueMarkers = collectIssueMarkers;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/validation/marker-navigator.js
  var require_marker_navigator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/validation/marker-navigator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MarkerNavigatorKeyListener = exports.MarkerNavigatorContextMenuItemProvider = exports.NavigateToMarkerActionHandler = exports.MarkerNavigator = exports.LeftToRightTopToBottomComparator = exports.GModelElementComparator = exports.NavigateToMarkerAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var selection_service_1 = require_selection_service();
      var gmodel_util_1 = require_gmodel_util();
      var marker_1 = require_marker();
      var NavigateToMarkerAction;
      (function(NavigateToMarkerAction2) {
        NavigateToMarkerAction2.KIND = "navigateToMarker";
        function is(object) {
          return sprotty_1.Action.hasKind(object, NavigateToMarkerAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "direction") && (0, sprotty_1.hasArrayProp)(object, "severities");
        }
        NavigateToMarkerAction2.is = is;
        function create(options) {
          return {
            kind: NavigateToMarkerAction2.KIND,
            direction: "next",
            severities: MarkerNavigator.ALL_SEVERITIES,
            ...options
          };
        }
        NavigateToMarkerAction2.create = create;
      })(NavigateToMarkerAction || (exports.NavigateToMarkerAction = NavigateToMarkerAction = {}));
      var GModelElementComparator = class {
        compare(_one, _other) {
          return 0;
        }
      };
      exports.GModelElementComparator = GModelElementComparator;
      var LeftToRightTopToBottomComparator = class LeftToRightTopToBottomComparator {
        compare(one, other) {
          const boundsOne = (0, sprotty_1.findParentByFeature)(one, gmodel_util_1.isSelectableAndBoundsAware);
          const boundsOther = (0, sprotty_1.findParentByFeature)(other, gmodel_util_1.isSelectableAndBoundsAware);
          if (boundsOne && boundsOther) {
            if (boundsOne.bounds.y !== boundsOther.bounds.y) {
              return boundsOne.bounds.y - boundsOther.bounds.y;
            }
            if (boundsOne.bounds.x !== boundsOther.bounds.x) {
              return boundsOne.bounds.x - boundsOther.bounds.x;
            }
          }
          return 0;
        }
      };
      exports.LeftToRightTopToBottomComparator = LeftToRightTopToBottomComparator;
      exports.LeftToRightTopToBottomComparator = LeftToRightTopToBottomComparator = __decorate([
        (0, inversify_1.injectable)()
      ], LeftToRightTopToBottomComparator);
      var MarkerNavigator = class MarkerNavigator {
        next(root, current, predicate = marker_1.MarkerPredicates.ALL) {
          const markers = this.getMarkers(root, predicate);
          if (current === void 0) {
            return markers.length > 0 ? markers[0] : void 0;
          }
          return markers[this.getNextIndex(current, markers) % markers.length];
        }
        previous(root, current, predicate = marker_1.MarkerPredicates.ALL) {
          const markers = this.getMarkers(root, predicate);
          if (current === void 0) {
            return markers.length > 0 ? markers[0] : void 0;
          }
          return markers[this.getPreviousIndex(current, markers) % markers.length];
        }
        getMarkers(root, predicate) {
          const markers = (0, marker_1.collectIssueMarkers)(root);
          return markers.filter(predicate).sort(this.markerComparator.compare);
        }
        getNextIndex(current, markers) {
          for (let index = 0; index < markers.length; index++) {
            if (this.markerComparator.compare(markers[index], current) > 0) {
              return index;
            }
          }
          return 0;
        }
        getPreviousIndex(current, markers) {
          for (let index = markers.length - 1; index >= 0; index--) {
            if (this.markerComparator.compare(markers[index], current) < 0) {
              return index;
            }
          }
          return markers.length - 1;
        }
      };
      exports.MarkerNavigator = MarkerNavigator;
      MarkerNavigator.ALL_SEVERITIES = ["error", "warning", "info"];
      __decorate([
        (0, inversify_1.inject)(GModelElementComparator),
        __metadata("design:type", GModelElementComparator)
      ], MarkerNavigator.prototype, "markerComparator", void 0);
      exports.MarkerNavigator = MarkerNavigator = __decorate([
        (0, inversify_1.injectable)()
      ], MarkerNavigator);
      var NavigateToMarkerActionHandler = class NavigateToMarkerActionHandler {
        handle(action) {
          const selected = this.getSelectedElements(action);
          const target = this.getTarget(action, selected);
          const selectableTarget = target ? (0, sprotty_1.findParentByFeature)(target, sprotty_1.isSelectable) : void 0;
          if (selectableTarget) {
            const deselectedElementsIDs = selected.map((e2) => e2.id).filter((id) => id !== selectableTarget.id);
            this.actionDispatcher.dispatch(sprotty_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs }));
            this.actionDispatcher.dispatch(sprotty_1.CenterAction.create([selectableTarget.id]));
          }
        }
        getSelectedElements(action) {
          if (action.selectedElementIds && action.selectedElementIds.length > 0) {
            return (0, gmodel_util_1.getElements)(this.selectionService.getModelRoot().index, action.selectedElementIds, sprotty_1.isSelectable);
          }
          return this.selectionService.getSelectedElements();
        }
        getTarget(action, selected) {
          const root = this.selectionService.getModelRoot();
          const target = selected.sort(this.markerComparator.compare).find(sprotty_1.isBoundsAware);
          if (action.direction === "previous") {
            return this.markerNavigator.previous(root, target, (marker) => this.matchesSeverities(action, marker));
          } else {
            return this.markerNavigator.next(root, target, (marker) => this.matchesSeverities(action, marker));
          }
        }
        matchesSeverities(action, marker) {
          return marker.issues.find((issue) => action.severities.includes(issue.severity)) !== void 0;
        }
      };
      exports.NavigateToMarkerActionHandler = NavigateToMarkerActionHandler;
      __decorate([
        (0, inversify_1.inject)(GModelElementComparator),
        __metadata("design:type", GModelElementComparator)
      ], NavigateToMarkerActionHandler.prototype, "markerComparator", void 0);
      __decorate([
        (0, inversify_1.inject)(MarkerNavigator),
        __metadata("design:type", MarkerNavigator)
      ], NavigateToMarkerActionHandler.prototype, "markerNavigator", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], NavigateToMarkerActionHandler.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], NavigateToMarkerActionHandler.prototype, "actionDispatcher", void 0);
      exports.NavigateToMarkerActionHandler = NavigateToMarkerActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], NavigateToMarkerActionHandler);
      var MarkerNavigatorContextMenuItemProvider = class MarkerNavigatorContextMenuItemProvider {
        getItems(root, lastMousePosition) {
          const selectedElementIds = Array.from(this.selectionService.getSelectedElementIDs());
          const hasMarkers = (0, marker_1.collectIssueMarkers)(root).length > 0;
          return Promise.resolve([
            {
              id: "navigate",
              label: "Go to",
              group: "navigate",
              actions: [],
              children: [
                {
                  id: "next-marker",
                  label: "Next marker",
                  group: "marker",
                  actions: [NavigateToMarkerAction.create({ direction: "next", selectedElementIds })],
                  isEnabled: () => hasMarkers
                },
                {
                  id: "previous-marker",
                  label: "Previous marker",
                  group: "marker",
                  actions: [NavigateToMarkerAction.create({ direction: "previous", selectedElementIds })],
                  isEnabled: () => hasMarkers
                }
              ]
            }
          ]);
        }
      };
      exports.MarkerNavigatorContextMenuItemProvider = MarkerNavigatorContextMenuItemProvider;
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], MarkerNavigatorContextMenuItemProvider.prototype, "selectionService", void 0);
      exports.MarkerNavigatorContextMenuItemProvider = MarkerNavigatorContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], MarkerNavigatorContextMenuItemProvider);
      var MarkerNavigatorKeyListener = class MarkerNavigatorKeyListener extends sprotty_1.KeyListener {
        keyDown(_element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Period", "ctrl")) {
            return [NavigateToMarkerAction.create({ direction: "next" })];
          } else if ((0, sprotty_1.matchesKeystroke)(event, "Comma", "ctrl")) {
            return [NavigateToMarkerAction.create({ direction: "previous" })];
          }
          return [];
        }
      };
      exports.MarkerNavigatorKeyListener = MarkerNavigatorKeyListener;
      exports.MarkerNavigatorKeyListener = MarkerNavigatorKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], MarkerNavigatorKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/validation/validate.js
  var require_validate2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/validation/validate.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteMarkersCommand = exports.ApplyMarkersCommand = exports.ApplyMarkersAction = exports.SetMarkersActionHandler = exports.ExternalMarkerManager = exports.ValidationFeedbackEmitter = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var issue_marker_1 = require_issue_marker();
      var ValidationFeedbackEmitter = class ValidationFeedbackEmitter {
        constructor() {
          this.registeredFeedbackByReason = /* @__PURE__ */ new Map();
        }
        /**
         * Register the action that should be emitted for visualizing validation feedback.
         * @param action the action that should be emitted when the model is updated and that will visualize the model validation feedback.
         * @param reason the reason for this validation feedback.
         */
        registerValidationFeedbackAction(action, reason = "") {
          var _a4, _b2;
          const emitter = (_b2 = (_a4 = this.registeredFeedbackByReason.get(reason)) === null || _a4 === void 0 ? void 0 : _a4.dispose()) !== null && _b2 !== void 0 ? _b2 : this.feedbackActionDispatcher.createEmitter();
          emitter.add(action, () => sprotty_1.DeleteMarkersAction.create(action.markers)).submit();
          this.registeredFeedbackByReason.set(reason, emitter);
        }
      };
      exports.ValidationFeedbackEmitter = ValidationFeedbackEmitter;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], ValidationFeedbackEmitter.prototype, "feedbackActionDispatcher", void 0);
      exports.ValidationFeedbackEmitter = ValidationFeedbackEmitter = __decorate([
        (0, inversify_1.injectable)()
      ], ValidationFeedbackEmitter);
      var ExternalMarkerManager = class ExternalMarkerManager {
        connect(actionDispatcher) {
          this.actionDispatcher = actionDispatcher;
        }
        removeMarkers(markers) {
          if (this.actionDispatcher) {
            this.actionDispatcher.dispatch(sprotty_1.DeleteMarkersAction.create(markers));
          }
        }
      };
      exports.ExternalMarkerManager = ExternalMarkerManager;
      exports.ExternalMarkerManager = ExternalMarkerManager = __decorate([
        (0, inversify_1.injectable)()
      ], ExternalMarkerManager);
      var SetMarkersActionHandler = class SetMarkersActionHandler {
        handle(action) {
          const markers = action.markers;
          this.setMarkers(markers, action.reason);
        }
        async setMarkers(markers, reason) {
          var _a4;
          const uri = this.editorContextService.sourceUri;
          (_a4 = this.externalMarkerManager) === null || _a4 === void 0 ? void 0 : _a4.setMarkers(markers, reason, uri);
          const applyMarkersAction = ApplyMarkersAction.create(markers);
          this.validationFeedbackEmitter.registerValidationFeedbackAction(applyMarkersAction, reason);
        }
      };
      exports.SetMarkersActionHandler = SetMarkersActionHandler;
      __decorate([
        (0, inversify_1.inject)(ValidationFeedbackEmitter),
        __metadata("design:type", ValidationFeedbackEmitter)
      ], SetMarkersActionHandler.prototype, "validationFeedbackEmitter", void 0);
      __decorate([
        (0, inversify_1.inject)(ExternalMarkerManager),
        (0, inversify_1.optional)(),
        __metadata("design:type", ExternalMarkerManager)
      ], SetMarkersActionHandler.prototype, "externalMarkerManager", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], SetMarkersActionHandler.prototype, "editorContextService", void 0);
      exports.SetMarkersActionHandler = SetMarkersActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], SetMarkersActionHandler);
      var ApplyMarkersAction;
      (function(ApplyMarkersAction2) {
        ApplyMarkersAction2.KIND = "applyMarkers";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ApplyMarkersAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "markers");
        }
        ApplyMarkersAction2.is = is;
        function create(markers) {
          return {
            kind: ApplyMarkersAction2.KIND,
            markers
          };
        }
        ApplyMarkersAction2.create = create;
      })(ApplyMarkersAction || (exports.ApplyMarkersAction = ApplyMarkersAction = {}));
      var ApplyMarkersCommand = class ApplyMarkersCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.action.markers.forEach((marker) => {
            const modelElement = context.root.index.getById(marker.elementId);
            if (modelElement instanceof sprotty_1.GParentElement) {
              const issueMarker = (0, issue_marker_1.getOrCreateGIssueMarker)(modelElement);
              const issue = (0, issue_marker_1.createGIssue)(marker);
              issueMarker.issues.push(issue);
              if (issueMarker instanceof issue_marker_1.GIssueMarker) {
                issueMarker.computeProjectionCssClasses();
              }
              addMaxSeverityCSSClassToIssueParent(modelElement, issueMarker);
            }
          });
          return context.root;
        }
      };
      exports.ApplyMarkersCommand = ApplyMarkersCommand;
      ApplyMarkersCommand.KIND = ApplyMarkersAction.KIND;
      exports.ApplyMarkersCommand = ApplyMarkersCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ApplyMarkersCommand);
      function addMaxSeverityCSSClassToIssueParent(modelElement, issueMarker) {
        const maxSeverityCSSClass = (0, issue_marker_1.getSeverity)(issueMarker);
        if (!modelElement.cssClasses) {
          modelElement.cssClasses = [maxSeverityCSSClass];
        } else {
          modelElement.cssClasses = modelElement.cssClasses.filter((value) => !value.match("info|warning|error"));
          modelElement.cssClasses.push(maxSeverityCSSClass);
        }
      }
      function removeCSSClassFromIssueParent(modelElement, issueMarker) {
        const severity = (0, issue_marker_1.getSeverity)(issueMarker);
        (0, gmodel_util_1.removeCssClasses)(modelElement, [severity]);
      }
      var DeleteMarkersCommand = class DeleteMarkersCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.action.markers.forEach((marker) => {
            const modelElement = context.root.index.getById(marker.elementId);
            if (modelElement instanceof sprotty_1.GParentElement) {
              const issueMarker = (0, issue_marker_1.getGIssueMarker)(modelElement);
              if (issueMarker) {
                removeCSSClassFromIssueParent(modelElement, issueMarker);
                for (let index = 0; index < issueMarker.issues.length; ++index) {
                  const issue = issueMarker.issues[index];
                  if (issue.message === marker.description) {
                    issueMarker.issues.splice(index--, 1);
                  }
                }
                if (issueMarker.issues.length === 0) {
                  modelElement.remove(issueMarker);
                } else {
                  addMaxSeverityCSSClassToIssueParent(modelElement, issueMarker);
                }
              }
            }
          });
          return context.root;
        }
      };
      exports.DeleteMarkersCommand = DeleteMarkersCommand;
      DeleteMarkersCommand.KIND = sprotty_1.DeleteMarkersAction.KIND;
      exports.DeleteMarkersCommand = DeleteMarkersCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DeleteMarkersCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/validation/validation-modules.js
  var require_validation_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/validation/validation-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneMarkerNavigatorModule = exports.markerNavigatorModule = exports.validationModule = void 0;
      var sprotty_1 = require_lib4();
      var marker_navigator_1 = require_marker_navigator();
      var validate_1 = require_validate2();
      exports.validationModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetMarkersAction.KIND, validate_1.SetMarkersActionHandler);
        (0, sprotty_1.configureCommand)(context, validate_1.ApplyMarkersCommand);
        (0, sprotty_1.configureCommand)(context, validate_1.DeleteMarkersCommand);
        bind(validate_1.ValidationFeedbackEmitter).toSelf().inSingletonScope();
      }, { featureId: Symbol("validation") });
      exports.markerNavigatorModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        bind(marker_navigator_1.GModelElementComparator).to(marker_navigator_1.LeftToRightTopToBottomComparator).inSingletonScope();
        bind(marker_navigator_1.MarkerNavigator).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)({ bind, isBound }, marker_navigator_1.NavigateToMarkerAction.KIND, marker_navigator_1.NavigateToMarkerActionHandler);
      }, { featureId: Symbol("markerNavigator") });
      exports.standaloneMarkerNavigatorModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IContextMenuProvider, marker_navigator_1.MarkerNavigatorContextMenuItemProvider);
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.KeyListener, marker_navigator_1.MarkerNavigatorKeyListener);
      }, { featureId: Symbol("standaloneMarkerNavigator"), requires: exports.markerNavigatorModule });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/actions.js
  var require_actions2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusDomAction = void 0;
      var sprotty_1 = require_lib4();
      var FocusDomAction;
      (function(FocusDomAction2) {
        FocusDomAction2.KIND = "focusDomAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, FocusDomAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "id");
        }
        FocusDomAction2.is = is;
        function create(id) {
          return { kind: FocusDomAction2.KIND, id };
        }
        FocusDomAction2.create = create;
      })(FocusDomAction || (exports.FocusDomAction = FocusDomAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/glsp-scroll-mouse-listener.js
  var require_glsp_scroll_mouse_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/glsp-scroll-mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPScrollMouseListener = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var tool_1 = require_tool();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var GLSPScrollMouseListener = class GLSPScrollMouseListener extends sprotty_1.ScrollMouseListener {
        constructor() {
          super(...arguments);
          this.preventScrolling = false;
        }
        handle(action) {
          if (action.kind === tool_1.EnableToolsAction.KIND) {
            if (action.toolIds.includes(marquee_mouse_tool_1.MarqueeMouseTool.ID)) {
              this.preventScrolling = true;
            }
          } else if (action.kind === tool_1.EnableDefaultToolsAction.KIND) {
            this.preventScrolling = false;
          }
        }
        mouseDown(target, event) {
          if (this.preventScrolling) {
            return [];
          }
          return super.mouseDown(target, event);
        }
      };
      exports.GLSPScrollMouseListener = GLSPScrollMouseListener;
      exports.GLSPScrollMouseListener = GLSPScrollMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPScrollMouseListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/reposition.js
  var require_reposition = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/reposition.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RepositionCommand = exports.RepositionAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var model_1 = require_model22();
      var gmodel_util_1 = require_gmodel_util();
      var RepositionAction;
      (function(RepositionAction2) {
        RepositionAction2.KIND = "repositionAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, RepositionAction2.KIND) && (0, sprotty_1.hasArrayProp)(object, "elementIDs");
        }
        RepositionAction2.is = is;
        function create(elementIDs) {
          return {
            kind: RepositionAction2.KIND,
            elementIDs
          };
        }
        RepositionAction2.create = create;
      })(RepositionAction || (exports.RepositionAction = RepositionAction = {}));
      var RepositionCommand = class RepositionCommand extends sprotty_1.BoundsAwareViewportCommand {
        constructor(action) {
          super(true);
          this.action = action;
        }
        boundsInViewport(element, bounds, viewport) {
          var _a4;
          if (element instanceof sprotty_1.GChildElement && element.parent !== viewport) {
            return this.boundsInViewport(element.parent, element.parent.localToParent(bounds), viewport);
          } else if (element instanceof model_1.GEdge) {
            const edgeBounds = (0, sprotty_1.getRouteBounds)((_a4 = (0, gmodel_util_1.calcElementAndRoute)(element).newRoutingPoints) !== null && _a4 !== void 0 ? _a4 : []);
            if (element instanceof sprotty_1.GChildElement && element.parent !== viewport) {
              return this.boundsInViewport(element.parent, element.parent.localToParent(edgeBounds), viewport);
            }
            return edgeBounds;
          }
          return bounds;
        }
        getElementIds() {
          return this.action.elementIDs;
        }
        getNewViewport(combinedElementBounds, model) {
          if (!sprotty_1.Dimension.isValid(model.canvasBounds)) {
            return void 0;
          }
          if ((0, sprotty_1.isViewport)(model)) {
            if (this.isFullyVisible(combinedElementBounds, model)) {
              return void 0;
            } else {
              const zoom = model.zoom;
              const centerOfElements = sprotty_1.Bounds.center(combinedElementBounds);
              const canvasCenter = sprotty_1.Dimension.center(model.canvasBounds);
              const scrollCenter = sprotty_1.Point.subtract(centerOfElements, canvasCenter);
              const scroll = sprotty_1.Point.map(scrollCenter, (coordinate) => coordinate / zoom);
              return { scroll, zoom };
            }
          }
          return void 0;
        }
        isFullyVisible(bounds, viewport) {
          return bounds.x >= viewport.scroll.x && bounds.x + bounds.width <= viewport.scroll.x + viewport.canvasBounds.width / viewport.zoom && bounds.y >= viewport.scroll.y && bounds.y + bounds.height <= viewport.scroll.y + viewport.canvasBounds.height / viewport.zoom;
        }
      };
      exports.RepositionCommand = RepositionCommand;
      RepositionCommand.KIND = RepositionAction.KIND;
      exports.RepositionCommand = RepositionCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], RepositionCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-handler.js
  var require_viewport_handler = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZoomHandler = exports.MoveViewportHandler = exports.RestoreViewportHandler = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var focus_tracker_1 = require_focus_tracker();
      var tool_1 = require_tool();
      var gmodel_util_1 = require_gmodel_util();
      var actions_1 = require_actions2();
      var RestoreViewportHandler = class RestoreViewportHandler {
        handle(action) {
          if (tool_1.EnableDefaultToolsAction.is(action) || actions_1.FocusDomAction.is(action) && action.id === "graph") {
            this.focusGraph();
          }
        }
        get graphSelector() {
          const rootId = CSS.escape(this.domHelper.createUniqueDOMElementId(this.editorContext.modelRoot));
          return `#${rootId}`;
        }
        async postRequestModel() {
          await this.waitForElement(this.graphSelector);
          this.focusGraph();
        }
        focusGraph() {
          var _a4;
          if (this.focusTracker.hasFocus) {
            const container = (_a4 = this.focusTracker.diagramElement) === null || _a4 === void 0 ? void 0 : _a4.querySelector(this.graphSelector);
            container === null || container === void 0 ? void 0 : container.focus();
          }
        }
        waitForElement(selector) {
          return new Promise((resolve) => {
            if (document.querySelector(selector)) {
              return resolve(document.querySelector(selector));
            }
            const observer = new MutationObserver((mutations) => {
              if (document.querySelector(selector)) {
                observer.disconnect();
                resolve(document.querySelector(selector));
              }
            });
            observer.observe(document.body, {
              childList: true,
              subtree: true
            });
          });
        }
      };
      exports.RestoreViewportHandler = RestoreViewportHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.DOMHelper),
        __metadata("design:type", sprotty_1.DOMHelper)
      ], RestoreViewportHandler.prototype, "domHelper", void 0);
      __decorate([
        (0, inversify_1.inject)(focus_tracker_1.FocusTracker),
        __metadata("design:type", focus_tracker_1.FocusTracker)
      ], RestoreViewportHandler.prototype, "focusTracker", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], RestoreViewportHandler.prototype, "editorContext", void 0);
      exports.RestoreViewportHandler = RestoreViewportHandler = __decorate([
        (0, inversify_1.injectable)()
      ], RestoreViewportHandler);
      var MoveViewportHandler = class MoveViewportHandler {
        handle(action) {
          return this.handleMoveViewport(action);
        }
        handleMoveViewport(action) {
          const viewport = (0, sprotty_1.findParentByFeature)(this.editorContextService.modelRoot, sprotty_1.isViewport);
          if (!viewport) {
            return;
          }
          const newViewport = {
            scroll: {
              x: viewport.scroll.x + action.moveX,
              y: viewport.scroll.y + action.moveY
            },
            zoom: viewport.zoom
          };
          return sprotty_1.SetViewportAction.create(viewport.id, newViewport, { animate: false });
        }
      };
      exports.MoveViewportHandler = MoveViewportHandler;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], MoveViewportHandler.prototype, "editorContextService", void 0);
      exports.MoveViewportHandler = MoveViewportHandler = __decorate([
        (0, inversify_1.injectable)()
      ], MoveViewportHandler);
      var ZoomHandler = class ZoomHandler {
        handle(action) {
          if (action.elementIds) {
            return this.handleZoomElement(action.elementIds, action.zoomFactor);
          } else {
            return this.handleZoomViewport(action.zoomFactor);
          }
        }
        handleZoomViewport(zoomFactor) {
          const viewport = (0, sprotty_1.findParentByFeature)(this.editorContextService.modelRoot, sprotty_1.isViewport);
          if (!viewport) {
            return;
          }
          const newZoom = viewport.zoom * zoomFactor;
          const newViewport = {
            scroll: viewport.scroll,
            zoom: newZoom
          };
          return sprotty_1.SetViewportAction.create(viewport.id, newViewport, { animate: false });
        }
        handleZoomElement(elementIds, zoomFactor) {
          const viewport = (0, sprotty_1.findParentByFeature)(this.editorContextService.modelRoot, sprotty_1.isViewport);
          if (!viewport) {
            return;
          }
          const elements = (0, gmodel_util_1.getElements)(this.editorContextService.modelRoot.index, elementIds, gmodel_util_1.isSelectableAndBoundsAware);
          const center = this.getCenter(viewport, elements);
          const newZoom = viewport.zoom * zoomFactor;
          const newViewport = {
            scroll: {
              x: center.x - 0.5 * viewport.canvasBounds.width / newZoom,
              y: center.y - 0.5 * viewport.canvasBounds.height / newZoom
            },
            zoom: newZoom
          };
          return sprotty_1.SetViewportAction.create(viewport.id, newViewport, { animate: false });
        }
        getCenter(viewport, selectedElements) {
          const allBounds = selectedElements.map((e2) => this.boundsInViewport(viewport, e2, e2.bounds));
          const mergedBounds = allBounds.reduce((b0, b1) => sprotty_1.Bounds.combine(b0, b1));
          return sprotty_1.Bounds.center(mergedBounds);
        }
        boundsInViewport(viewport, element, bounds) {
          if (element instanceof sprotty_1.GChildElement && element.parent !== viewport) {
            return this.boundsInViewport(viewport, element.parent, element.parent.localToParent(bounds));
          } else {
            return bounds;
          }
        }
      };
      exports.ZoomHandler = ZoomHandler;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], ZoomHandler.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ZoomHandler.prototype, "actionDispatcher", void 0);
      exports.ZoomHandler = ZoomHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ZoomHandler);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/zoom-viewport-action.js
  var require_zoom_viewport_action = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/zoom-viewport-action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZoomAction = exports.ZoomFactors = void 0;
      var sprotty_1 = require_lib4();
      var ZoomFactors;
      (function(ZoomFactors2) {
        ZoomFactors2.DEFAULT = { in: 1.2, out: 0.8 };
      })(ZoomFactors || (exports.ZoomFactors = ZoomFactors = {}));
      var ZoomAction;
      (function(ZoomAction2) {
        ZoomAction2.KIND = "zoom";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ZoomAction2.KIND);
        }
        ZoomAction2.is = is;
        function create(options) {
          return { kind: ZoomAction2.KIND, ...options };
        }
        ZoomAction2.create = create;
      })(ZoomAction || (exports.ZoomAction = ZoomAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-key-listener.js
  var require_viewport_key_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-key-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZoomKeyListener = exports.MoveViewportKeyListener = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var selection_service_1 = require_selection_service();
      var grid_1 = require_grid();
      var zoom_viewport_action_1 = require_zoom_viewport_action();
      var MoveViewportKeyListener = class MoveViewportKeyListener extends sprotty_1.KeyListener {
        constructor() {
          super(...arguments);
          this.grid = grid_1.Grid.DEFAULT;
        }
        keyDown(_element, event) {
          const selectedElementIds = this.selectionService.getSelectedElementIDs();
          const snap = this.changeBoundsManager.usePositionSnap(event);
          const offsetX = snap ? this.grid.x : 1;
          const offsetY = snap ? this.grid.y : 1;
          if (selectedElementIds.length === 0) {
            if (this.matchesMoveUpKeystroke(event)) {
              return [sprotty_1.MoveViewportAction.create({ moveX: 0, moveY: -offsetY })];
            } else if (this.matchesMoveDownKeystroke(event)) {
              return [sprotty_1.MoveViewportAction.create({ moveX: 0, moveY: offsetY })];
            } else if (this.matchesMoveRightKeystroke(event)) {
              return [sprotty_1.MoveViewportAction.create({ moveX: offsetX, moveY: 0 })];
            } else if (this.matchesMoveLeftKeystroke(event)) {
              return [sprotty_1.MoveViewportAction.create({ moveX: -offsetX, moveY: 0 })];
            }
          }
          return [];
        }
        matchesMoveUpKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowUp");
        }
        matchesMoveDownKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowDown");
        }
        matchesMoveRightKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowRight");
        }
        matchesMoveLeftKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowLeft");
        }
      };
      exports.MoveViewportKeyListener = MoveViewportKeyListener;
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], MoveViewportKeyListener.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IChangeBoundsManager),
        __metadata("design:type", Object)
      ], MoveViewportKeyListener.prototype, "changeBoundsManager", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.Grid),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], MoveViewportKeyListener.prototype, "grid", void 0);
      exports.MoveViewportKeyListener = MoveViewportKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], MoveViewportKeyListener);
      var ZoomKeyListener = class ZoomKeyListener extends sprotty_1.KeyListener {
        keyDown(element, event) {
          const selectedElementIds = this.selectionService.getSelectedElementIDs();
          if (selectedElementIds.length === 0) {
            if (this.matchesZoomOutKeystroke(event)) {
              return [zoom_viewport_action_1.ZoomAction.create({ zoomFactor: zoom_viewport_action_1.ZoomFactors.DEFAULT.out })];
            } else if (this.matchesZoomInKeystroke(event)) {
              return [zoom_viewport_action_1.ZoomAction.create({ zoomFactor: zoom_viewport_action_1.ZoomFactors.DEFAULT.in })];
            } else if (this.matchesMinZoomLevelKeystroke(event)) {
              return [sprotty_1.CenterAction.create(selectedElementIds)];
            }
          } else {
            if (this.matchesZoomOutKeystroke(event)) {
              if (selectedElementIds.length > 0) {
                return [
                  zoom_viewport_action_1.ZoomAction.create({
                    elementIds: selectedElementIds,
                    zoomFactor: zoom_viewport_action_1.ZoomFactors.DEFAULT.out
                  })
                ];
              }
            } else if (this.matchesZoomInKeystroke(event)) {
              if (selectedElementIds.length > 0) {
                return [zoom_viewport_action_1.ZoomAction.create({ elementIds: selectedElementIds, zoomFactor: zoom_viewport_action_1.ZoomFactors.DEFAULT.in })];
              }
            } else if (this.matchesMinZoomLevelKeystroke(event)) {
              return [sprotty_1.CenterAction.create(selectedElementIds)];
            }
          }
          return [];
        }
        matchesZoomInKeystroke(event) {
          return !event.ctrlKey && (event.key === "+" || (0, sprotty_1.matchesKeystroke)(event, "NumpadAdd"));
        }
        matchesMinZoomLevelKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Digit0", "ctrl") || (0, sprotty_1.matchesKeystroke)(event, "Numpad0", "ctrl");
        }
        matchesZoomOutKeystroke(event) {
          return !event.ctrlKey && ((0, sprotty_1.matchesKeystroke)(event, "Minus") || (0, sprotty_1.matchesKeystroke)(event, "NumpadSubtract"));
        }
      };
      exports.ZoomKeyListener = ZoomKeyListener;
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], ZoomKeyListener.prototype, "selectionService", void 0);
      exports.ZoomKeyListener = ZoomKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], ZoomKeyListener);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-tool.js
  var require_viewport_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var ViewportKeyTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewportKeyTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var messages_1 = require_messages3();
      var base_tools_1 = require_base_tools();
      var viewport_key_listener_1 = require_viewport_key_listener();
      var ViewportKeyTool = ViewportKeyTool_1 = class ViewportKeyTool extends base_tools_1.BaseTool {
        get id() {
          return ViewportKeyTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.keyTool.registerListener(this.moveKeyListener), this.keyTool.registerListener(this.zoomKeyListener), (0, messages_1.repeatOnMessagesUpdated)(() => this.shortcutManager.register(ViewportKeyTool_1.TOKEN, [
            {
              shortcuts: ["\u2B05 \u2B06 \u27A1 \u2B07"],
              description: messages_1.messages.viewport.shortcut_move_viewport,
              group: messages_1.messages.shortcut.group_move,
              position: 0
            },
            {
              shortcuts: ["+ -"],
              description: messages_1.messages.viewport.shortcut_zoom_viewport,
              group: messages_1.messages.shortcut.group_zoom,
              position: 0
            },
            {
              shortcuts: ["+ -"],
              description: messages_1.messages.viewport.shortcut_zoom_element,
              group: messages_1.messages.shortcut.group_zoom,
              position: 0
            }
          ])));
        }
      };
      exports.ViewportKeyTool = ViewportKeyTool;
      ViewportKeyTool.ID = "glsp.viewport-key-tool";
      ViewportKeyTool.TOKEN = Symbol.for(ViewportKeyTool_1.ID);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
        __metadata("design:type", Object)
      ], ViewportKeyTool.prototype, "shortcutManager", void 0);
      __decorate([
        (0, inversify_1.inject)(viewport_key_listener_1.ZoomKeyListener),
        __metadata("design:type", viewport_key_listener_1.ZoomKeyListener)
      ], ViewportKeyTool.prototype, "zoomKeyListener", void 0);
      __decorate([
        (0, inversify_1.inject)(viewport_key_listener_1.MoveViewportKeyListener),
        __metadata("design:type", viewport_key_listener_1.MoveViewportKeyListener)
      ], ViewportKeyTool.prototype, "moveKeyListener", void 0);
      exports.ViewportKeyTool = ViewportKeyTool = ViewportKeyTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ViewportKeyTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-modules.js
  var require_viewport_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/viewport/viewport-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.standaloneViewportModule = exports.viewportModule = void 0;
      var sprotty_1 = require_lib4();
      var tool_1 = require_tool();
      var actions_1 = require_actions2();
      var glsp_scroll_mouse_listener_1 = require_glsp_scroll_mouse_listener();
      var origin_viewport_1 = require_origin_viewport();
      var reposition_1 = require_reposition();
      var viewport_handler_1 = require_viewport_handler();
      var viewport_key_listener_1 = require_viewport_key_listener();
      var viewport_tool_1 = require_viewport_tool();
      var zoom_viewport_action_1 = require_zoom_viewport_action();
      exports.viewportModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.configureCommand)(context, sprotty_1.CenterCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.FitToScreenCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.GetViewportCommand);
        (0, sprotty_1.configureCommand)(context, sprotty_1.SetViewportCommand);
        (0, sprotty_1.configureCommand)(context, reposition_1.RepositionCommand);
        (0, sprotty_1.configureCommand)(context, origin_viewport_1.OriginViewportCommand);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, sprotty_1.ZoomMouseListener);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.MouseListener, glsp_scroll_mouse_listener_1.GLSPScrollMouseListener);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableToolsAction.KIND, glsp_scroll_mouse_listener_1.GLSPScrollMouseListener);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, glsp_scroll_mouse_listener_1.GLSPScrollMouseListener);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDiagramStartup, viewport_handler_1.RestoreViewportHandler);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, viewport_handler_1.RestoreViewportHandler);
        (0, sprotty_1.configureActionHandler)(context, actions_1.FocusDomAction.KIND, viewport_handler_1.RestoreViewportHandler);
        bind(sprotty_1.TYPES.ZoomFactors).toConstantValue(zoom_viewport_action_1.ZoomFactors.DEFAULT);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, viewport_tool_1.ViewportKeyTool);
        bind(viewport_handler_1.MoveViewportHandler).toSelf().inSingletonScope();
        bind(viewport_key_listener_1.MoveViewportKeyListener).toSelf();
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.MoveViewportAction.KIND, viewport_handler_1.MoveViewportHandler);
        bind(viewport_handler_1.ZoomHandler).toSelf().inSingletonScope();
        bind(viewport_key_listener_1.ZoomKeyListener).toSelf();
        (0, sprotty_1.configureActionHandler)(context, zoom_viewport_action_1.ZoomAction.KIND, viewport_handler_1.ZoomHandler);
      }, { featureId: Symbol("viewport") });
      exports.standaloneViewportModule = new sprotty_1.FeatureModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.KeyListener, sprotty_1.CenterKeyboardListener);
      }, { featureId: Symbol("standaloneViewport"), requires: exports.viewportModule });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/default-modules.js
  var require_default_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/default-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.initializeDiagramContainer = exports.configureDiagramOptions = exports.createDiagramOptionsModule = exports.DEFAULT_MODULES = void 0;
      var sprotty_1 = require_lib4();
      var default_module_1 = require_default_module();
      var bounds_module_1 = require_bounds_module();
      var resize_module_1 = require_resize_module();
      var command_palette_module_1 = require_command_palette_module();
      var context_menu_module_1 = require_context_menu_module();
      var copy_paste_modules_1 = require_copy_paste_modules();
      var decoration_module_1 = require_decoration_module();
      var element_template_module_1 = require_element_template_module();
      var export_modules_1 = require_export_modules();
      var type_hints_module_1 = require_type_hints_module();
      var hover_module_1 = require_hover_module();
      var label_edit_ui_module_1 = require_label_edit_ui_module();
      var label_edit_module_1 = require_label_edit_module();
      var layout_module_1 = require_layout_module();
      var navigation_module_1 = require_navigation_module();
      var routing_module_1 = require_routing_module();
      var select_module_1 = require_select_module();
      var source_model_watcher_module_1 = require_source_model_watcher_module();
      var status_module_1 = require_status_module();
      var svg_metadata_module_1 = require_svg_metadata_module();
      var tool_palette_module_1 = require_tool_palette_module();
      var change_bounds_tool_module_1 = require_change_bounds_tool_module();
      var deletion_tool_module_1 = require_deletion_tool_module();
      var edege_creation_module_1 = require_edege_creation_module();
      var edge_edit_module_1 = require_edge_edit_module();
      var marquee_selection_module_1 = require_marquee_selection_module();
      var node_creation_module_1 = require_node_creation_module();
      var tool_focus_loss_module_1 = require_tool_focus_loss_module();
      var validation_modules_1 = require_validation_modules();
      var viewport_modules_1 = require_viewport_modules();
      exports.DEFAULT_MODULES = [
        default_module_1.defaultModule,
        sprotty_1.buttonModule,
        sprotty_1.edgeIntersectionModule,
        sprotty_1.edgeLayoutModule,
        sprotty_1.expandModule,
        export_modules_1.exportModule,
        sprotty_1.fadeModule,
        bounds_module_1.boundsModule,
        command_palette_module_1.commandPaletteModule,
        context_menu_module_1.contextMenuModule,
        decoration_module_1.decorationModule,
        label_edit_module_1.labelEditModule,
        hover_module_1.hoverModule,
        select_module_1.selectModule,
        copy_paste_modules_1.copyPasteModule,
        viewport_modules_1.viewportModule,
        label_edit_ui_module_1.labelEditUiModule,
        layout_module_1.layoutModule,
        validation_modules_1.markerNavigatorModule,
        type_hints_module_1.typeHintsModule,
        sprotty_1.modelSourceModule,
        source_model_watcher_module_1.sourceModelWatcherModule,
        navigation_module_1.navigationModule,
        routing_module_1.routingModule,
        tool_palette_module_1.toolPaletteModule,
        edege_creation_module_1.edgeCreationToolModule,
        edge_edit_module_1.edgeEditToolModule,
        deletion_tool_module_1.deletionToolModule,
        element_template_module_1.elementTemplateModule,
        node_creation_module_1.nodeCreationToolModule,
        change_bounds_tool_module_1.changeBoundsToolModule,
        marquee_selection_module_1.marqueeSelectionToolModule,
        tool_focus_loss_module_1.toolFocusLossModule,
        validation_modules_1.validationModule,
        sprotty_1.zorderModule,
        svg_metadata_module_1.svgMetadataModule,
        status_module_1.statusModule,
        resize_module_1.resizeModule
      ];
      function createDiagramOptionsModule(diagramOptions, viewerOptions) {
        return new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => configureDiagramOptions({ bind, unbind, isBound, rebind }, diagramOptions, viewerOptions));
      }
      exports.createDiagramOptionsModule = createDiagramOptionsModule;
      function configureDiagramOptions(context, diagramOptions, viewerOptions) {
        (0, sprotty_1.configureViewerOptions)(context, {
          baseDiv: diagramOptions.clientId,
          hiddenDiv: diagramOptions.clientId + "_hidden",
          zoomLimits: { min: 0.1, max: 20 },
          ...viewerOptions
        });
        context.bind(sprotty_1.TYPES.IDiagramOptions).toConstantValue(diagramOptions);
      }
      exports.configureDiagramOptions = configureDiagramOptions;
      function initializeDiagramContainer2(container, ...containerConfigurations) {
        const modules = (0, sprotty_1.resolveContainerConfiguration)(...exports.DEFAULT_MODULES, ...containerConfigurations);
        const firstModule = modules[0];
        if (!firstModule || !(firstModule instanceof sprotty_1.FeatureModule && firstModule.featureId === default_module_1.defaultModule.featureId)) {
          throw new Error("Invalid module configuration. The first module to load should be the `defaultModule` (or an equivalent replacement module)");
        }
        container.load(...modules);
        return container;
      }
      exports.initializeDiagramContainer = initializeDiagramContainer2;
    }
  });

  // node_modules/@eclipse-glsp/client/css/navigation.css
  var require_navigation = __commonJS({
    "node_modules/@eclipse-glsp/client/css/navigation.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-palette.js
  var require_search_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var SearchAutocompletePalette_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SearchAutocompletePalette = exports.RevealEdgeElementAutocompleteSuggestionProvider = exports.RevealNodesWithoutNameAutocompleteSuggestionProvider = exports.RevealNamedElementAutocompleteSuggestionProvider = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var lodash_1 = require_lodash();
      var base_autocomplete_palette_1 = require_base_autocomplete_palette();
      var css_feedback_1 = require_css_feedback();
      var messages_1 = require_messages3();
      var reposition_1 = require_reposition();
      var model_1 = require_model22();
      var CSS_SEARCH_HIDDEN = "search-hidden";
      var CSS_SEARCH_HIGHLIGHTED = "search-highlighted";
      var RevealNamedElementAutocompleteSuggestionProvider = class {
        async retrieveSuggestions(root, text) {
          const nameables = (0, sprotty_1.toArray)(root.index.all().filter((element) => (0, sprotty_1.isNameable)(element)));
          return nameables.map((nameable) => {
            var _a4;
            return {
              element: nameable,
              action: {
                label: `[${nameable.type}] ${(_a4 = (0, sprotty_1.name)(nameable)) !== null && _a4 !== void 0 ? _a4 : "<no-name>"}`,
                actions: this.getActions(nameable),
                icon: (0, sprotty_1.codiconCSSString)("eye")
              }
            };
          });
        }
        getActions(nameable) {
          return [sprotty_1.SelectAction.create({ selectedElementsIDs: [nameable.id] }), sprotty_1.CenterAction.create([nameable.id], { retainZoom: true })];
        }
      };
      exports.RevealNamedElementAutocompleteSuggestionProvider = RevealNamedElementAutocompleteSuggestionProvider;
      var RevealNodesWithoutNameAutocompleteSuggestionProvider = class {
        async retrieveSuggestions(root, text) {
          const nodes = (0, sprotty_1.toArray)(root.index.all().filter((element) => !(0, sprotty_1.isNameable)(element) && element instanceof sprotty_1.GNode));
          return nodes.map((node) => ({
            element: node,
            action: {
              label: `[${node.type}]`,
              actions: this.getActions(node),
              icon: (0, sprotty_1.codiconCSSString)("symbol-namespace")
            }
          }));
        }
        getActions(nameable) {
          return [sprotty_1.SelectAction.create({ selectedElementsIDs: [nameable.id] }), sprotty_1.CenterAction.create([nameable.id], { retainZoom: true })];
        }
      };
      exports.RevealNodesWithoutNameAutocompleteSuggestionProvider = RevealNodesWithoutNameAutocompleteSuggestionProvider;
      var RevealEdgeElementAutocompleteSuggestionProvider = class {
        async retrieveSuggestions(root, text) {
          const edges = (0, sprotty_1.toArray)(root.index.all().filter((element) => element instanceof model_1.GEdge));
          return edges.map((edge) => ({
            element: edge,
            action: {
              label: `[${edge.type}]  ${this.getEdgeLabel(root, edge)}`,
              actions: this.getActions(edge),
              icon: (0, sprotty_1.codiconCSSString)("arrow-both")
            }
          }));
        }
        getActions(edge) {
          return [sprotty_1.SelectAction.create({ selectedElementsIDs: [edge.id] }), sprotty_1.CenterAction.create([edge.sourceId, edge.targetId])];
        }
        getEdgeLabel(root, edge) {
          var _a4, _b2;
          let sourceName = "";
          let targetName = "";
          const sourceNode = root.index.getById(edge.sourceId);
          const targetNode = root.index.getById(edge.targetId);
          if (sourceNode !== void 0) {
            sourceName = (_a4 = (0, sprotty_1.name)(sourceNode)) !== null && _a4 !== void 0 ? _a4 : sourceNode.type;
          }
          if (targetNode !== void 0) {
            targetName = (_b2 = (0, sprotty_1.name)(targetNode)) !== null && _b2 !== void 0 ? _b2 : targetNode.type;
          }
          return sourceName + " -> " + targetName;
        }
      };
      exports.RevealEdgeElementAutocompleteSuggestionProvider = RevealEdgeElementAutocompleteSuggestionProvider;
      var SearchAutocompletePalette = SearchAutocompletePalette_1 = class SearchAutocompletePalette extends base_autocomplete_palette_1.BaseAutocompletePalette {
        constructor() {
          super(...arguments);
          this.cachedSuggestions = [];
        }
        id() {
          return SearchAutocompletePalette_1.ID;
        }
        initializeContents(containerElement) {
          super.initializeContents(containerElement);
          this.autocompleteWidget.inputField.placeholder = messages_1.messages.search.placeholder;
          containerElement.setAttribute("aria-label", messages_1.messages.search.label);
        }
        getSuggestionProviders(root, input) {
          return [
            new RevealNamedElementAutocompleteSuggestionProvider(),
            new RevealEdgeElementAutocompleteSuggestionProvider(),
            new RevealNodesWithoutNameAutocompleteSuggestionProvider()
          ];
        }
        async retrieveSuggestions(root, input) {
          const providers = this.getSuggestionProviders(root, input);
          const suggestions = (await Promise.all(providers.map((provider) => provider.retrieveSuggestions(root, input)))).flat(1);
          this.cachedSuggestions = suggestions;
          return suggestions.map((s3) => s3.action);
        }
        async visibleSuggestionsChanged(root, labeledActions) {
          await this.applyCSS(this.getHiddenElements(root, this.getSuggestionsFromLabeledActions(labeledActions)), CSS_SEARCH_HIDDEN);
          await this.deleteCSS(this.getSuggestionsFromLabeledActions(labeledActions).map((s3) => s3.element), CSS_SEARCH_HIDDEN);
        }
        async selectedSuggestionChanged(root, labeledAction) {
          await this.deleteAllCSS(root, CSS_SEARCH_HIGHLIGHTED);
          if (labeledAction !== void 0) {
            const suggestions = this.getSuggestionsFromLabeledActions([labeledAction]);
            const actions = [];
            suggestions.map((currElem) => actions.push(reposition_1.RepositionAction.create([currElem.element.id])));
            this.actionDispatcher.dispatchAll(actions);
            await this.applyCSS(suggestions.map((s3) => s3.element), CSS_SEARCH_HIGHLIGHTED);
          }
        }
        show(root, ...contextElementIds) {
          this.actionDispatcher.dispatch(sprotty_1.SelectAllAction.create(false));
          super.show(root, ...contextElementIds);
        }
        hide() {
          if (this.root !== void 0) {
            this.deleteAllCSS(this.root, CSS_SEARCH_HIDDEN);
            this.deleteAllCSS(this.root, CSS_SEARCH_HIGHLIGHTED);
            this.autocompleteWidget.inputField.value = "";
          }
          super.hide();
        }
        applyCSS(elements, cssClass) {
          const actions = elements.map((element) => (0, css_feedback_1.applyCssClasses)(element, cssClass));
          return this.actionDispatcher.dispatchAll(actions);
        }
        deleteCSS(elements, cssClass) {
          const actions = elements.map((element) => (0, css_feedback_1.deleteCssClasses)(element, cssClass));
          return this.actionDispatcher.dispatchAll(actions);
        }
        deleteAllCSS(root, cssClass) {
          const actions = (0, sprotty_1.toArray)(root.index.all().map((element) => (0, css_feedback_1.deleteCssClasses)(element, cssClass)));
          return this.actionDispatcher.dispatchAll(actions);
        }
        getSuggestionsFromLabeledActions(labeledActions) {
          return this.cachedSuggestions.filter((c3) => labeledActions.find((s3) => (0, lodash_1.isEqual)(s3, c3.action)));
        }
        getHiddenSuggestionsFromLabeledActions(labeledActions) {
          return this.cachedSuggestions.filter((c3) => !labeledActions.find((s3) => (0, lodash_1.isEqual)(s3, c3.action)));
        }
        getHiddenElements(root, suggestions) {
          return (0, sprotty_1.toArray)(root.index.all().filter((element) => element instanceof sprotty_1.GNode || element instanceof model_1.GEdge).filter((element) => suggestions.find((suggestion) => suggestion.element.id === element.id) === void 0));
        }
      };
      exports.SearchAutocompletePalette = SearchAutocompletePalette;
      SearchAutocompletePalette.ID = "search-autocomplete-palette";
      exports.SearchAutocompletePalette = SearchAutocompletePalette = SearchAutocompletePalette_1 = __decorate([
        (0, inversify_1.injectable)()
      ], SearchAutocompletePalette);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-tool.js
  var require_search_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var SearchAutocompletePaletteTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SearchAutocompletePaletteKeyListener = exports.SearchAutocompletePaletteTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var messages_1 = require_messages3();
      var base_tools_1 = require_base_tools();
      var search_palette_1 = require_search_palette();
      var SearchAutocompletePaletteTool = SearchAutocompletePaletteTool_1 = class SearchAutocompletePaletteTool extends base_tools_1.BaseTool {
        constructor() {
          super(...arguments);
          this.keyListener = new SearchAutocompletePaletteKeyListener(this);
        }
        get id() {
          return SearchAutocompletePaletteTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.keyTool.registerListener(this.keyListener), (0, messages_1.repeatOnMessagesUpdated)(() => this.shortcutManager.register(SearchAutocompletePaletteTool_1.TOKEN, [
            {
              shortcuts: ["CTRL", "F"],
              description: messages_1.messages.search.shortcut_activate,
              group: messages_1.messages.shortcut.group_search,
              position: 0
            }
          ])));
        }
      };
      exports.SearchAutocompletePaletteTool = SearchAutocompletePaletteTool;
      SearchAutocompletePaletteTool.ID = "glsp.search-autocomplete-palette-tool";
      SearchAutocompletePaletteTool.TOKEN = Symbol.for(SearchAutocompletePaletteTool_1.ID);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
        __metadata("design:type", Object)
      ], SearchAutocompletePaletteTool.prototype, "shortcutManager", void 0);
      exports.SearchAutocompletePaletteTool = SearchAutocompletePaletteTool = SearchAutocompletePaletteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], SearchAutocompletePaletteTool);
      var SearchAutocompletePaletteKeyListener = class extends sprotty_1.KeyListener {
        constructor(tool) {
          super();
          this.tool = tool;
        }
        keyDown(element, event) {
          if (this.matchesSearchActivateKeystroke(event)) {
            return [
              sprotty_1.SetUIExtensionVisibilityAction.create({
                extensionId: search_palette_1.SearchAutocompletePalette.ID,
                visible: true
              })
            ];
          }
          return [];
        }
        matchesSearchActivateKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "KeyF", "ctrl");
        }
      };
      exports.SearchAutocompletePaletteKeyListener = SearchAutocompletePaletteKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/diagram-navigation-tool.js
  var require_diagram_navigation_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/diagram-navigation-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var ElementNavigatorTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ElementNavigatorKeyListener = exports.ElementNavigatorTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var messages_1 = require_messages3();
      var available_shortcuts_tool_1 = require_available_shortcuts_tool();
      var tool_1 = require_tool();
      var model_1 = require_model22();
      var base_tools_1 = require_base_tools();
      var reposition_1 = require_reposition();
      var search_tool_1 = require_search_tool();
      var toast_handler_1 = require_toast_handler();
      var ElementNavigatorTool = ElementNavigatorTool_1 = class ElementNavigatorTool extends base_tools_1.BaseTool {
        constructor() {
          super(...arguments);
          this.elementNavigatorKeyListener = new ElementNavigatorKeyListener(this);
        }
        get id() {
          return ElementNavigatorTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.keyTool.registerListener(this.elementNavigatorKeyListener), (0, messages_1.repeatOnMessagesUpdated)(() => this.shortcutManager.register(ElementNavigatorTool_1.TOKEN, [
            {
              shortcuts: ["ALT", "N"],
              description: messages_1.messages.navigation.shortcut_local_mode,
              group: messages_1.messages.shortcut.group_navigation,
              position: 0
            },
            {
              shortcuts: ["N"],
              description: messages_1.messages.navigation.shortcut_global_mode,
              group: messages_1.messages.shortcut.group_navigation,
              position: 1
            }
          ])));
        }
      };
      exports.ElementNavigatorTool = ElementNavigatorTool;
      ElementNavigatorTool.ID = "glsp.diagram-navigation";
      ElementNavigatorTool.TOKEN = Symbol.for(ElementNavigatorTool_1.ID);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
        __metadata("design:type", Object)
      ], ElementNavigatorTool.prototype, "shortcutManager", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IElementNavigator),
        __metadata("design:type", Object)
      ], ElementNavigatorTool.prototype, "elementNavigator", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILocalElementNavigator),
        __metadata("design:type", Object)
      ], ElementNavigatorTool.prototype, "localElementNavigator", void 0);
      exports.ElementNavigatorTool = ElementNavigatorTool = ElementNavigatorTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ElementNavigatorTool);
      var NavigationMode;
      (function(NavigationMode2) {
        NavigationMode2["POSITION"] = "position";
        NavigationMode2["DEFAULT"] = "default";
        NavigationMode2["NONE"] = "none";
      })(NavigationMode || (NavigationMode = {}));
      var ElementNavigatorKeyListener = class _ElementNavigatorKeyListener extends sprotty_1.KeyListener {
        constructor(tool) {
          super();
          this.tool = tool;
          this.mode = NavigationMode.NONE;
          this.token = _ElementNavigatorKeyListener.name;
        }
        keyDown(element, event) {
          this.resetOnEscape(event, element);
          if (this.getSelectedElements(element.root).length > 0) {
            if (!this.triggerPositionNavigationOnEvent(event, element)) {
              this.triggerDefaultNavigationOnEvent(event, element);
            }
            return this.navigate(element, event);
          }
          this.resetPositionNavigationOnEvent(event, element);
          this.resetDefaultNavigationOnEvent(event, element);
          return [];
        }
        resetOnEscape(event, element) {
          var _a4, _b2;
          if (this.mode !== NavigationMode.NONE && this.matchesDeactivateNavigationMode(event)) {
            (_b2 = (_a4 = this.navigator) === null || _a4 === void 0 ? void 0 : _a4.clean) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, element.root);
            this.clean();
            if (this.mode === NavigationMode.POSITION) {
              this.tool.dispatchActions([
                tool_1.EnableDefaultToolsAction.create(),
                toast_handler_1.ShowToastMessageAction.createWithTimeout({
                  id: Symbol.for(_ElementNavigatorKeyListener.name),
                  message: messages_1.messages.navigation.local_navigation_mode_deactivated
                })
              ]);
            } else if (this.mode === NavigationMode.DEFAULT) {
              this.tool.dispatchActions([
                tool_1.EnableDefaultToolsAction.create(),
                toast_handler_1.ShowToastMessageAction.createWithTimeout({
                  id: Symbol.for(_ElementNavigatorKeyListener.name),
                  message: messages_1.messages.navigation.default_navigation_mode_deactivated
                })
              ]);
            }
            this.mode = NavigationMode.NONE;
          }
        }
        triggerPositionNavigationOnEvent(event, element) {
          if (this.matchesActivatePositionNavigation(event)) {
            if (this.mode !== NavigationMode.POSITION) {
              this.clean();
              this.tool.dispatchActions([
                tool_1.EnableToolsAction.create([ElementNavigatorTool.ID, search_tool_1.SearchAutocompletePaletteTool.ID, available_shortcuts_tool_1.AvailableShortcutsTool.ID]),
                toast_handler_1.ShowToastMessageAction.create({
                  id: Symbol.for(_ElementNavigatorKeyListener.name),
                  message: messages_1.messages.navigation.local_navigation_mode_activated
                })
              ]);
              this.navigator = this.tool.elementNavigator;
              this.mode = NavigationMode.POSITION;
            } else {
              this.resetPositionNavigationOnEvent(event, element);
            }
            return true;
          }
          return false;
        }
        resetPositionNavigationOnEvent(event, element) {
          var _a4, _b2;
          if (this.mode === NavigationMode.POSITION && this.matchesActivatePositionNavigation(event)) {
            (_b2 = (_a4 = this.navigator) === null || _a4 === void 0 ? void 0 : _a4.clean) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, element.root);
            this.clean();
            this.mode = NavigationMode.NONE;
            this.tool.dispatchActions([
              tool_1.EnableDefaultToolsAction.create(),
              toast_handler_1.ShowToastMessageAction.createWithTimeout({
                id: Symbol.for(_ElementNavigatorKeyListener.name),
                message: messages_1.messages.navigation.local_navigation_mode_deactivated
              })
            ]);
          }
        }
        triggerDefaultNavigationOnEvent(event, element) {
          if (this.matchesActivateDefaultNavigation(event)) {
            if (this.mode !== NavigationMode.DEFAULT) {
              this.clean();
              this.tool.dispatchActions([
                tool_1.EnableToolsAction.create([ElementNavigatorTool.ID, search_tool_1.SearchAutocompletePaletteTool.ID, available_shortcuts_tool_1.AvailableShortcutsTool.ID]),
                toast_handler_1.ShowToastMessageAction.create({
                  id: Symbol.for(_ElementNavigatorKeyListener.name),
                  message: messages_1.messages.navigation.default_navigation_mode_activated
                })
              ]);
              this.navigator = this.tool.localElementNavigator;
              this.mode = NavigationMode.DEFAULT;
            } else {
              this.resetDefaultNavigationOnEvent(event, element);
            }
            return true;
          }
          return false;
        }
        resetDefaultNavigationOnEvent(event, element) {
          var _a4, _b2;
          if (this.mode === NavigationMode.DEFAULT && this.matchesActivateDefaultNavigation(event)) {
            (_b2 = (_a4 = this.navigator) === null || _a4 === void 0 ? void 0 : _a4.clean) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, element.root);
            this.clean();
            this.mode = NavigationMode.NONE;
            this.tool.dispatchActions([
              tool_1.EnableDefaultToolsAction.create(),
              toast_handler_1.ShowToastMessageAction.createWithTimeout({
                id: Symbol.for(_ElementNavigatorKeyListener.name),
                message: messages_1.messages.navigation.default_navigation_mode_deactivated
              })
            ]);
          }
        }
        navigate(element, event) {
          var _a4, _b2, _c, _d;
          const selected = this.getSelectedElements(element.root);
          const current = selected.length > 0 ? selected[0] : void 0;
          if (this.mode !== NavigationMode.NONE && this.navigator !== void 0 && current !== void 0 && (0, sprotty_1.isBoundsAware)(current)) {
            (_b2 = (_a4 = this.navigator).clean) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, current.root, current, this.previousNode);
            const target = this.navigateOnEvent(event, this.navigator, current);
            if (target !== void 0) {
              (_d = (_c = this.navigator).process) === null || _d === void 0 ? void 0 : _d.call(_c, current.root, current, target, this.previousNode);
            }
            const selectableTarget = target ? (0, sprotty_1.findParentByFeature)(target, sprotty_1.isSelectable) : void 0;
            if (selectableTarget) {
              if (!(current instanceof model_1.GEdge)) {
                this.previousNode = current;
              }
              const deselectedElementsIDs = selected.map((e2) => e2.id).filter((id) => id !== selectableTarget.id);
              return [
                sprotty_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs }),
                reposition_1.RepositionAction.create([selectableTarget.id])
              ];
            }
          }
          return [];
        }
        navigateOnEvent(event, navigator2, current) {
          var _a4, _b2;
          if (this.matchesNavigatePrevious(event)) {
            return navigator2.previous(current.root, current);
          } else if (this.matchesNavigateNext(event)) {
            return navigator2.next(current.root, current);
          } else if (this.matchesNavigateUp(event)) {
            return (_a4 = navigator2.up) === null || _a4 === void 0 ? void 0 : _a4.call(navigator2, current.root, current, this.previousNode);
          } else if (this.matchesNavigateDown(event)) {
            return (_b2 = navigator2.down) === null || _b2 === void 0 ? void 0 : _b2.call(navigator2, current.root, current, this.previousNode);
          }
          return void 0;
        }
        clean() {
          this.previousNode = void 0;
          this.navigator = void 0;
        }
        getSelectedElements(root) {
          return (0, sprotty_1.toArray)(root.index.all().filter((e2) => (0, sprotty_1.isSelected)(e2)));
        }
        matchesDeactivateNavigationMode(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Escape");
        }
        matchesActivateDefaultNavigation(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "KeyN");
        }
        matchesActivatePositionNavigation(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "KeyN", "alt");
        }
        matchesNavigatePrevious(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowLeft");
        }
        matchesNavigateNext(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowRight");
        }
        matchesNavigateUp(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowUp");
        }
        matchesNavigateDown(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowDown");
        }
      };
      exports.ElementNavigatorKeyListener = ElementNavigatorKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/local-element-navigator.js
  var require_local_element_navigator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/local-element-navigator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocalElementNavigator = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var css_feedback_1 = require_css_feedback();
      var model_1 = require_model22();
      var LocalElementNavigator = class LocalElementNavigator {
        constructor() {
          this.navigableElementCSS = "navigable-element";
        }
        previous(root, current, previousCurrent, predicate) {
          return this.getPreviousElement(current, predicate);
        }
        next(root, current, previousCurrent, predicate) {
          return this.getNextElement(current, predicate);
        }
        up(root, current, previousCurrent, predicate) {
          return this.getIterable(current, previousCurrent, predicate);
        }
        down(root, current, previousCurrent, predicate) {
          return this.getIterable(current, previousCurrent, predicate);
        }
        process(root, current, target, previousCurrent, predicate) {
          let elements = [];
          if (target instanceof model_1.GEdge) {
            if (current instanceof model_1.GEdge) {
              elements = this.getIterables(target, current.source === target.source ? current.source : current.target, predicate);
            } else {
              elements = this.getIterables(target, current, predicate);
            }
          }
          elements.filter((e2) => e2.id !== target.id).forEach((e2) => this.actionDispatcher.dispatch((0, css_feedback_1.applyCssClasses)(e2, this.navigableElementCSS)));
        }
        clean(root, current, previousCurrent) {
          root.index.all().forEach((e2) => this.actionDispatcher.dispatch((0, css_feedback_1.deleteCssClasses)(e2, this.navigableElementCSS)));
        }
        getIterables(current, previousCurrent, predicate = () => true) {
          var _a4, _b2;
          const elements = [];
          if (current instanceof model_1.GEdge) {
            if (current.target === previousCurrent) {
              (_a4 = current.target) === null || _a4 === void 0 ? void 0 : _a4.incomingEdges.forEach((e2) => elements.push(e2));
            } else {
              (_b2 = current.source) === null || _b2 === void 0 ? void 0 : _b2.outgoingEdges.forEach((e2) => elements.push(e2));
            }
          }
          return elements.filter(predicate);
        }
        getIterable(current, previousCurrent, predicate = () => true) {
          return this.getIterables(current, previousCurrent, predicate).filter((e2) => e2.id !== current.id)[0];
        }
        getNextElement(current, predicate = () => true) {
          const elements = [];
          if (current instanceof sprotty_1.GConnectableElement) {
            current.outgoingEdges.forEach((e2) => elements.push(e2));
          } else if (current instanceof model_1.GEdge) {
            const target = current.target;
            elements.push(target);
          }
          return elements.filter(predicate)[0];
        }
        getPreviousElement(current, predicate = () => true) {
          const elements = [];
          if (current instanceof sprotty_1.GConnectableElement) {
            current.incomingEdges.forEach((e2) => elements.push(e2));
          } else if (current instanceof model_1.GEdge) {
            const source = current.source;
            elements.push(source);
          }
          return elements.filter(predicate)[0];
        }
      };
      exports.LocalElementNavigator = LocalElementNavigator;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], LocalElementNavigator.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], LocalElementNavigator.prototype, "actionDispatcher", void 0);
      exports.LocalElementNavigator = LocalElementNavigator = __decorate([
        (0, inversify_1.injectable)()
      ], LocalElementNavigator);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/position-navigator.js
  var require_position_navigator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/position-navigator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PositionNavigator = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var PositionNavigator = class PositionNavigator {
        previous(root, current, previousCurrent, predicate) {
          return this.getNearestElement(root, current, (e2) => this.bounds(root, e2).x < this.bounds(root, current).x);
        }
        next(root, current, previousCurrent, predicate) {
          return this.getNearestElement(root, current, (e2) => this.bounds(root, e2).x > this.bounds(root, current).x);
        }
        up(root, current, previousCurrent, predicate) {
          return this.getNearestElement(root, current, (e2) => this.bounds(root, e2).y < this.bounds(root, current).y);
        }
        down(root, current, previousCurrent, predicate) {
          return this.getNearestElement(root, current, (e2) => this.bounds(root, e2).y > this.bounds(root, current).y);
        }
        getNearestElement(root, current, filter) {
          const elements = this.boundElements(root).filter(filter);
          return this.sortByDistance(root, current, elements)[0];
        }
        sortByDistance(root, current, elements) {
          const distance = (coor1, coor2) => {
            const x3 = coor2.x - coor1.x;
            const y3 = coor2.y - coor1.y;
            return Math.sqrt(x3 * x3 + y3 * y3);
          };
          return elements.sort((a3, b3) => distance(this.bounds(root, a3), this.bounds(root, current)) - distance(this.bounds(root, b3), this.bounds(root, current)));
        }
        boundElements(root) {
          return (0, sprotty_1.toArray)(root.index.all().filter((e2) => e2 instanceof sprotty_1.GNode && (0, sprotty_1.isSelectable)(e2) && (0, sprotty_1.isBoundsAware)(e2)));
        }
        bounds(root, element) {
          return this.boundsInViewport(element, element.bounds, root);
        }
        boundsInViewport(element, bounds, viewport) {
          if (element instanceof sprotty_1.GChildElement && element.parent !== viewport) {
            return this.boundsInViewport(element.parent, element.parent.localToParent(bounds), viewport);
          } else {
            return bounds;
          }
        }
      };
      exports.PositionNavigator = PositionNavigator;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], PositionNavigator.prototype, "actionDispatcher", void 0);
      exports.PositionNavigator = PositionNavigator = __decorate([
        (0, inversify_1.injectable)()
      ], PositionNavigator);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/element-navigation-module.js
  var require_element_navigation_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/element-navigation-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.glspElementNavigationModule = exports.configureElementNavigationTool = exports.elementNavigationModule = void 0;
      var sprotty_1 = require_lib4();
      require_navigation();
      var diagram_navigation_tool_1 = require_diagram_navigation_tool();
      var local_element_navigator_1 = require_local_element_navigator();
      var position_navigator_1 = require_position_navigator();
      exports.elementNavigationModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureElementNavigationTool(context);
      }, { featureId: Symbol("elementNavigation") });
      exports.glspElementNavigationModule = exports.elementNavigationModule;
      function configureElementNavigationTool(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, diagram_navigation_tool_1.ElementNavigatorTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IElementNavigator, position_navigator_1.PositionNavigator);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.ILocalElementNavigator, local_element_navigator_1.LocalElementNavigator);
      }
      exports.configureElementNavigationTool = configureElementNavigationTool;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/focus-tracker/focus-tracker-tool.js
  var require_focus_tracker_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/focus-tracker/focus-tracker-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var FocusTrackerTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusTrackerTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var messages_1 = require_messages3();
      var toast_handler_1 = require_toast_handler();
      var FocusTrackerTool = FocusTrackerTool_1 = class FocusTrackerTool {
        constructor() {
          this.isEditTool = false;
          this.focusInFunction = (event) => this.focusIn(event);
          this.focusOutFunction = (event) => this.focusOut(event);
          this.registered = false;
        }
        get id() {
          return FocusTrackerTool_1.ID;
        }
        enable() {
          if (!this.registered) {
            document.addEventListener("focusin", this.focusInFunction);
            document.addEventListener("focusout", this.focusOutFunction);
          }
          this.registered = true;
        }
        disable() {
        }
        async focusOut(event) {
          await this.showToast(messages_1.messages.focus.focus_not_set);
        }
        async focusIn(event) {
          let message;
          const target = event.target;
          if (target instanceof HTMLElement) {
            const parent = this.parentWithAriaLabel(target);
            const textMessage = this.handleTextNode(target);
            if (target.ariaLabel !== null) {
              message = this.handleAriaLabel(target);
            } else {
              if (parent === void 0 && textMessage !== void 0) {
                message = textMessage;
              } else if (parent !== void 0 && textMessage === void 0) {
                message = `${messages_1.messages.focus.focus_within} ${parent.ariaLabel}`;
              } else if (parent !== void 0 && textMessage !== void 0) {
                message = `${parent.ariaLabel} -> ${textMessage}`;
              }
            }
          }
          await this.showToast(message);
        }
        handleTextNode(target) {
          const textNode = Array.prototype.filter.call(target.childNodes, (element) => element.nodeType === Node.TEXT_NODE).map((element) => element.textContent).join("");
          if (textNode.trim().length !== 0) {
            return textNode;
          }
          return void 0;
        }
        handleAriaLabel(target) {
          return target.ariaLabel === null ? void 0 : target.ariaLabel;
        }
        showToast(message) {
          return this.actionDispatcher.dispatchAll([
            toast_handler_1.ShowToastMessageAction.create({
              id: Symbol.for(FocusTrackerTool_1.ID),
              message: `${messages_1.messages.focus.focus_on} ${message !== null && message !== void 0 ? message : "unknown"}`,
              position: "left"
            })
          ]);
        }
        parentWithAriaLabel(target) {
          let current = target.parentElement;
          while (
            // eslint-disable-next-line no-null/no-null
            current !== null && current !== document.body && current !== document.getElementById(this.viewerOptions.baseDiv) && // eslint-disable-next-line no-null/no-null
            current.ariaLabel === null
          ) {
            current = current.parentElement;
          }
          if (current === document.getElementById(this.viewerOptions.baseDiv) || current === document.body) {
            return void 0;
          }
          return current !== null && current !== void 0 ? current : void 0;
        }
      };
      exports.FocusTrackerTool = FocusTrackerTool;
      FocusTrackerTool.ID = "glsp.focus-tracker";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], FocusTrackerTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], FocusTrackerTool.prototype, "viewerOptions", void 0);
      exports.FocusTrackerTool = FocusTrackerTool = FocusTrackerTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], FocusTrackerTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/focus-tracker/focus-tracker-module.js
  var require_focus_tracker_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/focus-tracker/focus-tracker-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.glspFocusTrackerModule = exports.configureFocusTrackerTool = exports.focusTrackerModule = void 0;
      var sprotty_1 = require_lib4();
      var focus_tracker_tool_1 = require_focus_tracker_tool();
      exports.focusTrackerModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureFocusTrackerTool(context);
      }, { featureId: Symbol("focusTracker") });
      exports.glspFocusTrackerModule = exports.focusTrackerModule;
      function configureFocusTrackerTool(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, focus_tracker_tool_1.FocusTrackerTool);
      }
      exports.configureFocusTrackerTool = configureFocusTrackerTool;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/action.js
  var require_action2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetEdgeTargetSelectionAction = void 0;
      var sprotty_1 = require_lib4();
      var SetEdgeTargetSelectionAction;
      (function(SetEdgeTargetSelectionAction2) {
        SetEdgeTargetSelectionAction2.KIND = "setEdgeTargetSelectionAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, SetEdgeTargetSelectionAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "elementId") && (0, sprotty_1.hasObjectProp)(object, "context");
        }
        SetEdgeTargetSelectionAction2.is = is;
        function create(elementId, context) {
          return { kind: SetEdgeTargetSelectionAction2.KIND, elementId, context };
        }
        SetEdgeTargetSelectionAction2.create = create;
      })(SetEdgeTargetSelectionAction || (exports.SetEdgeTargetSelectionAction = SetEdgeTargetSelectionAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-palette.js
  var require_edge_autocomplete_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PossibleEdgeTargetAutocompleteSuggestionProvider = exports.EdgeAutocompletePalette = exports.EdgeAutocompletePaletteMetadata = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var auto_complete_widget_1 = require_auto_complete_widget();
      var tool_1 = require_tool();
      var model_1 = require_model22();
      var search_palette_1 = require_search_palette();
      var action_1 = require_action2();
      var EdgeAutocompletePaletteMetadata;
      (function(EdgeAutocompletePaletteMetadata2) {
        EdgeAutocompletePaletteMetadata2.ID = "edge-autocomplete-palette";
      })(EdgeAutocompletePaletteMetadata || (exports.EdgeAutocompletePaletteMetadata = EdgeAutocompletePaletteMetadata = {}));
      var EdgeAutocompletePalette = class EdgeAutocompletePalette extends search_palette_1.SearchAutocompletePalette {
        constructor() {
          super(...arguments);
          this.targetSuggestionProvider = new PossibleEdgeTargetAutocompleteSuggestionProvider();
        }
        id() {
          return EdgeAutocompletePaletteMetadata.ID;
        }
        handle(action) {
          if (sprotty_1.TriggerEdgeCreationAction.is(action)) {
            this.context = {
              trigger: action,
              role: "source"
            };
            this.targetSuggestionProvider.setContext(action, this.context);
          }
        }
        onBeforeShow(containerElement, root, ...contextElementIds) {
          var _a4;
          super.onBeforeShow(containerElement, root, ...contextElementIds);
          this.autocompleteWidget.inputField.placeholder = `Search for ${(_a4 = this.context) === null || _a4 === void 0 ? void 0 : _a4.role} elements`;
        }
        getSuggestionProviders(root, input) {
          return [this.targetSuggestionProvider];
        }
        reload() {
          const context = this.context;
          this.hide();
          this.context = context;
          this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({
            extensionId: EdgeAutocompletePaletteMetadata.ID,
            visible: true
          }));
        }
        executeSuggestion(input) {
          var _a4, _b2, _c, _d;
          const action = (0, auto_complete_widget_1.toActionArray)(input)[0];
          if (((_a4 = this.context) === null || _a4 === void 0 ? void 0 : _a4.role) === "source") {
            this.context.sourceId = action.elementId;
            this.context.role = "target";
            this.reload();
          } else if (((_b2 = this.context) === null || _b2 === void 0 ? void 0 : _b2.role) === "target") {
            this.context.targetId = action.elementId;
          }
          if (((_c = this.context) === null || _c === void 0 ? void 0 : _c.sourceId) !== void 0 && ((_d = this.context) === null || _d === void 0 ? void 0 : _d.targetId) !== void 0) {
            this.actionDispatcher.dispatchAll([
              sprotty_1.CreateEdgeOperation.create({
                elementTypeId: this.context.trigger.elementTypeId,
                sourceElementId: this.context.sourceId,
                targetElementId: this.context.targetId,
                args: this.context.trigger.args
              }),
              tool_1.EnableDefaultToolsAction.create()
            ]);
            this.hide();
          }
        }
        autocompleteHide(reason) {
          if (reason !== "submission") {
            this.hide();
          }
        }
      };
      exports.EdgeAutocompletePalette = EdgeAutocompletePalette;
      exports.EdgeAutocompletePalette = EdgeAutocompletePalette = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeAutocompletePalette);
      var PossibleEdgeTargetAutocompleteSuggestionProvider = class PossibleEdgeTargetAutocompleteSuggestionProvider {
        setContext(triggerAction, edgeAutocompleteContext) {
          this.proxyEdge = new model_1.GEdge();
          this.proxyEdge.type = triggerAction.elementTypeId;
          this.context = edgeAutocompleteContext;
        }
        isAllowedSource(element, role) {
          return element !== void 0 && this.proxyEdge !== void 0 && (0, sprotty_1.isConnectable)(element) && element.canConnect(this.proxyEdge, role);
        }
        async retrieveSuggestions(root, text) {
          const context = this.context;
          if (this.context === void 0) {
            return [];
          }
          const nodes = (0, sprotty_1.toArray)(root.index.all().filter((element) => this.isAllowedSource(element, context.role)));
          return nodes.map((node) => {
            var _a4;
            return {
              element: node,
              action: {
                label: `[${node.type}] ${(_a4 = (0, sprotty_1.name)(node)) !== null && _a4 !== void 0 ? _a4 : "<no-name>"}`,
                actions: [action_1.SetEdgeTargetSelectionAction.create(node.id, context.role)],
                icon: (0, sprotty_1.codiconCSSString)("arrow-both")
              }
            };
          });
        }
      };
      exports.PossibleEdgeTargetAutocompleteSuggestionProvider = PossibleEdgeTargetAutocompleteSuggestionProvider;
      exports.PossibleEdgeTargetAutocompleteSuggestionProvider = PossibleEdgeTargetAutocompleteSuggestionProvider = __decorate([
        (0, inversify_1.injectable)()
      ], PossibleEdgeTargetAutocompleteSuggestionProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-tool.js
  var require_edge_autocomplete_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var EdgeAutocompletePaletteTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeAutocompletePaletteKeyListener = exports.EdgeAutocompletePaletteTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var edge_autocomplete_palette_1 = require_edge_autocomplete_palette();
      var EdgeAutocompletePaletteTool = EdgeAutocompletePaletteTool_1 = class EdgeAutocompletePaletteTool {
        constructor() {
          this.keyListener = new EdgeAutocompletePaletteKeyListener();
        }
        get id() {
          return EdgeAutocompletePaletteTool_1.ID;
        }
        enable() {
          this.keyTool.register(this.keyListener);
        }
        disable() {
          this.keyTool.deregister(this.keyListener);
        }
      };
      exports.EdgeAutocompletePaletteTool = EdgeAutocompletePaletteTool;
      EdgeAutocompletePaletteTool.ID = "glsp.edge-autocomplete-palette-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], EdgeAutocompletePaletteTool.prototype, "keyTool", void 0);
      exports.EdgeAutocompletePaletteTool = EdgeAutocompletePaletteTool = EdgeAutocompletePaletteTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeAutocompletePaletteTool);
      var EdgeAutocompletePaletteKeyListener = class extends sprotty_1.KeyListener {
        keyDown(element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            return [
              sprotty_1.SetUIExtensionVisibilityAction.create({
                extensionId: edge_autocomplete_palette_1.EdgeAutocompletePaletteMetadata.ID,
                visible: false,
                contextElementsId: []
              })
            ];
          }
          return [];
        }
      };
      exports.EdgeAutocompletePaletteKeyListener = EdgeAutocompletePaletteKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/constants.js
  var require_constants = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardNodeGridMetadata = exports.KeyboardGridMetadata = void 0;
      var KeyboardGridMetadata;
      (function(KeyboardGridMetadata2) {
        KeyboardGridMetadata2.ID = "keyboard-grid";
        KeyboardGridMetadata2.TAB_INDEX = 15;
      })(KeyboardGridMetadata || (exports.KeyboardGridMetadata = KeyboardGridMetadata = {}));
      var KeyboardNodeGridMetadata;
      (function(KeyboardNodeGridMetadata2) {
        KeyboardNodeGridMetadata2.ID = "keyboard-node-grid";
      })(KeyboardNodeGridMetadata || (exports.KeyboardNodeGridMetadata = KeyboardNodeGridMetadata = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/constants.js
  var require_constants2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardPointerMetadata = void 0;
      var KeyboardPointerMetadata;
      (function(KeyboardPointerMetadata2) {
        KeyboardPointerMetadata2.ID = "keyboard-pointer";
        KeyboardPointerMetadata2.CRICLE_HEIGHT = 16;
        KeyboardPointerMetadata2.CIRCLE_WIDTH = 16;
        KeyboardPointerMetadata2.TAB_INDEX = 10;
      })(KeyboardPointerMetadata || (exports.KeyboardPointerMetadata = KeyboardPointerMetadata = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/global-keylistener-tool.js
  var require_global_keylistener_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/global-keylistener-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var GlobalKeyListenerTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GlobalKeyListenerTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var messages_1 = require_messages3();
      var constants_1 = require_constants();
      var tool_palette_1 = require_tool_palette3();
      var base_tools_1 = require_base_tools();
      var actions_1 = require_actions2();
      var constants_2 = require_constants2();
      var GlobalKeyListenerTool = GlobalKeyListenerTool_1 = class GlobalKeyListenerTool extends base_tools_1.BaseEditTool {
        constructor() {
          super(...arguments);
          this.alreadyRegistered = false;
        }
        get id() {
          return GlobalKeyListenerTool_1.ID;
        }
        enable() {
          if (!this.alreadyRegistered) {
            this.alreadyRegistered = true;
            document.addEventListener("keyup", this.trigger.bind(this));
            (0, messages_1.repeatOnMessagesUpdated)(() => this.shortcutManager.register(GlobalKeyListenerTool_1.TOKEN, [
              {
                shortcuts: ["ALT", "P"],
                description: messages_1.messages.focus.shortcut_focus_palette,
                group: messages_1.messages.shortcut.group_tool_palette,
                position: 0
              },
              {
                shortcuts: ["ALT", "G"],
                description: messages_1.messages.focus.shortcut_focus_graph,
                group: messages_1.messages.shortcut.group_graph,
                position: 0
              }
            ]));
          }
        }
        trigger(event) {
          this.actionDispatcher.dispatchAll(this.handleKeyEvent(event));
        }
        handleKeyEvent(event) {
          if (this.matchesSetFocusOnToolPalette(event)) {
            return [actions_1.FocusDomAction.create(tool_palette_1.ToolPalette.ID)];
          } else if (this.matchesSetFocusOnDiagram(event)) {
            return [actions_1.FocusDomAction.create("graph")];
          } else if (this.matchesReleaseFocusFromToolPalette(event)) {
            return [
              sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: constants_2.KeyboardPointerMetadata.ID, visible: false, contextElementsId: [] }),
              sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: constants_1.KeyboardGridMetadata.ID, visible: false, contextElementsId: [] }),
              sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: constants_1.KeyboardNodeGridMetadata.ID, visible: false, contextElementsId: [] })
            ];
          }
          return [];
        }
        matchesSetFocusOnToolPalette(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "KeyP", "alt");
        }
        matchesSetFocusOnDiagram(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "KeyG", "alt");
        }
        matchesReleaseFocusFromToolPalette(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Escape");
        }
      };
      exports.GlobalKeyListenerTool = GlobalKeyListenerTool;
      GlobalKeyListenerTool.ID = "glsp.global-key-listener";
      GlobalKeyListenerTool.TOKEN = Symbol.for(GlobalKeyListenerTool_1.name);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
        __metadata("design:type", Object)
      ], GlobalKeyListenerTool.prototype, "shortcutManager", void 0);
      exports.GlobalKeyListenerTool = GlobalKeyListenerTool = GlobalKeyListenerTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], GlobalKeyListenerTool);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/action.js
  var require_action3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardGridKeyboardEventAction = exports.KeyboardGridCellSelectedAction = exports.EnableKeyboardGridAction = void 0;
      var sprotty_1 = require_lib4();
      var EnableKeyboardGridAction;
      (function(EnableKeyboardGridAction2) {
        EnableKeyboardGridAction2.KIND = "enableKeyboardGrid";
        function is(object) {
          return sprotty_1.Action.hasKind(object, EnableKeyboardGridAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "options");
        }
        EnableKeyboardGridAction2.is = is;
        function create(options) {
          return {
            kind: EnableKeyboardGridAction2.KIND,
            options
          };
        }
        EnableKeyboardGridAction2.create = create;
      })(EnableKeyboardGridAction || (exports.EnableKeyboardGridAction = EnableKeyboardGridAction = {}));
      var KeyboardGridCellSelectedAction;
      (function(KeyboardGridCellSelectedAction2) {
        KeyboardGridCellSelectedAction2.KIND = "keyboardGridCellSelectedAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, KeyboardGridCellSelectedAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "options");
        }
        KeyboardGridCellSelectedAction2.is = is;
        function create(options) {
          return {
            kind: KeyboardGridCellSelectedAction2.KIND,
            options
          };
        }
        KeyboardGridCellSelectedAction2.create = create;
      })(KeyboardGridCellSelectedAction || (exports.KeyboardGridCellSelectedAction = KeyboardGridCellSelectedAction = {}));
      var KeyboardGridKeyboardEventAction;
      (function(KeyboardGridKeyboardEventAction2) {
        KeyboardGridKeyboardEventAction2.KIND = "keyboardGridKeyboardEvent";
        function is(object) {
          return sprotty_1.Action.hasKind(object, KeyboardGridKeyboardEventAction2.KIND) && (0, sprotty_1.hasObjectProp)(object, "options");
        }
        KeyboardGridKeyboardEventAction2.is = is;
        function create(options) {
          return {
            kind: KeyboardGridKeyboardEventAction2.KIND,
            options
          };
        }
        KeyboardGridKeyboardEventAction2.create = create;
      })(KeyboardGridKeyboardEventAction || (exports.KeyboardGridKeyboardEventAction = KeyboardGridKeyboardEventAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/css/keyboard.css
  var require_keyboard2 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/keyboard.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-grid.js
  var require_keyboard_grid = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-grid.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardGrid = void 0;
      require_keyboard2();
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var ui_extension_1 = require_ui_extension2();
      var action_1 = require_action3();
      var constants_1 = require_constants();
      var KeyboardGrid = class KeyboardGrid extends ui_extension_1.GLSPAbstractUIExtension {
        constructor() {
          super(...arguments);
          this.triggerActions = [];
        }
        id() {
          return constants_1.KeyboardGridMetadata.ID;
        }
        containerClass() {
          return constants_1.KeyboardGridMetadata.ID;
        }
        handle(action) {
          if (action_1.EnableKeyboardGridAction.is(action)) {
            this.triggerActions = action.options.triggerActions;
            this.originId = action.options.originId;
            this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({
              extensionId: constants_1.KeyboardGridMetadata.ID,
              visible: true
            }));
          }
        }
        initializeContents(containerElement) {
          containerElement.tabIndex = constants_1.KeyboardGridMetadata.TAB_INDEX;
          containerElement.classList.add("grid-container");
          for (let i2 = 1; i2 <= 9; i2++) {
            const gridNumber = document.createElement("div");
            const gridItem = document.createElement("div");
            gridItem.classList.add("grid-item");
            gridItem.id = `keyboard-grid-item-${i2}`;
            gridNumber.classList.add("grid-item-number");
            gridNumber.innerHTML = i2.toString();
            gridItem.appendChild(gridNumber);
            containerElement.appendChild(gridItem);
          }
          this.containerElement.onkeydown = (ev) => {
            this.onKeyDown(ev);
          };
        }
        onKeyDown(event) {
          this.activateCellIfDigitEvent(event);
          this.hideIfEscapeEvent(event);
          this.actionDispatcher.dispatch(action_1.KeyboardGridKeyboardEventAction.create({
            originId: this.originId,
            event
          }));
        }
        setContainerVisible(visible) {
          if (this.containerElement) {
            if (visible) {
              this.containerElement.classList.remove("grid-hidden");
              this.containerElement.classList.add("grid-visible");
            } else {
              this.containerElement.classList.remove("grid-visible");
              this.containerElement.classList.add("grid-hidden");
            }
          }
        }
        show(root, ...contextElementIds) {
          super.show(root, ...contextElementIds);
          this.containerElement.focus();
        }
        hideIfEscapeEvent(event) {
          if (this.matchesDeactivateGrid(event)) {
            this.hide();
          }
        }
        activateCellIfDigitEvent(event) {
          let index = void 0;
          for (let i2 = 1; i2 <= 9; i2++) {
            if (this.matchesGridBoxAtIndex(event, i2)) {
              index = i2;
              break;
            }
          }
          if (index !== void 0) {
            const position = this.centerPositionOfCell(index);
            this.dispatchActionsForCell(index, position);
          }
        }
        dispatchActionsForCell(index, cellCenter) {
          this.actionDispatcher.dispatchAll([
            ...this.triggerActions,
            action_1.KeyboardGridCellSelectedAction.create({
              originId: this.originId,
              cellId: index.toString(),
              centerCellPosition: cellCenter
            })
          ]);
        }
        centerPositionOfCell(index) {
          let x3 = 0;
          let y3 = 0;
          const activeGridCell = document.getElementById(`keyboard-grid-item-${index}`);
          if (activeGridCell !== null) {
            const positions = this.getCenterOfCell(activeGridCell);
            x3 = positions[0];
            y3 = positions[1];
          }
          return {
            x: x3,
            y: y3
          };
        }
        matchesDeactivateGrid(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Escape");
        }
        matchesGridBoxAtIndex(event, index) {
          return (0, sprotty_1.matchesKeystroke)(event, "Digit" + index) || (0, sprotty_1.matchesKeystroke)(event, "Numpad" + index);
        }
        // https://www.delftstack.com/howto/javascript/get-position-of-element-in-javascript/
        getOffset(el) {
          let _x = 0;
          let _y = 0;
          while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
            _x += el.offsetLeft - el.scrollLeft;
            _y += el.offsetTop - el.scrollTop;
            el = el.offsetParent;
          }
          return { top: _y, left: _x };
        }
        getCenterOfCell(cell) {
          const cellLeft = this.getOffset(cell).left;
          const cellTop = this.getOffset(cell).top;
          const cellWidth = cell.offsetWidth;
          const cellHeight = cell.offsetHeight;
          const newCellWidth = cellWidth / 2;
          const newCellHeight = cellHeight / 2;
          return [cellLeft + newCellWidth, cellTop + newCellHeight];
        }
      };
      exports.KeyboardGrid = KeyboardGrid;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], KeyboardGrid.prototype, "actionDispatcher", void 0);
      exports.KeyboardGrid = KeyboardGrid = __decorate([
        (0, inversify_1.injectable)()
      ], KeyboardGrid);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-grid-search-palette.js
  var require_keyboard_grid_search_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-grid-search-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GridRevealNamedElementSuggestionProvider = exports.GridRevealEdgeSuggestionProvider = exports.GridSearchPalette = exports.GridSearchPaletteMetadata = void 0;
      require_keyboard2();
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var search_palette_1 = require_search_palette();
      var constants_1 = require_constants();
      var GridSearchPaletteMetadata;
      (function(GridSearchPaletteMetadata2) {
        GridSearchPaletteMetadata2.ID = "grid-search-palette";
      })(GridSearchPaletteMetadata || (exports.GridSearchPaletteMetadata = GridSearchPaletteMetadata = {}));
      var GridSearchPalette = class GridSearchPalette extends search_palette_1.SearchAutocompletePalette {
        id() {
          return GridSearchPaletteMetadata.ID;
        }
        getSuggestionProviders(root, input) {
          return [new GridRevealNamedElementSuggestionProvider(), new GridRevealEdgeSuggestionProvider()];
        }
      };
      exports.GridSearchPalette = GridSearchPalette;
      exports.GridSearchPalette = GridSearchPalette = __decorate([
        (0, inversify_1.injectable)()
      ], GridSearchPalette);
      var GridRevealEdgeSuggestionProvider = class extends search_palette_1.RevealEdgeElementAutocompleteSuggestionProvider {
        getActions(edge) {
          return [
            ...super.getActions(edge),
            sprotty_1.SetUIExtensionVisibilityAction.create({
              extensionId: constants_1.KeyboardGridMetadata.ID,
              visible: true
            })
          ];
        }
      };
      exports.GridRevealEdgeSuggestionProvider = GridRevealEdgeSuggestionProvider;
      var GridRevealNamedElementSuggestionProvider = class extends search_palette_1.RevealNamedElementAutocompleteSuggestionProvider {
        getActions(nameable) {
          return [
            ...super.getActions(nameable),
            sprotty_1.SetUIExtensionVisibilityAction.create({
              extensionId: constants_1.KeyboardGridMetadata.ID,
              visible: true
            })
          ];
        }
      };
      exports.GridRevealNamedElementSuggestionProvider = GridRevealNamedElementSuggestionProvider;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/actions.js
  var require_actions3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetKeyboardPointerRenderPositionAction = void 0;
      var sprotty_1 = require_lib4();
      var SetKeyboardPointerRenderPositionAction;
      (function(SetKeyboardPointerRenderPositionAction2) {
        SetKeyboardPointerRenderPositionAction2.KIND = "setKeyboardPointerRenderPositionAction";
        function is(object) {
          return sprotty_1.Action.hasKind(object, SetKeyboardPointerRenderPositionAction2.KIND) && (0, sprotty_1.hasNumberProp)(object, "x") && (0, sprotty_1.hasNumberProp)(object, "y");
        }
        SetKeyboardPointerRenderPositionAction2.is = is;
        function create(x3, y3) {
          return { kind: SetKeyboardPointerRenderPositionAction2.KIND, x: x3, y: y3 };
        }
        SetKeyboardPointerRenderPositionAction2.create = create;
      })(SetKeyboardPointerRenderPositionAction || (exports.SetKeyboardPointerRenderPositionAction = SetKeyboardPointerRenderPositionAction = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-listener.js
  var require_keyboard_pointer_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-listener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardPointerKeyboardListener = void 0;
      var sprotty_1 = require_lib4();
      var css_feedback_1 = require_css_feedback();
      var tool_1 = require_tool();
      var constants_1 = require_constants();
      var constants_2 = require_constants2();
      var KeyboardPointerKeyboardListener = class {
        get position() {
          return this.keyboardPointer.getPosition;
        }
        constructor(keyboardPointer, actionDispatcher) {
          this.keyboardPointer = keyboardPointer;
          this.actionDispatcher = actionDispatcher;
        }
        keyDown(event) {
          this.moveIfArrows(event);
          this.createIfEnterEvent(event);
          this.hideIfEscapeEvent(event);
        }
        moveIfArrows(event) {
          if (this.matchesMovePointerDown(event)) {
            this.position.renderPosition = this.position.calcRelativeRenderPosition(0, 10);
            this.keyboardPointer.render();
          } else if (this.matchesMovePointerUp(event)) {
            this.position.renderPosition = this.position.calcRelativeRenderPosition(0, -10);
            this.keyboardPointer.render();
          } else if (this.matchesMovePointerRight(event)) {
            this.position.renderPosition = this.position.calcRelativeRenderPosition(10, 0);
            this.keyboardPointer.render();
          } else if (this.matchesMovePointerLeft(event)) {
            this.position.renderPosition = this.position.calcRelativeRenderPosition(-10, 0);
            this.keyboardPointer.render();
          }
        }
        createIfEnterEvent(event) {
          const elementTypeId = this.keyboardPointer.triggerAction.elementTypeId;
          const { container, status } = this.position.containableParentAtDiagramPosition(elementTypeId);
          if (container !== void 0 && status === css_feedback_1.CursorCSS.NODE_CREATION) {
            if (this.matchesConfirmPointerPosition(event)) {
              const containerId = container.id;
              const location2 = this.position.diagramPosition;
              this.actionDispatcher.dispatchAll([
                sprotty_1.SetUIExtensionVisibilityAction.create({
                  extensionId: constants_2.KeyboardPointerMetadata.ID,
                  visible: false,
                  contextElementsId: []
                }),
                sprotty_1.SetUIExtensionVisibilityAction.create({
                  extensionId: constants_1.KeyboardNodeGridMetadata.ID,
                  visible: false,
                  contextElementsId: []
                }),
                sprotty_1.CreateNodeOperation.create(elementTypeId, { location: location2, containerId, args: this.keyboardPointer.triggerAction.args }),
                tool_1.EnableDefaultToolsAction.create()
              ]);
            } else if (this.matchesConfirmPointerPositionAndStayInMode(event)) {
              const containerId = container.id;
              const location2 = this.position.diagramPosition;
              this.actionDispatcher.dispatch(sprotty_1.CreateNodeOperation.create(elementTypeId, { location: location2, containerId, args: this.keyboardPointer.triggerAction.args }));
            }
          }
        }
        hideIfEscapeEvent(event) {
          if (this.matchesDeactivatePointer(event)) {
            this.keyboardPointer.hide();
          }
        }
        matchesDeactivatePointer(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Escape");
        }
        matchesConfirmPointerPosition(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Enter");
        }
        matchesConfirmPointerPositionAndStayInMode(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Enter", "ctrl");
        }
        matchesMovePointerLeft(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowLeft");
        }
        matchesMovePointerRight(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowRight");
        }
        matchesMovePointerUp(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowUp");
        }
        matchesMovePointerDown(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "ArrowDown");
        }
      };
      exports.KeyboardPointerKeyboardListener = KeyboardPointerKeyboardListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-position.js
  var require_keyboard_pointer_position = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-position.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardPointerPosition = void 0;
      var sprotty_1 = require_lib4();
      var css_feedback_1 = require_css_feedback();
      var viewpoint_util_1 = require_viewpoint_util();
      var model_1 = require_model21();
      var constants_1 = require_constants2();
      var KeyboardPointerPosition = class {
        constructor(keyboardPointer) {
          this.keyboardPointer = keyboardPointer;
          this.renderPosition = { x: 20, y: 20 };
        }
        get centerizedRenderPosition() {
          return {
            x: this.renderPosition.x + constants_1.KeyboardPointerMetadata.CIRCLE_WIDTH / 2,
            y: this.renderPosition.y + constants_1.KeyboardPointerMetadata.CRICLE_HEIGHT / 2
          };
        }
        get diagramPosition() {
          return (0, viewpoint_util_1.getAbsolutePositionByPoint)(this.keyboardPointer.editorContextService.modelRoot, this.centerizedRenderPosition);
        }
        childrenAtDiagramPosition() {
          const position = this.diagramPosition;
          return [
            this.keyboardPointer.editorContextService.modelRoot,
            ...(0, sprotty_1.findChildrenAtPosition)(this.keyboardPointer.editorContextService.modelRoot, position)
          ];
        }
        containableParentAtDiagramPosition(elementTypeId) {
          const children = this.childrenAtDiagramPosition();
          return this.containableParentOf(children.reverse()[0], elementTypeId);
        }
        calcRelativeRenderPosition(x3, y3) {
          return {
            x: this.renderPosition.x + x3,
            y: this.renderPosition.y + y3
          };
        }
        containableParentOf(target, elementTypeId) {
          const container = (0, sprotty_1.findParentByFeature)(target, model_1.isContainable);
          return {
            container,
            status: this.keyboardPointer.containerManager.isCreationAllowed(container, elementTypeId) ? css_feedback_1.CursorCSS.NODE_CREATION : css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED
          };
        }
      };
      exports.KeyboardPointerPosition = KeyboardPointerPosition;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer.js
  var require_keyboard_pointer = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardPointer = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var css_feedback_1 = require_css_feedback();
      var ui_extension_1 = require_ui_extension2();
      var container_manager_1 = require_container_manager();
      var action_1 = require_action3();
      var actions_1 = require_actions3();
      var constants_1 = require_constants2();
      var keyboard_pointer_listener_1 = require_keyboard_pointer_listener();
      var keyboard_pointer_position_1 = require_keyboard_pointer_position();
      var KeyboardPointer = class KeyboardPointer extends ui_extension_1.GLSPAbstractUIExtension {
        constructor(actionDispatcher) {
          super();
          this.actionDispatcher = actionDispatcher;
          this._triggerAction = {
            elementTypeId: "task:automated",
            kind: "triggerNodeCreation"
          };
          this.position = new keyboard_pointer_position_1.KeyboardPointerPosition(this);
          this.keyListener = new keyboard_pointer_listener_1.KeyboardPointerKeyboardListener(this, actionDispatcher);
        }
        get triggerAction() {
          return this._triggerAction;
        }
        get isVisible() {
          var _a4;
          return ((_a4 = this.containerElement) === null || _a4 === void 0 ? void 0 : _a4.style.visibility) === "visible";
        }
        get getPosition() {
          return this.position;
        }
        get getKeyListener() {
          return this.keyListener;
        }
        id() {
          return constants_1.KeyboardPointerMetadata.ID;
        }
        containerClass() {
          return constants_1.KeyboardPointerMetadata.ID;
        }
        initializeContents(containerElement) {
          containerElement.style.position = "absolute";
          containerElement.style.height = `${constants_1.KeyboardPointerMetadata.CRICLE_HEIGHT}px`;
          containerElement.style.width = `${constants_1.KeyboardPointerMetadata.CIRCLE_WIDTH}px`;
          containerElement.style.borderRadius = "100%";
        }
        onBeforeShow(containerElement, root, ...selectedElementIds) {
          this.render();
        }
        handle(action) {
          if (sprotty_1.TriggerNodeCreationAction.is(action)) {
            this._triggerAction = action;
          } else if (actions_1.SetKeyboardPointerRenderPositionAction.is(action)) {
            this.position.renderPosition = { x: action.x, y: action.y };
            this.render();
          } else if (action_1.KeyboardGridCellSelectedAction.is(action) && action.options.originId === constants_1.KeyboardPointerMetadata.ID) {
            this.position.renderPosition = action.options.centerCellPosition;
            this.render();
          }
        }
        render() {
          if (this.containerElement !== void 0) {
            const { x: x3, y: y3 } = this.position.renderPosition;
            this.containerElement.style.left = `${x3}px`;
            this.containerElement.style.top = `${y3}px`;
            const { status } = this.position.containableParentAtDiagramPosition(this._triggerAction.elementTypeId);
            this.containerElement.style.borderStyle = "solid";
            this.containerElement.style.borderWidth = "thick";
            switch (status) {
              case css_feedback_1.CursorCSS.NODE_CREATION: {
                this.containerElement.style.borderColor = "green";
                break;
              }
              case css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED: {
                this.containerElement.style.borderColor = "red";
                break;
              }
            }
          }
        }
      };
      exports.KeyboardPointer = KeyboardPointer;
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], KeyboardPointer.prototype, "editorContextService", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IContainerManager),
        __metadata("design:type", container_manager_1.ContainerManager)
      ], KeyboardPointer.prototype, "containerManager", void 0);
      exports.KeyboardPointer = KeyboardPointer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher)),
        __metadata("design:paramtypes", [Object])
      ], KeyboardPointer);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-node-grid.js
  var require_keyboard_node_grid = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-grid/keyboard-node-grid.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardNodeGrid = void 0;
      require_keyboard2();
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var constants_1 = require_constants2();
      var keyboard_pointer_1 = require_keyboard_pointer();
      var constants_2 = require_constants();
      var keyboard_grid_1 = require_keyboard_grid();
      var keyboard_grid_search_palette_1 = require_keyboard_grid_search_palette();
      var KeyboardNodeGrid = class KeyboardNodeGrid extends keyboard_grid_1.KeyboardGrid {
        constructor() {
          super(...arguments);
          this.triggerActions = [sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: constants_1.KeyboardPointerMetadata.ID, visible: true })];
          this.originId = constants_1.KeyboardPointerMetadata.ID;
        }
        id() {
          return constants_2.KeyboardNodeGridMetadata.ID;
        }
        handle(action) {
        }
        onKeyDown(event) {
          super.onKeyDown(event);
          this.showSearchOnEvent(event);
          if (this.keyboardPointer.isVisible) {
            this.keyboardPointer.getKeyListener.keyDown(event);
          }
        }
        showSearchOnEvent(event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "KeyF", "ctrl")) {
            event.preventDefault();
            this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({
              extensionId: keyboard_grid_search_palette_1.GridSearchPaletteMetadata.ID,
              visible: true
            }));
            this.hide();
          }
        }
      };
      exports.KeyboardNodeGrid = KeyboardNodeGrid;
      __decorate([
        (0, inversify_1.inject)(keyboard_pointer_1.KeyboardPointer),
        __metadata("design:type", keyboard_pointer_1.KeyboardPointer)
      ], KeyboardNodeGrid.prototype, "keyboardPointer", void 0);
      exports.KeyboardNodeGrid = KeyboardNodeGrid = __decorate([
        (0, inversify_1.injectable)()
      ], KeyboardNodeGrid);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-module.js
  var require_keyboard_pointer_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-pointer/keyboard-pointer-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureKeyboardControlTools = exports.keyboardControlModule = void 0;
      var sprotty_1 = require_lib4();
      var action_1 = require_action2();
      var edge_autocomplete_palette_1 = require_edge_autocomplete_palette();
      var edge_autocomplete_tool_1 = require_edge_autocomplete_tool();
      var global_keylistener_tool_1 = require_global_keylistener_tool();
      var action_2 = require_action3();
      var keyboard_grid_1 = require_keyboard_grid();
      var keyboard_grid_search_palette_1 = require_keyboard_grid_search_palette();
      var keyboard_node_grid_1 = require_keyboard_node_grid();
      var actions_1 = require_actions3();
      var keyboard_pointer_1 = require_keyboard_pointer();
      exports.keyboardControlModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureKeyboardControlTools(context);
      }, { featureId: Symbol("keyboardControl") });
      function configureKeyboardControlTools(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, global_keylistener_tool_1.GlobalKeyListenerTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_pointer_1.KeyboardPointer);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_grid_1.KeyboardGrid);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_node_grid_1.KeyboardNodeGrid);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.TriggerNodeCreationAction.KIND, keyboard_pointer_1.KeyboardPointer);
        (0, sprotty_1.configureActionHandler)(context, actions_1.SetKeyboardPointerRenderPositionAction.KIND, keyboard_pointer_1.KeyboardPointer);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, edge_autocomplete_palette_1.EdgeAutocompletePalette);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, edge_autocomplete_tool_1.EdgeAutocompletePaletteTool);
        (0, sprotty_1.configureActionHandler)(context, action_2.EnableKeyboardGridAction.KIND, keyboard_grid_1.KeyboardGrid);
        (0, sprotty_1.configureActionHandler)(context, action_2.KeyboardGridCellSelectedAction.KIND, keyboard_pointer_1.KeyboardPointer);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.TriggerEdgeCreationAction.KIND, edge_autocomplete_palette_1.EdgeAutocompletePalette);
        (0, sprotty_1.configureActionHandler)(context, action_1.SetEdgeTargetSelectionAction.KIND, edge_autocomplete_palette_1.EdgeAutocompletePalette);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_grid_search_palette_1.GridSearchPalette);
      }
      exports.configureKeyboardControlTools = configureKeyboardControlTools;
    }
  });

  // node_modules/@eclipse-glsp/client/css/keyboard-tool-palette.css
  var require_keyboard_tool_palette = __commonJS({
    "node_modules/@eclipse-glsp/client/css/keyboard-tool-palette.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-tool-palette/keyboard-tool-palette.js
  var require_keyboard_tool_palette2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-tool-palette/keyboard-tool-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyboardToolPalette = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var messages_1 = require_messages3();
      var tool_1 = require_tool();
      var tool_palette_1 = require_tool_palette3();
      var delete_tool_1 = require_delete_tool();
      var marquee_mouse_tool_1 = require_marquee_mouse_tool();
      var actions_1 = require_actions2();
      var edge_autocomplete_palette_1 = require_edge_autocomplete_palette();
      var diagram_navigation_tool_1 = require_diagram_navigation_tool();
      var constants_1 = require_constants();
      var toast_handler_1 = require_toast_handler();
      var SEARCH_ICON_ID = "search";
      var SELECTION_TOOL_KEY = ["Digit1", "Numpad1"];
      var DELETION_TOOL_KEY = ["Digit2", "Numpad2"];
      var MARQUEE_TOOL_KEY = ["Digit3", "Numpad3"];
      var VALIDATION_TOOL_KEY = ["Digit4", "Numpad4"];
      var SEARCH_TOOL_KEY = ["Digit5", "Numpad5"];
      var SHOW_SHORTCUTS_CLASS = "accessibility-show-shortcuts";
      var AVAILABLE_KEYS = [
        "KeyA",
        "KeyB",
        "KeyC",
        "KeyD",
        "KeyE",
        "KeyF",
        "KeyG",
        "KeyH",
        "KeyI",
        "KeyJ",
        "KeyK",
        "KeyL",
        "KeyM",
        "KeyN",
        "KeyO",
        "KeyP",
        "KeyQ",
        "KeyR",
        "KeyS",
        "KeyT",
        "KeyU",
        "KeyV",
        "KeyX",
        "KeyY",
        "KeyZ"
      ];
      var HEADER_TOOL_KEYS = [SELECTION_TOOL_KEY, DELETION_TOOL_KEY, MARQUEE_TOOL_KEY, VALIDATION_TOOL_KEY, SEARCH_TOOL_KEY];
      var KeyboardToolPalette = class KeyboardToolPalette extends tool_palette_1.ToolPalette {
        constructor() {
          super(...arguments);
          this.keyboardIndexButtonMapping = /* @__PURE__ */ new Map();
          this.headerToolsButtonMapping = /* @__PURE__ */ new Map();
        }
        get interactablePaletteItems() {
          return this.paletteItems.sort(tool_palette_1.compare).map((item) => {
            var _a4, _b2;
            return (_b2 = (_a4 = item.children) === null || _a4 === void 0 ? void 0 : _a4.sort(tool_palette_1.compare)) !== null && _b2 !== void 0 ? _b2 : [item];
          }).reduce((acc, val) => acc.concat(val), []);
        }
        initializeContents(_containerElement) {
          this.containerElement.setAttribute("aria-label", messages_1.messages.tool_palette.label);
          this.containerElement.tabIndex = 20;
          this.containerElement.classList.add("accessibility-tool-palette");
          this.addMinimizePaletteButton();
          this.createHeader();
          this.createBody();
          this.lastActiveButton = this.defaultToolsButton;
          this.containerElement.onkeyup = (ev) => {
            this.clearToolOnEscape(ev);
            if (this.isShortcutsVisible()) {
              this.selectItemOnCharacter(ev);
              this.triggerHeaderToolsByKey(ev);
            }
          };
        }
        handle(action) {
          if (tool_palette_1.EnableToolPaletteAction.is(action)) {
            const requestAction = sprotty_1.RequestContextActions.create({
              contextId: tool_palette_1.ToolPalette.ID,
              editorContext: {
                selectedElementIds: []
              }
            });
            this.actionDispatcher.requestUntil(requestAction).then((response) => {
              if (sprotty_1.SetContextActions.is(response)) {
                this.paletteItems = response.actions.map((e2) => e2);
                this.actionDispatcher.dispatchAll([
                  sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: tool_palette_1.ToolPalette.ID, visible: !this.editorContext.isReadonly })
                ]);
              }
            });
          } else if (actions_1.FocusDomAction.is(action) && action.id === tool_palette_1.ToolPalette.ID) {
            if (this.containerElement.contains(document.activeElement)) {
              this.toggleShortcutVisibility();
            } else {
              this.showShortcuts();
            }
            this.containerElement.focus();
          } else {
            super.handle(action);
          }
        }
        createBody() {
          const bodyDiv = document.createElement("div");
          bodyDiv.classList.add("palette-body");
          const tabIndex = 21;
          let toolButtonCounter = 0;
          this.keyboardIndexButtonMapping.clear();
          this.paletteItems.sort(tool_palette_1.compare).forEach((item) => {
            if (item.children) {
              const group = (0, tool_palette_1.createToolGroup)(item);
              item.children.sort(tool_palette_1.compare).forEach((child) => {
                const button = this.createKeyboardToolButton(child, tabIndex, toolButtonCounter);
                group.appendChild(button);
                this.keyboardIndexButtonMapping.set(toolButtonCounter, button);
                toolButtonCounter++;
              });
              bodyDiv.appendChild(group);
            } else {
              const button = this.createKeyboardToolButton(item, tabIndex, toolButtonCounter);
              bodyDiv.appendChild(button);
              this.keyboardIndexButtonMapping.set(toolButtonCounter, button);
              toolButtonCounter++;
            }
          });
          if (this.paletteItems.length === 0) {
            const noResultsDiv = document.createElement("div");
            noResultsDiv.innerText = messages_1.messages.tool_palette.no_items;
            noResultsDiv.classList.add("tool-button");
            bodyDiv.appendChild(noResultsDiv);
          }
          if (this.bodyDiv) {
            this.containerElement.removeChild(this.bodyDiv);
          }
          this.containerElement.appendChild(bodyDiv);
          this.bodyDiv = bodyDiv;
        }
        createHeaderTools() {
          this.headerToolsButtonMapping.clear();
          let mappingIndex = 0;
          const headerTools = document.createElement("div");
          headerTools.classList.add("header-tools");
          this.defaultToolsButton = this.createDefaultToolButton();
          this.headerToolsButtonMapping.set(mappingIndex++, this.defaultToolsButton);
          headerTools.appendChild(this.defaultToolsButton);
          this.deleteToolButton = this.createMouseDeleteToolButton();
          this.headerToolsButtonMapping.set(mappingIndex++, this.deleteToolButton);
          headerTools.appendChild(this.deleteToolButton);
          this.marqueeToolButton = this.createMarqueeToolButton();
          this.headerToolsButtonMapping.set(mappingIndex++, this.marqueeToolButton);
          headerTools.appendChild(this.marqueeToolButton);
          this.validateToolButton = this.createValidateButton();
          this.headerToolsButtonMapping.set(mappingIndex++, this.validateToolButton);
          headerTools.appendChild(this.validateToolButton);
          const resetViewportButton = this.createResetViewportButton();
          this.headerToolsButtonMapping.set(mappingIndex++, resetViewportButton);
          headerTools.appendChild(resetViewportButton);
          if (this.gridManager) {
            const toggleGridButton = this.createToggleGridButton();
            this.headerToolsButtonMapping.set(mappingIndex++, toggleGridButton);
            headerTools.appendChild(toggleGridButton);
          }
          if (this.debugManager) {
            const toggleDebugButton = this.createToggleDebugButton();
            this.headerToolsButtonMapping.set(mappingIndex++, toggleDebugButton);
            headerTools.appendChild(toggleDebugButton);
          }
          this.searchToolButton = this.createSearchButton();
          this.headerToolsButtonMapping.set(mappingIndex++, this.searchToolButton);
          headerTools.appendChild(this.searchToolButton);
          return headerTools;
        }
        createDefaultToolButton() {
          const button = (0, tool_palette_1.createIcon)("inspect");
          button.id = "btn_default_tools";
          button.title = messages_1.messages.tool_palette.selection_button;
          button.onclick = this.onClickStaticToolButton(button);
          button.appendChild(this.createKeyboardShotcut(SELECTION_TOOL_KEY[0]));
          return button;
        }
        createMouseDeleteToolButton() {
          const deleteToolButton = (0, tool_palette_1.createIcon)("chrome-close");
          deleteToolButton.title = messages_1.messages.tool_palette.delete_button;
          deleteToolButton.onclick = this.onClickStaticToolButton(deleteToolButton, delete_tool_1.MouseDeleteTool.ID);
          deleteToolButton.appendChild(this.createKeyboardShotcut(DELETION_TOOL_KEY[0]));
          return deleteToolButton;
        }
        createMarqueeToolButton() {
          const marqueeToolButton = (0, tool_palette_1.createIcon)("screen-full");
          marqueeToolButton.title = messages_1.messages.tool_palette.marquee_button;
          const toastMessageAction = toast_handler_1.ShowToastMessageAction.createWithTimeout({
            id: Symbol.for(diagram_navigation_tool_1.ElementNavigatorKeyListener.name),
            message: messages_1.messages.tool_palette.marquee_message
          });
          marqueeToolButton.onclick = this.onClickStaticToolButton(marqueeToolButton, marquee_mouse_tool_1.MarqueeMouseTool.ID, toastMessageAction);
          marqueeToolButton.appendChild(this.createKeyboardShotcut(MARQUEE_TOOL_KEY[0]));
          return marqueeToolButton;
        }
        createValidateButton() {
          const validateToolButton = (0, tool_palette_1.createIcon)("pass");
          validateToolButton.title = messages_1.messages.tool_palette.validate_button;
          validateToolButton.onclick = (_event) => {
            const modelIds = [this.modelRootId];
            this.actionDispatcher.dispatch(sprotty_1.RequestMarkersAction.create(modelIds));
          };
          validateToolButton.appendChild(this.createKeyboardShotcut(VALIDATION_TOOL_KEY[0]));
          return validateToolButton;
        }
        onClickStaticToolButton(button, toolId, action) {
          return (_ev) => {
            if (!this.editorContext.isReadonly) {
              const defaultAction = toolId ? tool_1.EnableToolsAction.create([toolId]) : tool_1.EnableDefaultToolsAction.create();
              if (action) {
                this.actionDispatcher.dispatchAll([defaultAction, action]);
              } else {
                this.actionDispatcher.dispatchAll([defaultAction]);
              }
              this.changeActiveButton(button);
              button.focus();
            }
          };
        }
        createSearchButton() {
          const searchIcon = (0, tool_palette_1.createIcon)(SEARCH_ICON_ID);
          searchIcon.onclick = (_ev) => {
            const searchField = document.getElementById(this.containerElement.id + "_search_field");
            if (searchField) {
              if (searchField.style.display === "none") {
                searchField.style.display = "";
                searchField.focus();
              } else {
                searchField.style.display = "none";
              }
            }
          };
          searchIcon.classList.add("search-icon");
          searchIcon.title = messages_1.messages.tool_palette.search_button;
          searchIcon.appendChild(this.createKeyboardShotcut(SEARCH_TOOL_KEY[0]));
          return searchIcon;
        }
        createHeaderSearchField() {
          const searchField = document.createElement("input");
          searchField.classList.add("search-input");
          searchField.tabIndex = 21;
          searchField.id = this.containerElement.id + "_search_field";
          searchField.type = "text";
          searchField.placeholder = messages_1.messages.tool_palette.search_placeholder;
          searchField.style.display = "none";
          searchField.onkeyup = (ev) => {
            this.requestFilterUpdate(this.searchField.value);
            ev.stopPropagation();
            if (searchField.value === "") {
              this.focusToolPaletteOnEscape(ev);
            } else {
              this.clearOnEscape(ev);
            }
          };
          return searchField;
        }
        focusToolPaletteOnEscape(event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            this.containerElement.focus();
          }
        }
        createKeyboardShotcut(keyShortcut) {
          const hint = document.createElement("div");
          hint.classList.add("key-shortcut");
          let keyShortcutValue = keyShortcut.toString();
          if (keyShortcut.includes("Key")) {
            keyShortcutValue = keyShortcut.toString().substring(3);
          } else if (keyShortcut.includes("Digit")) {
            keyShortcutValue = keyShortcut.toString().substring(5);
          }
          hint.innerHTML = keyShortcutValue;
          return hint;
        }
        createKeyboardToolButton(item, tabIndex, buttonIndex) {
          const button = document.createElement("div");
          if (buttonIndex < AVAILABLE_KEYS.length) {
            button.appendChild(this.createKeyboardShotcut(AVAILABLE_KEYS[buttonIndex]));
          }
          button.tabIndex = tabIndex;
          button.classList.add("tool-button");
          if (item.icon) {
            button.appendChild((0, tool_palette_1.createIcon)(item.icon));
          }
          button.insertAdjacentText("beforeend", item.label);
          button.onclick = this.onClickCreateToolButton(button, item);
          button.onkeydown = (ev) => {
            this.clickToolOnEnter(ev, button, item);
            this.clearToolOnEscape(ev);
            if ((0, sprotty_1.matchesKeystroke)(ev, "ArrowDown")) {
              if (buttonIndex + 1 > this.keyboardIndexButtonMapping.size - 1) {
                this.selectItemViaArrowKey(this.keyboardIndexButtonMapping.get(0));
              } else {
                this.selectItemViaArrowKey(this.keyboardIndexButtonMapping.get(buttonIndex + 1));
              }
            } else if ((0, sprotty_1.matchesKeystroke)(ev, "ArrowUp")) {
              if (buttonIndex - 1 < 0) {
                this.selectItemViaArrowKey(this.keyboardIndexButtonMapping.get(this.keyboardIndexButtonMapping.size - 1));
              } else {
                this.selectItemViaArrowKey(this.keyboardIndexButtonMapping.get(buttonIndex - 1));
              }
            }
          };
          return button;
        }
        clickToolOnEnter(event, button, item) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Enter")) {
            if (!this.editorContext.isReadonly) {
              this.actionDispatcher.dispatchAll(item.actions);
              this.changeActiveButton(button);
              this.selectItemOnCharacter(event);
            }
          }
        }
        selectItemOnCharacter(event) {
          var _a4;
          let index = void 0;
          const items = this.interactablePaletteItems;
          const itemsCount = items.length < AVAILABLE_KEYS.length ? items.length : AVAILABLE_KEYS.length;
          for (let i2 = 0; i2 < itemsCount; i2++) {
            const keycode = AVAILABLE_KEYS[i2];
            if ((0, sprotty_1.matchesKeystroke)(event, keycode)) {
              index = i2;
              break;
            }
          }
          if (index !== void 0) {
            if (items[index].actions.some((a3) => a3.kind === sprotty_1.TriggerNodeCreationAction.KIND)) {
              this.actionDispatcher.dispatchAll([
                ...items[index].actions,
                sprotty_1.SetUIExtensionVisibilityAction.create({
                  extensionId: constants_1.KeyboardNodeGridMetadata.ID,
                  visible: true,
                  contextElementsId: []
                })
              ]);
            } else {
              this.actionDispatcher.dispatchAll([
                ...items[index].actions,
                sprotty_1.SetUIExtensionVisibilityAction.create({
                  extensionId: edge_autocomplete_palette_1.EdgeAutocompletePaletteMetadata.ID,
                  visible: true,
                  contextElementsId: []
                })
              ]);
            }
            this.changeActiveButton(this.keyboardIndexButtonMapping.get(index));
            (_a4 = this.keyboardIndexButtonMapping.get(index)) === null || _a4 === void 0 ? void 0 : _a4.focus();
          }
        }
        triggerHeaderToolsByKey(event) {
          var _a4;
          let index = void 0;
          for (let i2 = 0; i2 < HEADER_TOOL_KEYS.length; i2++) {
            for (let j3 = 0; j3 < HEADER_TOOL_KEYS[i2].length; j3++) {
              const keycode = HEADER_TOOL_KEYS[i2][j3];
              if ((0, sprotty_1.matchesKeystroke)(event, keycode)) {
                event.stopPropagation();
                event.preventDefault();
                index = i2;
                break;
              }
            }
          }
          if (index !== void 0) {
            (_a4 = this.headerToolsButtonMapping.get(index)) === null || _a4 === void 0 ? void 0 : _a4.click();
          }
        }
        selectItemViaArrowKey(currentButton) {
          if (currentButton !== void 0) {
            this.changeActiveButton(currentButton);
            currentButton === null || currentButton === void 0 ? void 0 : currentButton.focus();
          }
        }
        clearToolOnEscape(event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "Escape")) {
            if (event.target instanceof HTMLElement) {
              event.target.blur();
            }
            this.actionDispatcher.dispatch(tool_1.EnableDefaultToolsAction.create());
          }
        }
        toggleShortcutVisibility() {
          if (this.isShortcutsVisible()) {
            this.hideShortcuts();
          } else {
            this.showShortcuts();
          }
        }
        isShortcutsVisible() {
          return this.containerElement.classList.contains(SHOW_SHORTCUTS_CLASS);
        }
        showShortcuts() {
          this.containerElement.classList.add(SHOW_SHORTCUTS_CLASS);
        }
        hideShortcuts() {
          this.containerElement.classList.remove(SHOW_SHORTCUTS_CLASS);
        }
      };
      exports.KeyboardToolPalette = KeyboardToolPalette;
      exports.KeyboardToolPalette = KeyboardToolPalette = __decorate([
        (0, inversify_1.injectable)()
      ], KeyboardToolPalette);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-tool-palette/keyboard-tool-palette-module.js
  var require_keyboard_tool_palette_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/keyboard-tool-palette/keyboard-tool-palette-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureKeyboardToolPaletteTool = exports.keyboardToolPaletteModule = void 0;
      require_keyboard_tool_palette();
      var sprotty_1 = require_lib4();
      var tool_1 = require_tool();
      var tool_palette_1 = require_tool_palette3();
      var actions_1 = require_actions2();
      var keyboard_tool_palette_1 = require_keyboard_tool_palette2();
      exports.keyboardToolPaletteModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureKeyboardToolPaletteTool(context);
      }, { featureId: Symbol("keyboardToolPalette") });
      function configureKeyboardToolPaletteTool(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, keyboard_tool_palette_1.KeyboardToolPalette);
        context.bind(sprotty_1.TYPES.IDiagramStartup).toService(keyboard_tool_palette_1.KeyboardToolPalette);
        (0, sprotty_1.configureActionHandler)(context, tool_1.EnableDefaultToolsAction.KIND, keyboard_tool_palette_1.KeyboardToolPalette);
        (0, sprotty_1.configureActionHandler)(context, actions_1.FocusDomAction.KIND, keyboard_tool_palette_1.KeyboardToolPalette);
        (0, sprotty_1.configureActionHandler)(context, tool_palette_1.EnableToolPaletteAction.KIND, keyboard_tool_palette_1.KeyboardToolPalette);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.UpdateModelAction.KIND, keyboard_tool_palette_1.KeyboardToolPalette);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetModelAction.KIND, keyboard_tool_palette_1.KeyboardToolPalette);
      }
      exports.configureKeyboardToolPaletteTool = configureKeyboardToolPaletteTool;
    }
  });

  // node_modules/@eclipse-glsp/client/css/search.css
  var require_search = __commonJS({
    "node_modules/@eclipse-glsp/client/css/search.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-palette-module.js
  var require_search_palette_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/search/search-palette-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureSearchPaletteModule = exports.searchPaletteModule = void 0;
      var sprotty_1 = require_lib4();
      require_search();
      var search_palette_1 = require_search_palette();
      var search_tool_1 = require_search_tool();
      exports.searchPaletteModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, rebind) => {
        const context = { bind, isBound, rebind };
        configureSearchPaletteModule(context);
      }, { featureId: Symbol("searchPalette") });
      function configureSearchPaletteModule(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, search_palette_1.SearchAutocompletePalette);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, search_tool_1.SearchAutocompletePaletteTool);
      }
      exports.configureSearchPaletteModule = configureSearchPaletteModule;
    }
  });

  // node_modules/@eclipse-glsp/client/css/toast.css
  var require_toast = __commonJS({
    "node_modules/@eclipse-glsp/client/css/toast.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-tool.js
  var require_toast_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var Toast_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Toast = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var ui_extension_1 = require_ui_extension2();
      var toast_handler_1 = require_toast_handler();
      var Toast = Toast_1 = class Toast extends ui_extension_1.GLSPAbstractUIExtension {
        constructor() {
          super(...arguments);
          this.messages = {};
        }
        id() {
          return Toast_1.ID;
        }
        containerClass() {
          return Toast_1.ID;
        }
        initializeContents(_containerElement) {
          this.render();
        }
        handle(action) {
          if (toast_handler_1.ShowToastMessageAction.is(action)) {
            this.messages[action.options.id] = action.options;
            this.render();
            if (action.options.timeout) {
              setTimeout(() => {
                this.delete(action.options.id);
              }, action.options.timeout);
            }
          } else if (toast_handler_1.HideToastAction.is(action)) {
            if (action.options.timeout) {
              setTimeout(() => {
                this.delete(action.options.id);
              }, action.options.timeout);
            } else {
              this.delete(action.options.id);
            }
          }
        }
        render() {
          if (this.containerElement === void 0) {
            return;
          }
          this.containerElement.innerHTML = "";
          this.values(this.messages).forEach((message) => {
            this.containerElement.appendChild(this.createToastMessage(message));
          });
        }
        delete(id) {
          delete this.messages[id];
          this.render();
        }
        createToastMessage(option) {
          const cell = document.createElement("div");
          cell.classList.add("toast-cell", `toast-column-${option.position}`);
          const container = document.createElement("div");
          container.classList.add("toast-container");
          const text = document.createElement("span");
          text.textContent = option.message;
          container.appendChild(text);
          cell.appendChild(container);
          return cell;
        }
        preInitialize() {
          this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({ extensionId: Toast_1.ID, visible: true }));
        }
        values(obj) {
          return Object.getOwnPropertySymbols(obj).map((s3) => obj[s3]);
        }
      };
      exports.Toast = Toast;
      Toast.ID = "toast";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], Toast.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], Toast.prototype, "editorContext", void 0);
      exports.Toast = Toast = Toast_1 = __decorate([
        (0, inversify_1.injectable)()
      ], Toast);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-module.js
  var require_toast_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/toast/toast-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.glspToastModule = exports.configureToastTool = exports.toastModule = void 0;
      var sprotty_1 = require_lib4();
      require_toast();
      var toast_handler_1 = require_toast_handler();
      var toast_tool_1 = require_toast_tool();
      exports.toastModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureToastTool(context);
      }, { featureId: Symbol("toast") });
      exports.glspToastModule = exports.toastModule;
      function configureToastTool(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IUIExtension, toast_tool_1.Toast);
        context.bind(sprotty_1.TYPES.IDiagramStartup).toService(toast_tool_1.Toast);
        (0, sprotty_1.configureActionHandler)(context, toast_handler_1.ShowToastMessageAction.KIND, toast_tool_1.Toast);
        (0, sprotty_1.configureActionHandler)(context, toast_handler_1.HideToastAction.KIND, toast_tool_1.Toast);
      }
      exports.configureToastTool = configureToastTool;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/deselect-key-tool.js
  var require_deselect_key_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/deselect-key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var DeselectKeyTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeselectKeyListener = exports.DeselectKeyTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var edge_edit_tool_feedback_1 = require_edge_edit_tool_feedback();
      var DeselectKeyTool = DeselectKeyTool_1 = class DeselectKeyTool {
        constructor() {
          this.isEditTool = true;
          this.deselectKeyListener = new DeselectKeyListener();
        }
        get id() {
          return DeselectKeyTool_1.ID;
        }
        enable() {
          this.keytool.register(this.deselectKeyListener);
        }
        disable() {
          this.keytool.deregister(this.deselectKeyListener);
        }
      };
      exports.DeselectKeyTool = DeselectKeyTool;
      DeselectKeyTool.ID = "glsp.deselect-key-tool";
      __decorate([
        (0, inversify_1.inject)(sprotty_1.KeyTool),
        __metadata("design:type", sprotty_1.KeyTool)
      ], DeselectKeyTool.prototype, "keytool", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IToolManager),
        __metadata("design:type", Object)
      ], DeselectKeyTool.prototype, "toolManager", void 0);
      exports.DeselectKeyTool = DeselectKeyTool = DeselectKeyTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], DeselectKeyTool);
      var DeselectKeyListener = class extends sprotty_1.KeyListener {
        keyDown(target, event) {
          if (this.matchesDeselectKeystroke(event)) {
            const deselect = (0, sprotty_1.toArray)(target.root.index.all().filter((element) => (0, sprotty_1.isSelectable)(element) && element.selected));
            const actions = [];
            if (deselect.length > 0) {
              actions.push(sprotty_1.SelectAction.create({ deselectedElementsIDs: deselect.map((e2) => e2.id) }));
            }
            const routableDeselect = deselect.filter((e2) => e2 instanceof sprotty_1.GRoutableElement).map((e2) => e2.id);
            if (routableDeselect.length > 0) {
              actions.push(edge_edit_tool_feedback_1.SwitchRoutingModeAction.create({ elementsToDeactivate: routableDeselect }));
            }
            return actions;
          }
          return [];
        }
        matchesDeselectKeystroke(event) {
          return (0, sprotty_1.matchesKeystroke)(event, "Escape");
        }
      };
      exports.DeselectKeyListener = DeselectKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/grid-cell-zoom-key-tool.js
  var require_grid_cell_zoom_key_tool = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/grid-cell-zoom-key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var GridCellZoomTool_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GridZoomKeyListener = exports.GridCellZoomTool = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var messages_1 = require_messages3();
      var selection_service_1 = require_selection_service();
      var viewpoint_util_1 = require_viewpoint_util();
      var base_tools_1 = require_base_tools();
      var diagram_navigation_tool_1 = require_diagram_navigation_tool();
      var action_1 = require_action3();
      var toast_handler_1 = require_toast_handler();
      var GridCellZoomTool = GridCellZoomTool_1 = class GridCellZoomTool extends base_tools_1.BaseTool {
        constructor() {
          super(...arguments);
          this.zoomKeyListener = new GridZoomKeyListener(this);
        }
        get id() {
          return GridCellZoomTool_1.ID;
        }
        enable() {
          this.toDisposeOnDisable.push(this.keyTool.registerListener(this.zoomKeyListener), (0, messages_1.repeatOnMessagesUpdated)(() => this.shortcutManager.register(GridCellZoomTool_1.TOKEN, [
            {
              shortcuts: ["CTRL", "+"],
              description: messages_1.messages.grid.shortcut_zoom_in,
              group: messages_1.messages.shortcut.group_zoom,
              position: 0
            }
          ])));
        }
        handle(action) {
          if ((0, sprotty_1.isViewport)(this.editorContext.modelRoot)) {
            let viewportAction = void 0;
            if (action_1.KeyboardGridCellSelectedAction.is(action) && action.options.originId === GridCellZoomTool_1.ID) {
              viewportAction = this.zoomKeyListener.setNewZoomFactor(this.editorContext.modelRoot, this.zoomFactors.in, (0, viewpoint_util_1.getAbsolutePositionByPoint)(this.editorContext.modelRoot, action.options.centerCellPosition));
            } else if (action_1.KeyboardGridKeyboardEventAction.is(action) && action.options.originId === GridCellZoomTool_1.ID) {
              if ((0, sprotty_1.matchesKeystroke)(action.options.event, "Minus")) {
                viewportAction = this.zoomKeyListener.setNewZoomFactor(this.editorContext.modelRoot, this.zoomFactors.out);
              } else if ((0, sprotty_1.matchesKeystroke)(action.options.event, "Digit0", "ctrl")) {
                viewportAction = sprotty_1.CenterAction.create([]);
              }
            }
            if (viewportAction) {
              this.actionDispatcher.dispatchAll([
                viewportAction,
                toast_handler_1.HideToastAction.create({ id: Symbol.for(diagram_navigation_tool_1.ElementNavigatorKeyListener.name) })
              ]);
            }
          }
        }
      };
      exports.GridCellZoomTool = GridCellZoomTool;
      GridCellZoomTool.ID = "glsp.accessibility-grid-cell-zoom-tool";
      GridCellZoomTool.TOKEN = Symbol.for(GridCellZoomTool_1.name);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
        __metadata("design:type", Object)
      ], GridCellZoomTool.prototype, "shortcutManager", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ZoomFactors),
        __metadata("design:type", Object)
      ], GridCellZoomTool.prototype, "zoomFactors", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], GridCellZoomTool.prototype, "selectionService", void 0);
      exports.GridCellZoomTool = GridCellZoomTool = GridCellZoomTool_1 = __decorate([
        (0, inversify_1.injectable)()
      ], GridCellZoomTool);
      var GridZoomKeyListener = class extends sprotty_1.KeyListener {
        constructor(tool) {
          super();
          this.tool = tool;
        }
        setNewZoomFactor(viewport, zoomFactor, point) {
          let newViewport;
          const newZoom = viewport.zoom * zoomFactor;
          if (point) {
            newViewport = {
              scroll: {
                x: point.x - 0.5 * viewport.canvasBounds.width / newZoom,
                y: point.y - 0.5 * viewport.canvasBounds.height / newZoom
              },
              zoom: newZoom
            };
          } else {
            newViewport = {
              scroll: viewport.scroll,
              zoom: newZoom
            };
          }
          return sprotty_1.SetViewportAction.create(viewport.id, newViewport, { animate: false });
        }
        keyDown(element, event) {
          if (this.matchesZoomViaGrid(event)) {
            return [
              action_1.EnableKeyboardGridAction.create({
                originId: GridCellZoomTool.ID,
                triggerActions: []
              }),
              toast_handler_1.ShowToastMessageAction.createWithTimeout({
                id: Symbol.for(diagram_navigation_tool_1.ElementNavigatorKeyListener.name),
                message: messages_1.messages.grid.zoom_in_grid
              })
            ];
          }
          return [];
        }
        matchesZoomViaGrid(event) {
          return event.key === "+" && event.ctrlKey;
        }
      };
      exports.GridZoomKeyListener = GridZoomKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/view-key-tools-module.js
  var require_view_key_tools_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/view-key-tools/view-key-tools-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureViewKeyTools = exports.viewKeyToolsModule = void 0;
      var sprotty_1 = require_lib4();
      var viewport_modules_1 = require_viewport_modules();
      var action_1 = require_action3();
      var deselect_key_tool_1 = require_deselect_key_tool();
      var grid_cell_zoom_key_tool_1 = require_grid_cell_zoom_key_tool();
      exports.viewKeyToolsModule = new sprotty_1.FeatureModule((bind, _unbind, isBound, rebind) => {
        const context = { bind, isBound, rebind };
        configureViewKeyTools(context);
      }, {
        featureId: Symbol("viewKeyTools"),
        requires: viewport_modules_1.viewportModule
      });
      function configureViewKeyTools(context) {
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, grid_cell_zoom_key_tool_1.GridCellZoomTool);
        (0, sprotty_1.configureActionHandler)(context, action_1.KeyboardGridCellSelectedAction.KIND, grid_cell_zoom_key_tool_1.GridCellZoomTool);
        (0, sprotty_1.configureActionHandler)(context, action_1.KeyboardGridKeyboardEventAction.KIND, grid_cell_zoom_key_tool_1.GridCellZoomTool);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDefaultTool, deselect_key_tool_1.DeselectKeyTool);
      }
      exports.configureViewKeyTools = configureViewKeyTools;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/accessibility-module.js
  var require_accessibility_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/accessibility-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.accessibilityModule = void 0;
      var sprotty_1 = require_lib4();
      var element_navigation_module_1 = require_element_navigation_module();
      var focus_tracker_module_1 = require_focus_tracker_module();
      var keyboard_pointer_module_1 = require_keyboard_pointer_module();
      var keyboard_tool_palette_module_1 = require_keyboard_tool_palette_module();
      var search_palette_module_1 = require_search_palette_module();
      var toast_module_1 = require_toast_module();
      var view_key_tools_module_1 = require_view_key_tools_module();
      exports.accessibilityModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, view_key_tools_module_1.configureViewKeyTools)(context);
        (0, search_palette_module_1.configureSearchPaletteModule)(context);
        (0, keyboard_tool_palette_module_1.configureKeyboardToolPaletteTool)(context);
        (0, keyboard_pointer_module_1.configureKeyboardControlTools)(context);
        (0, element_navigation_module_1.configureElementNavigationTool)(context);
        (0, focus_tracker_module_1.configureFocusTrackerTool)(context);
        (0, toast_module_1.configureToastTool)(context);
      }, {
        featureId: Symbol("accessibility")
      });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-context.js
  var require_edge_autocomplete_context = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/edge-autocomplete/edge-autocomplete-context.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/element-navigator.js
  var require_element_navigator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/element-navigator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/left-right-top-bottom-navigator.js
  var require_left_right_top_bottom_navigator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/accessibility/element-navigation/left-right-top-bottom-navigator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LeftToRightTopToBottomElementNavigator = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var model_1 = require_model22();
      var gmodel_util_1 = require_gmodel_util();
      var LeftToRightTopToBottomElementNavigator = class LeftToRightTopToBottomElementNavigator {
        previous(root, current, previousCurrent, predicate = () => true) {
          const elements = this.getElements(root, predicate);
          if (current === void 0) {
            return elements.length > 0 ? elements[0] : void 0;
          }
          return elements[this.getPreviousIndex(current, elements) % elements.length];
        }
        next(root, current, previousCurrent, predicate = () => true) {
          const elements = this.getElements(root, predicate);
          if (current === void 0) {
            return elements.length > 0 ? elements[0] : void 0;
          }
          return elements[this.getNextIndex(current, elements) % elements.length];
        }
        getElements(root, predicate) {
          const elements = (0, sprotty_1.toArray)(root.index.all().filter((e2) => (0, gmodel_util_1.isSelectableAndBoundsAware)(e2)));
          return elements.sort((a3, b3) => this.compare(a3, b3)).filter(predicate);
        }
        getNextIndex(current, elements) {
          for (let index = 0; index < elements.length; index++) {
            if (this.compare(elements[index], current) > 0) {
              return index;
            }
          }
          return 0;
        }
        getPreviousIndex(current, elements) {
          for (let index = elements.length - 1; index >= 0; index--) {
            if (this.compare(elements[index], current) < 0) {
              return index;
            }
          }
          return elements.length - 1;
        }
        compare(one, other) {
          var _a4, _b2;
          let positionOne = void 0;
          let positionOther = void 0;
          if (one instanceof model_1.GEdge && (0, gmodel_util_1.isRoutable)(one)) {
            positionOne = (_a4 = (0, gmodel_util_1.calcElementAndRoute)(one, this.edgeRouterRegistry).newRoutingPoints) === null || _a4 === void 0 ? void 0 : _a4[0];
          }
          if (other instanceof model_1.GEdge && (0, gmodel_util_1.isRoutable)(other)) {
            positionOther = (_b2 = (0, gmodel_util_1.calcElementAndRoute)(other, this.edgeRouterRegistry).newRoutingPoints) === null || _b2 === void 0 ? void 0 : _b2[0];
          }
          const boundsOne = (0, sprotty_1.findParentByFeature)(one, gmodel_util_1.isSelectableAndBoundsAware);
          const boundsOther = (0, sprotty_1.findParentByFeature)(other, gmodel_util_1.isSelectableAndBoundsAware);
          if (positionOne === void 0 && boundsOne) {
            positionOne = boundsOne.bounds;
          }
          if (positionOther === void 0 && boundsOther) {
            positionOther = boundsOther.bounds;
          }
          if (positionOne && positionOther) {
            if (positionOne.y !== positionOther.y) {
              return positionOne.y - positionOther.y;
            }
            if (positionOne.x !== positionOther.x) {
              return positionOne.x - positionOther.x;
            }
          }
          return 0;
        }
      };
      exports.LeftToRightTopToBottomElementNavigator = LeftToRightTopToBottomElementNavigator;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], LeftToRightTopToBottomElementNavigator.prototype, "edgeRouterRegistry", void 0);
      exports.LeftToRightTopToBottomElementNavigator = LeftToRightTopToBottomElementNavigator = __decorate([
        (0, inversify_1.injectable)()
      ], LeftToRightTopToBottomElementNavigator);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/html-utils.js
  var require_html_utils = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/html-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isMouseEvent = exports.createElementFromHTML = void 0;
      var sprotty_1 = require_lib4();
      function createElementFromHTML(html) {
        const template = document.createElement("template");
        html = html.trim();
        template.innerHTML = html;
        const node = template.content.firstChild;
        if (node && node instanceof HTMLElement) {
          return node;
        }
        return void 0;
      }
      exports.createElementFromHTML = createElementFromHTML;
      function isMouseEvent(object) {
        return sprotty_1.AnyObject.is(object) && (0, sprotty_1.hasNumberProp)(object, "pageX") && (0, sprotty_1.hasNumberProp)(object, "pageY");
      }
      exports.isMouseEvent = isMouseEvent;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/snap.js
  var require_snap2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/snap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unsnapModifier = exports.useSnap = void 0;
      function useSnap(event) {
        return !event.shiftKey;
      }
      exports.useSnap = useSnap;
      function unsnapModifier() {
        return "shift";
      }
      exports.unsnapModifier = unsnapModifier;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/change-bounds/point-position-updater.js
  var require_point_position_updater = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/change-bounds/point-position-updater.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PointPositionUpdater = void 0;
      var sprotty_1 = require_lib4();
      var gmodel_util_1 = require_gmodel_util();
      var html_utils_1 = require_html_utils();
      var model_1 = require_model20();
      var position_snapper_1 = require_position_snapper();
      var snap_1 = require_snap2();
      var PointPositionUpdater = class {
        constructor(first, helperLineManager) {
          this.positionDelta = { x: 0, y: 0 };
          this.positionSnapper = first instanceof position_snapper_1.PositionSnapper ? first : new position_snapper_1.PositionSnapper(first, helperLineManager);
        }
        updateLastDragPosition(first) {
          this.lastDragPosition = (0, html_utils_1.isMouseEvent)(first) ? { x: first.pageX, y: first.pageY } : first;
        }
        /**
         * Check if the mouse is currently not in a drag mode.
         * @returns true if the last drag position is undefined
         */
        isLastDragPositionUndefined() {
          return this.lastDragPosition === void 0;
        }
        /**
         * Reset the updater for new movements.
         * This method is normally called in the `mouseUp` event.
         */
        resetPosition() {
          this.lastDragPosition = void 0;
          this.positionDelta = { x: 0, y: 0 };
        }
        updatePosition(target, second, third, fourth) {
          if (!this.lastDragPosition) {
            return void 0;
          }
          const mousePosition = (0, html_utils_1.isMouseEvent)(second) ? { x: second.pageX, y: second.pageY } : second;
          const shouldSnap = typeof third === "boolean" ? third : (0, snap_1.useSnap)(second);
          const direction = typeof third !== "boolean" ? third : fourth;
          const deltaToLastPosition = (0, gmodel_util_1.calculateDeltaBetweenPoints)(mousePosition, this.lastDragPosition, target);
          this.lastDragPosition = mousePosition;
          if (sprotty_1.Point.equals(deltaToLastPosition, sprotty_1.Point.ORIGIN)) {
            return void 0;
          }
          this.positionDelta.x += deltaToLastPosition.x;
          this.positionDelta.y += deltaToLastPosition.y;
          const directions = direction !== null && direction !== void 0 ? direction : (0, model_1.getDirectionOf)(this.positionDelta);
          const positionUpdate = this.positionSnapper.snapDelta(this.positionDelta, target, shouldSnap, directions);
          if (sprotty_1.Point.equals(positionUpdate, sprotty_1.Point.ORIGIN)) {
            return void 0;
          }
          this.positionDelta.x -= positionUpdate.x;
          this.positionDelta.y -= positionUpdate.y;
          return positionUpdate;
        }
      };
      exports.PointPositionUpdater = PointPositionUpdater;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/context-menu/delete-element-context-menu.js
  var require_delete_element_context_menu = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/context-menu/delete-element-context-menu.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteElementContextMenuItemProvider = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var editor_context_service_1 = require_editor_context_service();
      var DeleteElementContextMenuItemProvider = class DeleteElementContextMenuItemProvider {
        async getItems(_root, _lastMousePosition) {
          return [this.createDeleteMenuItem()];
        }
        createDeleteMenuItem() {
          return {
            id: "delete",
            label: "Delete",
            sortString: "d",
            group: "edit",
            actions: [sprotty_1.DeleteElementOperation.create(this.editorContext.selectedElements.map((e2) => e2.id))],
            isEnabled: () => !this.editorContext.isReadonly && this.editorContext.selectedElements.length > 0
          };
        }
      };
      exports.DeleteElementContextMenuItemProvider = DeleteElementContextMenuItemProvider;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IEditorContextServiceProvider),
        __metadata("design:type", Function)
      ], DeleteElementContextMenuItemProvider.prototype, "editorContextServiceProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(editor_context_service_1.EditorContextService),
        __metadata("design:type", editor_context_service_1.EditorContextService)
      ], DeleteElementContextMenuItemProvider.prototype, "editorContext", void 0);
      exports.DeleteElementContextMenuItemProvider = DeleteElementContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], DeleteElementContextMenuItemProvider);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-context-menu.js
  var require_copy_paste_context_menu = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/copy-paste/copy-paste-context-menu.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isNative = exports.supportsPaste = exports.supportsCut = exports.supportsCopy = exports.CopyPasteContextMenuItemProvider = exports.InvokeCopyPasteActionHandler = exports.InvokeCopyPasteAction = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_1 = require_lib4();
      var InvokeCopyPasteAction;
      (function(InvokeCopyPasteAction2) {
        InvokeCopyPasteAction2.KIND = "invokeCopyPaste";
        function is(object) {
          return sprotty_1.Action.hasKind(object, InvokeCopyPasteAction2.KIND) && (0, sprotty_1.hasStringProp)(object, "command");
        }
        InvokeCopyPasteAction2.is = is;
        function create(command) {
          return { kind: InvokeCopyPasteAction2.KIND, command };
        }
        InvokeCopyPasteAction2.create = create;
      })(InvokeCopyPasteAction || (exports.InvokeCopyPasteAction = InvokeCopyPasteAction = {}));
      var InvokeCopyPasteActionHandler = class InvokeCopyPasteActionHandler {
        handle(action) {
          switch (action.command) {
            case "copy":
              if (supportsCopy()) {
                document.execCommand("copy");
              } else {
                this.notifyUserToUseShortcut("copy");
              }
              break;
            case "paste":
              if (supportsPaste()) {
                document.execCommand("paste");
              } else {
                this.notifyUserToUseShortcut("paste");
              }
              break;
            case "cut":
              if (supportsCut()) {
                document.execCommand("cut");
              } else {
                this.notifyUserToUseShortcut("cut");
              }
              break;
          }
        }
        notifyUserToUseShortcut(operation) {
          const message = `Please use the browser's ${operation} command or shortcut.`;
          const timeout = 1e4;
          const severity = "WARNING";
          this.dispatcher.dispatchAll([sprotty_1.StatusAction.create(message, { severity, timeout }), sprotty_1.MessageAction.create(message, { severity })]);
        }
      };
      exports.InvokeCopyPasteActionHandler = InvokeCopyPasteActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], InvokeCopyPasteActionHandler.prototype, "dispatcher", void 0);
      exports.InvokeCopyPasteActionHandler = InvokeCopyPasteActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], InvokeCopyPasteActionHandler);
      var CopyPasteContextMenuItemProvider = class CopyPasteContextMenuItemProvider {
        getItems(root, _lastMousePosition) {
          const hasSelectedElements = Array.from(root.index.all().filter(sprotty_1.isSelected)).length > 0;
          return Promise.resolve([
            this.createCopyMenuItem(hasSelectedElements),
            this.createCutMenuItem(hasSelectedElements),
            this.createPasteMenuItem()
          ]);
        }
        createPasteMenuItem() {
          return {
            id: "paste",
            label: "Paste",
            group: "copy-paste",
            actions: [InvokeCopyPasteAction.create("paste")],
            isEnabled: () => true
          };
        }
        createCutMenuItem(hasSelectedElements) {
          return {
            id: "cut",
            label: "Cut",
            group: "copy-paste",
            actions: [InvokeCopyPasteAction.create("cut")],
            isEnabled: () => hasSelectedElements
          };
        }
        createCopyMenuItem(hasSelectedElements) {
          return {
            id: "copy",
            label: "Copy",
            group: "copy-paste",
            actions: [InvokeCopyPasteAction.create("copy")],
            isEnabled: () => hasSelectedElements
          };
        }
      };
      exports.CopyPasteContextMenuItemProvider = CopyPasteContextMenuItemProvider;
      exports.CopyPasteContextMenuItemProvider = CopyPasteContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], CopyPasteContextMenuItemProvider);
      function supportsCopy() {
        return isNative() || document.queryCommandSupported("copy");
      }
      exports.supportsCopy = supportsCopy;
      function supportsCut() {
        return isNative() || document.queryCommandSupported("cut");
      }
      exports.supportsCut = supportsCut;
      function supportsPaste() {
        const isChrome = userAgent().indexOf("Chrome") >= 0;
        return isNative() || !isChrome && document.queryCommandSupported("paste");
      }
      exports.supportsPaste = supportsPaste;
      function isNative() {
        return typeof window.process !== "undefined";
      }
      exports.isNative = isNative;
      function userAgent() {
        return typeof navigator !== "undefined" ? navigator.userAgent : "";
      }
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/debug/debug-bounds-decorator.js
  var require_debug_bounds_decorator = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/debug/debug-bounds-decorator.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DebugBoundsDecorator = exports.CSS_DEBUG_BOUNDS = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var model_1 = require_model22();
      exports.CSS_DEBUG_BOUNDS = "debug-bounds";
      var DebugBoundsDecorator = class DebugBoundsDecorator {
        decorate(vnode, element) {
          var _a4;
          if (!((_a4 = this.debugManager) === null || _a4 === void 0 ? void 0 : _a4.isDebugEnabled)) {
            return vnode;
          }
          if ((0, sprotty_1.isSizeable)(element) && this.shouldDecorateSizeable(element)) {
            this.decorateSizeable(vnode, element);
          }
          if (element instanceof model_1.GGraph && this.shouldDecorateGraph(element)) {
            this.decorateGraph(vnode, element);
          }
          return vnode;
        }
        postUpdate() {
        }
        get decorationSize() {
          return 5;
        }
        shouldDecorateGraph(graph) {
          return true;
        }
        decorateGraph(vnode, graph) {
          var _a4, _b2, _c;
          (0, sprotty_1.setClass)(vnode, exports.CSS_DEBUG_BOUNDS, true);
          const svgChild = (_a4 = vnode.children) === null || _a4 === void 0 ? void 0 : _a4.find((child) => typeof child !== "string" && child.sel === "svg");
          const group = (_b2 = svgChild === null || svgChild === void 0 ? void 0 : svgChild.children) === null || _b2 === void 0 ? void 0 : _b2.find((child) => typeof child !== "string" && child.sel === "g");
          (_c = group === null || group === void 0 ? void 0 : group.children) === null || _c === void 0 ? void 0 : _c.push(this.renderOrigin(graph));
        }
        renderOrigin(graph) {
          return (0, sprotty_1.svg)(
            "polyline",
            { "class-debug-bounds-decoration": true, "class-debug-bounds-origin": true, points: `0,${this.decorationSize} 0,0  ${this.decorationSize},0` },
            (0, sprotty_1.svg)("title", null, "Origin = x: 0, y: 0")
          );
        }
        shouldDecorateSizeable(element) {
          return !(0, sprotty_1.isDecoration)(element);
        }
        decorateSizeable(vnode, element) {
          var _a4, _b2, _c, _d, _e3;
          (0, sprotty_1.setClass)(vnode, exports.CSS_DEBUG_BOUNDS, true);
          (_a4 = vnode.children) === null || _a4 === void 0 ? void 0 : _a4.push(this.renderTopLeftCorner(element));
          (_b2 = vnode.children) === null || _b2 === void 0 ? void 0 : _b2.push(this.renderTopRightCorner(element));
          (_c = vnode.children) === null || _c === void 0 ? void 0 : _c.push(this.renderBottomLeftCorner(element));
          (_d = vnode.children) === null || _d === void 0 ? void 0 : _d.push(this.renderBottomRightCorner(element));
          (_e3 = vnode.children) === null || _e3 === void 0 ? void 0 : _e3.push(this.renderCenter(element));
        }
        renderTopLeftCorner(element) {
          const position = sprotty_1.Bounds.position(element.bounds);
          const topLeft = sprotty_1.Bounds.topLeft(element.bounds);
          const corner = sprotty_1.Point.subtract(topLeft, position);
          return (0, sprotty_1.svg)(
            "polyline",
            { "class-debug-bounds-decoration": true, "class-debug-bounds-top-left": true, points: `${corner.x},${corner.y + this.decorationSize} ${corner.x},${corner.y} ${corner.x + this.decorationSize},${corner.y}` },
            (0, sprotty_1.svg)(
              "title",
              null,
              "Top Left = x: ",
              topLeft.x,
              ", y: ",
              topLeft.y
            )
          );
        }
        renderTopRightCorner(element) {
          const position = sprotty_1.Bounds.position(element.bounds);
          const topRight = sprotty_1.Bounds.topRight(element.bounds);
          const corner = sprotty_1.Point.subtract(topRight, position);
          return (0, sprotty_1.svg)(
            "polyline",
            { "class-debug-bounds-decoration": true, "class-debug-bounds-top-right": true, points: `${corner.x - this.decorationSize},${corner.y} ${corner.x},${corner.y} ${corner.x},${corner.y + this.decorationSize}` },
            (0, sprotty_1.svg)(
              "title",
              null,
              "Top Right = x: ",
              topRight.x,
              ", y: ",
              topRight.y
            )
          );
        }
        renderBottomLeftCorner(element) {
          const position = sprotty_1.Bounds.position(element.bounds);
          const bottomLeft = sprotty_1.Bounds.bottomLeft(element.bounds);
          const corner = sprotty_1.Point.subtract(bottomLeft, position);
          return (0, sprotty_1.svg)(
            "polyline",
            { "class-debug-bounds-decoration": true, "class-debug-bounds-bottom-left": true, points: `${corner.x},${corner.y - this.decorationSize} ${corner.x},${corner.y} ${corner.x + this.decorationSize},${corner.y}` },
            (0, sprotty_1.svg)(
              "title",
              null,
              "Bottom Left = x: ",
              bottomLeft.x,
              ", y: ",
              bottomLeft.y
            )
          );
        }
        renderBottomRightCorner(element) {
          const position = sprotty_1.Bounds.position(element.bounds);
          const bottomRight = sprotty_1.Bounds.bottomRight(element.bounds);
          const corner = sprotty_1.Point.subtract(bottomRight, position);
          return (0, sprotty_1.svg)(
            "polyline",
            { "class-debug-bounds-decoration": true, "class-debug-bounds-bottom-right": true, points: `${corner.x - this.decorationSize},${corner.y} ${corner.x},${corner.y} ${corner.x},${corner.y - this.decorationSize}` },
            (0, sprotty_1.svg)(
              "title",
              null,
              "Bottom Right = x: ",
              bottomRight.x,
              ", y: ",
              bottomRight.y
            )
          );
        }
        renderCenter(element) {
          const bounds = element.bounds;
          const position = sprotty_1.Bounds.position(bounds);
          const center = sprotty_1.Bounds.center(bounds);
          const corner = sprotty_1.Point.subtract(center, position);
          return (0, sprotty_1.svg)(
            "g",
            null,
            (0, sprotty_1.svg)(
              "title",
              null,
              "Center = x: ",
              center.x,
              ", y: ",
              center.y,
              "\rBounds = x: ",
              bounds.x,
              ", y: ",
              bounds.y,
              ", width: ",
              bounds.width,
              ", height: ",
              bounds.height
            ),
            (0, sprotty_1.svg)("polyline", { "class-debug-bounds-decoration": true, "class-debug-bounds-center": true, points: `${corner.x - this.decorationSize / 2},${corner.y - this.decorationSize / 2} ${corner.x + this.decorationSize / 2},${corner.y + this.decorationSize / 2}` }),
            (0, sprotty_1.svg)("polyline", { "class-debug-bounds-decoration": true, "class-debug-bounds-center": true, points: `${corner.x + this.decorationSize / 2},${corner.y - this.decorationSize / 2} ${corner.x - this.decorationSize / 2},${corner.y + this.decorationSize / 2}` })
          );
        }
      };
      exports.DebugBoundsDecorator = DebugBoundsDecorator;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IDebugManager),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], DebugBoundsDecorator.prototype, "debugManager", void 0);
      exports.DebugBoundsDecorator = DebugBoundsDecorator = __decorate([
        (0, inversify_1.injectable)()
      ], DebugBoundsDecorator);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/debug/debug-model.js
  var require_debug_model = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/debug/debug-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EnableDebugModeCommand = exports.EnableDebugModeAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var EnableDebugModeAction;
      (function(EnableDebugModeAction2) {
        EnableDebugModeAction2.KIND = "enableDebugMode";
        EnableDebugModeAction2.CSS_ROOT_CLASS = "debug-mode";
        function is(object) {
          return sprotty_1.Action.hasKind(object, EnableDebugModeAction2.KIND) && (0, sprotty_1.hasBooleanProp)(object, "enable");
        }
        EnableDebugModeAction2.is = is;
        function create(options) {
          return {
            kind: EnableDebugModeAction2.KIND,
            ...options
          };
        }
        EnableDebugModeAction2.create = create;
      })(EnableDebugModeAction || (exports.EnableDebugModeAction = EnableDebugModeAction = {}));
      var EnableDebugModeCommand = class EnableDebugModeCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          return this.setDebugMode(context.root, this.action.enable);
        }
        setDebugMode(root, show) {
          if (show) {
            (0, gmodel_util_1.addCssClasses)(root, [EnableDebugModeAction.CSS_ROOT_CLASS]);
          } else {
            (0, gmodel_util_1.removeCssClasses)(root, [EnableDebugModeAction.CSS_ROOT_CLASS]);
          }
          return root;
        }
      };
      exports.EnableDebugModeCommand = EnableDebugModeCommand;
      EnableDebugModeCommand.KIND = EnableDebugModeAction.KIND;
      exports.EnableDebugModeCommand = EnableDebugModeCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], EnableDebugModeCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/debug/debug-manager.js
  var require_debug_manager = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/debug/debug-manager.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DebugManager = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var debug_model_1 = require_debug_model();
      var DebugManager = class DebugManager {
        constructor() {
          this._debugEnabled = false;
        }
        get isDebugEnabled() {
          return this._debugEnabled;
        }
        init() {
          this.debugFeedback = this.feedbackDispatcher.createEmitter();
        }
        handle(action) {
          this.setDebugEnabled(action.enable);
        }
        setDebugEnabled(enabled) {
          if (this._debugEnabled && !enabled) {
            this._debugEnabled = false;
            this.debugFeedback.dispose();
          } else if (!this._debugEnabled && enabled) {
            this._debugEnabled = true;
            this.debugFeedback.add(debug_model_1.EnableDebugModeAction.create({ enable: true }), debug_model_1.EnableDebugModeAction.create({ enable: false })).submit();
          }
        }
        toggleDebugEnabled() {
          this.setDebugEnabled(!this._debugEnabled);
        }
      };
      exports.DebugManager = DebugManager;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], DebugManager.prototype, "feedbackDispatcher", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], DebugManager.prototype, "init", null);
      exports.DebugManager = DebugManager = __decorate([
        (0, inversify_1.injectable)()
      ], DebugManager);
    }
  });

  // node_modules/@eclipse-glsp/client/css/debug.css
  var require_debug = __commonJS({
    "node_modules/@eclipse-glsp/client/css/debug.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/debug/debug-module.js
  var require_debug_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/debug/debug-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debugModule = void 0;
      var sprotty_1 = require_lib4();
      require_debug();
      var debug_bounds_decorator_1 = require_debug_bounds_decorator();
      var debug_manager_1 = require_debug_manager();
      var debug_model_1 = require_debug_model();
      exports.debugModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.configureCommand)(context, debug_model_1.EnableDebugModeCommand);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IDebugManager, debug_manager_1.DebugManager);
        (0, sprotty_1.configureActionHandler)(context, debug_model_1.EnableDebugModeAction.KIND, debug_manager_1.DebugManager);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IVNodePostprocessor, debug_bounds_decorator_1.DebugBoundsDecorator);
      }, { featureId: Symbol("debug") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/grid/grid-model.js
  var require_grid_model = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/grid/grid-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShowGridCommand = exports.ShowGridAction = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var ShowGridAction;
      (function(ShowGridAction2) {
        ShowGridAction2.KIND = "showGrid";
        ShowGridAction2.CSS_ROOT_CLASS = "grid-background";
        function is(object) {
          return sprotty_1.Action.hasKind(object, ShowGridAction2.KIND) && (0, sprotty_1.hasBooleanProp)(object, "show");
        }
        ShowGridAction2.is = is;
        function create(options) {
          return {
            kind: ShowGridCommand.KIND,
            ...options
          };
        }
        ShowGridAction2.create = create;
      })(ShowGridAction || (exports.ShowGridAction = ShowGridAction = {}));
      var ShowGridCommand = class ShowGridCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          return this.setGrid(context.root, this.action.show);
        }
        setGrid(root, show) {
          if (show) {
            (0, gmodel_util_1.addCssClasses)(root, [ShowGridAction.CSS_ROOT_CLASS]);
          } else {
            (0, gmodel_util_1.removeCssClasses)(root, [ShowGridAction.CSS_ROOT_CLASS]);
          }
          return root;
        }
      };
      exports.ShowGridCommand = ShowGridCommand;
      ShowGridCommand.KIND = ShowGridAction.KIND;
      exports.ShowGridCommand = ShowGridCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ShowGridCommand);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/grid/grid-manager.js
  var require_grid_manager = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/grid/grid-manager.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GridManager = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var grid_1 = require_grid();
      var grid_model_1 = require_grid_model();
      var GridManager = class GridManager {
        constructor() {
          this._gridVisible = false;
        }
        get isGridVisible() {
          return this._gridVisible;
        }
        init() {
          this.gridFeedback = this.feedbackDispatcher.createEmitter();
        }
        handle(action) {
          this.setGridVisible(action.show);
        }
        setGridVisible(visible) {
          if (this._gridVisible && !visible) {
            this._gridVisible = false;
            this.gridFeedback.dispose();
          } else if (!this._gridVisible && visible) {
            this._gridVisible = true;
            this.gridFeedback.add(grid_model_1.ShowGridAction.create({ show: true }), grid_model_1.ShowGridAction.create({ show: false })).submit();
          }
        }
        toggleGridVisible() {
          this.setGridVisible(!this._gridVisible);
        }
      };
      exports.GridManager = GridManager;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], GridManager.prototype, "feedbackDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.Grid),
        __metadata("design:type", Object)
      ], GridManager.prototype, "grid", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], GridManager.prototype, "init", null);
      exports.GridManager = GridManager = __decorate([
        (0, inversify_1.injectable)()
      ], GridManager);
    }
  });

  // node_modules/@eclipse-glsp/client/css/grid.css
  var require_grid2 = __commonJS({
    "node_modules/@eclipse-glsp/client/css/grid.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/grid/grid-snapper.js
  var require_grid_snapper = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/grid/grid-snapper.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPCenterGridSnapper = exports.GridSnapper = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var grid_1 = require_grid();
      var GridSnapper = class GridSnapper {
        constructor(grid = grid_1.Grid.DEFAULT) {
          this.grid = grid;
        }
        snap(position, element) {
          return sprotty_1.Point.snapToGrid(position, this.grid);
        }
      };
      exports.GridSnapper = GridSnapper;
      exports.GridSnapper = GridSnapper = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.optional)()),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Grid)),
        __metadata("design:paramtypes", [Object])
      ], GridSnapper);
      var GLSPCenterGridSnapper = class GLSPCenterGridSnapper extends sprotty_1.CenterGridSnapper {
        constructor(grid = grid_1.Grid.DEFAULT) {
          super();
          this.grid = grid;
        }
        get gridX() {
          return this.grid.x;
        }
        get gridY() {
          return this.grid.y;
        }
      };
      exports.GLSPCenterGridSnapper = GLSPCenterGridSnapper;
      exports.GLSPCenterGridSnapper = GLSPCenterGridSnapper = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.optional)()),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Grid)),
        __metadata("design:paramtypes", [Object])
      ], GLSPCenterGridSnapper);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/grid/grid-module.js
  var require_grid_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/grid/grid-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.gridModule = void 0;
      var sprotty_1 = require_lib4();
      require_grid2();
      var grid_1 = require_grid();
      var grid_manager_1 = require_grid_manager();
      var grid_model_1 = require_grid_model();
      var grid_snapper_1 = require_grid_snapper();
      exports.gridModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        bind(sprotty_1.TYPES.Grid).toConstantValue(grid_1.Grid.DEFAULT);
        (0, sprotty_1.configureCommand)(context, grid_model_1.ShowGridCommand);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.IGridManager, grid_manager_1.GridManager);
        (0, sprotty_1.configureActionHandler)(context, grid_model_1.ShowGridAction.KIND, grid_manager_1.GridManager);
        bind(sprotty_1.TYPES.ISnapper).to(grid_snapper_1.GridSnapper);
      }, { featureId: Symbol("grid") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/grid/grid-style.js
  var require_grid_style = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/grid/grid-style.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GridProperty = void 0;
      var GridProperty;
      (function(GridProperty2) {
        GridProperty2.GRID_BACKGROUND_X = "--grid-background-x";
        GridProperty2.GRID_BACKGROUND_Y = "--grid-background-y";
        GridProperty2.GRID_BACKGROUND_WIDTH = "--grid-background-width";
        GridProperty2.GRID_BACKGROUND_HEIGHT = "--grid-background-height";
        GridProperty2.GRID_BACKGROUND_ZOOM = "--grid-background-zoom";
        GridProperty2.GRID_COLOR = "--grid-color";
      })(GridProperty || (exports.GridProperty = GridProperty = {}));
    }
  });

  // node_modules/@eclipse-glsp/client/css/helper-lines.css
  var require_helper_lines = __commonJS({
    "node_modules/@eclipse-glsp/client/css/helper-lines.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/helper-lines/helper-line-feedback.js
  var require_helper_line_feedback = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/helper-lines/helper-line-feedback.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.boundsInViewport = exports.removeSelectionBounds = exports.removeHelperLines = exports.RemoveHelperLinesFeedbackCommand = exports.RemoveHelperLinesFeedbackAction = exports.DrawHelperLinesFeedbackCommand = exports.DrawHelperLinesFeedbackAction = exports.DEFAULT_DEBUG = exports.DEFAULT_ALIGNABLE_ELEMENT_FILTER = exports.DEFAULT_EPSILON = exports.DEFAULT_VIEWPORT_LINES = exports.DEFAULT_ELEMENT_LINES = exports.ALL_VIEWPORT_LINE_TYPES = exports.ALL_ELEMENT_LINE_TYPES = exports.isTopLevelBoundsAwareElement = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var lodash_1 = require_lodash();
      require_helper_lines();
      var feedback_command_1 = require_feedback_command();
      var gmodel_util_1 = require_gmodel_util();
      var viewpoint_util_1 = require_viewpoint_util();
      var dangling_edge_feedback_1 = require_dangling_edge_feedback();
      var model_1 = require_model20();
      var isTopLevelBoundsAwareElement = (element) => (0, gmodel_util_1.findTopLevelElementByFeature)(element, sprotty_1.isBoundsAware, sprotty_1.isViewport) === element;
      exports.isTopLevelBoundsAwareElement = isTopLevelBoundsAwareElement;
      exports.ALL_ELEMENT_LINE_TYPES = Object.values(model_1.HelperLineType);
      exports.ALL_VIEWPORT_LINE_TYPES = [model_1.HelperLineType.Center, model_1.HelperLineType.Middle];
      exports.DEFAULT_ELEMENT_LINES = exports.ALL_ELEMENT_LINE_TYPES;
      exports.DEFAULT_VIEWPORT_LINES = exports.ALL_VIEWPORT_LINE_TYPES;
      exports.DEFAULT_EPSILON = 1;
      var DEFAULT_ALIGNABLE_ELEMENT_FILTER = (element) => (0, gmodel_util_1.isVisibleOnCanvas)(element) && !(0, gmodel_util_1.isRoutable)(element) && !(element instanceof sprotty_1.GLabel) && !(element.id === (0, dangling_edge_feedback_1.feedbackEdgeId)(element.root)) && !(element.id === (0, dangling_edge_feedback_1.feedbackEdgeEndId)(element.root)) && !(0, sprotty_1.isDecoration)(element);
      exports.DEFAULT_ALIGNABLE_ELEMENT_FILTER = DEFAULT_ALIGNABLE_ELEMENT_FILTER;
      exports.DEFAULT_DEBUG = false;
      var DrawHelperLinesFeedbackAction;
      (function(DrawHelperLinesFeedbackAction2) {
        DrawHelperLinesFeedbackAction2.KIND = "drawHelperLines";
        function create(options) {
          return {
            kind: DrawHelperLinesFeedbackAction2.KIND,
            ...options
          };
        }
        DrawHelperLinesFeedbackAction2.create = create;
      })(DrawHelperLinesFeedbackAction || (exports.DrawHelperLinesFeedbackAction = DrawHelperLinesFeedbackAction = {}));
      var DrawHelperLinesFeedbackCommand = class DrawHelperLinesFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action, logger) {
          var _a4, _b2, _c, _d, _e3;
          super();
          this.logger = logger;
          this.elementIds = action.elementIds;
          this.elementLines = (_a4 = action.elementLines) !== null && _a4 !== void 0 ? _a4 : exports.DEFAULT_ELEMENT_LINES;
          this.viewportLines = (_b2 = action.viewportLines) !== null && _b2 !== void 0 ? _b2 : exports.DEFAULT_VIEWPORT_LINES;
          this.alignmentEpsilon = (_c = action.alignmentEpsilon) !== null && _c !== void 0 ? _c : exports.DEFAULT_EPSILON;
          this.alignableElementFilter = (_d = action.alignmentElementFilter) !== null && _d !== void 0 ? _d : exports.DEFAULT_ALIGNABLE_ELEMENT_FILTER;
          this.isAlignableElementPredicate = this.isAlignableElement.bind(this);
          this.debug = (_e3 = action.debug) !== null && _e3 !== void 0 ? _e3 : exports.DEFAULT_DEBUG;
        }
        execute(context) {
          removeHelperLines(context.root);
          removeSelectionBounds(context.root);
          const alignableElements = (0, gmodel_util_1.getMatchingElements)(context.root.index, this.isAlignableElementPredicate);
          this.log("All alignable elements: ", alignableElements);
          const [referenceElements, elements] = (0, lodash_1.partition)(alignableElements, (element) => this.elementIds.includes(element.id));
          this.log("Split alignable elements into reference elements and other elements: ", referenceElements, elements);
          if (referenceElements.length === 0) {
            this.log("--> No helper lines as we do not have any reference elements.");
            return context.root;
          }
          const referenceBounds = this.calcReferenceBounds(referenceElements);
          this.log("Bounds encompasing all reference elements: ", referenceBounds);
          const helperLines = this.calcHelperLines(elements, referenceBounds, context);
          if (referenceElements.length > 1) {
            context.root.add(new model_1.SelectionBounds(referenceBounds));
            this.log("Render selection bounds for more than one reference element:", referenceBounds);
          }
          helperLines.forEach((helperLine) => context.root.add(helperLine));
          if (helperLines.length > 0) {
            this.log(`--> Add ${helperLines.length} helper lines to root:`, helperLines);
          } else {
            this.log("--> Add no helper lines to root.");
          }
          return context.root;
        }
        isAlignableElement(element) {
          return (0, sprotty_1.isBoundsAware)(element) && this.alignableElementFilter(element, this.elementIds);
        }
        calcReferenceBounds(referenceElements) {
          return referenceElements.map((element) => this.calcBounds(element)).reduce(sprotty_1.Bounds.combine, sprotty_1.Bounds.EMPTY);
        }
        calcBounds(element) {
          return (0, viewpoint_util_1.toAbsoluteBounds)(element);
        }
        calcHelperLines(elements, bounds, context) {
          const helperLines = [];
          const viewport = (0, sprotty_1.findParentByFeature)(context.root, sprotty_1.isViewport);
          if (viewport) {
            helperLines.push(...this.calcHelperLinesForViewport(viewport, bounds, this.viewportLines));
          }
          elements.flatMap((element) => this.calcHelperLinesForElement(element, bounds, this.elementLines)).forEach((line) => helperLines.push(line));
          return helperLines;
        }
        calcHelperLinesForViewport(root, bounds, lineTypes) {
          const helperLines = [];
          this.log("Find helperlines for viewport:", root);
          const viewportBounds = (0, viewpoint_util_1.getViewportBounds)(root, root.canvasBounds);
          if (lineTypes.includes(model_1.HelperLineType.Center) && this.isAligned(sprotty_1.Bounds.centerX, viewportBounds, bounds, 2)) {
            helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.topCenter(viewportBounds), sprotty_1.Bounds.bottomCenter(viewportBounds), model_1.HelperLineType.Center));
            this.log("- Reference bounds center align with viewport.", viewportBounds);
          }
          if (lineTypes.includes(model_1.HelperLineType.Middle) && this.isAligned(sprotty_1.Bounds.middle, viewportBounds, bounds, 2)) {
            helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.middleLeft(viewportBounds), sprotty_1.Bounds.middleRight(viewportBounds), model_1.HelperLineType.Middle));
            this.log("- Reference bounds middle align with viewport.", viewportBounds);
          }
          if (helperLines.length > 0) {
            this.log(`--> Add ${helperLines.length} helperlines for viewport:`, helperLines);
          }
          return helperLines;
        }
        calcHelperLinesForElement(element, bounds, lineTypes) {
          this.log("Find helperlines for element:", element);
          return this.calcHelperLinesForBounds(this.calcBounds(element), bounds, lineTypes);
        }
        calcHelperLinesForBounds(elementBounds, bounds, lineTypes) {
          const helperLines = [];
          if (lineTypes.includes(model_1.HelperLineType.Left) && this.isAligned(sprotty_1.Bounds.left, elementBounds, bounds, this.alignmentEpsilon)) {
            const [above, below] = sprotty_1.Bounds.sortBy(sprotty_1.Bounds.top, elementBounds, bounds);
            helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.bottomLeft(below), sprotty_1.Bounds.topLeft(above), model_1.HelperLineType.Left));
            this.log("- Reference bounds left align with element", elementBounds);
          }
          if (lineTypes.includes(model_1.HelperLineType.Center) && this.isAligned(sprotty_1.Bounds.centerX, elementBounds, bounds, this.alignmentEpsilon)) {
            const [above, below] = sprotty_1.Bounds.sortBy(sprotty_1.Bounds.top, elementBounds, bounds);
            helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.topCenter(above), sprotty_1.Bounds.bottomCenter(below), model_1.HelperLineType.Center));
            this.log("- Reference bounds center align with element", elementBounds);
          }
          if (lineTypes.includes(model_1.HelperLineType.Right) && this.isAligned(sprotty_1.Bounds.right, elementBounds, bounds, this.alignmentEpsilon)) {
            const [above, below] = sprotty_1.Bounds.sortBy(sprotty_1.Bounds.top, elementBounds, bounds);
            helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.bottomRight(below), sprotty_1.Bounds.topRight(above), model_1.HelperLineType.Right));
            this.log("- Reference bounds right align with element", elementBounds);
          }
          if (lineTypes.includes(model_1.HelperLineType.Bottom) && this.isAligned(sprotty_1.Bounds.bottom, elementBounds, bounds, this.alignmentEpsilon)) {
            const [before, after] = sprotty_1.Bounds.sortBy(sprotty_1.Bounds.left, elementBounds, bounds);
            helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.bottomLeft(before), sprotty_1.Bounds.bottomRight(after), model_1.HelperLineType.Bottom));
            this.log("- Reference bounds bottom align with element", elementBounds);
          }
          if (lineTypes.includes(model_1.HelperLineType.Middle) && this.isAligned(sprotty_1.Bounds.centerY, elementBounds, bounds, this.alignmentEpsilon)) {
            const [before, after] = sprotty_1.Bounds.sortBy(sprotty_1.Bounds.left, elementBounds, bounds);
            helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.middleLeft(before), sprotty_1.Bounds.middleRight(after), model_1.HelperLineType.Middle));
            this.log("- Reference bounds middle align with element", elementBounds);
          }
          if (lineTypes.includes(model_1.HelperLineType.Top) && this.isAligned(sprotty_1.Bounds.top, elementBounds, bounds, this.alignmentEpsilon)) {
            const [before, after] = sprotty_1.Bounds.sortBy(sprotty_1.Bounds.left, elementBounds, bounds);
            helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.topLeft(before), sprotty_1.Bounds.topRight(after), model_1.HelperLineType.Top));
            this.log("- Reference bounds top align with element", elementBounds);
          }
          if (lineTypes.includes(model_1.HelperLineType.LeftRight) && this.isMatch(sprotty_1.Bounds.left(elementBounds), sprotty_1.Bounds.right(bounds), this.alignmentEpsilon)) {
            if (sprotty_1.Bounds.isAbove(bounds, elementBounds)) {
              helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.bottomLeft(elementBounds), sprotty_1.Bounds.topRight(bounds), model_1.HelperLineType.RightLeft));
              this.log("- Reference bounds right aligns with element left", elementBounds);
            } else {
              helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.topLeft(elementBounds), sprotty_1.Bounds.bottomRight(bounds), model_1.HelperLineType.RightLeft));
              this.log("- Reference bounds right aligns with element left", elementBounds);
            }
          }
          if (lineTypes.includes(model_1.HelperLineType.LeftRight) && this.isMatch(sprotty_1.Bounds.right(elementBounds), sprotty_1.Bounds.left(bounds), this.alignmentEpsilon)) {
            if (sprotty_1.Bounds.isAbove(bounds, elementBounds)) {
              helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.bottomRight(elementBounds), sprotty_1.Bounds.topLeft(bounds), model_1.HelperLineType.LeftRight));
              this.log("- Reference bounds left aligns with element right", elementBounds);
            } else {
              helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.topRight(elementBounds), sprotty_1.Bounds.bottomLeft(bounds), model_1.HelperLineType.LeftRight));
              this.log("- Reference bounds left aligns with element right", elementBounds);
            }
          }
          if (lineTypes.includes(model_1.HelperLineType.TopBottom) && this.isMatch(sprotty_1.Bounds.top(elementBounds), sprotty_1.Bounds.bottom(bounds), this.alignmentEpsilon)) {
            if (sprotty_1.Bounds.isBefore(bounds, elementBounds)) {
              helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.topRight(elementBounds), sprotty_1.Bounds.bottomLeft(bounds), model_1.HelperLineType.BottomTop));
              this.log("- Reference bounds bottom aligns with element top", elementBounds);
            } else {
              helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.topLeft(elementBounds), sprotty_1.Bounds.bottomRight(bounds), model_1.HelperLineType.BottomTop));
              this.log("- Reference bounds bottom aligns with element top", elementBounds);
            }
          }
          if (lineTypes.includes(model_1.HelperLineType.TopBottom) && this.isMatch(sprotty_1.Bounds.bottom(elementBounds), sprotty_1.Bounds.top(bounds), this.alignmentEpsilon)) {
            if (sprotty_1.Bounds.isBefore(bounds, elementBounds)) {
              helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.bottomRight(elementBounds), sprotty_1.Bounds.topLeft(bounds), model_1.HelperLineType.TopBottom));
              this.log("- Reference bounds top aligns with element bottom", elementBounds);
            } else {
              helperLines.push(new model_1.HelperLine(sprotty_1.Bounds.bottomLeft(elementBounds), sprotty_1.Bounds.topRight(bounds), model_1.HelperLineType.TopBottom));
              this.log("- Reference bounds top aligns with element bottom", elementBounds);
            }
          }
          if (helperLines.length > 0) {
            this.log(`--> Add ${helperLines.length} helperlines for element:`, helperLines);
          }
          return helperLines;
        }
        isAligned(coordinate, leftBounds, rightBounds, epsilon) {
          return this.isMatch(coordinate(leftBounds), coordinate(rightBounds), epsilon);
        }
        isMatch(leftCoordinate, rightCoordinate, epsilon) {
          return (0, sprotty_1.equalUpTo)(leftCoordinate, rightCoordinate, epsilon);
        }
        log(message, ...params) {
          if (this.debug) {
            this.logger.log(this, message, params);
          }
        }
      };
      exports.DrawHelperLinesFeedbackCommand = DrawHelperLinesFeedbackCommand;
      DrawHelperLinesFeedbackCommand.KIND = DrawHelperLinesFeedbackAction.KIND;
      exports.DrawHelperLinesFeedbackCommand = DrawHelperLinesFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __param(1, (0, inversify_1.inject)(sprotty_1.TYPES.ILogger)),
        __metadata("design:paramtypes", [Object, Object])
      ], DrawHelperLinesFeedbackCommand);
      var RemoveHelperLinesFeedbackAction;
      (function(RemoveHelperLinesFeedbackAction2) {
        RemoveHelperLinesFeedbackAction2.KIND = "removeHelperLines";
        function create(options = {}) {
          return {
            kind: RemoveHelperLinesFeedbackAction2.KIND,
            ...options
          };
        }
        RemoveHelperLinesFeedbackAction2.create = create;
      })(RemoveHelperLinesFeedbackAction || (exports.RemoveHelperLinesFeedbackAction = RemoveHelperLinesFeedbackAction = {}));
      var RemoveHelperLinesFeedbackCommand = class RemoveHelperLinesFeedbackCommand extends feedback_command_1.FeedbackCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          removeHelperLines(context.root);
          removeSelectionBounds(context.root);
          return context.root;
        }
      };
      exports.RemoveHelperLinesFeedbackCommand = RemoveHelperLinesFeedbackCommand;
      RemoveHelperLinesFeedbackCommand.KIND = RemoveHelperLinesFeedbackAction.KIND;
      exports.RemoveHelperLinesFeedbackCommand = RemoveHelperLinesFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], RemoveHelperLinesFeedbackCommand);
      function removeHelperLines(root) {
        (0, gmodel_util_1.forEachElement)(root.index, model_1.isHelperLine, (line) => root.remove(line));
      }
      exports.removeHelperLines = removeHelperLines;
      function removeSelectionBounds(root) {
        (0, gmodel_util_1.forEachElement)(root.index, model_1.isSelectionBounds, (line) => root.remove(line));
      }
      exports.removeSelectionBounds = removeSelectionBounds;
      function boundsInViewport(element, bounds) {
        if (element instanceof sprotty_1.GChildElement && !(0, sprotty_1.isViewport)(element.parent)) {
          return boundsInViewport(element.parent, element.parent.localToParent(bounds));
        } else {
          return bounds;
        }
      }
      exports.boundsInViewport = boundsInViewport;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/helper-lines/helper-line-manager.js
  var require_helper_line_manager = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/helper-lines/helper-line-manager.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HelperLineManager = exports.DEFAULT_HELPER_LINE_OPTIONS = exports.DEFAULT_MOVE_DELTA = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var selection_service_1 = require_selection_service();
      var set_bounds_feedback_command_1 = require_set_bounds_feedback_command();
      var model_1 = require_model19();
      var grid_1 = require_grid();
      var change_bounds_tool_feedback_1 = require_change_bounds_tool_feedback();
      var helper_line_feedback_1 = require_helper_line_feedback();
      var model_2 = require_model20();
      exports.DEFAULT_MOVE_DELTA = { x: 1, y: 1 };
      exports.DEFAULT_HELPER_LINE_OPTIONS = {
        elementLines: helper_line_feedback_1.DEFAULT_ELEMENT_LINES,
        viewportLines: helper_line_feedback_1.DEFAULT_VIEWPORT_LINES,
        alignmentEpsilon: helper_line_feedback_1.DEFAULT_EPSILON,
        alignmentElementFilter: helper_line_feedback_1.DEFAULT_ALIGNABLE_ELEMENT_FILTER,
        minimumMoveDelta: exports.DEFAULT_MOVE_DELTA,
        debug: helper_line_feedback_1.DEFAULT_DEBUG
      };
      var HelperLineManager = class HelperLineManager {
        init() {
          this.feedback = this.feedbackDispatcher.createEmitter();
          const dynamicOptions = {};
          if (this.grid) {
            dynamicOptions.alignmentEpsilon = 0;
            dynamicOptions.minimumMoveDelta = sprotty_1.Point.multiplyScalar(this.grid, 2);
          }
          this.options = { ...exports.DEFAULT_HELPER_LINE_OPTIONS, ...dynamicOptions, ...this.userOptions };
          this.selectionService.addListener(this);
        }
        handle(action) {
          if (change_bounds_tool_feedback_1.MoveInitializedEventAction.is(action)) {
            this.handleMoveInitializedAction(action);
          } else if (sprotty_1.MoveAction.is(action)) {
            this.handleMoveAction(action);
          } else if (change_bounds_tool_feedback_1.MoveFinishedEventAction.is(action)) {
            this.handleMoveFinishedAction(action);
          } else if (sprotty_1.SetBoundsAction.is(action) || set_bounds_feedback_command_1.SetBoundsFeedbackAction.is(action)) {
            this.handleSetBoundsAction(action);
          }
        }
        handleMoveInitializedAction(_action) {
          this.submitHelperLineFeedback();
        }
        handleMoveFinishedAction(_action) {
          this.feedback.dispose();
        }
        handleMoveAction(action) {
          if (!action.finished) {
            this.submitHelperLineFeedback(action.moves.map((move) => move.elementId));
          } else {
            this.feedback.dispose();
          }
        }
        submitHelperLineFeedback(elementIds = this.selectionService.getSelectedElementIDs()) {
          const feedback = this.createHelperLineFeedback(elementIds);
          this.feedback.add(feedback, [helper_line_feedback_1.RemoveHelperLinesFeedbackAction.create()]).submit();
        }
        createHelperLineFeedback(elementIds) {
          return helper_line_feedback_1.DrawHelperLinesFeedbackAction.create({ elementIds, ...this.options });
        }
        handleSetBoundsAction(action) {
          this.submitHelperLineFeedback(action.bounds.map((bound) => bound.elementId));
        }
        selectionChanged(root, selectedElements, deselectedElements) {
          this.feedback.dispose();
        }
        getMinimumMoveDelta(element, isSnap, direction) {
          if (!isSnap) {
            return 0;
          }
          const minimumMoveDelta = this.options.minimumMoveDelta;
          return direction === model_2.Direction.Left || direction === model_2.Direction.Right ? minimumMoveDelta.x : minimumMoveDelta.y;
        }
        getMinimumMoveVector(element, isSnap, move) {
          if (!isSnap) {
            return void 0;
          }
          const state = this.getHelperLineState(element);
          if (state.helperLines.length === 0) {
            return void 0;
          }
          const minimum = { ...sprotty_1.Vector.ZERO };
          const resize = element instanceof model_1.GResizeHandle ? model_1.ResizeHandleLocation.direction(element.location) : [model_2.Direction.Left, model_2.Direction.Right, model_2.Direction.Up, model_2.Direction.Down];
          if ((state.types.left || state.types.center) && move.includes(model_2.Direction.Left) && resize.includes(model_2.Direction.Left)) {
            minimum.x = this.getMinimumMoveDelta(element, isSnap, model_2.Direction.Left);
          } else if ((state.types.right || state.types.center) && move.includes(model_2.Direction.Right) && resize.includes(model_2.Direction.Right)) {
            minimum.x = this.getMinimumMoveDelta(element, isSnap, model_2.Direction.Right);
          }
          if ((state.types.top || state.types.middle) && move.includes(model_2.Direction.Up) && resize.includes(model_2.Direction.Up)) {
            minimum.y = this.getMinimumMoveDelta(element, isSnap, model_2.Direction.Up);
          } else if ((state.types.bottom || state.types.middle) && move.includes(model_2.Direction.Down) && resize.includes(model_2.Direction.Down)) {
            minimum.y = this.getMinimumMoveDelta(element, isSnap, model_2.Direction.Down);
          }
          return sprotty_1.Vector.isZero(minimum) ? void 0 : minimum;
        }
        getHelperLineState(element) {
          const helperLines = element.root.children.filter(model_2.isHelperLine) || [];
          const types = {
            left: false,
            right: false,
            top: false,
            bottom: false,
            center: false,
            middle: false
          };
          for (const line of helperLines) {
            switch (line.lineType) {
              case model_2.HelperLineType.Left:
              case model_2.HelperLineType.LeftRight:
                types.left = true;
                break;
              case model_2.HelperLineType.Right:
              case model_2.HelperLineType.RightLeft:
                types.right = true;
                break;
              case model_2.HelperLineType.Top:
              case model_2.HelperLineType.TopBottom:
                types.top = true;
                break;
              case model_2.HelperLineType.Bottom:
              case model_2.HelperLineType.BottomTop:
                types.bottom = true;
                break;
              case model_2.HelperLineType.Center:
                types.center = true;
                break;
              case model_2.HelperLineType.Middle:
                types.middle = true;
                break;
            }
          }
          return { helperLines, types };
        }
      };
      exports.HelperLineManager = HelperLineManager;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IFeedbackActionDispatcher),
        __metadata("design:type", Object)
      ], HelperLineManager.prototype, "feedbackDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(selection_service_1.SelectionService),
        __metadata("design:type", selection_service_1.SelectionService)
      ], HelperLineManager.prototype, "selectionService", void 0);
      __decorate([
        (0, inversify_1.optional)(),
        (0, inversify_1.inject)(sprotty_1.TYPES.IHelperLineOptions),
        __metadata("design:type", Object)
      ], HelperLineManager.prototype, "userOptions", void 0);
      __decorate([
        (0, inversify_1.optional)(),
        (0, inversify_1.inject)(sprotty_1.TYPES.Grid),
        __metadata("design:type", Object)
      ], HelperLineManager.prototype, "grid", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], HelperLineManager.prototype, "init", null);
      exports.HelperLineManager = HelperLineManager = __decorate([
        (0, inversify_1.injectable)()
      ], HelperLineManager);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/helper-lines/view.js
  var require_view5 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/helper-lines/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectionBoundsView = exports.HelperLineView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var HelperLineView = class HelperLineView extends sprotty_1.ShapeView {
        render(model, _context) {
          return (0, sprotty_1.svg)(
            "g",
            null,
            (0, sprotty_1.svg)("line", { "data-alignment": model.lineType, x1: model.startPoint.x, y1: model.startPoint.y, x2: model.endPoint.x, y2: model.endPoint.y, "class-helper-line": true })
          );
        }
      };
      exports.HelperLineView = HelperLineView;
      exports.HelperLineView = HelperLineView = __decorate([
        (0, inversify_1.injectable)()
      ], HelperLineView);
      var SelectionBoundsView = class SelectionBoundsView extends sprotty_1.ShapeView {
        render(model, context, args) {
          if (!this.isVisible(model, context)) {
            return void 0;
          }
          return (0, sprotty_1.svg)(
            "g",
            null,
            (0, sprotty_1.svg)("rect", { "class-selection-bounds": true, x: 0, y: 0, width: Math.max(model.size.width, 0), height: Math.max(model.size.height, 0) })
          );
        }
      };
      exports.SelectionBoundsView = SelectionBoundsView;
      exports.SelectionBoundsView = SelectionBoundsView = __decorate([
        (0, inversify_1.injectable)()
      ], SelectionBoundsView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/helper-lines/helper-line-module.js
  var require_helper_line_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/helper-lines/helper-line-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.helperLineModule = void 0;
      var sprotty_1 = require_lib4();
      var set_bounds_feedback_command_1 = require_set_bounds_feedback_command();
      var change_bounds_tool_feedback_1 = require_change_bounds_tool_feedback();
      var helper_line_feedback_1 = require_helper_line_feedback();
      var helper_line_manager_1 = require_helper_line_manager();
      var model_1 = require_model20();
      var view_1 = require_view5();
      exports.helperLineModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        (0, sprotty_1.configureModelElement)(context, model_1.HELPER_LINE, model_1.HelperLine, view_1.HelperLineView);
        (0, sprotty_1.configureModelElement)(context, model_1.SELECTION_BOUNDS, model_1.SelectionBounds, view_1.SelectionBoundsView);
        (0, sprotty_1.configureCommand)(context, helper_line_feedback_1.DrawHelperLinesFeedbackCommand);
        (0, sprotty_1.configureCommand)(context, helper_line_feedback_1.RemoveHelperLinesFeedbackCommand);
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.IHelperLineManager, helper_line_manager_1.HelperLineManager);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.SetBoundsAction.KIND, sprotty_1.TYPES.IHelperLineManager);
        (0, sprotty_1.configureActionHandler)(context, set_bounds_feedback_command_1.SetBoundsFeedbackAction.KIND, sprotty_1.TYPES.IHelperLineManager);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.MoveAction.KIND, sprotty_1.TYPES.IHelperLineManager);
        (0, sprotty_1.configureActionHandler)(context, change_bounds_tool_feedback_1.MoveInitializedEventAction.KIND, sprotty_1.TYPES.IHelperLineManager);
        (0, sprotty_1.configureActionHandler)(context, change_bounds_tool_feedback_1.MoveFinishedEventAction.KIND, sprotty_1.TYPES.IHelperLineManager);
      }, { featureId: Symbol("helperLine") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/save/save-keylistener.js
  var require_save_keylistener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/save/save-keylistener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SaveModelKeyboardListener = void 0;
      var sprotty_1 = require_lib4();
      var SaveModelKeyboardListener = class extends sprotty_1.KeyListener {
        keyDown(_element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "KeyS", "ctrlCmd")) {
            return [sprotty_1.SaveModelAction.create()];
          }
          return [];
        }
      };
      exports.SaveModelKeyboardListener = SaveModelKeyboardListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/save/save-module.js
  var require_save_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/save/save-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.saveModule = void 0;
      var sprotty_1 = require_lib4();
      var save_keylistener_1 = require_save_keylistener();
      exports.saveModule = new sprotty_1.FeatureModule((bind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.KeyListener, save_keylistener_1.SaveModelKeyboardListener);
      }, { featureId: Symbol("save") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/undo-redo/undo-redo-key-listener.js
  var require_undo_redo_key_listener = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/undo-redo/undo-redo-key-listener.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPUndoRedoKeyListener = void 0;
      var sprotty_1 = require_lib4();
      var GLSPUndoRedoKeyListener = class extends sprotty_1.KeyListener {
        keyDown(element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd")) {
            return [sprotty_1.UndoAction.create()];
          }
          if ((0, sprotty_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd", "shift") || !(0, sprotty_1.isMac)() && (0, sprotty_1.matchesKeystroke)(event, "KeyY", "ctrlCmd")) {
            return [sprotty_1.RedoAction.create()];
          }
          return [];
        }
      };
      exports.GLSPUndoRedoKeyListener = GLSPUndoRedoKeyListener;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/features/undo-redo/undo-redo-module.js
  var require_undo_redo_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/features/undo-redo/undo-redo-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.undoRedoModule = void 0;
      var sprotty_1 = require_lib4();
      var undo_redo_key_listener_1 = require_undo_redo_key_listener();
      exports.undoRedoModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        (0, sprotty_1.bindAsService)(bind, sprotty_1.TYPES.KeyListener, undo_redo_key_listener_1.GLSPUndoRedoKeyListener);
      }, { featureId: Symbol("undoRedo") });
    }
  });

  // node_modules/@eclipse-glsp/client/lib/re-exports.js
  var require_re_exports3 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/re-exports.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_lib4(), exports);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/standalone-modules.js
  var require_standalone_modules = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/standalone-modules.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.STANDALONE_MODULE_CONFIG = exports.STANDALONE_MODULES = exports.LayoutKeyListener = exports.FallbackActionHandler = exports.standaloneDefaultModule = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var shortcuts_module_1 = require_shortcuts_module();
      var resize_module_1 = require_resize_module();
      var copy_paste_modules_1 = require_copy_paste_modules();
      var export_modules_1 = require_export_modules();
      var save_module_1 = require_save_module();
      var select_module_1 = require_select_module();
      var undo_redo_module_1 = require_undo_redo_module();
      var validation_modules_1 = require_validation_modules();
      var viewport_modules_1 = require_viewport_modules();
      exports.standaloneDefaultModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        bind(FallbackActionHandler).toSelf().inSingletonScope();
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.MessageAction.KIND, FallbackActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.StartProgressAction.KIND, FallbackActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.UpdateProgressAction.KIND, FallbackActionHandler);
        (0, sprotty_1.configureActionHandler)(context, sprotty_1.EndProgressAction.KIND, FallbackActionHandler);
        (0, sprotty_1.bindAsService)(context, sprotty_1.TYPES.KeyListener, LayoutKeyListener);
      }, { featureId: Symbol("standaloneDefault") });
      var FallbackActionHandler = class FallbackActionHandler {
        handle(action) {
          this.logger.log(this, "Unhandled action received:", action);
        }
      };
      exports.FallbackActionHandler = FallbackActionHandler;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], FallbackActionHandler.prototype, "logger", void 0);
      exports.FallbackActionHandler = FallbackActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], FallbackActionHandler);
      var LayoutKeyListener = class LayoutKeyListener extends sprotty_1.KeyListener {
        keyDown(_element, event) {
          if ((0, sprotty_1.matchesKeystroke)(event, "KeyL", "ctrlCmd", "shift")) {
            return [sprotty_1.LayoutOperation.create()];
          }
          return [];
        }
      };
      exports.LayoutKeyListener = LayoutKeyListener;
      exports.LayoutKeyListener = LayoutKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], LayoutKeyListener);
      exports.STANDALONE_MODULES = [
        viewport_modules_1.standaloneViewportModule,
        copy_paste_modules_1.standaloneCopyPasteModule,
        validation_modules_1.standaloneMarkerNavigatorModule,
        select_module_1.standaloneSelectModule,
        export_modules_1.standaloneExportModule,
        exports.standaloneDefaultModule,
        shortcuts_module_1.standaloneShortcutsModule,
        resize_module_1.standaloneResizeModule,
        save_module_1.saveModule,
        undo_redo_module_1.undoRedoModule
      ];
      exports.STANDALONE_MODULE_CONFIG = {
        add: [...exports.STANDALONE_MODULES]
      };
    }
  });

  // node_modules/@eclipse-glsp/client/lib/utils/geometry-util.js
  var require_geometry_util2 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/utils/geometry-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isAfter = exports.isBefore = exports.isBelow = exports.isAbove = exports.compareFunction = exports.sortBy = exports.bottomRight = exports.bottomCenter = exports.bottomLeft = exports.middleRight = exports.middleCenter = exports.middleLeft = exports.topRight = exports.topCenter = exports.topLeft = exports.bottom = exports.middle = exports.top = exports.right = exports.center = exports.left = void 0;
      var sprotty_1 = require_lib4();
      exports.left = sprotty_1.Bounds.left;
      exports.center = sprotty_1.Bounds.center;
      exports.right = sprotty_1.Bounds.right;
      exports.top = sprotty_1.Bounds.top;
      exports.middle = sprotty_1.Bounds.middle;
      exports.bottom = sprotty_1.Bounds.bottom;
      exports.topLeft = sprotty_1.Bounds.topLeft;
      exports.topCenter = sprotty_1.Bounds.topCenter;
      exports.topRight = sprotty_1.Bounds.topRight;
      exports.middleLeft = sprotty_1.Bounds.middleLeft;
      exports.middleCenter = sprotty_1.Bounds.middleCenter;
      exports.middleRight = sprotty_1.Bounds.middleRight;
      exports.bottomLeft = sprotty_1.Bounds.bottomLeft;
      exports.bottomCenter = sprotty_1.Bounds.bottomCenter;
      exports.bottomRight = sprotty_1.Bounds.bottomRight;
      exports.sortBy = sprotty_1.Bounds.sortBy;
      var compareFunction = (rankFunc) => (x3, y3) => rankFunc(x3) - rankFunc(y3);
      exports.compareFunction = compareFunction;
      exports.isAbove = sprotty_1.Bounds.isAbove;
      exports.isBelow = sprotty_1.Bounds.isBelow;
      exports.isBefore = sprotty_1.Bounds.isBefore;
      exports.isAfter = sprotty_1.Bounds.isAfter;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/gedge-view.js
  var require_gedge_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/gedge-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GEdgeView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var argument_utils_1 = require_argument_utils();
      var GEdgeView = class GEdgeView extends sprotty_1.PolylineEdgeView {
        render(edge, context) {
          const router = this.edgeRouterRegistry.get(edge.routerKind);
          const route = router.route(edge);
          if (route.length === 0) {
            return this.renderDanglingEdge("Cannot compute route", edge, context);
          }
          return (0, sprotty_1.svg)(
            "g",
            { "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback, ...this.additionalClasses(edge, context) },
            this.renderLine(edge, route, context),
            this.renderAdditionals(edge, route, context),
            context.renderChildren(edge, { route })
          );
        }
        additionalClasses(_edge, _context) {
          return {};
        }
        renderLine(_edge, segments, _context) {
          return (0, sprotty_1.svg)("path", { d: this.createPathForSegments(segments) });
        }
        renderAdditionals(edge, segments, _context) {
          const edgePadding = argument_utils_1.EdgePadding.from(edge);
          return edgePadding ? [this.renderMouseHandle(segments, edgePadding)] : [];
        }
        renderMouseHandle(segments, padding) {
          return (0, sprotty_1.svg)("path", { "class-mouse-handle": true, d: this.createPathForSegments(segments), "style-stroke-width": padding * 2, "style-stroke": "transparent", "style-stroke-dasharray": "none", "style-stroke-dashoffset": "0" });
        }
        createPathForSegments(segments) {
          const firstPoint = segments[0];
          let path = `M ${firstPoint.x},${firstPoint.y}`;
          for (let i2 = 1; i2 < segments.length; i2++) {
            const p3 = segments[i2];
            path += ` L ${p3.x},${p3.y}`;
          }
          return path;
        }
      };
      exports.GEdgeView = GEdgeView;
      exports.GEdgeView = GEdgeView = __decorate([
        (0, inversify_1.injectable)()
      ], GEdgeView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/ggraph-view.js
  var require_ggraph_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/ggraph-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GGraphView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var grid_style_1 = require_grid_style();
      var GGraphView = class GGraphView extends sprotty_1.SGraphView {
        render(model, context) {
          const graph = super.render(model, context);
          if (graph.data) {
            graph.data.style = { ...graph.data.style, ...this.getGridStyle(model, context) };
          }
          return graph;
        }
        getGridStyle(viewport, context) {
          if (context.targetKind === "hidden" || !this.gridManager) {
            return {};
          }
          const bounds = this.getBackgroundBounds(viewport, context, this.gridManager);
          return {
            [grid_style_1.GridProperty.GRID_BACKGROUND_X]: bounds.x + "px",
            [grid_style_1.GridProperty.GRID_BACKGROUND_Y]: bounds.y + "px",
            [grid_style_1.GridProperty.GRID_BACKGROUND_WIDTH]: bounds.width + "px",
            [grid_style_1.GridProperty.GRID_BACKGROUND_HEIGHT]: bounds.height + "px",
            [grid_style_1.GridProperty.GRID_BACKGROUND_ZOOM]: viewport.zoom + ""
          };
        }
        getBackgroundBounds(viewport, context, gridManager) {
          const position = sprotty_1.Point.multiplyScalar(sprotty_1.Point.subtract(gridManager.grid, viewport.scroll), viewport.zoom);
          const size = sprotty_1.Dimension.fromPoint(sprotty_1.Point.multiplyScalar(gridManager.grid, viewport.zoom));
          return { ...position, ...size };
        }
      };
      exports.GGraphView = GGraphView;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IGridManager),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], GGraphView.prototype, "gridManager", void 0);
      exports.GGraphView = GGraphView = __decorate([
        (0, inversify_1.injectable)()
      ], GGraphView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/issue-marker-view.js
  var require_issue_marker_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/issue-marker-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GIssueMarkerView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var GIssueMarkerView = class GIssueMarkerView extends sprotty_1.IssueMarkerView {
        render(marker, _context) {
          const maxSeverity = super.getMaxSeverity(marker);
          const group = (0, sprotty_1.svg)(
            "g",
            { "class-sprotty-issue": true },
            (0, sprotty_1.svg)(
              "g",
              null,
              this.getGlspIssueMarkerBackground(maxSeverity),
              (0, sprotty_1.svg)("path", { d: this.getGlspIssueMarkerPath(maxSeverity) })
            )
          );
          (0, sprotty_1.setClass)(group, "sprotty-" + maxSeverity, true);
          return group;
        }
        getGlspIssueMarkerBackground(severity) {
          switch (severity) {
            case "warning":
              return (0, sprotty_1.svg)("polygon", { "class-sprotty-issue-background": true, points: "8 2, 15.9 14.9, 0.2 14.9" });
            case "error":
            case "info":
              return (0, sprotty_1.svg)("circle", { "class-sprotty-issue-background": true, r: this.radius, cx: this.radius, cy: this.radius });
          }
        }
        get radius() {
          return 8;
        }
        getGlspIssueMarkerPath(severity) {
          switch (severity) {
            // paths used here are svg versions of codicons, resized to var(--theia-icon-size) 16px
            case "error":
              return "m 8.8527788,0.00699568 c 1.8523692,0.115773 3.5889642,1.04195762 4.8624692,2.31546152 1.505048,1.620823 2.31546,3.5889653 2.31546,5.9044268 0,1.852369 -0.694637,3.588965 -1.852367,5.094015 -1.157733,1.389277 -2.778554,2.431235 -4.6309235,2.778554 C 7.6950478,16.446772 5.8426784,16.215226 4.2218552,15.289042 2.6010319,14.362857 1.3275281,12.97358 0.63288942,11.236984 -0.06174907,9.5003878 -0.17752216,7.5322456 0.4013433,5.7956494 0.98020876,3.9432802 2.0221665,2.4382302 3.6429898,1.3962725 5.14804,0.35431486 7.0004094,-0.10877742 8.8527788,0.00699568 Z M 9.4316445,14.941722 c 1.5050505,-0.347319 2.8943275,-1.15773 3.9362845,-2.431234 0.926185,-1.273504 1.50505,-2.778554 1.389277,-4.3993771 0,-1.8523692 -0.69464,-3.7047384 -1.968142,-4.9782422 C 11.631331,1.9751379 10.242054,1.2804995 8.6212324,1.1647264 7.1161824,1.0489533 5.4953592,1.3962725 4.2218552,2.3224572 2.9483511,3.2486418 2.0221665,4.5221456 1.5590742,6.1429686 c -0.4630923,1.50505 -0.4630923,3.1258731 0.2315462,4.6309234 0.6946384,1.50505 1.7365963,2.66278 3.1258734,3.473192 1.3892769,0.810411 3.0101002,1.041958 4.5151507,0.694638 z M 8.042367,7.5322456 10.82092,4.6379187 11.631331,5.4483302 8.8527788,8.3426571 11.631331,11.236984 10.82092,12.047395 8.042367,9.1530686 5.2638128,12.047395 4.4534013,11.236984 7.2319555,8.3426571 4.4534013,5.4483302 5.2638128,4.6379187 Z";
            case "warning":
              return "M 7.5587159,0.61312771 H 8.565869 L 16.050847,14.644601 15.54727,15.491525 H 0.55442396 L 0.05084746,14.644601 Z M 8.0622924,2.0780776 1.5157974,14.347033 H 14.585897 Z M 8.7776,13.202541 V 12.058049 H 7.3469848 v 1.144492 z M 7.3469848,10.913557 V 6.3355883 H 8.7776 v 4.5779687 z";
            case "info":
              return "M 8.7624795,0.01729008 A 7.8878137,7.8878137 0 0 1 13.625085,2.3592747 8.1894066,8.1894066 0 0 1 14.158672,13.251418 7.9458123,7.9458123 0 0 1 4.2061071,15.26977 8.1198082,8.1198082 0 0 1 0.58699265,11.209866 8.259005,8.259005 0 0 1 0.32019895,5.7463948 8.1198082,8.1198082 0 0 1 3.533323,1.3500986 7.8878137,7.8878137 0 0 1 8.7624795,0.01729008 Z M 9.3099868,14.921778 A 6.8322386,6.8322386 0 0 0 13.265493,12.520635 7.0410337,7.0410337 0 0 0 12.801504,3.1712556 6.7510406,6.7510406 0 0 0 4.1829077,2.3128758 7.029434,7.029434 0 0 0 4.762894,14.248994 6.7394408,6.7394408 0 0 0 9.3099868,14.921778 Z M 7.3786322,5.7811939 H 8.8285979 V 4.6212213 H 7.3786322 Z M 8.8285979,6.9411665 V 11.581057 H 7.3786322 V 6.9411665 Z";
          }
        }
      };
      exports.GIssueMarkerView = GIssueMarkerView;
      exports.GIssueMarkerView = GIssueMarkerView = __decorate([
        (0, inversify_1.injectable)()
      ], GIssueMarkerView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/rounded-corner.js
  var require_rounded_corner = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/rounded-corner.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scaledRadius = exports.RoundedCornerWrapper = void 0;
      var RoundedCornerWrapper = class {
        constructor(element, cornerRadius) {
          this.element = element;
          this.cornerRadius = cornerRadius;
        }
        get size() {
          return this.element.size;
        }
        get topLeftCorner() {
          if (!this._topLeftCorner) {
            this._topLeftCorner = {
              radiusX: scaledRadius(this.cornerRadius.topLeft, this.element.size.width / 2),
              radiusY: scaledRadius(this.cornerRadius.topLeft, this.element.size.height / 2)
            };
          }
          return this._topLeftCorner;
        }
        get topRightCorner() {
          if (!this._topRightCorner) {
            this._topRightCorner = {
              radiusX: scaledRadius(this.cornerRadius.topRight, this.element.size.width / 2),
              radiusY: scaledRadius(this.cornerRadius.topRight, this.element.size.height / 2)
            };
          }
          return this._topRightCorner;
        }
        get bottomRightCorner() {
          if (!this._bottomRightCorner) {
            this._bottomRightCorner = {
              radiusX: scaledRadius(this.cornerRadius.bottomRight, this.element.size.width / 2),
              radiusY: scaledRadius(this.cornerRadius.bottomRight, this.element.size.height / 2)
            };
          }
          return this._bottomRightCorner;
        }
        get bottomLeftCorner() {
          if (!this._bottomLeftCorner) {
            this._bottomLeftCorner = {
              radiusX: scaledRadius(this.cornerRadius.bottomLeft, this.element.size.width / 2),
              radiusY: scaledRadius(this.cornerRadius.bottomLeft, this.element.size.height / 2)
            };
          }
          return this._bottomLeftCorner;
        }
      };
      exports.RoundedCornerWrapper = RoundedCornerWrapper;
      function scaledRadius(radius, maximalLength) {
        if (radius <= maximalLength) {
          return radius;
        } else {
          return radius * (maximalLength / radius);
        }
      }
      exports.scaledRadius = scaledRadius;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/rounded-corner-view.js
  var require_rounded_corner_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/rounded-corner-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toClipPathId = exports.RoundedCornerNodeView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var argument_utils_1 = require_argument_utils();
      var rounded_corner_1 = require_rounded_corner();
      var RoundedCornerNodeView3 = class RoundedCornerNodeView extends sprotty_1.RectangularNodeView {
        render(node, context) {
          const cornerRadius = argument_utils_1.CornerRadius.from(node);
          if (!cornerRadius) {
            return this.renderWithoutRadius(node, context);
          }
          const wrapper = new rounded_corner_1.RoundedCornerWrapper(node, cornerRadius);
          return (0, sprotty_1.svg)(
            "g",
            { "class-node": true },
            (0, sprotty_1.svg)(
              "defs",
              null,
              (0, sprotty_1.svg)(
                "clipPath",
                { id: toClipPathId(node) },
                (0, sprotty_1.svg)("path", { d: this.renderPath(wrapper, context, this.getClipPathInsets() || 0) })
              )
            ),
            this.renderPathNode(wrapper, context),
            context.renderChildren(node)
          );
        }
        renderWithoutRadius(node, context) {
          return super.render(node, context);
        }
        getClipPathInsets() {
          return 2;
        }
        renderPathNode(wrapper, context) {
          return (0, sprotty_1.svg)("path", { d: this.renderPath(wrapper, context, 0), "class-sprotty-node": wrapper.element instanceof sprotty_1.GNode, "class-sprotty-port": wrapper.element instanceof sprotty_1.GPort, "class-mouseover": wrapper.element.hoverFeedback, "class-selected": wrapper.element.selected, ...this.additionalClasses(wrapper.element, context) });
        }
        additionalClasses(_node, _context) {
          return {};
        }
        renderPath(wrapper, _context, inset) {
          const topLineLength = Math.max(0, wrapper.size.width - wrapper.cornerRadius.topLeft - wrapper.cornerRadius.topRight);
          const rightLineLength = Math.max(0, wrapper.size.height - wrapper.cornerRadius.topRight - wrapper.cornerRadius.bottomRight);
          const bottomLineLength = Math.max(0, wrapper.size.width - wrapper.cornerRadius.bottomLeft - wrapper.cornerRadius.bottomRight);
          const path = `M${0 + inset},${0 + wrapper.topLeftCorner.radiusY}q${0},${-(wrapper.topLeftCorner.radiusY - inset)} ${wrapper.topLeftCorner.radiusX - inset},${-(wrapper.topLeftCorner.radiusY - inset)}h${topLineLength}q${wrapper.topRightCorner.radiusX - inset},0 ${wrapper.topRightCorner.radiusX - inset},${wrapper.topRightCorner.radiusY - inset}v${rightLineLength}q0,${wrapper.bottomRightCorner.radiusY - inset} ${-(wrapper.bottomRightCorner.radiusX - inset)},${wrapper.bottomRightCorner.radiusY - inset}h${-bottomLineLength}q${-(wrapper.bottomLeftCorner.radiusX - inset)},0 ${-(wrapper.bottomLeftCorner.radiusX - inset)},${-(wrapper.bottomLeftCorner.radiusY - inset)}z `;
          return path;
        }
      };
      exports.RoundedCornerNodeView = RoundedCornerNodeView3;
      exports.RoundedCornerNodeView = RoundedCornerNodeView3 = __decorate([
        (0, inversify_1.injectable)()
      ], RoundedCornerNodeView3);
      function toClipPathId(node) {
        return `${node.id}_clip_path`;
      }
      exports.toClipPathId = toClipPathId;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/routing-point-handle-view.js
  var require_routing_point_handle_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/routing-point-handle-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GRoutingHandleView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var model_1 = require_model23();
      var GRoutingHandleView = class GRoutingHandleView extends sprotty_1.SRoutingHandleView {
        render(handle, context, args) {
          if (!(0, model_1.isReconnectHandle)(handle) && (handle.kind === "source" || handle.kind === "target")) {
            return void 0;
          }
          return super.render(handle, context, args);
        }
      };
      exports.GRoutingHandleView = GRoutingHandleView;
      exports.GRoutingHandleView = GRoutingHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], GRoutingHandleView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/base-view-module.js
  var require_base_view_module = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/base-view-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureDefaultModelElements = exports.baseViewModule = void 0;
      var sprotty_1 = require_lib4();
      var issue_marker_1 = require_issue_marker();
      var model_1 = require_model22();
      var gedge_view_1 = require_gedge_view();
      var ggraph_view_1 = require_ggraph_view();
      var issue_marker_view_1 = require_issue_marker_view();
      var rounded_corner_view_1 = require_rounded_corner_view();
      var routing_point_handle_view_1 = require_routing_point_handle_view();
      exports.baseViewModule = new sprotty_1.FeatureModule((bind, unbind, isBound, rebind) => {
        const context = { bind, unbind, isBound, rebind };
        configureDefaultModelElements2(context);
      }, { featureId: Symbol("baseView") });
      function configureDefaultModelElements2(context) {
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.HTML, sprotty_1.GHtmlRoot, sprotty_1.HtmlRootView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.FOREIGN_OBJECT, sprotty_1.GForeignObjectElement, sprotty_1.ForeignObjectView, {
          disable: [sprotty_1.selectFeature, sprotty_1.moveFeature]
        });
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.PRE_RENDERED, sprotty_1.GPreRenderedElement, sprotty_1.PreRenderedView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.SHAPE_PRE_RENDERED, sprotty_1.GShapedPreRenderedElement, sprotty_1.PreRenderedView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.SVG, sprotty_1.GViewportRootElement, sprotty_1.SvgViewportView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.GRAPH, model_1.GGraph, ggraph_view_1.GGraphView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.NODE, sprotty_1.GNode, rounded_corner_view_1.RoundedCornerNodeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.COMPARTMENT, sprotty_1.GCompartment, sprotty_1.GCompartmentView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.COMPARTMENT_HEADER, sprotty_1.GCompartment, sprotty_1.GCompartmentView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.EDGE, model_1.GEdge, gedge_view_1.GEdgeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.PORT, sprotty_1.GPort, sprotty_1.RectangularNodeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.ROUTING_POINT, sprotty_1.GRoutingHandle, routing_point_handle_view_1.GRoutingHandleView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.VOLATILE_ROUTING_POINT, sprotty_1.GRoutingHandle, routing_point_handle_view_1.GRoutingHandleView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.LABEL, sprotty_1.GLabel, sprotty_1.GLabelView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.BUTTON_EXPAND, sprotty_1.GButton, sprotty_1.ExpandButtonView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.ISSUE_MARKER, issue_marker_1.GIssueMarker, issue_marker_view_1.GIssueMarkerView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.NODE_CIRCLE, sprotty_1.CircularNode, sprotty_1.CircularNodeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.NODE_DIAMOND, sprotty_1.DiamondNode, sprotty_1.DiamondNodeView);
        (0, sprotty_1.configureModelElement)(context, sprotty_1.DefaultTypes.NODE_RECTANGLE, sprotty_1.RectangularNode, sprotty_1.RectangularNodeView);
      }
      exports.configureDefaultModelElements = configureDefaultModelElements2;
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/compartments.js
  var require_compartments = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/compartments.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StructureCompartmentView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var StructureCompartmentView = class StructureCompartmentView extends sprotty_1.ShapeView {
        render(model, context) {
          if (!this.isVisible(model, context)) {
            return void 0;
          }
          return (0, sprotty_1.svg)(
            "g",
            null,
            (0, sprotty_1.svg)("rect", { "class-sprotty-comp": true, x: "0", y: "0", width: model.size.width, height: model.size.height }),
            context.renderChildren(model)
          );
        }
      };
      exports.StructureCompartmentView = StructureCompartmentView;
      exports.StructureCompartmentView = StructureCompartmentView = __decorate([
        (0, inversify_1.injectable)()
      ], StructureCompartmentView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/views/glsp-projection-view.js
  var require_glsp_projection_view = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/views/glsp-projection-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPProjectionView = void 0;
      var sprotty_1 = require_lib4();
      var inversify_1 = require_cjs4();
      var snabbdom_1 = require_snabbdom_cjs();
      var messages_1 = require_messages3();
      var grid_style_1 = require_grid_style();
      var GLSPProjectionView = class GLSPProjectionView extends sprotty_1.ProjectedViewportView {
        render(model, context, args) {
          const rootNode = (0, sprotty_1.html)(
            "div",
            { "class-sprotty-graph": false, style: { width: "100%", height: "100%" } },
            this.renderSvg(model, context, args),
            this.renderProjections(model, context, args)
          );
          (0, sprotty_1.setAttr)(rootNode, "tabindex", 1);
          (0, sprotty_1.setAttr)(rootNode, "aria-label", messages_1.messages.diagram.label);
          return rootNode;
        }
        renderSvg(model, context, args) {
          const edgeRouting = this.edgeRouterRegistry.routeAllChildren(model);
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          const ns = "http://www.w3.org/2000/svg";
          const svg = (0, snabbdom_1.h)("svg", { ns, style: { height: "100%", ...this.getGridStyle(model, context) }, class: { "sprotty-graph": true } }, (0, snabbdom_1.h)("g", { ns, attrs: { transform } }, context.renderChildren(model, { edgeRouting })));
          return svg;
        }
        getGridStyle(viewport, context) {
          if (context.targetKind === "hidden" || !this.gridManager) {
            return {};
          }
          const bounds = this.getBackgroundBounds(viewport, context, this.gridManager);
          return {
            [grid_style_1.GridProperty.GRID_BACKGROUND_X]: bounds.x + "px",
            [grid_style_1.GridProperty.GRID_BACKGROUND_Y]: bounds.y + "px",
            [grid_style_1.GridProperty.GRID_BACKGROUND_WIDTH]: bounds.width + "px",
            [grid_style_1.GridProperty.GRID_BACKGROUND_HEIGHT]: bounds.height + "px",
            [grid_style_1.GridProperty.GRID_BACKGROUND_ZOOM]: viewport.zoom + ""
          };
        }
        getBackgroundBounds(viewport, context, gridManager) {
          const position = sprotty_1.Point.multiplyScalar(sprotty_1.Point.subtract(gridManager.grid, viewport.scroll), viewport.zoom);
          const size = sprotty_1.Dimension.fromPoint(sprotty_1.Point.multiplyScalar(gridManager.grid, viewport.zoom));
          return { ...position, ...size };
        }
        renderProjectionBar(projections, model, modelBounds, orientation) {
          const vnode = super.renderProjectionBar(projections, model, modelBounds, orientation);
          (0, sprotty_1.setClass)(vnode, "bordered-projection-bar", true);
          return vnode;
        }
        renderViewport(model, params) {
          let canvasSize;
          let viewportPos;
          if (params.orientation === "horizontal") {
            canvasSize = model.canvasBounds.width;
            viewportPos = (model.scroll.x - params.modelBounds.x) * params.factor;
          } else {
            canvasSize = model.canvasBounds.height;
            viewportPos = (model.scroll.y - params.modelBounds.y) * params.factor;
          }
          let viewportSize = canvasSize * params.zoomedFactor;
          if (viewportPos < 0) {
            viewportSize += viewportPos;
            viewportPos = 0;
          } else if (viewportPos > canvasSize) {
            viewportPos = canvasSize;
          }
          if (viewportSize < 0) {
            viewportSize = 0;
          } else if (viewportPos + viewportSize > canvasSize) {
            viewportSize = canvasSize - viewportPos;
          }
          if (Math.abs(viewportSize - canvasSize) < 1) {
            viewportSize = 0;
          }
          const style = params.orientation === "horizontal" ? {
            left: `${viewportPos}px`,
            width: `${viewportSize}px`
          } : {
            top: `${viewportPos}px`,
            height: `${viewportSize}px`
          };
          return (0, sprotty_1.html)("div", { "class-sprotty-viewport": viewportSize !== 0, "class-projection-scroll-bar": true, style });
        }
        renderProjection(projection, model, params) {
          const vnode = super.renderProjection(projection, model, params);
          (0, sprotty_1.setClass)(vnode, "glsp-projection", true);
          const style = vnode.data.style;
          if (style.left) {
            style.height = "60%";
          } else {
            style.width = "60%";
          }
          return vnode;
        }
      };
      exports.GLSPProjectionView = GLSPProjectionView;
      __decorate([
        (0, inversify_1.inject)(sprotty_1.EdgeRouterRegistry),
        __metadata("design:type", sprotty_1.EdgeRouterRegistry)
      ], GLSPProjectionView.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(sprotty_1.TYPES.IGridManager),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], GLSPProjectionView.prototype, "gridManager", void 0);
      exports.GLSPProjectionView = GLSPProjectionView = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPProjectionView);
    }
  });

  // node_modules/@eclipse-glsp/client/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/@eclipse-glsp/client/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_action_dispatcher2(), exports);
      __exportStar(require_action_handler_registry(), exports);
      __exportStar(require_args_feature(), exports);
      __exportStar(require_auto_complete_actions(), exports);
      __exportStar(require_auto_complete_widget(), exports);
      __exportStar(require_autocomplete_suggestion_providers(), exports);
      __exportStar(require_base_autocomplete_palette(), exports);
      __exportStar(require_validation_decorator(), exports);
      __exportStar(require_command_stack2(), exports);
      __exportStar(require_default_module(), exports);
      __exportStar(require_drag_aware_mouse_listener(), exports);
      __exportStar(require_editor_context_service(), exports);
      __exportStar(require_css_feedback(), exports);
      __exportStar(require_feedback_action_dispatcher(), exports);
      __exportStar(require_feedback_command(), exports);
      __exportStar(require_feedback_emitter(), exports);
      __exportStar(require_set_model_command(), exports);
      __exportStar(require_update_model_command(), exports);
      __exportStar(require_focus_state_change_action(), exports);
      __exportStar(require_focus_tracker(), exports);
      __exportStar(require_messages3(), exports);
      __exportStar(require_diagram_loader(), exports);
      __exportStar(require_glsp_model_source(), exports);
      __exportStar(require_model_initialization_constraint(), exports);
      __exportStar(require_model_registry(), exports);
      __exportStar(require_mouse_position_tracker(), exports);
      __exportStar(require_ranked(), exports);
      __exportStar(require_selection_clearing_mouse_listener(), exports);
      __exportStar(require_selection_service(), exports);
      __exportStar(require_available_shortcuts_extension(), exports);
      __exportStar(require_available_shortcuts_tool(), exports);
      __exportStar(require_shortcuts_manager(), exports);
      __exportStar(require_shortcuts_module(), exports);
      __exportStar(require_tool(), exports);
      __exportStar(require_tool_manager(), exports);
      __exportStar(require_ui_extension2(), exports);
      __exportStar(require_ui_extension_registry2(), exports);
      __exportStar(require_key_tool2(), exports);
      __exportStar(require_mouse_tool2(), exports);
      __exportStar(require_view_registry(), exports);
      __exportStar(require_default_modules(), exports);
      __exportStar(require_accessibility_module(), exports);
      __exportStar(require_actions2(), exports);
      __exportStar(require_action2(), exports);
      __exportStar(require_edge_autocomplete_context(), exports);
      __exportStar(require_edge_autocomplete_palette(), exports);
      __exportStar(require_edge_autocomplete_tool(), exports);
      __exportStar(require_diagram_navigation_tool(), exports);
      __exportStar(require_element_navigation_module(), exports);
      __exportStar(require_element_navigator(), exports);
      __exportStar(require_left_right_top_bottom_navigator(), exports);
      __exportStar(require_local_element_navigator(), exports);
      __exportStar(require_position_navigator(), exports);
      __exportStar(require_focus_tracker_module(), exports);
      __exportStar(require_focus_tracker_tool(), exports);
      __exportStar(require_global_keylistener_tool(), exports);
      __exportStar(require_action3(), exports);
      __exportStar(require_constants(), exports);
      __exportStar(require_keyboard_grid(), exports);
      __exportStar(require_keyboard_grid_search_palette(), exports);
      __exportStar(require_keyboard_node_grid(), exports);
      __exportStar(require_actions3(), exports);
      __exportStar(require_constants2(), exports);
      __exportStar(require_keyboard_pointer(), exports);
      __exportStar(require_keyboard_pointer_listener(), exports);
      __exportStar(require_keyboard_pointer_module(), exports);
      __exportStar(require_keyboard_pointer_position(), exports);
      __exportStar(require_keyboard_tool_palette2(), exports);
      __exportStar(require_keyboard_tool_palette_module(), exports);
      __exportStar(require_search_palette(), exports);
      __exportStar(require_search_palette_module(), exports);
      __exportStar(require_search_tool(), exports);
      __exportStar(require_toast_handler(), exports);
      __exportStar(require_toast_module(), exports);
      __exportStar(require_toast_tool(), exports);
      __exportStar(require_deselect_key_tool(), exports);
      __exportStar(require_grid_cell_zoom_key_tool(), exports);
      __exportStar(require_view_key_tools_module(), exports);
      __exportStar(require_bounds_module(), exports);
      __exportStar(require_freeform_layout(), exports);
      __exportStar(require_glsp_hidden_bounds_updater(), exports);
      __exportStar(require_hbox_layout2(), exports);
      __exportStar(require_layout_data(), exports);
      __exportStar(require_layouter(), exports);
      __exportStar(require_local_bounds(), exports);
      __exportStar(require_set_bounds_feedback_command(), exports);
      __exportStar(require_vbox_layout2(), exports);
      __exportStar(require_model19(), exports);
      __exportStar(require_move_element_action(), exports);
      __exportStar(require_move_element_handler(), exports);
      __exportStar(require_movement_restrictor(), exports);
      __exportStar(require_point_position_updater(), exports);
      __exportStar(require_position_snapper(), exports);
      __exportStar(require_resize_default_tool(), exports);
      __exportStar(require_resize_handler(), exports);
      __exportStar(require_resize_module(), exports);
      __exportStar(require_resize_tool(), exports);
      __exportStar(require_snap2(), exports);
      __exportStar(require_tracker(), exports);
      __exportStar(require_command_palette3(), exports);
      __exportStar(require_command_palette_module(), exports);
      __exportStar(require_command_palette_tool(), exports);
      __exportStar(require_server_command_palette_provider(), exports);
      __exportStar(require_context_menu_module(), exports);
      __exportStar(require_delete_element_context_menu(), exports);
      __exportStar(require_glsp_context_menu_mouse_listener(), exports);
      __exportStar(require_server_context_menu_provider(), exports);
      __exportStar(require_copy_paste_context_menu(), exports);
      __exportStar(require_copy_paste_handler(), exports);
      __exportStar(require_copy_paste_modules(), exports);
      __exportStar(require_copy_paste_standalone(), exports);
      __exportStar(require_debug_bounds_decorator(), exports);
      __exportStar(require_debug_manager(), exports);
      __exportStar(require_debug_model(), exports);
      __exportStar(require_debug_module(), exports);
      __exportStar(require_decoration_module(), exports);
      __exportStar(require_decoration_placer2(), exports);
      __exportStar(require_add_template_element(), exports);
      __exportStar(require_element_template_module(), exports);
      __exportStar(require_mouse_tracking_element_position_listener(), exports);
      __exportStar(require_remove_template_element(), exports);
      __exportStar(require_export_modules(), exports);
      __exportStar(require_export_svg_action_handler(), exports);
      __exportStar(require_glsp_svg_exporter(), exports);
      __exportStar(require_grid(), exports);
      __exportStar(require_grid_manager(), exports);
      __exportStar(require_grid_model(), exports);
      __exportStar(require_grid_module(), exports);
      __exportStar(require_grid_snapper(), exports);
      __exportStar(require_grid_style(), exports);
      __exportStar(require_helper_line_feedback(), exports);
      __exportStar(require_helper_line_manager(), exports);
      __exportStar(require_helper_line_module(), exports);
      __exportStar(require_model20(), exports);
      __exportStar(require_view5(), exports);
      __exportStar(require_model21(), exports);
      __exportStar(require_type_hint_provider(), exports);
      __exportStar(require_type_hints_module(), exports);
      __exportStar(require_hover2(), exports);
      __exportStar(require_hover_module(), exports);
      __exportStar(require_label_edit_ui(), exports);
      __exportStar(require_label_edit_ui_module(), exports);
      __exportStar(require_edit_label_tool(), exports);
      __exportStar(require_edit_label_validator(), exports);
      __exportStar(require_label_edit_module(), exports);
      __exportStar(require_layout_elements_action(), exports);
      __exportStar(require_layout_module(), exports);
      __exportStar(require_navigation_action_handler(), exports);
      __exportStar(require_navigation_module(), exports);
      __exportStar(require_navigation_target_resolver(), exports);
      __exportStar(require_model23(), exports);
      __exportStar(require_edge_router(), exports);
      __exportStar(require_routing_module(), exports);
      __exportStar(require_save_keylistener(), exports);
      __exportStar(require_save_module(), exports);
      __exportStar(require_select_feedback_command(), exports);
      __exportStar(require_select_module(), exports);
      __exportStar(require_select_mouse_listener(), exports);
      __exportStar(require_source_model_changed_action_handler(), exports);
      __exportStar(require_source_model_watcher_module(), exports);
      __exportStar(require_status_module(), exports);
      __exportStar(require_status_overlay2(), exports);
      __exportStar(require_metadata_placer(), exports);
      __exportStar(require_svg_metadata_module(), exports);
      __exportStar(require_tool_palette3(), exports);
      __exportStar(require_tool_palette_module(), exports);
      __exportStar(require_base_tools(), exports);
      __exportStar(require_change_bounds_manager(), exports);
      __exportStar(require_change_bounds_tool(), exports);
      __exportStar(require_change_bounds_tool_feedback(), exports);
      __exportStar(require_change_bounds_tool_module(), exports);
      __exportStar(require_change_bounds_tool_move_feedback(), exports);
      __exportStar(require_change_bounds_tracker(), exports);
      __exportStar(require_view3(), exports);
      __exportStar(require_delete_tool(), exports);
      __exportStar(require_deletion_tool_module(), exports);
      __exportStar(require_dangling_edge_feedback(), exports);
      __exportStar(require_edege_creation_module(), exports);
      __exportStar(require_edge_creation_tool(), exports);
      __exportStar(require_edge_creation_tool_feedback(), exports);
      __exportStar(require_view2(), exports);
      __exportStar(require_edge_edit_module(), exports);
      __exportStar(require_edge_edit_tool(), exports);
      __exportStar(require_edge_edit_tool_feedback(), exports);
      __exportStar(require_marquee_behavior(), exports);
      __exportStar(require_marquee_mouse_tool(), exports);
      __exportStar(require_marquee_selection_module(), exports);
      __exportStar(require_marquee_tool(), exports);
      __exportStar(require_marquee_tool_feedback(), exports);
      __exportStar(require_model24(), exports);
      __exportStar(require_view4(), exports);
      __exportStar(require_container_manager(), exports);
      __exportStar(require_insert_indicator(), exports);
      __exportStar(require_node_creation_module(), exports);
      __exportStar(require_node_creation_tool(), exports);
      __exportStar(require_node_creation_views(), exports);
      __exportStar(require_tool_focus_loss_module(), exports);
      __exportStar(require_undo_redo_key_listener(), exports);
      __exportStar(require_undo_redo_module(), exports);
      __exportStar(require_issue_marker(), exports);
      __exportStar(require_marker_navigator(), exports);
      __exportStar(require_validate2(), exports);
      __exportStar(require_validation_modules(), exports);
      __exportStar(require_glsp_scroll_mouse_listener(), exports);
      __exportStar(require_origin_viewport(), exports);
      __exportStar(require_reposition(), exports);
      __exportStar(require_viewport_handler(), exports);
      __exportStar(require_viewport_key_listener(), exports);
      __exportStar(require_viewport_modules(), exports);
      __exportStar(require_zoom_viewport_action(), exports);
      __exportStar(require_model22(), exports);
      __exportStar(require_re_exports3(), exports);
      __exportStar(require_standalone_modules(), exports);
      __exportStar(require_argument_utils(), exports);
      __exportStar(require_geometry_util2(), exports);
      __exportStar(require_gmodel_util(), exports);
      __exportStar(require_html_utils(), exports);
      __exportStar(require_layout_utils(), exports);
      __exportStar(require_marker(), exports);
      __exportStar(require_viewpoint_util(), exports);
      __exportStar(require_base_view_module(), exports);
      __exportStar(require_compartments(), exports);
      __exportStar(require_gedge_view(), exports);
      __exportStar(require_ggraph_view(), exports);
      __exportStar(require_glsp_projection_view(), exports);
      __exportStar(require_issue_marker_view(), exports);
      __exportStar(require_rounded_corner(), exports);
      __exportStar(require_rounded_corner_view(), exports);
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/copyPaste/copy-paste-startup.js
  var require_copy_paste_startup = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/copyPaste/copy-paste-startup.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CopyPasteStartup = exports.CopyPasteHandlerProvider = void 0;
      var inversify_1 = require_cjs4();
      exports.CopyPasteHandlerProvider = Symbol("CopyPasteHandlerProvider");
      var CopyPasteStartup = class CopyPasteStartup {
        preInitialize() {
          this.copyPasteHandlerProvider().then((copyPasteHandler) => {
            document.addEventListener("copy", (e2) => {
              copyPasteHandler.handleCopy(e2);
            });
            document.addEventListener("cut", (e2) => {
              copyPasteHandler.handleCut(e2);
            });
            document.addEventListener("paste", (e2) => {
              copyPasteHandler.handlePaste(e2);
            });
          });
        }
      };
      exports.CopyPasteStartup = CopyPasteStartup;
      __decorate([
        (0, inversify_1.inject)(exports.CopyPasteHandlerProvider),
        __metadata("design:type", Function)
      ], CopyPasteStartup.prototype, "copyPasteHandlerProvider", void 0);
      exports.CopyPasteStartup = CopyPasteStartup = __decorate([
        (0, inversify_1.injectable)()
      ], CopyPasteStartup);
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/copyPaste/copy-paste-module.js
  var require_copy_paste_module = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/copyPaste/copy-paste-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.vscodeCopyPasteModule = void 0;
      var client_1 = require_lib5();
      var copy_paste_startup_1 = require_copy_paste_startup();
      exports.vscodeCopyPasteModule = new client_1.FeatureModule((bind) => {
        bind(copy_paste_startup_1.CopyPasteHandlerProvider).toProvider((ctx) => () => new Promise((resolve) => resolve(ctx.container.get(client_1.TYPES.ICopyPasteHandler))));
        (0, client_1.bindAsService)(bind, client_1.TYPES.IDiagramStartup, copy_paste_startup_1.CopyPasteStartup);
      }, { requires: client_1.copyPasteModule, featureId: Symbol("vscodeCopyPaste") });
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/glsp-diagram-widget.js
  var require_glsp_diagram_widget = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/glsp-diagram-widget.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GLSPDiagramWidget = exports.GLSPDiagramWidgetFactory = void 0;
      var client_1 = require_lib5();
      var inversify_1 = require_cjs4();
      exports.GLSPDiagramWidgetFactory = Symbol("GLSPDiagramWidgetFactory");
      var GLSPDiagramWidget = class GLSPDiagramWidget {
        get clientId() {
          return this.diagramOptions.clientId;
        }
        initialize() {
          this.initializeHtml();
          this.loadDiagram();
        }
        initializeHtml() {
          const containerDiv = document.getElementById(this.clientId + "_container");
          if (containerDiv) {
            const svgContainer = document.createElement("div");
            svgContainer.id = this.viewerOptions.baseDiv;
            containerDiv.appendChild(svgContainer);
            const hiddenContainer = document.createElement("div");
            hiddenContainer.id = this.viewerOptions.hiddenDiv;
            document.body.appendChild(hiddenContainer);
            this.containerDiv = containerDiv;
            containerDiv.addEventListener("mouseenter", (e2) => this.handleMouseEnter(e2));
            containerDiv.addEventListener("mouseleave", (e2) => this.handleMouseLeave(e2));
            window.addEventListener("focus", (e2) => this.handleFocusChange(e2, true));
            window.addEventListener("blur", (e2) => this.handleFocusChange(e2, false));
            window.addEventListener("contextmenu", (e2) => this.handleContextMenu(e2));
          }
        }
        handleContextMenu(e2) {
          e2.preventDefault();
          window.focus();
        }
        handleMouseEnter(e2) {
          var _a4, _b2;
          (_a4 = this.containerDiv) === null || _a4 === void 0 ? void 0 : _a4.classList.add("mouse-enter");
          (_b2 = this.containerDiv) === null || _b2 === void 0 ? void 0 : _b2.classList.remove("mouse-leave");
        }
        handleMouseLeave(e2) {
          var _a4, _b2;
          (_a4 = this.containerDiv) === null || _a4 === void 0 ? void 0 : _a4.classList.add("mouse-leave");
          (_b2 = this.containerDiv) === null || _b2 === void 0 ? void 0 : _b2.classList.remove("mouse-enter");
        }
        handleFocusChange(e2, hasFocus) {
          this.actionDispatcher.dispatch(client_1.FocusStateChangedAction.create(hasFocus));
        }
        createDiagramLoadingOptions() {
          return void 0;
        }
        loadDiagram() {
          return this.diagramLoader.load(this.createDiagramLoadingOptions());
        }
      };
      exports.GLSPDiagramWidget = GLSPDiagramWidget;
      __decorate([
        (0, inversify_1.inject)(client_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], GLSPDiagramWidget.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(client_1.TYPES.ModelSource),
        __metadata("design:type", client_1.ModelSource)
      ], GLSPDiagramWidget.prototype, "modelSource", void 0);
      __decorate([
        (0, inversify_1.inject)(client_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], GLSPDiagramWidget.prototype, "diagramOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(client_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], GLSPDiagramWidget.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(client_1.DiagramLoader),
        __metadata("design:type", client_1.DiagramLoader)
      ], GLSPDiagramWidget.prototype, "diagramLoader", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], GLSPDiagramWidget.prototype, "initialize", null);
      exports.GLSPDiagramWidget = GLSPDiagramWidget = __decorate([
        (0, inversify_1.injectable)()
      ], GLSPDiagramWidget);
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/default/extension-action-handler.js
  var require_extension_action_handler = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/default/extension-action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HostExtensionActionHandler = exports.ExtensionActionKind = void 0;
      var client_1 = require_lib5();
      var inversify_1 = require_cjs4();
      exports.ExtensionActionKind = Symbol("ExtensionActionKind");
      var HostExtensionActionHandler = class HostExtensionActionHandler {
        constructor() {
          this.actionKinds = [];
        }
        postConstruct() {
          this.diagramOptions.glspClientProvider().then((glspClient) => this.glspClient = glspClient);
        }
        initialize(registry) {
          this.actionKinds.forEach((kind) => registry.register(kind, this));
        }
        handle(action) {
          var _a4;
          if (this.actionKinds.includes(action.kind)) {
            const message = {
              clientId: this.diagramOptions.clientId,
              action
            };
            (_a4 = this.glspClient) === null || _a4 === void 0 ? void 0 : _a4.sendActionMessage(message);
          }
        }
      };
      exports.HostExtensionActionHandler = HostExtensionActionHandler;
      __decorate([
        (0, inversify_1.multiInject)(exports.ExtensionActionKind),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], HostExtensionActionHandler.prototype, "actionKinds", void 0);
      __decorate([
        (0, inversify_1.inject)(client_1.TYPES.IDiagramOptions),
        __metadata("design:type", Object)
      ], HostExtensionActionHandler.prototype, "diagramOptions", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], HostExtensionActionHandler.prototype, "postConstruct", null);
      exports.HostExtensionActionHandler = HostExtensionActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], HostExtensionActionHandler);
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/default/default-module.js
  var require_default_module2 = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/default/default-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.vscodeDefaultModule = void 0;
      var client_1 = require_lib5();
      var glsp_diagram_widget_1 = require_glsp_diagram_widget();
      var extension_action_handler_1 = require_extension_action_handler();
      exports.vscodeDefaultModule = new client_1.FeatureModule((bind) => {
        bind(glsp_diagram_widget_1.GLSPDiagramWidget).toSelf().inSingletonScope();
        bind(glsp_diagram_widget_1.GLSPDiagramWidgetFactory).toFactory((context) => () => context.container.get(glsp_diagram_widget_1.GLSPDiagramWidget));
        (0, client_1.bindAsService)(bind, client_1.TYPES.IActionHandlerInitializer, extension_action_handler_1.HostExtensionActionHandler);
        bind(extension_action_handler_1.ExtensionActionKind).toConstantValue(client_1.SelectAction.KIND);
      }, { requires: client_1.defaultModule, featureId: Symbol("vscodeDefault") });
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/export/export-module.js
  var require_export_module = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/export/export-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.vscodeExportModule = void 0;
      var client_1 = require_lib5();
      var extension_action_handler_1 = require_extension_action_handler();
      exports.vscodeExportModule = new client_1.FeatureModule((bind) => {
        bind(extension_action_handler_1.ExtensionActionKind).toConstantValue(client_1.ExportSvgAction.KIND);
      }, { requires: client_1.exportModule, featureId: Symbol("vscodeExport") });
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/navigation/navigation-module.js
  var require_navigation_module2 = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/navigation/navigation-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.vscodeNavigationModule = void 0;
      var client_1 = require_lib5();
      var extension_action_handler_1 = require_extension_action_handler();
      exports.vscodeNavigationModule = new client_1.FeatureModule((bind) => {
        bind(extension_action_handler_1.ExtensionActionKind).toConstantValue(client_1.NavigateToExternalTargetAction.KIND);
      }, { requires: client_1.navigationModule, featureId: Symbol("vscodeNavigation") });
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/notification/notification-module.js
  var require_notification_module = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/notification/notification-module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.vscodeNotificationModule = void 0;
      var client_1 = require_lib5();
      var extension_action_handler_1 = require_extension_action_handler();
      exports.vscodeNotificationModule = new client_1.FeatureModule((bind) => {
        bind(extension_action_handler_1.ExtensionActionKind).toConstantValue(client_1.MessageAction.KIND);
        bind(extension_action_handler_1.ExtensionActionKind).toConstantValue(client_1.StartProgressAction.KIND);
        bind(extension_action_handler_1.ExtensionActionKind).toConstantValue(client_1.EndProgressAction.KIND);
        bind(extension_action_handler_1.ExtensionActionKind).toConstantValue(client_1.UpdateProgressAction.KIND);
      }, { featureId: Symbol("vscodeNotification") });
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/default-modules.js
  var require_default_modules2 = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/default-modules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VSCODE_DEFAULT_MODULE_CONFIG = exports.VSCODE_DEFAULT_MODULES = void 0;
      var client_1 = require_lib5();
      var copy_paste_module_1 = require_copy_paste_module();
      var default_module_1 = require_default_module2();
      var export_module_1 = require_export_module();
      var navigation_module_1 = require_navigation_module2();
      var notification_module_1 = require_notification_module();
      exports.VSCODE_DEFAULT_MODULES = [
        default_module_1.vscodeDefaultModule,
        copy_paste_module_1.vscodeCopyPasteModule,
        export_module_1.vscodeExportModule,
        navigation_module_1.vscodeNavigationModule,
        notification_module_1.vscodeNotificationModule
      ];
      exports.VSCODE_DEFAULT_MODULE_CONFIG = {
        add: [...exports.VSCODE_DEFAULT_MODULES],
        remove: [client_1.contextMenuModule]
      };
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/diagram-identifier.js
  var require_diagram_identifier = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/diagram-identifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WebviewReadyMessage = exports.isDiagramIdentifier = exports.GLSPDiagramIdentifier = void 0;
      var client_1 = require_lib5();
      exports.GLSPDiagramIdentifier = Symbol("GLSPDiagramIdentifier");
      function isDiagramIdentifier(object) {
        return client_1.AnyObject.is(object) && //
        (0, client_1.hasStringProp)(object, "clientId") && (0, client_1.hasStringProp)(object, "diagramType") && (0, client_1.hasStringProp)(object, "uri");
      }
      exports.isDiagramIdentifier = isDiagramIdentifier;
      var WebviewReadyMessage;
      (function(WebviewReadyMessage2) {
        function is(object) {
          return client_1.AnyObject.is(object) && (0, client_1.hasStringProp)(object, "readyMessage");
        }
        WebviewReadyMessage2.is = is;
      })(WebviewReadyMessage || (exports.WebviewReadyMessage = WebviewReadyMessage = {}));
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/default/vscode-glsp-modelsource.js
  var require_vscode_glsp_modelsource = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/features/default/vscode-glsp-modelsource.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VsCodeGLSPModelSource = exports.ExtensionAction = void 0;
      var client_1 = require_lib5();
      var inversify_1 = require_cjs4();
      var ExtensionAction;
      (function(ExtensionAction2) {
        function is(object) {
          return client_1.Action.is(object) && "__localDispatch" in object && object.__localDispatch === true;
        }
        ExtensionAction2.is = is;
        function mark(action) {
          action.__localDispatch = true;
        }
        ExtensionAction2.mark = mark;
      })(ExtensionAction || (exports.ExtensionAction = ExtensionAction = {}));
      var VsCodeGLSPModelSource = class VsCodeGLSPModelSource extends client_1.GLSPModelSource {
      };
      exports.VsCodeGLSPModelSource = VsCodeGLSPModelSource;
      exports.VsCodeGLSPModelSource = VsCodeGLSPModelSource = __decorate([
        (0, inversify_1.injectable)()
      ], VsCodeGLSPModelSource);
    }
  });

  // node_modules/vscode-messenger-common/lib/messages.js
  var require_messages4 = __commonJS({
    "node_modules/vscode-messenger-common/lib/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isNotificationMessage = exports.isResponseMessage = exports.isRequestMessage = exports.isMessage = exports.equalParticipants = exports.BROADCAST = exports.isWebviewTypeMessageParticipant = exports.isWebviewIdMessageParticipant = exports.HOST_EXTENSION = void 0;
      exports.HOST_EXTENSION = { type: "extension" };
      function isWebviewIdMessageParticipant(participant) {
        return participant.type === "webview" && typeof participant.webviewId === "string";
      }
      exports.isWebviewIdMessageParticipant = isWebviewIdMessageParticipant;
      function isWebviewTypeMessageParticipant(participant) {
        return participant.type === "webview" && typeof participant.webviewType === "string";
      }
      exports.isWebviewTypeMessageParticipant = isWebviewTypeMessageParticipant;
      exports.BROADCAST = { type: "broadcast" };
      function equalParticipants(p1, p22) {
        if (p1.type === "extension" && p22.type === "extension") {
          return p1.extensionId === p22.extensionId;
        }
        if (p1.type === "webview" && p22.type === "webview") {
          if (isWebviewIdMessageParticipant(p1) && isWebviewIdMessageParticipant(p22)) {
            return p1.webviewId === p22.webviewId;
          }
          if (isWebviewTypeMessageParticipant(p1) && isWebviewTypeMessageParticipant(p22)) {
            return p1.webviewType === p22.webviewType;
          }
        }
        return p1.type === p22.type;
      }
      exports.equalParticipants = equalParticipants;
      function isMessage(obj) {
        return typeof obj === "object" && obj !== null && typeof obj.receiver === "object";
      }
      exports.isMessage = isMessage;
      function isRequestMessage(msg) {
        return !!msg.id && !!msg.method;
      }
      exports.isRequestMessage = isRequestMessage;
      function isResponseMessage(msg) {
        return !!msg.id && !msg.method;
      }
      exports.isResponseMessage = isResponseMessage;
      function isNotificationMessage(msg) {
        return !msg.id && !!msg.method;
      }
      exports.isNotificationMessage = isNotificationMessage;
    }
  });

  // node_modules/vscode-messenger-common/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/vscode-messenger-common/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_messages4(), exports);
    }
  });

  // node_modules/vscode-messenger-webview/lib/vscode-api.js
  var require_vscode_api = __commonJS({
    "node_modules/vscode-messenger-webview/lib/vscode-api.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/vscode-messenger-webview/lib/messenger.js
  var require_messenger = __commonJS({
    "node_modules/vscode-messenger-webview/lib/messenger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Messenger = void 0;
      var vscode_messenger_common_1 = require_lib6();
      var vscode_api_1 = require_vscode_api();
      var Messenger = class {
        constructor(vscode, options) {
          this.handlerRegistry = /* @__PURE__ */ new Map();
          this.requests = /* @__PURE__ */ new Map();
          this.started = false;
          this.nextMsgId = 0;
          this.vscode = vscode !== null && vscode !== void 0 ? vscode : (0, vscode_api_1.acquireVsCodeApi)();
          const defaultOptions = {
            debugLog: false
          };
          this.options = Object.assign(Object.assign({}, defaultOptions), options);
        }
        onRequest(type, handler) {
          this.handlerRegistry.set(type.method, handler);
          return this;
        }
        onNotification(type, handler) {
          this.handlerRegistry.set(type.method, handler);
          return this;
        }
        start() {
          if (this.started) {
            return;
          }
          window.addEventListener("message", (event) => {
            if ((0, vscode_messenger_common_1.isMessage)(event.data)) {
              this.processMessage(event.data).catch((err) => this.log(String(err), "error"));
            }
          });
          this.started = true;
        }
        async processMessage(msg) {
          if (msg.receiver.type === "extension") {
            return;
          }
          if ((0, vscode_messenger_common_1.isRequestMessage)(msg)) {
            this.log(`View received Request message: ${msg.method} (id ${msg.id})`);
            const handler = this.handlerRegistry.get(msg.method);
            if (handler) {
              try {
                const result = await handler(msg.params, msg.sender);
                const response = {
                  id: msg.id,
                  receiver: msg.sender,
                  result
                };
                this.vscode.postMessage(response);
              } catch (error) {
                const response = {
                  id: msg.id,
                  receiver: msg.sender,
                  error: this.createResponseError(error)
                };
                this.vscode.postMessage(response);
              }
            } else {
              this.log(`Received request with unknown method: ${msg.method}`, "warn");
              const response = {
                id: msg.id,
                receiver: msg.sender,
                error: {
                  message: `Unknown method: ${msg.method}`
                }
              };
              this.vscode.postMessage(response);
            }
          } else if ((0, vscode_messenger_common_1.isNotificationMessage)(msg)) {
            this.log(`View received Notification message: ${msg.method}`);
            const handler = this.handlerRegistry.get(msg.method);
            if (handler) {
              handler(msg.params, msg.sender);
            } else if (msg.receiver.type !== "broadcast") {
              this.log(`Received notification with unknown method: ${msg.method}`, "warn");
            }
          } else if ((0, vscode_messenger_common_1.isResponseMessage)(msg)) {
            this.log(`View received Response message: ${msg.id}`);
            const request = this.requests.get(msg.id);
            if (request) {
              if (msg.error) {
                request.reject(msg.error);
              } else {
                request.resolve(msg.result);
              }
              this.requests.delete(msg.id);
            } else {
              this.log(`Received response for untracked message id: ${msg.id} (sender: ${participantToString(msg.sender)})`, "warn");
            }
          } else {
            this.log(`Invalid message: ${JSON.stringify(msg)}`, "error");
          }
        }
        createResponseError(error) {
          if (error instanceof Error) {
            return { message: error.message, data: error.stack };
          } else if (typeof error === "object" && error !== null && typeof error.message === "string") {
            return { message: error.message, data: error.data };
          } else {
            return { message: String(error) };
          }
        }
        sendRequest(type, receiver, params) {
          if (receiver.type === "broadcast") {
            throw new Error("Only notification messages are allowed for broadcast.");
          }
          const msgId = this.createMsgId();
          const result = new Promise((resolve, reject) => {
            this.requests.set(msgId, { resolve, reject });
          });
          const message = {
            id: msgId,
            method: type.method,
            receiver,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            params
          };
          this.vscode.postMessage(message);
          return result;
        }
        sendNotification(type, receiver, params) {
          const message = {
            method: type.method,
            receiver,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            params
          };
          this.vscode.postMessage(message);
        }
        createMsgId() {
          const cryptoRand = window.crypto.getRandomValues(new Uint8Array(10));
          const rand = Array.from(cryptoRand).map((b3) => b3.toString(16)).join("");
          return "req_" + this.nextMsgId++ + "_" + rand;
        }
        log(text, level = "debug") {
          switch (level) {
            case "debug": {
              if (this.options.debugLog) {
                console.debug(text);
              }
              break;
            }
            case "warn": {
              console.warn(text);
              break;
            }
            case "error": {
              console.error(text);
              break;
            }
          }
        }
      };
      exports.Messenger = Messenger;
      function participantToString(participant) {
        switch (participant.type) {
          case "extension":
            return "host extension";
          case "webview": {
            if ((0, vscode_messenger_common_1.isWebviewIdMessageParticipant)(participant)) {
              return participant.webviewId;
            } else if (participant.webviewType) {
              return participant.webviewType;
            } else {
              return "unspecified webview";
            }
          }
          case "broadcast":
            return "broadcast";
        }
      }
    }
  });

  // node_modules/vscode-messenger-webview/lib/index.js
  var require_lib7 = __commonJS({
    "node_modules/vscode-messenger-webview/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_messenger(), exports);
      __exportStar(require_vscode_api(), exports);
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/webview-glsp-client.js
  var require_webview_glsp_client = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/webview-glsp-client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WebviewGlspClient = exports.StopRequest = exports.ShutdownServerNotification = exports.DisposeClientSessionRequest = exports.InitializeClientSessionRequest = exports.InitializeServerRequest = exports.StartRequest = exports.ClientStateChangeNotification = exports.ActionMessageNotification = void 0;
      var client_1 = require_lib5();
      var vscode_messenger_common_1 = require_lib6();
      var vscode_messenger_webview_1 = require_lib7();
      exports.ActionMessageNotification = { method: "actionMessage" };
      exports.ClientStateChangeNotification = { method: "notifyClientStateChange" };
      exports.StartRequest = { method: "start" };
      exports.InitializeServerRequest = { method: "initializeServer" };
      exports.InitializeClientSessionRequest = { method: "initializeClientSession" };
      exports.DisposeClientSessionRequest = { method: "disposeClientSession" };
      exports.ShutdownServerNotification = { method: "shutdownServer" };
      exports.StopRequest = { method: "stop" };
      var WebviewGlspClient = class {
        get onCurrentStateChanged() {
          return this.onCurrentStateChangedEmitter.event;
        }
        get currentState() {
          return this._currentState;
        }
        get initializeResult() {
          return this._initializeResult;
        }
        get onServerInitialized() {
          return this.onServerInitializedEmitter.event;
        }
        constructor(options) {
          var _a4;
          this.toDispose = new client_1.DisposableCollection();
          this.onActionMessageEmitter = new client_1.Emitter();
          this.onCurrentStateChangedEmitter = new client_1.Emitter();
          this._currentState = client_1.ClientState.Initial;
          this.onServerInitializedEmitter = new client_1.Emitter();
          this.id = options.id;
          this.messenger = (_a4 = options.messenger) !== null && _a4 !== void 0 ? _a4 : new vscode_messenger_webview_1.Messenger();
          this.toDispose.push(this.onActionMessageEmitter, this.onServerInitializedEmitter, this.onCurrentStateChangedEmitter);
          this.messenger.onNotification(exports.ActionMessageNotification, (msg) => this.onActionMessageEmitter.fire(msg));
          this.messenger.onNotification(exports.ClientStateChangeNotification, (state) => this.updateState(state));
        }
        updateState(state) {
          if (this._currentState !== state) {
            this._currentState = state;
            this.onCurrentStateChangedEmitter.fire(this._currentState);
          }
        }
        async start() {
          try {
            await this.messenger.sendRequest(exports.StartRequest, vscode_messenger_common_1.HOST_EXTENSION);
          } catch (error) {
            console.error("Failed to start connection to server", error);
            this.updateState(client_1.ClientState.StartFailed);
          }
        }
        async initializeServer(params) {
          if (this.initializeResult) {
            return this.initializeResult;
          }
          const result = await this.messenger.sendRequest(exports.InitializeServerRequest, vscode_messenger_common_1.HOST_EXTENSION, params);
          this._initializeResult = result;
          this.onServerInitializedEmitter.fire(result);
          return result;
        }
        initializeClientSession(params) {
          return this.messenger.sendRequest(exports.InitializeClientSessionRequest, vscode_messenger_common_1.HOST_EXTENSION, params);
        }
        disposeClientSession(params) {
          return this.messenger.sendRequest(exports.DisposeClientSessionRequest, vscode_messenger_common_1.HOST_EXTENSION, params);
        }
        shutdownServer() {
          this.messenger.sendNotification(exports.ShutdownServerNotification, vscode_messenger_common_1.HOST_EXTENSION);
        }
        async stop() {
          if (this.currentState === client_1.ClientState.Stopped) {
            return;
          }
          await this.messenger.sendRequest(exports.StopRequest, vscode_messenger_common_1.HOST_EXTENSION);
        }
        sendActionMessage(message) {
          this.messenger.sendNotification(exports.ActionMessageNotification, vscode_messenger_common_1.HOST_EXTENSION, message);
        }
        onActionMessage(handler) {
          return this.onActionMessageEmitter.event(handler);
        }
        dispose() {
          this.toDispose.dispose();
        }
      };
      exports.WebviewGlspClient = WebviewGlspClient;
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/glsp-starter.js
  var require_glsp_starter = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/glsp-starter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.decodeURI = exports.GLSPStarter = exports.InitializeNotification = exports.WebviewReadyNotification = void 0;
      var client_1 = require_lib5();
      var vscode_messenger_common_1 = require_lib6();
      var vscode_messenger_webview_1 = require_lib7();
      var default_modules_1 = require_default_modules2();
      var diagram_identifier_1 = require_diagram_identifier();
      var glsp_diagram_widget_1 = require_glsp_diagram_widget();
      var webview_glsp_client_1 = require_webview_glsp_client();
      exports.WebviewReadyNotification = { method: "ready" };
      exports.InitializeNotification = { method: "initialize" };
      var GLSPStarter2 = class {
        constructor() {
          this.messenger = new vscode_messenger_webview_1.Messenger(acquireVsCodeApi());
          this.messenger.onNotification(exports.InitializeNotification, (identifier) => this.acceptDiagramIdentifier(identifier));
          this.messenger.start();
          this.sendReadyMessage();
        }
        sendReadyMessage() {
          this.messenger.sendNotification(exports.WebviewReadyNotification, vscode_messenger_common_1.HOST_EXTENSION);
        }
        acceptDiagramIdentifier(identifier) {
          var _a4;
          if (this.container) {
            const oldIdentifier = this.container.get(diagram_identifier_1.GLSPDiagramIdentifier);
            oldIdentifier.diagramType = identifier.diagramType;
            oldIdentifier.uri = identifier.uri;
            const diagramWidget = this.container.get(glsp_diagram_widget_1.GLSPDiagramWidget);
            diagramWidget.loadDiagram();
          } else {
            const diagramModule = this.createDiagramOptionsModule(identifier);
            this.container = this.createContainer(diagramModule, ...this.getContainerConfiguration());
            (_a4 = this.addVscodeBindings) === null || _a4 === void 0 ? void 0 : _a4.call(this, this.container, identifier);
            this.container.get(glsp_diagram_widget_1.GLSPDiagramWidget);
          }
        }
        createDiagramOptionsModule(identifier) {
          const glspClient = new webview_glsp_client_1.WebviewGlspClient({ id: identifier.diagramType, messenger: this.messenger });
          return (0, client_1.createDiagramOptionsModule)({
            clientId: identifier.clientId,
            diagramType: identifier.diagramType,
            glspClientProvider: async () => glspClient,
            sourceUri: decodeURIComponent(identifier.uri)
          });
        }
        /**
         * Retrieves additional {@link ContainerConfiguration} for the diagram container.
         * Typically this composes a set of vscode specific customization modules.
         * @returns the container configuration
         */
        getContainerConfiguration() {
          return [default_modules_1.VSCODE_DEFAULT_MODULE_CONFIG];
        }
      };
      exports.GLSPStarter = GLSPStarter2;
      function decodeURI(uri) {
        return decodeURIComponent(uri.replace(/\+/g, " "));
      }
      exports.decodeURI = decodeURI;
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/lib/index.js
  var require_lib8 = __commonJS({
    "node_modules/@eclipse-glsp/vscode-integration-webview/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      });
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_default_modules2(), exports);
      __exportStar(require_diagram_identifier(), exports);
      __exportStar(require_copy_paste_module(), exports);
      __exportStar(require_copy_paste_startup(), exports);
      __exportStar(require_default_module2(), exports);
      __exportStar(require_extension_action_handler(), exports);
      __exportStar(require_vscode_glsp_modelsource(), exports);
      __exportStar(require_export_module(), exports);
      __exportStar(require_navigation_module2(), exports);
      __exportStar(require_notification_module(), exports);
      __exportStar(require_glsp_diagram_widget(), exports);
      __exportStar(require_glsp_starter(), exports);
      __exportStar(require_webview_glsp_client(), exports);
    }
  });

  // node_modules/@eclipse-glsp/vscode-integration-webview/css/glsp-vscode.css
  var init_glsp_vscode = __esm({
    "node_modules/@eclipse-glsp/vscode-integration-webview/css/glsp-vscode.css"() {
    }
  });

  // node_modules/@inversifyjs/common/lib/esm/index.js
  var t, _a, _e, r;
  var init_esm = __esm({
    "node_modules/@inversifyjs/common/lib/esm/index.js"() {
      t = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
      _a = t;
      r = class {
        constructor(e2) {
          __publicField(this, _a);
          __privateAdd(this, _e);
          __privateSet(this, _e, e2), this[t] = true;
        }
        static is(e2) {
          return "object" == typeof e2 && null !== e2 && true === e2[t];
        }
        unwrap() {
          return __privateGet(this, _e).call(this);
        }
      };
      _e = new WeakMap();
    }
  });

  // node_modules/@inversifyjs/reflect-metadata-utils/lib/esm/index.js
  function t2(t3, e2) {
    return Reflect.getMetadata(e2, t3);
  }
  function e(e2, n, a3, c3) {
    const f3 = c3(t2(e2, n) ?? a3);
    Reflect.defineMetadata(n, f3, e2);
  }
  var init_esm2 = __esm({
    "node_modules/@inversifyjs/reflect-metadata-utils/lib/esm/index.js"() {
    }
  });

  // node_modules/@inversifyjs/core/lib/esm/index.js
  function h(t3, e2) {
    const n = [];
    for (let t4 = 0; t4 < e2.length; ++t4) {
      void 0 === e2[t4] && n.push(t4);
    }
    if (n.length > 0) throw new f(g.missingInjectionDecorator, `Found unexpected missing metadata on type "${t3.name}" at constructor indexes "${n.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
  }
  function y(t3) {
    return { kind: p.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), targetName: void 0, value: t3 };
  }
  function v(t3) {
    const e2 = t3.find((t4) => t4.key === s), n = t3.find((t4) => t4.key === c);
    if (void 0 !== t3.find((t4) => t4.key === i)) return function(t4, e3) {
      if (void 0 !== e3 || void 0 !== t4) throw new f(g.missingInjectionDecorator, "Expected a single @inject, @multiInject or @unmanaged metadata");
      return { kind: p.unmanaged };
    }(e2, n);
    if (void 0 === n && void 0 === e2) throw new f(g.missingInjectionDecorator, "Expected @inject, @multiInject or @unmanaged metadata");
    const u3 = t3.find((t4) => t4.key === a), d3 = t3.find((t4) => t4.key === o), l3 = t3.find((t4) => t4.key === r2);
    return { kind: void 0 === e2 ? p.multipleInjection : p.singleInjection, name: u3?.value, optional: void 0 !== d3, tags: new Map(t3.filter((t4) => m.every((e3) => t4.key !== e3)).map((t4) => [t4.key, t4.value])), targetName: l3?.value, value: void 0 === e2 ? n?.value : e2.value };
  }
  function j(t3, e2, n) {
    try {
      return v(n);
    } catch (n2) {
      throw f.isErrorOfKind(n2, g.missingInjectionDecorator) ? new f(g.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t3.name}" at constructor arguments at index "${e2.toString()}"`, { cause: n2 }) : n2;
    }
  }
  function k(e2) {
    const n = t2(e2, "design:paramtypes"), a3 = t2(e2, "inversify:tagged"), r3 = [];
    if (void 0 !== a3) for (const [t3, n2] of Object.entries(a3)) {
      const a4 = parseInt(t3);
      r3[a4] = j(e2, a4, n2);
    }
    if (void 0 !== n) {
      for (let t3 = 0; t3 < n.length; ++t3) if (void 0 === r3[t3]) {
        const e3 = n[t3];
        r3[t3] = y(e3);
      }
    }
    return h(e2, r3), r3;
  }
  function I(t3, e2, n) {
    try {
      return v(n);
    } catch (n2) {
      throw f.isErrorOfKind(n2, g.missingInjectionDecorator) ? new f(g.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t3.name}" at property "${e2.toString()}"`, { cause: n2 }) : n2;
    }
  }
  function w(e2) {
    const n = t2(e2, "inversify:tagged_props"), a3 = /* @__PURE__ */ new Map();
    if (void 0 !== n) for (const t3 of Reflect.ownKeys(n)) {
      const r3 = n[t3];
      a3.set(t3, I(e2, t3, r3));
    }
    return a3;
  }
  function M(e2) {
    const n = t2(e2, u), a3 = t2(e2, d);
    return { constructorArguments: k(e2), lifecycle: { postConstructMethodName: n?.value, preDestroyMethodName: a3?.value }, properties: w(e2) };
  }
  function N(t3, e2) {
    const n = e2.getConstructorMetadata(t3), a3 = [];
    for (const [e3, r3] of Object.entries(n.userGeneratedMetadata)) {
      const n2 = parseInt(e3);
      a3[n2] = j(t3, n2, r3);
    }
    if (void 0 !== n.compilerGeneratedMetadata) {
      for (let t4 = 0; t4 < n.compilerGeneratedMetadata.length; ++t4) if (void 0 === a3[t4]) {
        const e3 = n.compilerGeneratedMetadata[t4];
        a3[t4] = y(e3);
      }
    }
    return h(t3, a3), a3;
  }
  function E(t3, e2) {
    const n = e2.getPropertiesMetadata(t3), a3 = /* @__PURE__ */ new Map();
    for (const e3 of Reflect.ownKeys(n)) {
      const r3 = n[e3];
      a3.set(e3, I(t3, e3, r3));
    }
    return a3;
  }
  function D(e2, n) {
    const a3 = t2(e2, u), r3 = t2(e2, d);
    return { constructorArguments: N(e2, n), lifecycle: { postConstructMethodName: a3?.value, preDestroyMethodName: r3?.value }, properties: E(e2, n) };
  }
  function b(t3) {
    const e2 = Object.getPrototypeOf(t3.prototype), n = e2?.constructor;
    return n;
  }
  function O(t3) {
    return t3.kind === p.unmanaged ? [{ key: i, value: true }] : function(t4) {
      const e2 = [A(t4)];
      void 0 !== t4.name && e2.push({ key: a, value: t4.name });
      t4.optional && e2.push({ key: o, value: true });
      for (const [n, a3] of t4.tags) e2.push({ key: n, value: a3 });
      void 0 !== t4.targetName && e2.push({ key: r2, value: t4.targetName });
      return e2;
    }(t3);
  }
  function A(t3) {
    let e2;
    switch (t3.kind) {
      case p.multipleInjection:
        e2 = { key: c, value: t3.value };
        break;
      case p.singleInjection:
        e2 = { key: s, value: t3.value };
    }
    return e2;
  }
  var a, r2, i, o, s, c, u, d, m, l, _a2, _b, f, g, p, _t, x, C, _e2, _n, _a3, _r, _i, _o, T, _;
  var init_esm3 = __esm({
    "node_modules/@inversifyjs/core/lib/esm/index.js"() {
      init_esm2();
      init_esm();
      a = "named";
      r2 = "name";
      i = "unmanaged";
      o = "optional";
      s = "inject";
      c = "multi_inject";
      u = "post_construct";
      d = "pre_destroy";
      m = [s, c, r2, i, a, o];
      l = Symbol.for("@inversifyjs/core/InversifyCoreError");
      f = class _f extends (_b = Error, _a2 = l, _b) {
        constructor(t3, e2, n) {
          super(e2, n);
          __publicField(this, _a2);
          __publicField(this, "kind");
          this[l] = true, this.kind = t3;
        }
        static is(t3) {
          return "object" == typeof t3 && null !== t3 && true === t3[l];
        }
        static isErrorOfKind(t3, e2) {
          return _f.is(t3) && t3.kind === e2;
        }
      };
      !function(t3) {
        t3[t3.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", t3[t3.missingInjectionDecorator = 1] = "missingInjectionDecorator", t3[t3.planning = 2] = "planning", t3[t3.unknown = 3] = "unknown";
      }(g || (g = {})), function(t3) {
        t3[t3.multipleInjection = 0] = "multipleInjection", t3[t3.singleInjection = 1] = "singleInjection", t3[t3.unmanaged = 2] = "unmanaged";
      }(p || (p = {}));
      x = class {
        constructor(t3) {
          __privateAdd(this, _t);
          __privateSet(this, _t, t3);
        }
        startsWith(t3) {
          return __privateGet(this, _t).startsWith(t3);
        }
        endsWith(t3) {
          return __privateGet(this, _t).endsWith(t3);
        }
        contains(t3) {
          return __privateGet(this, _t).includes(t3);
        }
        equals(t3) {
          return __privateGet(this, _t) === t3;
        }
        value() {
          return __privateGet(this, _t);
        }
      };
      _t = new WeakMap();
      C = "@inversifyjs/core/targetId";
      T = class {
        constructor(n, a3, r3) {
          __privateAdd(this, _e2);
          __privateAdd(this, _n);
          __privateAdd(this, _a3);
          __privateAdd(this, _r);
          __privateAdd(this, _i);
          __privateAdd(this, _o);
          __privateSet(this, _n, function() {
            const n2 = t2(Object, C) ?? 0;
            return n2 === Number.MAX_SAFE_INTEGER ? e(Object, C, n2, () => Number.MIN_SAFE_INTEGER) : e(Object, C, n2, (t3) => t3 + 1), n2;
          }()), __privateSet(this, _a3, n), __privateSet(this, _r, void 0), __privateSet(this, _e2, a3), __privateSet(this, _i, new x("string" == typeof n ? n : n.toString().slice(7, -1))), __privateSet(this, _o, r3);
        }
        get id() {
          return __privateGet(this, _n);
        }
        get identifier() {
          return __privateGet(this, _a3);
        }
        get metadata() {
          return void 0 === __privateGet(this, _r) && __privateSet(this, _r, O(__privateGet(this, _e2))), __privateGet(this, _r);
        }
        get name() {
          return __privateGet(this, _i);
        }
        get type() {
          return __privateGet(this, _o);
        }
        get serviceIdentifier() {
          return r.is(__privateGet(this, _e2).value) ? __privateGet(this, _e2).value.unwrap() : __privateGet(this, _e2).value;
        }
        getCustomTags() {
          return [...__privateGet(this, _e2).tags.entries()].map(([t3, e2]) => ({ key: t3, value: e2 }));
        }
        getNamedTag() {
          return void 0 === __privateGet(this, _e2).name ? null : { key: a, value: __privateGet(this, _e2).name };
        }
        hasTag(t3) {
          return this.metadata.some((e2) => e2.key === t3);
        }
        isArray() {
          return __privateGet(this, _e2).kind === p.multipleInjection;
        }
        isNamed() {
          return void 0 !== __privateGet(this, _e2).name;
        }
        isOptional() {
          return __privateGet(this, _e2).optional;
        }
        isTagged() {
          return __privateGet(this, _e2).tags.size > 0;
        }
        matchesArray(t3) {
          return this.isArray() && __privateGet(this, _e2).value === t3;
        }
        matchesNamedTag(t3) {
          return __privateGet(this, _e2).name === t3;
        }
        matchesTag(t3) {
          return (e2) => this.metadata.some((n) => n.key === t3 && n.value === e2);
        }
      };
      _e2 = new WeakMap();
      _n = new WeakMap();
      _a3 = new WeakMap();
      _r = new WeakMap();
      _i = new WeakMap();
      _o = new WeakMap();
      _ = (t3) => /* @__PURE__ */ function(t4, e2) {
        return function(n) {
          const a3 = t4(n);
          let r3 = b(n);
          for (; void 0 !== r3 && r3 !== Object; ) {
            const t5 = e2(r3);
            for (const [e3, n2] of t5) a3.properties.has(e3) || a3.properties.set(e3, n2);
            r3 = b(r3);
          }
          const i2 = [];
          for (const t5 of a3.constructorArguments) if (t5.kind !== p.unmanaged) {
            const e3 = t5.targetName ?? "";
            i2.push(new T(e3, t5, "ConstructorArgument"));
          }
          for (const [t5, e3] of a3.properties) if (e3.kind !== p.unmanaged) {
            const n2 = e3.targetName ?? t5;
            i2.push(new T(n2, e3, "ClassProperty"));
          }
          return i2;
        };
      }(void 0 === t3 ? M : (e2) => D(e2, t3), void 0 === t3 ? w : (e2) => E(e2, t3));
    }
  });

  // node_modules/inversify/lib/esm/index.js
  function S() {
    return A2++;
  }
  function P(t3) {
    return t3 instanceof RangeError || "Maximum call stack size exceeded" === t3.message;
  }
  function k2(t3) {
    return "function" == typeof t3 ? t3.name : "symbol" == typeof t3 ? t3.toString() : t3;
  }
  function q(t3, n, e2) {
    let i2 = "";
    const r3 = e2(t3, n);
    return 0 !== r3.length && (i2 = "\nRegistered bindings:", r3.forEach((t4) => {
      let n2 = "Object";
      null !== t4.implementationType && (n2 = O2(t4.implementationType)), i2 = `${i2}
 ${n2}`, t4.constraint.metaData && (i2 = `${i2} - ${t4.constraint.metaData}`);
    })), i2;
  }
  function F(t3, n) {
    return null !== t3.parentRequest && (t3.parentRequest.serviceIdentifier === n || F(t3.parentRequest, n));
  }
  function j2(t3) {
    t3.childRequests.forEach((n) => {
      if (F(t3, n.serviceIdentifier)) {
        const t4 = function(t5) {
          const n2 = function t6(n3, e2 = []) {
            const i2 = k2(n3.serviceIdentifier);
            return e2.push(i2), null !== n3.parentRequest ? t6(n3.parentRequest, e2) : e2;
          }(t5);
          return n2.reverse().join(" --> ");
        }(n);
        throw new Error(`Circular dependency found: ${t4}`);
      }
      j2(n);
    });
  }
  function O2(t3) {
    if (null != t3.name && "" !== t3.name) return t3.name;
    {
      const n = t3.toString(), e2 = n.match(/^function\s*([^\s(]+)/);
      return null === e2 ? `Anonymous function: ${n}` : e2[1];
    }
  }
  function $(t3) {
    return `{"key":"${t3.key.toString()}","value":"${t3.value.toString()}"}`;
  }
  function K(t3, e2) {
    const i2 = function(t4) {
      const n = Object.getPrototypeOf(t4.prototype), e3 = n?.constructor;
      return e3;
    }(e2);
    if (void 0 === i2 || i2 === Object) return 0;
    const r3 = _(t3)(i2), s3 = r3.map((t4) => t4.metadata.filter((t5) => t5.key === a2)), o3 = [].concat.apply([], s3).length, c3 = r3.length - o3;
    return c3 > 0 ? c3 : K(t3, i2);
  }
  function U(t3) {
    return t3._bindingDictionary;
  }
  function L(t3, n, e2, i2, r3) {
    let s3 = J(e2.container, r3.serviceIdentifier), o3 = [];
    return s3.length === B.NoBindingsAvailable && true === e2.container.options.autoBindInjectable && "function" == typeof r3.serviceIdentifier && t3.getConstructorMetadata(r3.serviceIdentifier).compilerGeneratedMetadata && (e2.container.bind(r3.serviceIdentifier).toSelf(), s3 = J(e2.container, r3.serviceIdentifier)), o3 = n ? s3 : s3.filter((t4) => {
      const n2 = new H(t4.serviceIdentifier, e2, i2, t4, r3);
      return t4.constraint(n2);
    }), function(t4, n2, e3, i3, r4) {
      switch (n2.length) {
        case B.NoBindingsAvailable:
          if (i3.isOptional()) return n2;
          {
            const n3 = k2(t4);
            let s4 = x2;
            throw s4 += function(t5, n4) {
              if (n4.isTagged() || n4.isNamed()) {
                let e4 = "";
                const i4 = n4.getNamedTag(), r5 = n4.getCustomTags();
                return null !== i4 && (e4 += $(i4) + "\n"), null !== r5 && r5.forEach((t6) => {
                  e4 += $(t6) + "\n";
                }), ` ${t5}
 ${t5} - ${e4}`;
              }
              return ` ${t5}`;
            }(n3, i3), s4 += q(r4, n3, J), null !== e3 && (s4 += `
Trying to resolve bindings for "${k2(e3.serviceIdentifier)}"`), new Error(s4);
          }
        case B.OnlyOneBindingAvailable:
          return n2;
        case B.MultipleBindingsAvailable:
        default:
          if (i3.isArray()) return n2;
          {
            const n3 = k2(t4);
            let e4 = `${C2} ${n3}`;
            throw e4 += q(r4, n3, J), new Error(e4);
          }
      }
    }(r3.serviceIdentifier, o3, i2, r3, e2.container), o3;
  }
  function Y(t3, n) {
    const e2 = n.isMultiInject ? u2 : d2, i2 = [new W(e2, t3)];
    return void 0 !== n.customTag && i2.push(new W(n.customTag.key, n.customTag.value)), true === n.isOptional && i2.push(new W(c2, true)), i2;
  }
  function z(t3, e2, i2, r3, s3, o3) {
    let a3, c3;
    if (null === s3) {
      a3 = L(t3, e2, r3, null, o3), c3 = new H(i2, r3, null, a3, o3);
      const n = new G(r3, c3);
      r3.addPlan(n);
    } else a3 = L(t3, e2, r3, s3, o3), c3 = s3.addChildRequest(o3.serviceIdentifier, a3, o3);
    a3.forEach((e3) => {
      let i3 = null;
      if (o3.isArray()) i3 = c3.addChildRequest(e3.serviceIdentifier, e3, o3);
      else {
        if (null !== e3.cache) return;
        i3 = c3;
      }
      if (e3.type === w2.Instance && null !== e3.implementationType) {
        const s4 = function(t4, e4) {
          return _(t4)(e4);
        }(t3, e3.implementationType);
        if (true !== r3.container.options.skipBaseClassChecks) {
          const n = K(t3, e3.implementationType);
          if (s4.length < n) {
            const t4 = `The number of constructor arguments in the derived class ${O2(e3.implementationType)} must be >= than the number of constructor arguments of its base class.`;
            throw new Error(t4);
          }
        }
        s4.forEach((n) => {
          z(t3, false, n.serviceIdentifier, r3, i3, n);
        });
      }
    });
  }
  function J(t3, n) {
    let e2 = [];
    const i2 = U(t3);
    return i2.hasKey(n) ? e2 = i2.get(n) : null !== t3.parent && (e2 = J(t3.parent, n)), e2;
  }
  function Q(t3, n, s3, o3, a3, c3 = false) {
    const d3 = new V(n), u3 = function(t4, n2, s4) {
      const o4 = Y(n2, s4), a4 = v(o4);
      if (a4.kind === p.unmanaged) throw new Error("Unexpected metadata when creating target");
      return new T("", a4, t4);
    }(s3, o3, a3);
    try {
      return z(t3, c3, o3, d3, null, u3), d3;
    } catch (t4) {
      throw P(t4) && j2(d3.plan.rootRequest), t4;
    }
  }
  function X(t3) {
    return ("object" == typeof t3 && null !== t3 || "function" == typeof t3) && "function" == typeof t3.then;
  }
  function Z(t3) {
    return !!X(t3) || Array.isArray(t3) && t3.some(X);
  }
  function st(t3, n, e2) {
    let i2;
    if (n.length > 0) {
      const r3 = function(t4, n2) {
        return t4.reduce((t5, e3) => {
          const i3 = n2(e3);
          return e3.target.type === m2.ConstructorArgument ? t5.constructorInjections.push(i3) : (t5.propertyRequests.push(e3), t5.propertyInjections.push(i3)), t5.isAsync || (t5.isAsync = Z(i3)), t5;
        }, { constructorInjections: [], isAsync: false, propertyInjections: [], propertyRequests: [] });
      }(n, e2), s3 = { ...r3, constr: t3 };
      i2 = r3.isAsync ? async function(t4) {
        const n2 = await at(t4.constructorInjections), e3 = await at(t4.propertyInjections);
        return ot({ ...t4, constructorInjections: n2, propertyInjections: e3 });
      }(s3) : ot(s3);
    } else i2 = new t3();
    return i2;
  }
  function ot(t3) {
    const n = new t3.constr(...t3.constructorInjections);
    return t3.propertyRequests.forEach((e2, i2) => {
      const r3 = e2.target.identifier, s3 = t3.propertyInjections[i2];
      e2.target.isOptional() && void 0 === s3 || (n[r3] = s3);
    }), n;
  }
  async function at(t3) {
    const n = [];
    for (const e2 of t3) Array.isArray(e2) ? n.push(Promise.all(e2)) : n.push(e2);
    return Promise.all(n);
  }
  function ct(t3, n) {
    const e2 = function(t4, n2) {
      if (Reflect.hasMetadata(p2, t4)) {
        const r3 = Reflect.getMetadata(p2, t4);
        try {
          return n2[r3.value]?.();
        } catch (n3) {
          if (n3 instanceof Error) throw new Error((e3 = t4.name, i2 = n3.message, `@postConstruct error in class ${e3}: ${i2}`));
        }
      }
      var e3, i2;
    }(t3, n);
    return X(e2) ? e2.then(() => n) : n;
  }
  function dt(t3, n) {
    t3.scope !== b2.Singleton && function(t4, n2) {
      const e2 = `Class cannot be instantiated in ${t4.scope === b2.Request ? "request" : "transient"} scope.`;
      if ("function" == typeof t4.onDeactivation) throw new Error(E2(n2.name, e2));
      if (Reflect.hasMetadata(f2, n2)) throw new Error(`@preDestroy error in class ${n2.name}: ${e2}`);
    }(t3, n);
  }
  function pt(t3, n, e2) {
    let i2 = ft(t3.parentContext, n, e2);
    const r3 = wt(t3.parentContext.container);
    let s3, o3 = r3.next();
    do {
      s3 = o3.value;
      const n2 = t3.parentContext, e3 = t3.serviceIdentifier, a3 = bt(s3, e3);
      i2 = X(i2) ? vt(a3, n2, i2) : _t2(a3, n2, i2), o3 = r3.next();
    } while (true !== o3.done && !U(s3).hasKey(t3.serviceIdentifier));
    return i2;
  }
  function Ft(t3, n, e2, i2) {
    !function(t4) {
      if (void 0 !== t4) throw new Error(R);
    }(n), Ot(h2, t3, e2.toString(), i2);
  }
  function jt(t3) {
    let n = [];
    if (Array.isArray(t3)) {
      n = t3;
      const e2 = function(t4) {
        const n2 = /* @__PURE__ */ new Set();
        for (const e3 of t4) {
          if (n2.has(e3)) return e3;
          n2.add(e3);
        }
      }(n.map((t4) => t4.key));
      if (void 0 !== e2) throw new Error(`${T2} ${e2.toString()}`);
    } else n = [t3];
    return n;
  }
  function Ot(t3, n, e2, i2) {
    const r3 = jt(i2);
    let s3 = {};
    Reflect.hasOwnMetadata(t3, n) && (s3 = Reflect.getMetadata(t3, n));
    let o3 = s3[e2];
    if (void 0 === o3) o3 = [];
    else for (const t4 of o3) if (r3.some((n2) => n2.key === t4.key)) throw new Error(`${T2} ${t4.key.toString()}`);
    o3.push(...r3), s3[e2] = o3, Reflect.defineMetadata(t3, s3, n);
  }
  function $t(t3) {
    return (n, e2, i2) => {
      "number" == typeof i2 ? Ft(n, e2, i2, t3) : function(t4, n2, e3) {
        if (void 0 !== t4.prototype) throw new Error(R);
        Ot(l2, t4.constructor, n2, e3);
      }(n, e2, t3);
    };
  }
  function Kt() {
    return function(t3) {
      if (Reflect.hasOwnMetadata(g2, t3)) throw new Error("Cannot apply @injectable decorator multiple times.");
      const n = Reflect.getMetadata(y2, t3) || [];
      return Reflect.defineMetadata(g2, n, t3), t3;
    };
  }
  function Lt(t3) {
    return (n) => (e2, i2, r3) => {
      if (void 0 === n) {
        const t4 = "function" == typeof e2 ? e2.name : e2.constructor.name;
        throw new Error(`@inject called with undefined this could mean that the class ${t4} has a circular dependency problem. You can use a LazyServiceIdentifer to overcome this limitation.`);
      }
      $t(new W(t3, n))(e2, i2, r3);
    };
  }
  function Zt(t3, n) {
    return () => (e2, i2) => {
      const r3 = new W(t3, i2);
      if (Reflect.hasOwnMetadata(t3, e2.constructor)) throw new Error(n);
      Reflect.defineMetadata(t3, r3, e2.constructor);
    };
  }
  var import_reflect_metadata, s2, o2, a2, c2, d2, u2, h2, l2, g2, y2, p2, f2, _2, v2, b2, w2, m2, A2, I2, T2, D2, N2, C2, x2, R, E2, M2, B, V, W, G, H, tt, nt, et, it, ut, ht, lt, gt, yt, ft, _t2, vt, bt, wt, mt, At, St, It, Tt, Dt, Nt, Ct, xt, Rt, Et, Mt, Bt, Pt, kt, Yt, Qt, tn, nn;
  var init_esm4 = __esm({
    "node_modules/inversify/lib/esm/index.js"() {
      import_reflect_metadata = __toESM(require_Reflect(), 1);
      init_esm();
      init_esm();
      init_esm3();
      s2 = "named";
      o2 = "name";
      a2 = "unmanaged";
      c2 = "optional";
      d2 = "inject";
      u2 = "multi_inject";
      h2 = "inversify:tagged";
      l2 = "inversify:tagged_props";
      g2 = "inversify:paramtypes";
      y2 = "design:paramtypes";
      p2 = "post_construct";
      f2 = "pre_destroy";
      _2 = [d2, u2, o2, a2, s2, c2];
      v2 = Object.freeze({ __proto__: null, DESIGN_PARAM_TYPES: y2, INJECT_TAG: d2, MULTI_INJECT_TAG: u2, NAMED_TAG: s2, NAME_TAG: o2, NON_CUSTOM_TAG_KEYS: _2, OPTIONAL_TAG: c2, PARAM_TYPES: g2, POST_CONSTRUCT: p2, PRE_DESTROY: f2, TAGGED: h2, TAGGED_PROP: l2, UNMANAGED_TAG: a2 });
      b2 = { Request: "Request", Singleton: "Singleton", Transient: "Transient" };
      w2 = { ConstantValue: "ConstantValue", Constructor: "Constructor", DynamicValue: "DynamicValue", Factory: "Factory", Function: "Function", Instance: "Instance", Invalid: "Invalid", Provider: "Provider" };
      m2 = { ClassProperty: "ClassProperty", ConstructorArgument: "ConstructorArgument", Variable: "Variable" };
      A2 = 0;
      I2 = class _I {
        constructor(t3, n) {
          __publicField(this, "id");
          __publicField(this, "moduleId");
          __publicField(this, "activated");
          __publicField(this, "serviceIdentifier");
          __publicField(this, "implementationType");
          __publicField(this, "cache");
          __publicField(this, "dynamicValue");
          __publicField(this, "scope");
          __publicField(this, "type");
          __publicField(this, "factory");
          __publicField(this, "provider");
          __publicField(this, "constraint");
          __publicField(this, "onActivation");
          __publicField(this, "onDeactivation");
          this.id = S(), this.activated = false, this.serviceIdentifier = t3, this.scope = n, this.type = w2.Invalid, this.constraint = (t4) => true, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.onActivation = null, this.onDeactivation = null, this.dynamicValue = null;
        }
        clone() {
          const t3 = new _I(this.serviceIdentifier, this.scope);
          return t3.activated = t3.scope === b2.Singleton && this.activated, t3.implementationType = this.implementationType, t3.dynamicValue = this.dynamicValue, t3.scope = this.scope, t3.type = this.type, t3.factory = this.factory, t3.provider = this.provider, t3.constraint = this.constraint, t3.onActivation = this.onActivation, t3.onDeactivation = this.onDeactivation, t3.cache = this.cache, t3;
        }
      };
      T2 = "Metadata key was used more than once in a parameter:";
      D2 = "NULL argument";
      N2 = "Key Not Found";
      C2 = "Ambiguous match found for serviceIdentifier:";
      x2 = "No matching bindings found for serviceIdentifier:";
      R = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
      E2 = (t3, n) => `onDeactivation() error in class ${t3}: ${n}`;
      M2 = class {
        getConstructorMetadata(t3) {
          return { compilerGeneratedMetadata: Reflect.getMetadata(y2, t3) ?? [], userGeneratedMetadata: Reflect.getMetadata(h2, t3) ?? {} };
        }
        getPropertiesMetadata(t3) {
          return Reflect.getMetadata(l2, t3) ?? {};
        }
      };
      !function(t3) {
        t3[t3.MultipleBindingsAvailable = 2] = "MultipleBindingsAvailable", t3[t3.NoBindingsAvailable = 0] = "NoBindingsAvailable", t3[t3.OnlyOneBindingAvailable = 1] = "OnlyOneBindingAvailable";
      }(B || (B = {}));
      V = class {
        constructor(t3) {
          __publicField(this, "id");
          __publicField(this, "container");
          __publicField(this, "plan");
          __publicField(this, "currentRequest");
          this.id = S(), this.container = t3;
        }
        addPlan(t3) {
          this.plan = t3;
        }
        setCurrentRequest(t3) {
          this.currentRequest = t3;
        }
      };
      W = class {
        constructor(t3, n) {
          __publicField(this, "key");
          __publicField(this, "value");
          this.key = t3, this.value = n;
        }
        toString() {
          return this.key === s2 ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
        }
      };
      G = class {
        constructor(t3, n) {
          __publicField(this, "parentContext");
          __publicField(this, "rootRequest");
          this.parentContext = t3, this.rootRequest = n;
        }
      };
      H = class _H {
        constructor(t3, n, e2, i2, r3) {
          __publicField(this, "id");
          __publicField(this, "serviceIdentifier");
          __publicField(this, "parentContext");
          __publicField(this, "parentRequest");
          __publicField(this, "bindings");
          __publicField(this, "childRequests");
          __publicField(this, "target");
          __publicField(this, "requestScope");
          this.id = S(), this.serviceIdentifier = t3, this.parentContext = n, this.parentRequest = e2, this.target = r3, this.childRequests = [], this.bindings = Array.isArray(i2) ? i2 : [i2], this.requestScope = null === e2 ? /* @__PURE__ */ new Map() : null;
        }
        addChildRequest(t3, n, e2) {
          const i2 = new _H(t3, this.parentContext, this, n, e2);
          return this.childRequests.push(i2), i2;
        }
      };
      tt = (t3, n, e2) => {
        t3.has(n.id) || t3.set(n.id, e2);
      };
      nt = (t3, n) => {
        t3.cache = n, t3.activated = true, X(n) && et(t3, n);
      };
      et = async (t3, n) => {
        try {
          const e2 = await n;
          t3.cache = e2;
        } catch (n2) {
          throw t3.cache = null, t3.activated = false, n2;
        }
      };
      !function(t3) {
        t3.DynamicValue = "toDynamicValue", t3.Factory = "toFactory", t3.Provider = "toProvider";
      }(it || (it = {}));
      ut = (t3) => (n) => {
        n.parentContext.setCurrentRequest(n);
        const e2 = n.bindings, i2 = n.childRequests, r3 = n.target && n.target.isArray(), s3 = !(n.parentRequest && n.parentRequest.target && n.target && n.parentRequest.target.matchesArray(n.target.serviceIdentifier));
        if (r3 && s3) return i2.map((n2) => ut(t3)(n2));
        {
          if (n.target.isOptional() && 0 === e2.length) return;
          const i3 = e2[0];
          return yt(t3, n, i3);
        }
      };
      ht = (t3, n) => {
        const e2 = ((t4) => {
          switch (t4.type) {
            case w2.Factory:
              return { factory: t4.factory, factoryType: it.Factory };
            case w2.Provider:
              return { factory: t4.provider, factoryType: it.Provider };
            case w2.DynamicValue:
              return { factory: t4.dynamicValue, factoryType: it.DynamicValue };
            default:
              throw new Error(`Unexpected factory type ${t4.type}`);
          }
        })(t3);
        return ((t4, n2) => {
          try {
            return t4();
          } catch (t5) {
            if (P(t5)) throw n2();
            throw t5;
          }
        })(() => e2.factory.bind(t3)(n), () => {
          return new Error((t4 = e2.factoryType, i2 = n.currentRequest.serviceIdentifier.toString(), `It looks like there is a circular dependency in one of the '${t4}' bindings. Please investigate bindings with service identifier '${i2}'.`));
          var t4, i2;
        });
      };
      lt = (t3, n, e2) => {
        let i2;
        const r3 = n.childRequests;
        switch (((t4) => {
          let n2 = null;
          switch (t4.type) {
            case w2.ConstantValue:
            case w2.Function:
              n2 = t4.cache;
              break;
            case w2.Constructor:
            case w2.Instance:
              n2 = t4.implementationType;
              break;
            case w2.DynamicValue:
              n2 = t4.dynamicValue;
              break;
            case w2.Provider:
              n2 = t4.provider;
              break;
            case w2.Factory:
              n2 = t4.factory;
          }
          if (null === n2) {
            const n3 = k2(t4.serviceIdentifier);
            throw new Error(`Invalid binding type: ${n3}`);
          }
        })(e2), e2.type) {
          case w2.ConstantValue:
          case w2.Function:
            i2 = e2.cache;
            break;
          case w2.Constructor:
            i2 = e2.implementationType;
            break;
          case w2.Instance:
            i2 = function(t4, n2, e3, i3) {
              dt(t4, n2);
              const r4 = st(n2, e3, i3);
              return X(r4) ? r4.then((t5) => ct(n2, t5)) : ct(n2, r4);
            }(e2, e2.implementationType, r3, ut(t3));
            break;
          default:
            i2 = ht(e2, n.parentContext);
        }
        return i2;
      };
      gt = (t3, n, e2) => {
        let i2 = ((t4, n2) => n2.scope === b2.Singleton && n2.activated ? n2.cache : n2.scope === b2.Request && t4.has(n2.id) ? t4.get(n2.id) : null)(t3, n);
        return null !== i2 || (i2 = e2(), ((t4, n2, e3) => {
          n2.scope === b2.Singleton && nt(n2, e3), n2.scope === b2.Request && tt(t4, n2, e3);
        })(t3, n, i2)), i2;
      };
      yt = (t3, n, e2) => gt(t3, e2, () => {
        let i2 = lt(t3, n, e2);
        return i2 = X(i2) ? i2.then((t4) => pt(n, e2, t4)) : pt(n, e2, i2), i2;
      });
      ft = (t3, n, e2) => {
        let i2;
        return i2 = "function" == typeof n.onActivation ? n.onActivation(t3, e2) : e2, i2;
      };
      _t2 = (t3, n, e2) => {
        let i2 = t3.next();
        for (; true !== i2.done; ) {
          if (X(e2 = i2.value(n, e2))) return vt(t3, n, e2);
          i2 = t3.next();
        }
        return e2;
      };
      vt = async (t3, n, e2) => {
        let i2 = await e2, r3 = t3.next();
        for (; true !== r3.done; ) i2 = await r3.value(n, i2), r3 = t3.next();
        return i2;
      };
      bt = (t3, n) => {
        const e2 = t3._activations;
        return e2.hasKey(n) ? e2.get(n).values() : [].values();
      };
      wt = (t3) => {
        const n = [t3];
        let e2 = t3.parent;
        for (; null !== e2; ) n.push(e2), e2 = e2.parent;
        return { next: () => {
          const t4 = n.pop();
          return void 0 !== t4 ? { done: false, value: t4 } : { done: true, value: void 0 };
        } };
      };
      mt = (t3, n) => {
        const e2 = t3.parentRequest;
        return null !== e2 && (!!n(e2) || mt(e2, n));
      };
      At = (t3) => (n) => {
        const e2 = (e3) => null !== e3 && null !== e3.target && e3.target.matchesTag(t3)(n);
        return e2.metaData = new W(t3, n), e2;
      };
      St = At(s2);
      It = (t3) => (n) => {
        let e2 = null;
        if (null !== n) {
          if (e2 = n.bindings[0], "string" == typeof t3) return e2.serviceIdentifier === t3;
          {
            const e3 = n.bindings[0].implementationType;
            return t3 === e3;
          }
        }
        return false;
      };
      Tt = class {
        constructor(t3) {
          __publicField(this, "_binding");
          this._binding = t3;
        }
        when(t3) {
          return this._binding.constraint = t3, new Dt(this._binding);
        }
        whenTargetNamed(t3) {
          return this._binding.constraint = St(t3), new Dt(this._binding);
        }
        whenTargetIsDefault() {
          return this._binding.constraint = (t3) => {
            if (null === t3) return false;
            return null !== t3.target && !t3.target.isNamed() && !t3.target.isTagged();
          }, new Dt(this._binding);
        }
        whenTargetTagged(t3, n) {
          return this._binding.constraint = At(t3)(n), new Dt(this._binding);
        }
        whenInjectedInto(t3) {
          return this._binding.constraint = (n) => null !== n && It(t3)(n.parentRequest), new Dt(this._binding);
        }
        whenParentNamed(t3) {
          return this._binding.constraint = (n) => null !== n && St(t3)(n.parentRequest), new Dt(this._binding);
        }
        whenParentTagged(t3, n) {
          return this._binding.constraint = (e2) => null !== e2 && At(t3)(n)(e2.parentRequest), new Dt(this._binding);
        }
        whenAnyAncestorIs(t3) {
          return this._binding.constraint = (n) => null !== n && mt(n, It(t3)), new Dt(this._binding);
        }
        whenNoAncestorIs(t3) {
          return this._binding.constraint = (n) => null !== n && !mt(n, It(t3)), new Dt(this._binding);
        }
        whenAnyAncestorNamed(t3) {
          return this._binding.constraint = (n) => null !== n && mt(n, St(t3)), new Dt(this._binding);
        }
        whenNoAncestorNamed(t3) {
          return this._binding.constraint = (n) => null !== n && !mt(n, St(t3)), new Dt(this._binding);
        }
        whenAnyAncestorTagged(t3, n) {
          return this._binding.constraint = (e2) => null !== e2 && mt(e2, At(t3)(n)), new Dt(this._binding);
        }
        whenNoAncestorTagged(t3, n) {
          return this._binding.constraint = (e2) => null !== e2 && !mt(e2, At(t3)(n)), new Dt(this._binding);
        }
        whenAnyAncestorMatches(t3) {
          return this._binding.constraint = (n) => null !== n && mt(n, t3), new Dt(this._binding);
        }
        whenNoAncestorMatches(t3) {
          return this._binding.constraint = (n) => null !== n && !mt(n, t3), new Dt(this._binding);
        }
      };
      Dt = class {
        constructor(t3) {
          __publicField(this, "_binding");
          this._binding = t3;
        }
        onActivation(t3) {
          return this._binding.onActivation = t3, new Tt(this._binding);
        }
        onDeactivation(t3) {
          return this._binding.onDeactivation = t3, new Tt(this._binding);
        }
      };
      Nt = class {
        constructor(t3) {
          __publicField(this, "_bindingWhenSyntax");
          __publicField(this, "_bindingOnSyntax");
          __publicField(this, "_binding");
          this._binding = t3, this._bindingWhenSyntax = new Tt(this._binding), this._bindingOnSyntax = new Dt(this._binding);
        }
        when(t3) {
          return this._bindingWhenSyntax.when(t3);
        }
        whenTargetNamed(t3) {
          return this._bindingWhenSyntax.whenTargetNamed(t3);
        }
        whenTargetIsDefault() {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        }
        whenTargetTagged(t3, n) {
          return this._bindingWhenSyntax.whenTargetTagged(t3, n);
        }
        whenInjectedInto(t3) {
          return this._bindingWhenSyntax.whenInjectedInto(t3);
        }
        whenParentNamed(t3) {
          return this._bindingWhenSyntax.whenParentNamed(t3);
        }
        whenParentTagged(t3, n) {
          return this._bindingWhenSyntax.whenParentTagged(t3, n);
        }
        whenAnyAncestorIs(t3) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(t3);
        }
        whenNoAncestorIs(t3) {
          return this._bindingWhenSyntax.whenNoAncestorIs(t3);
        }
        whenAnyAncestorNamed(t3) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(t3);
        }
        whenAnyAncestorTagged(t3, n) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(t3, n);
        }
        whenNoAncestorNamed(t3) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(t3);
        }
        whenNoAncestorTagged(t3, n) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(t3, n);
        }
        whenAnyAncestorMatches(t3) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(t3);
        }
        whenNoAncestorMatches(t3) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(t3);
        }
        onActivation(t3) {
          return this._bindingOnSyntax.onActivation(t3);
        }
        onDeactivation(t3) {
          return this._bindingOnSyntax.onDeactivation(t3);
        }
      };
      Ct = class {
        constructor(t3) {
          __publicField(this, "_binding");
          this._binding = t3;
        }
        inRequestScope() {
          return this._binding.scope = b2.Request, new Nt(this._binding);
        }
        inSingletonScope() {
          return this._binding.scope = b2.Singleton, new Nt(this._binding);
        }
        inTransientScope() {
          return this._binding.scope = b2.Transient, new Nt(this._binding);
        }
      };
      xt = class {
        constructor(t3) {
          __publicField(this, "_bindingInSyntax");
          __publicField(this, "_bindingWhenSyntax");
          __publicField(this, "_bindingOnSyntax");
          __publicField(this, "_binding");
          this._binding = t3, this._bindingWhenSyntax = new Tt(this._binding), this._bindingOnSyntax = new Dt(this._binding), this._bindingInSyntax = new Ct(t3);
        }
        inRequestScope() {
          return this._bindingInSyntax.inRequestScope();
        }
        inSingletonScope() {
          return this._bindingInSyntax.inSingletonScope();
        }
        inTransientScope() {
          return this._bindingInSyntax.inTransientScope();
        }
        when(t3) {
          return this._bindingWhenSyntax.when(t3);
        }
        whenTargetNamed(t3) {
          return this._bindingWhenSyntax.whenTargetNamed(t3);
        }
        whenTargetIsDefault() {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        }
        whenTargetTagged(t3, n) {
          return this._bindingWhenSyntax.whenTargetTagged(t3, n);
        }
        whenInjectedInto(t3) {
          return this._bindingWhenSyntax.whenInjectedInto(t3);
        }
        whenParentNamed(t3) {
          return this._bindingWhenSyntax.whenParentNamed(t3);
        }
        whenParentTagged(t3, n) {
          return this._bindingWhenSyntax.whenParentTagged(t3, n);
        }
        whenAnyAncestorIs(t3) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(t3);
        }
        whenNoAncestorIs(t3) {
          return this._bindingWhenSyntax.whenNoAncestorIs(t3);
        }
        whenAnyAncestorNamed(t3) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(t3);
        }
        whenAnyAncestorTagged(t3, n) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(t3, n);
        }
        whenNoAncestorNamed(t3) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(t3);
        }
        whenNoAncestorTagged(t3, n) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(t3, n);
        }
        whenAnyAncestorMatches(t3) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(t3);
        }
        whenNoAncestorMatches(t3) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(t3);
        }
        onActivation(t3) {
          return this._bindingOnSyntax.onActivation(t3);
        }
        onDeactivation(t3) {
          return this._bindingOnSyntax.onDeactivation(t3);
        }
      };
      Rt = class {
        constructor(t3) {
          __publicField(this, "_binding");
          this._binding = t3;
        }
        to(t3) {
          return this._binding.type = w2.Instance, this._binding.implementationType = t3, new xt(this._binding);
        }
        toSelf() {
          if ("function" != typeof this._binding.serviceIdentifier) throw new Error("The toSelf function can only be applied when a constructor is used as service identifier");
          const t3 = this._binding.serviceIdentifier;
          return this.to(t3);
        }
        toConstantValue(t3) {
          return this._binding.type = w2.ConstantValue, this._binding.cache = t3, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = b2.Singleton, new Nt(this._binding);
        }
        toDynamicValue(t3) {
          return this._binding.type = w2.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = t3, this._binding.implementationType = null, new xt(this._binding);
        }
        toConstructor(t3) {
          return this._binding.type = w2.Constructor, this._binding.implementationType = t3, this._binding.scope = b2.Singleton, new Nt(this._binding);
        }
        toFactory(t3) {
          return this._binding.type = w2.Factory, this._binding.factory = t3, this._binding.scope = b2.Singleton, new Nt(this._binding);
        }
        toFunction(t3) {
          if ("function" != typeof t3) throw new Error("Value provided to function binding must be a function!");
          const n = this.toConstantValue(t3);
          return this._binding.type = w2.Function, this._binding.scope = b2.Singleton, n;
        }
        toAutoFactory(t3) {
          return this._binding.type = w2.Factory, this._binding.factory = (n) => () => n.container.get(t3), this._binding.scope = b2.Singleton, new Nt(this._binding);
        }
        toAutoNamedFactory(t3) {
          return this._binding.type = w2.Factory, this._binding.factory = (n) => (e2) => n.container.getNamed(t3, e2), new Nt(this._binding);
        }
        toProvider(t3) {
          return this._binding.type = w2.Provider, this._binding.provider = t3, this._binding.scope = b2.Singleton, new Nt(this._binding);
        }
        toService(t3) {
          this._binding.type = w2.DynamicValue, Object.defineProperty(this._binding, "cache", { configurable: true, enumerable: true, get: () => null, set(t4) {
          } }), this._binding.dynamicValue = (n) => {
            try {
              return n.container.get(t3);
            } catch (e2) {
              return n.container.getAsync(t3);
            }
          }, this._binding.implementationType = null;
        }
      };
      Et = class _Et {
        constructor() {
          __publicField(this, "bindings");
          __publicField(this, "activations");
          __publicField(this, "deactivations");
          __publicField(this, "middleware");
          __publicField(this, "moduleActivationStore");
        }
        static of(t3, n, e2, i2, r3) {
          const s3 = new _Et();
          return s3.bindings = t3, s3.middleware = n, s3.deactivations = i2, s3.activations = e2, s3.moduleActivationStore = r3, s3;
        }
      };
      Mt = class _Mt {
        constructor() {
          __publicField(this, "_map");
          this._map = /* @__PURE__ */ new Map();
        }
        getMap() {
          return this._map;
        }
        add(t3, n) {
          if (this._checkNonNulish(t3), null == n) throw new Error(D2);
          const e2 = this._map.get(t3);
          void 0 !== e2 ? e2.push(n) : this._map.set(t3, [n]);
        }
        get(t3) {
          this._checkNonNulish(t3);
          const n = this._map.get(t3);
          if (void 0 !== n) return n;
          throw new Error(N2);
        }
        remove(t3) {
          if (this._checkNonNulish(t3), !this._map.delete(t3)) throw new Error(N2);
        }
        removeIntersection(t3) {
          this.traverse((n, e2) => {
            const i2 = t3.hasKey(n) ? t3.get(n) : void 0;
            if (void 0 !== i2) {
              const t4 = e2.filter((t5) => !i2.some((n2) => t5 === n2));
              this._setValue(n, t4);
            }
          });
        }
        removeByCondition(t3) {
          const n = [];
          return this._map.forEach((e2, i2) => {
            const r3 = [];
            for (const i3 of e2) {
              t3(i3) ? n.push(i3) : r3.push(i3);
            }
            this._setValue(i2, r3);
          }), n;
        }
        hasKey(t3) {
          return this._checkNonNulish(t3), this._map.has(t3);
        }
        clone() {
          const t3 = new _Mt();
          return this._map.forEach((n, e2) => {
            n.forEach((n2) => {
              var i2;
              t3.add(e2, "object" == typeof (i2 = n2) && null !== i2 && "clone" in i2 && "function" == typeof i2.clone ? n2.clone() : n2);
            });
          }), t3;
        }
        traverse(t3) {
          this._map.forEach((n, e2) => {
            t3(e2, n);
          });
        }
        _checkNonNulish(t3) {
          if (null == t3) throw new Error(D2);
        }
        _setValue(t3, n) {
          n.length > 0 ? this._map.set(t3, n) : this._map.delete(t3);
        }
      };
      Bt = class _Bt {
        constructor() {
          __publicField(this, "_map", /* @__PURE__ */ new Map());
        }
        remove(t3) {
          const n = this._map.get(t3);
          return void 0 === n ? this._getEmptyHandlersStore() : (this._map.delete(t3), n);
        }
        addDeactivation(t3, n, e2) {
          this._getModuleActivationHandlers(t3).onDeactivations.add(n, e2);
        }
        addActivation(t3, n, e2) {
          this._getModuleActivationHandlers(t3).onActivations.add(n, e2);
        }
        clone() {
          const t3 = new _Bt();
          return this._map.forEach((n, e2) => {
            t3._map.set(e2, { onActivations: n.onActivations.clone(), onDeactivations: n.onDeactivations.clone() });
          }), t3;
        }
        _getModuleActivationHandlers(t3) {
          let n = this._map.get(t3);
          return void 0 === n && (n = this._getEmptyHandlersStore(), this._map.set(t3, n)), n;
        }
        _getEmptyHandlersStore() {
          return { onActivations: new Mt(), onDeactivations: new Mt() };
        }
      };
      Pt = class _Pt {
        constructor(t3) {
          __publicField(this, "id");
          __publicField(this, "parent");
          __publicField(this, "options");
          __publicField(this, "_middleware");
          __publicField(this, "_bindingDictionary");
          __publicField(this, "_activations");
          __publicField(this, "_deactivations");
          __publicField(this, "_snapshots");
          __publicField(this, "_metadataReader");
          __publicField(this, "_moduleActivationStore");
          const n = t3 || {};
          if ("object" != typeof n) throw new Error("Invalid Container constructor argument. Container options must be an object.");
          if (void 0 === n.defaultScope) n.defaultScope = b2.Transient;
          else if (n.defaultScope !== b2.Singleton && n.defaultScope !== b2.Transient && n.defaultScope !== b2.Request) throw new Error('Invalid Container option. Default scope must be a string ("singleton" or "transient").');
          if (void 0 === n.autoBindInjectable) n.autoBindInjectable = false;
          else if ("boolean" != typeof n.autoBindInjectable) throw new Error("Invalid Container option. Auto bind injectable must be a boolean");
          if (void 0 === n.skipBaseClassChecks) n.skipBaseClassChecks = false;
          else if ("boolean" != typeof n.skipBaseClassChecks) throw new Error("Invalid Container option. Skip base check must be a boolean");
          this.options = { autoBindInjectable: n.autoBindInjectable, defaultScope: n.defaultScope, skipBaseClassChecks: n.skipBaseClassChecks }, this.id = S(), this._bindingDictionary = new Mt(), this._snapshots = [], this._middleware = null, this._activations = new Mt(), this._deactivations = new Mt(), this.parent = null, this._metadataReader = new M2(), this._moduleActivationStore = new Bt();
        }
        static merge(t3, n, ...e2) {
          const i2 = new _Pt(), r3 = [t3, n, ...e2].map((t4) => U(t4)), s3 = U(i2);
          return r3.forEach((t4) => {
            var n2;
            n2 = s3, t4.traverse((t5, e3) => {
              e3.forEach((t6) => {
                n2.add(t6.serviceIdentifier, t6.clone());
              });
            });
          }), i2;
        }
        load(...t3) {
          const n = this._getContainerModuleHelpersFactory();
          for (const e2 of t3) {
            const t4 = n(e2.id);
            e2.registry(t4.bindFunction, t4.unbindFunction, t4.isboundFunction, t4.rebindFunction, t4.unbindAsyncFunction, t4.onActivationFunction, t4.onDeactivationFunction);
          }
        }
        async loadAsync(...t3) {
          const n = this._getContainerModuleHelpersFactory();
          for (const e2 of t3) {
            const t4 = n(e2.id);
            await e2.registry(t4.bindFunction, t4.unbindFunction, t4.isboundFunction, t4.rebindFunction, t4.unbindAsyncFunction, t4.onActivationFunction, t4.onDeactivationFunction);
          }
        }
        unload(...t3) {
          t3.forEach((t4) => {
            const n = this._removeModuleBindings(t4.id);
            this._deactivateSingletons(n), this._removeModuleHandlers(t4.id);
          });
        }
        async unloadAsync(...t3) {
          for (const n of t3) {
            const t4 = this._removeModuleBindings(n.id);
            await this._deactivateSingletonsAsync(t4), this._removeModuleHandlers(n.id);
          }
        }
        bind(t3) {
          return this._bind(this._buildBinding(t3));
        }
        rebind(t3) {
          return this.unbind(t3), this.bind(t3);
        }
        async rebindAsync(t3) {
          return await this.unbindAsync(t3), this.bind(t3);
        }
        unbind(t3) {
          if (this._bindingDictionary.hasKey(t3)) {
            const n = this._bindingDictionary.get(t3);
            this._deactivateSingletons(n);
          }
          this._removeServiceFromDictionary(t3);
        }
        async unbindAsync(t3) {
          if (this._bindingDictionary.hasKey(t3)) {
            const n = this._bindingDictionary.get(t3);
            await this._deactivateSingletonsAsync(n);
          }
          this._removeServiceFromDictionary(t3);
        }
        unbindAll() {
          this._bindingDictionary.traverse((t3, n) => {
            this._deactivateSingletons(n);
          }), this._bindingDictionary = new Mt();
        }
        async unbindAllAsync() {
          const t3 = [];
          this._bindingDictionary.traverse((n, e2) => {
            t3.push(this._deactivateSingletonsAsync(e2));
          }), await Promise.all(t3), this._bindingDictionary = new Mt();
        }
        onActivation(t3, n) {
          this._activations.add(t3, n);
        }
        onDeactivation(t3, n) {
          this._deactivations.add(t3, n);
        }
        isBound(t3) {
          let n = this._bindingDictionary.hasKey(t3);
          return !n && this.parent && (n = this.parent.isBound(t3)), n;
        }
        isCurrentBound(t3) {
          return this._bindingDictionary.hasKey(t3);
        }
        isBoundNamed(t3, n) {
          return this.isBoundTagged(t3, s2, n);
        }
        isBoundTagged(t3, n, s3) {
          let o3 = false;
          if (this._bindingDictionary.hasKey(t3)) {
            const a3 = this._bindingDictionary.get(t3), c3 = function(t4, n2, s4) {
              const o4 = Y(n2, s4), a4 = v(o4);
              if (a4.kind === p.unmanaged) throw new Error("Unexpected metadata when creating target");
              const c4 = new T("", a4, "Variable"), d3 = new V(t4);
              return new H(n2, d3, null, [], c4);
            }(this, t3, { customTag: { key: n, value: s3 }, isMultiInject: false });
            o3 = a3.some((t4) => t4.constraint(c3));
          }
          return !o3 && this.parent && (o3 = this.parent.isBoundTagged(t3, n, s3)), o3;
        }
        snapshot() {
          this._snapshots.push(Et.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
        }
        restore() {
          const t3 = this._snapshots.pop();
          if (void 0 === t3) throw new Error("No snapshot available to restore.");
          this._bindingDictionary = t3.bindings, this._activations = t3.activations, this._deactivations = t3.deactivations, this._middleware = t3.middleware, this._moduleActivationStore = t3.moduleActivationStore;
        }
        createChild(t3) {
          const n = new _Pt(t3 || this.options);
          return n.parent = this, n;
        }
        applyMiddleware(...t3) {
          const n = this._middleware ? this._middleware : this._planAndResolve();
          this._middleware = t3.reduce((t4, n2) => n2(t4), n);
        }
        applyCustomMetadataReader(t3) {
          this._metadataReader = t3;
        }
        get(t3) {
          const n = this._getNotAllArgs(t3, false, false);
          return this._getButThrowIfAsync(n);
        }
        async getAsync(t3) {
          const n = this._getNotAllArgs(t3, false, false);
          return this._get(n);
        }
        getTagged(t3, n, e2) {
          const i2 = this._getNotAllArgs(t3, false, false, n, e2);
          return this._getButThrowIfAsync(i2);
        }
        async getTaggedAsync(t3, n, e2) {
          const i2 = this._getNotAllArgs(t3, false, false, n, e2);
          return this._get(i2);
        }
        getNamed(t3, n) {
          return this.getTagged(t3, s2, n);
        }
        async getNamedAsync(t3, n) {
          return this.getTaggedAsync(t3, s2, n);
        }
        getAll(t3, n) {
          const e2 = this._getAllArgs(t3, n, false);
          return this._getButThrowIfAsync(e2);
        }
        async getAllAsync(t3, n) {
          const e2 = this._getAllArgs(t3, n, false);
          return this._getAll(e2);
        }
        getAllTagged(t3, n, e2) {
          const i2 = this._getNotAllArgs(t3, true, false, n, e2);
          return this._getButThrowIfAsync(i2);
        }
        async getAllTaggedAsync(t3, n, e2) {
          const i2 = this._getNotAllArgs(t3, true, false, n, e2);
          return this._getAll(i2);
        }
        getAllNamed(t3, n) {
          return this.getAllTagged(t3, s2, n);
        }
        async getAllNamedAsync(t3, n) {
          return this.getAllTaggedAsync(t3, s2, n);
        }
        resolve(t3) {
          const n = this.isBound(t3);
          n || this.bind(t3).toSelf();
          const e2 = this.get(t3);
          return n || this.unbind(t3), e2;
        }
        tryGet(t3) {
          const n = this._getNotAllArgs(t3, false, true);
          return this._getButThrowIfAsync(n);
        }
        async tryGetAsync(t3) {
          const n = this._getNotAllArgs(t3, false, true);
          return this._get(n);
        }
        tryGetTagged(t3, n, e2) {
          const i2 = this._getNotAllArgs(t3, false, true, n, e2);
          return this._getButThrowIfAsync(i2);
        }
        async tryGetTaggedAsync(t3, n, e2) {
          const i2 = this._getNotAllArgs(t3, false, true, n, e2);
          return this._get(i2);
        }
        tryGetNamed(t3, n) {
          return this.tryGetTagged(t3, s2, n);
        }
        async tryGetNamedAsync(t3, n) {
          return this.tryGetTaggedAsync(t3, s2, n);
        }
        tryGetAll(t3, n) {
          const e2 = this._getAllArgs(t3, n, true);
          return this._getButThrowIfAsync(e2);
        }
        async tryGetAllAsync(t3, n) {
          const e2 = this._getAllArgs(t3, n, true);
          return this._getAll(e2);
        }
        tryGetAllTagged(t3, n, e2) {
          const i2 = this._getNotAllArgs(t3, true, true, n, e2);
          return this._getButThrowIfAsync(i2);
        }
        async tryGetAllTaggedAsync(t3, n, e2) {
          const i2 = this._getNotAllArgs(t3, true, true, n, e2);
          return this._getAll(i2);
        }
        tryGetAllNamed(t3, n) {
          return this.tryGetAllTagged(t3, s2, n);
        }
        async tryGetAllNamedAsync(t3, n) {
          return this.tryGetAllTaggedAsync(t3, s2, n);
        }
        _preDestroy(t3, n) {
          if (void 0 !== t3 && Reflect.hasMetadata(f2, t3)) {
            const e2 = Reflect.getMetadata(f2, t3);
            return n[e2.value]?.();
          }
        }
        _removeModuleHandlers(t3) {
          const n = this._moduleActivationStore.remove(t3);
          this._activations.removeIntersection(n.onActivations), this._deactivations.removeIntersection(n.onDeactivations);
        }
        _removeModuleBindings(t3) {
          return this._bindingDictionary.removeByCondition((n) => n.moduleId === t3);
        }
        _deactivate(t3, n) {
          const e2 = null == n ? void 0 : Object.getPrototypeOf(n).constructor;
          try {
            if (this._deactivations.hasKey(t3.serviceIdentifier)) {
              const i3 = this._deactivateContainer(n, this._deactivations.get(t3.serviceIdentifier).values());
              if (X(i3)) return this._handleDeactivationError(i3.then(async () => this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(t3, n, e2)), t3.serviceIdentifier);
            }
            const i2 = this._propagateContainerDeactivationThenBindingAndPreDestroy(t3, n, e2);
            if (X(i2)) return this._handleDeactivationError(i2, t3.serviceIdentifier);
          } catch (n2) {
            if (n2 instanceof Error) throw new Error(E2(k2(t3.serviceIdentifier), n2.message));
          }
        }
        async _handleDeactivationError(t3, n) {
          try {
            await t3;
          } catch (t4) {
            if (t4 instanceof Error) throw new Error(E2(k2(n), t4.message));
          }
        }
        _deactivateContainer(t3, n) {
          let e2 = n.next();
          for (; "function" == typeof e2.value; ) {
            const i2 = e2.value(t3);
            if (X(i2)) return i2.then(async () => this._deactivateContainerAsync(t3, n));
            e2 = n.next();
          }
        }
        async _deactivateContainerAsync(t3, n) {
          let e2 = n.next();
          for (; "function" == typeof e2.value; ) await e2.value(t3), e2 = n.next();
        }
        _getContainerModuleHelpersFactory() {
          const t3 = (t4) => (n2) => {
            const e3 = this._buildBinding(n2);
            return e3.moduleId = t4, this._bind(e3);
          }, n = () => (t4) => {
            this.unbind(t4);
          }, e2 = () => async (t4) => this.unbindAsync(t4), i2 = () => (t4) => this.isBound(t4), r3 = (n2) => {
            const e3 = t3(n2);
            return (t4) => (this.unbind(t4), e3(t4));
          }, s3 = (t4) => (n2, e3) => {
            this._moduleActivationStore.addActivation(t4, n2, e3), this.onActivation(n2, e3);
          }, o3 = (t4) => (n2, e3) => {
            this._moduleActivationStore.addDeactivation(t4, n2, e3), this.onDeactivation(n2, e3);
          };
          return (a3) => ({ bindFunction: t3(a3), isboundFunction: i2(), onActivationFunction: s3(a3), onDeactivationFunction: o3(a3), rebindFunction: r3(a3), unbindAsyncFunction: e2(), unbindFunction: n() });
        }
        _bind(t3) {
          return this._bindingDictionary.add(t3.serviceIdentifier, t3), new Rt(t3);
        }
        _buildBinding(t3) {
          const n = this.options.defaultScope || b2.Transient;
          return new I2(t3, n);
        }
        async _getAll(t3) {
          return Promise.all(this._get(t3));
        }
        _get(t3) {
          const n = { ...t3, contextInterceptor: (t4) => t4, targetType: m2.Variable };
          if (this._middleware) {
            const t4 = this._middleware(n);
            if (null == t4) throw new Error("Invalid return type in middleware. Middleware must return!");
            return t4;
          }
          return this._planAndResolve()(n);
        }
        _getButThrowIfAsync(t3) {
          const n = this._get(t3);
          if (Z(n)) throw new Error(`You are attempting to construct ${function(t4) {
            return "function" == typeof t4 ? `[function/class ${t4.name || "<anonymous>"}]` : "symbol" == typeof t4 ? t4.toString() : `'${t4}'`;
          }(t3.serviceIdentifier)} in a synchronous way but it has asynchronous dependencies.`);
          return n;
        }
        _getAllArgs(t3, n, e2) {
          return { avoidConstraints: !n?.enforceBindingConstraints, isMultiInject: true, isOptional: e2, serviceIdentifier: t3 };
        }
        _getNotAllArgs(t3, n, e2, i2, r3) {
          return { avoidConstraints: false, isMultiInject: n, isOptional: e2, key: i2, serviceIdentifier: t3, value: r3 };
        }
        _getPlanMetadataFromNextArgs(t3) {
          const n = { isMultiInject: t3.isMultiInject };
          return void 0 !== t3.key && (n.customTag = { key: t3.key, value: t3.value }), true === t3.isOptional && (n.isOptional = true), n;
        }
        _planAndResolve() {
          return (t3) => {
            let n = Q(this._metadataReader, this, t3.targetType, t3.serviceIdentifier, this._getPlanMetadataFromNextArgs(t3), t3.avoidConstraints);
            n = t3.contextInterceptor(n);
            const e2 = function(t4) {
              return ut(t4.plan.rootRequest.requestScope)(t4.plan.rootRequest);
            }(n);
            return e2;
          };
        }
        _deactivateIfSingleton(t3) {
          if (t3.activated) return X(t3.cache) ? t3.cache.then((n) => this._deactivate(t3, n)) : this._deactivate(t3, t3.cache);
        }
        _deactivateSingletons(t3) {
          for (const n of t3) {
            if (X(this._deactivateIfSingleton(n))) throw new Error("Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)");
          }
        }
        async _deactivateSingletonsAsync(t3) {
          await Promise.all(t3.map(async (t4) => this._deactivateIfSingleton(t4)));
        }
        _propagateContainerDeactivationThenBindingAndPreDestroy(t3, n, e2) {
          return this.parent ? this._deactivate.bind(this.parent)(t3, n) : this._bindingDeactivationAndPreDestroy(t3, n, e2);
        }
        async _propagateContainerDeactivationThenBindingAndPreDestroyAsync(t3, n, e2) {
          this.parent ? await this._deactivate.bind(this.parent)(t3, n) : await this._bindingDeactivationAndPreDestroyAsync(t3, n, e2);
        }
        _removeServiceFromDictionary(t3) {
          try {
            this._bindingDictionary.remove(t3);
          } catch (n) {
            throw new Error(`Could not unbind serviceIdentifier: ${k2(t3)}`);
          }
        }
        _bindingDeactivationAndPreDestroy(t3, n, e2) {
          if ("function" == typeof t3.onDeactivation) {
            const i2 = t3.onDeactivation(n);
            if (X(i2)) return i2.then(() => this._preDestroy(e2, n));
          }
          return this._preDestroy(e2, n);
        }
        async _bindingDeactivationAndPreDestroyAsync(t3, n, e2) {
          "function" == typeof t3.onDeactivation && await t3.onDeactivation(n), await this._preDestroy(e2, n);
        }
      };
      kt = class {
        constructor(t3) {
          __publicField(this, "id");
          __publicField(this, "registry");
          this.id = S(), this.registry = t3;
        }
      };
      Yt = Lt(d2);
      Qt = Lt(u2);
      tn = Zt(p2, "Cannot apply @postConstruct decorator multiple times in the same class");
      nn = Zt(f2, "Cannot apply @preDestroy decorator multiple times in the same class");
    }
  });

  // node_modules/balloon-css/balloon.min.css
  var init_balloon_min = __esm({
    "node_modules/balloon-css/balloon.min.css"() {
    }
  });

  // src/extension/diagram/actions/reload-model-action.ts
  var import_client, ReloadModelAction;
  var init_reload_model_action = __esm({
    "src/extension/diagram/actions/reload-model-action.ts"() {
      import_client = __toESM(require_lib5());
      ((ReloadModelAction2) => {
        ReloadModelAction2.KIND = "reloadModel";
        function is(action) {
          return import_client.Action.hasKind(action, ReloadModelAction2.KIND);
        }
        ReloadModelAction2.is = is;
        function create(options) {
          return {
            kind: ReloadModelAction2.KIND,
            ...options
          };
        }
        ReloadModelAction2.create = create;
      })(ReloadModelAction || (ReloadModelAction = {}));
    }
  });

  // src/extension/diagram/actions/reload-model-action-handler.ts
  var import_client2, ReloadModelActionHandler;
  var init_reload_model_action_handler = __esm({
    "src/extension/diagram/actions/reload-model-action-handler.ts"() {
      import_client2 = __toESM(require_lib5());
      init_esm4();
      init_reload_model_action();
      ReloadModelActionHandler = class {
        handle(action) {
          if (ReloadModelAction.is(action)) {
            if (this.editorContext) {
              const root = this.editorContext.modelRoot;
              if ((0, import_client2.isViewport)(root)) {
                this.cachedViewport = { scroll: root.scroll, zoom: root.zoom };
              }
              return import_client2.RequestModelAction.create({ options: action.options });
            }
          } else if ((import_client2.SetModelAction.is(action) || import_client2.UpdateModelAction.is(action)) && this.cachedViewport) {
            const viewport = this.cachedViewport;
            this.cachedViewport = void 0;
            return import_client2.SetViewportAction.create(action.newRoot.id, viewport, {
              animate: false
            });
          }
        }
      };
      __decorateClass([
        Yt(import_client2.EditorContextService)
      ], ReloadModelActionHandler.prototype, "editorContext", 2);
      ReloadModelActionHandler = __decorateClass([
        Kt()
      ], ReloadModelActionHandler);
    }
  });

  // src/diagram/view/CustomNodeViews.ts
  var import_client3, SensorSignalNodeView;
  var init_CustomNodeViews = __esm({
    "src/diagram/view/CustomNodeViews.ts"() {
      import_client3 = __toESM(require_lib5());
      SensorSignalNodeView = class extends import_client3.RoundedCornerNodeView {
        render(node, context) {
          const vnode = super.render(node, context);
          if (vnode === void 0) {
            return vnode;
          }
          return vnode;
        }
      };
    }
  });

  // src/diagram/view/nodeStyles.css
  var init_nodeStyles = __esm({
    "src/diagram/view/nodeStyles.css"() {
    }
  });

  // src/extension/diagram/sdvml-diagram-module.ts
  function initializesdvmlDiagramContainer(container, ...containerConfiguration) {
    return (0, import_client4.initializeDiagramContainer)(container, sdvmlDiagramModule, ...containerConfiguration);
  }
  var import_client4, import_sprotty, sdvmlDiagramModule;
  var init_sdvml_diagram_module = __esm({
    "src/extension/diagram/sdvml-diagram-module.ts"() {
      import_client4 = __toESM(require_lib5());
      import_sprotty = __toESM(require_lib4());
      init_balloon_min();
      init_esm4();
      init_reload_model_action_handler();
      init_reload_model_action();
      init_CustomNodeViews();
      init_nodeStyles();
      sdvmlDiagramModule = new kt((bind, unbind, isBound, rebind) => {
        rebind(import_client4.TYPES.ILogger).to(import_client4.ConsoleLogger).inSingletonScope();
        rebind(import_client4.TYPES.LogLevel).toConstantValue(import_client4.LogLevel.warn);
        const context = { bind, unbind, isBound, rebind };
        (0, import_client4.configureDefaultModelElements)(context);
        bind(ReloadModelActionHandler).toSelf().inSingletonScope();
        (0, import_client4.configureActionHandler)(context, ReloadModelAction.KIND, ReloadModelActionHandler);
        (0, import_client4.configureActionHandler)(context, import_sprotty.SetModelAction.KIND, ReloadModelActionHandler);
        (0, import_client4.configureActionHandler)(context, import_sprotty.UpdateModelAction.KIND, ReloadModelActionHandler);
        (0, import_sprotty.configureModelElement)(context, import_sprotty.DefaultTypes.ROUTING_POINT, import_sprotty.GRoutingHandle, import_sprotty.SRoutingHandleView);
        (0, import_sprotty.configureModelElement)(context, "edge:pushsub", import_client4.GEdge, import_sprotty.PolylineEdgeView);
        (0, import_sprotty.configureModelElement)(context, "node:vssnode", import_sprotty.GNode, import_sprotty.RectangularNodeView);
        (0, import_sprotty.configureModelElement)(context, "node:componentnode", import_sprotty.GNode, import_sprotty.RectangularNodeView);
        (0, import_sprotty.configureModelElement)(context, "container", import_sprotty.GNode, import_sprotty.RectangularNodeView);
        (0, import_sprotty.configureModelElement)(context, "node:inport", import_sprotty.GNode, import_sprotty.RectangularNodeView);
        (0, import_sprotty.configureModelElement)(context, "node:outport", import_sprotty.GNode, import_sprotty.CircularNodeView);
        (0, import_sprotty.configureModelElement)(context, "node:sensorsignalnode", import_sprotty.GNode, SensorSignalNodeView);
        (0, import_sprotty.configureModelElement)(context, "node:actuatorsignalnode", import_sprotty.GNode, import_client4.RoundedCornerNodeView);
        (0, import_sprotty.configureModelElement)(context, import_sprotty.DefaultTypes.LABEL, import_sprotty.GLabel, import_sprotty.GLabelView, { enable: [import_sprotty.editLabelFeature] });
      });
    }
  });

  // src/webview/sdvml-starter.ts
  function launchSDVMLDiagram() {
    new SDVMLStarter();
  }
  var import_reflect_metadata2, import_vscode_integration_webview, SDVMLStarter;
  var init_sdvml_starter = __esm({
    "src/webview/sdvml-starter.ts"() {
      import_reflect_metadata2 = __toESM(require_Reflect());
      import_vscode_integration_webview = __toESM(require_lib8());
      init_glsp_vscode();
      init_esm4();
      init_sdvml_diagram_module();
      SDVMLStarter = class extends import_vscode_integration_webview.GLSPStarter {
        createContainer(...containerConfiguration) {
          let container = initializesdvmlDiagramContainer(new Pt(), ...containerConfiguration);
          return container;
        }
      };
    }
  });

  // src/webview/main.ts
  var require_main2 = __commonJS({
    "src/webview/main.ts"() {
      var import_reflect_metadata3 = __toESM(require_Reflect());
      init_sdvml_starter();
      launchSDVMLDiagram();
    }
  });
  require_main2();
})();
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=webview.js.map
